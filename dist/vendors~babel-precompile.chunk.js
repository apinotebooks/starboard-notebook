(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~babel-precompile"],{

/***/ "./node_modules/@babel/helper-validator-identifier/lib/identifier.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/helper-validator-identifier/lib/identifier.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isIdentifierStart = isIdentifierStart;
exports.isIdentifierChar = isIdentifierChar;
exports.isIdentifierName = isIdentifierName;
let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
let nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
const astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

function isInAstralSet(code, set) {
  let pos = 0x10000;

  for (let i = 0, length = set.length; i < length; i += 2) {
    pos += set[i];
    if (pos > code) return false;
    pos += set[i + 1];
    if (pos >= code) return true;
  }

  return false;
}

function isIdentifierStart(code) {
  if (code < 65) return code === 36;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }

  return isInAstralSet(code, astralIdentifierStartCodes);
}

function isIdentifierChar(code) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  }

  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}

function isIdentifierName(name) {
  let isFirst = true;

  for (let _i = 0, _Array$from = Array.from(name); _i < _Array$from.length; _i++) {
    const char = _Array$from[_i];
    const cp = char.codePointAt(0);

    if (isFirst) {
      if (!isIdentifierStart(cp)) {
        return false;
      }

      isFirst = false;
    } else if (!isIdentifierChar(cp)) {
      return false;
    }
  }

  return !isFirst;
}

/***/ }),

/***/ "./node_modules/@babel/helper-validator-identifier/lib/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/helper-validator-identifier/lib/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "isIdentifierName", {
  enumerable: true,
  get: function () {
    return _identifier.isIdentifierName;
  }
});
Object.defineProperty(exports, "isIdentifierChar", {
  enumerable: true,
  get: function () {
    return _identifier.isIdentifierChar;
  }
});
Object.defineProperty(exports, "isIdentifierStart", {
  enumerable: true,
  get: function () {
    return _identifier.isIdentifierStart;
  }
});
Object.defineProperty(exports, "isReservedWord", {
  enumerable: true,
  get: function () {
    return _keyword.isReservedWord;
  }
});
Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
  enumerable: true,
  get: function () {
    return _keyword.isStrictBindOnlyReservedWord;
  }
});
Object.defineProperty(exports, "isStrictBindReservedWord", {
  enumerable: true,
  get: function () {
    return _keyword.isStrictBindReservedWord;
  }
});
Object.defineProperty(exports, "isStrictReservedWord", {
  enumerable: true,
  get: function () {
    return _keyword.isStrictReservedWord;
  }
});
Object.defineProperty(exports, "isKeyword", {
  enumerable: true,
  get: function () {
    return _keyword.isKeyword;
  }
});

var _identifier = __webpack_require__(/*! ./identifier */ "./node_modules/@babel/helper-validator-identifier/lib/identifier.js");

var _keyword = __webpack_require__(/*! ./keyword */ "./node_modules/@babel/helper-validator-identifier/lib/keyword.js");

/***/ }),

/***/ "./node_modules/@babel/helper-validator-identifier/lib/keyword.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babel/helper-validator-identifier/lib/keyword.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isReservedWord = isReservedWord;
exports.isStrictReservedWord = isStrictReservedWord;
exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
exports.isStrictBindReservedWord = isStrictBindReservedWord;
exports.isKeyword = isKeyword;
const reservedWords = {
  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
  strictBind: ["eval", "arguments"]
};
const keywords = new Set(reservedWords.keyword);
const reservedWordsStrictSet = new Set(reservedWords.strict);
const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);

function isReservedWord(word, inModule) {
  return inModule && word === "await" || word === "enum";
}

function isStrictReservedWord(word, inModule) {
  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}

function isStrictBindOnlyReservedWord(word) {
  return reservedWordsStrictBindSet.has(word);
}

function isStrictBindReservedWord(word, inModule) {
  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
}

function isKeyword(word) {
  return keywords.has(word);
}

/***/ }),

/***/ "./node_modules/@babel/parser/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@babel/parser/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/*! exports used: parse */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

const beforeExpr = true;
const startsExpr = true;
const isLoop = true;
const isAssign = true;
const prefix = true;
const postfix = true;
class TokenType {
  constructor(label, conf = {}) {
    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.rightAssociative = !!conf.rightAssociative;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop != null ? conf.binop : null;
    this.updateContext = null;
  }

}
const keywords = new Map();

function createKeyword(name, options = {}) {
  options.keyword = name;
  const token = new TokenType(name, options);
  keywords.set(name, token);
  return token;
}

function createBinop(name, binop) {
  return new TokenType(name, {
    beforeExpr,
    binop
  });
}

const types = {
  num: new TokenType("num", {
    startsExpr
  }),
  bigint: new TokenType("bigint", {
    startsExpr
  }),
  regexp: new TokenType("regexp", {
    startsExpr
  }),
  string: new TokenType("string", {
    startsExpr
  }),
  name: new TokenType("name", {
    startsExpr
  }),
  eof: new TokenType("eof"),
  bracketL: new TokenType("[", {
    beforeExpr,
    startsExpr
  }),
  bracketHashL: new TokenType("#[", {
    beforeExpr,
    startsExpr
  }),
  bracketBarL: new TokenType("[|", {
    beforeExpr,
    startsExpr
  }),
  bracketR: new TokenType("]"),
  bracketBarR: new TokenType("|]"),
  braceL: new TokenType("{", {
    beforeExpr,
    startsExpr
  }),
  braceBarL: new TokenType("{|", {
    beforeExpr,
    startsExpr
  }),
  braceHashL: new TokenType("#{", {
    beforeExpr,
    startsExpr
  }),
  braceR: new TokenType("}"),
  braceBarR: new TokenType("|}"),
  parenL: new TokenType("(", {
    beforeExpr,
    startsExpr
  }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", {
    beforeExpr
  }),
  semi: new TokenType(";", {
    beforeExpr
  }),
  colon: new TokenType(":", {
    beforeExpr
  }),
  doubleColon: new TokenType("::", {
    beforeExpr
  }),
  dot: new TokenType("."),
  question: new TokenType("?", {
    beforeExpr
  }),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", {
    beforeExpr
  }),
  template: new TokenType("template"),
  ellipsis: new TokenType("...", {
    beforeExpr
  }),
  backQuote: new TokenType("`", {
    startsExpr
  }),
  dollarBraceL: new TokenType("${", {
    beforeExpr,
    startsExpr
  }),
  at: new TokenType("@"),
  hash: new TokenType("#", {
    startsExpr
  }),
  interpreterDirective: new TokenType("#!..."),
  eq: new TokenType("=", {
    beforeExpr,
    isAssign
  }),
  assign: new TokenType("_=", {
    beforeExpr,
    isAssign
  }),
  incDec: new TokenType("++/--", {
    prefix,
    postfix,
    startsExpr
  }),
  bang: new TokenType("!", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  tilde: new TokenType("~", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  pipeline: createBinop("|>", 0),
  nullishCoalescing: createBinop("??", 1),
  logicalOR: createBinop("||", 1),
  logicalAND: createBinop("&&", 2),
  bitwiseOR: createBinop("|", 3),
  bitwiseXOR: createBinop("^", 4),
  bitwiseAND: createBinop("&", 5),
  equality: createBinop("==/!=/===/!==", 6),
  relational: createBinop("</>/<=/>=", 7),
  bitShift: createBinop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {
    beforeExpr,
    binop: 9,
    prefix,
    startsExpr
  }),
  modulo: new TokenType("%", {
    beforeExpr,
    binop: 10,
    startsExpr
  }),
  star: createBinop("*", 10),
  slash: createBinop("/", 10),
  exponent: new TokenType("**", {
    beforeExpr,
    binop: 11,
    rightAssociative: true
  }),
  _break: createKeyword("break"),
  _case: createKeyword("case", {
    beforeExpr
  }),
  _catch: createKeyword("catch"),
  _continue: createKeyword("continue"),
  _debugger: createKeyword("debugger"),
  _default: createKeyword("default", {
    beforeExpr
  }),
  _do: createKeyword("do", {
    isLoop,
    beforeExpr
  }),
  _else: createKeyword("else", {
    beforeExpr
  }),
  _finally: createKeyword("finally"),
  _for: createKeyword("for", {
    isLoop
  }),
  _function: createKeyword("function", {
    startsExpr
  }),
  _if: createKeyword("if"),
  _return: createKeyword("return", {
    beforeExpr
  }),
  _switch: createKeyword("switch"),
  _throw: createKeyword("throw", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  _try: createKeyword("try"),
  _var: createKeyword("var"),
  _const: createKeyword("const"),
  _while: createKeyword("while", {
    isLoop
  }),
  _with: createKeyword("with"),
  _new: createKeyword("new", {
    beforeExpr,
    startsExpr
  }),
  _this: createKeyword("this", {
    startsExpr
  }),
  _super: createKeyword("super", {
    startsExpr
  }),
  _class: createKeyword("class", {
    startsExpr
  }),
  _extends: createKeyword("extends", {
    beforeExpr
  }),
  _export: createKeyword("export"),
  _import: createKeyword("import", {
    startsExpr
  }),
  _null: createKeyword("null", {
    startsExpr
  }),
  _true: createKeyword("true", {
    startsExpr
  }),
  _false: createKeyword("false", {
    startsExpr
  }),
  _in: createKeyword("in", {
    beforeExpr,
    binop: 7
  }),
  _instanceof: createKeyword("instanceof", {
    beforeExpr,
    binop: 7
  }),
  _typeof: createKeyword("typeof", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  _void: createKeyword("void", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  _delete: createKeyword("delete", {
    beforeExpr,
    prefix,
    startsExpr
  })
};

const SCOPE_OTHER = 0b00000000,
      SCOPE_PROGRAM = 0b00000001,
      SCOPE_FUNCTION = 0b00000010,
      SCOPE_ARROW = 0b00000100,
      SCOPE_SIMPLE_CATCH = 0b00001000,
      SCOPE_SUPER = 0b00010000,
      SCOPE_DIRECT_SUPER = 0b00100000,
      SCOPE_CLASS = 0b01000000,
      SCOPE_TS_MODULE = 0b10000000,
      SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
const BIND_KIND_VALUE = 0b00000000001,
      BIND_KIND_TYPE = 0b00000000010,
      BIND_SCOPE_VAR = 0b00000000100,
      BIND_SCOPE_LEXICAL = 0b00000001000,
      BIND_SCOPE_FUNCTION = 0b00000010000,
      BIND_FLAGS_NONE = 0b00001000000,
      BIND_FLAGS_CLASS = 0b00010000000,
      BIND_FLAGS_TS_ENUM = 0b00100000000,
      BIND_FLAGS_TS_CONST_ENUM = 0b01000000000,
      BIND_FLAGS_TS_EXPORT_ONLY = 0b10000000000;
const BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,
      BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,
      BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,
      BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,
      BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,
      BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,
      BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,
      BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
      BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,
      BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,
      BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,
      BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
const CLASS_ELEMENT_FLAG_STATIC = 0b100,
      CLASS_ELEMENT_KIND_GETTER = 0b010,
      CLASS_ELEMENT_KIND_SETTER = 0b001,
      CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
const CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,
      CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,
      CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,
      CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,
      CLASS_ELEMENT_OTHER = 0;

const lineBreak = /\r\n?|[\n\u2028\u2029]/;
const lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
  switch (code) {
    case 10:
    case 13:
    case 8232:
    case 8233:
      return true;

    default:
      return false;
  }
}
const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
function isWhitespace(code) {
  switch (code) {
    case 0x0009:
    case 0x000b:
    case 0x000c:
    case 32:
    case 160:
    case 5760:
    case 0x2000:
    case 0x2001:
    case 0x2002:
    case 0x2003:
    case 0x2004:
    case 0x2005:
    case 0x2006:
    case 0x2007:
    case 0x2008:
    case 0x2009:
    case 0x200a:
    case 0x202f:
    case 0x205f:
    case 0x3000:
    case 0xfeff:
      return true;

    default:
      return false;
  }
}

class Position {
  constructor(line, col) {
    this.line = line;
    this.column = col;
  }

}
class SourceLocation {
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }

}
function getLineInfo(input, offset) {
  let line = 1;
  let lineStart = 0;
  let match;
  lineBreakG.lastIndex = 0;

  while ((match = lineBreakG.exec(input)) && match.index < offset) {
    line++;
    lineStart = lineBreakG.lastIndex;
  }

  return new Position(line, offset - lineStart);
}

class BaseParser {
  constructor() {
    this.sawUnambiguousESM = false;
    this.ambiguousScriptDifferentAst = false;
  }

  hasPlugin(name) {
    return this.plugins.has(name);
  }

  getPluginOption(plugin, name) {
    if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];
  }

}

function last(stack) {
  return stack[stack.length - 1];
}

class CommentsParser extends BaseParser {
  addComment(comment) {
    if (this.filename) comment.loc.filename = this.filename;
    this.state.trailingComments.push(comment);
    this.state.leadingComments.push(comment);
  }

  adjustCommentsAfterTrailingComma(node, elements, takeAllComments) {
    if (this.state.leadingComments.length === 0) {
      return;
    }

    let lastElement = null;
    let i = elements.length;

    while (lastElement === null && i > 0) {
      lastElement = elements[--i];
    }

    if (lastElement === null) {
      return;
    }

    for (let j = 0; j < this.state.leadingComments.length; j++) {
      if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
        this.state.leadingComments.splice(j, 1);
        j--;
      }
    }

    const newTrailingComments = [];

    for (let i = 0; i < this.state.leadingComments.length; i++) {
      const leadingComment = this.state.leadingComments[i];

      if (leadingComment.end < node.end) {
        newTrailingComments.push(leadingComment);

        if (!takeAllComments) {
          this.state.leadingComments.splice(i, 1);
          i--;
        }
      } else {
        if (node.trailingComments === undefined) {
          node.trailingComments = [];
        }

        node.trailingComments.push(leadingComment);
      }
    }

    if (takeAllComments) this.state.leadingComments = [];

    if (newTrailingComments.length > 0) {
      lastElement.trailingComments = newTrailingComments;
    } else if (lastElement.trailingComments !== undefined) {
      lastElement.trailingComments = [];
    }
  }

  processComment(node) {
    if (node.type === "Program" && node.body.length > 0) return;
    const stack = this.state.commentStack;
    let firstChild, lastChild, trailingComments, i, j;

    if (this.state.trailingComments.length > 0) {
      if (this.state.trailingComments[0].start >= node.end) {
        trailingComments = this.state.trailingComments;
        this.state.trailingComments = [];
      } else {
        this.state.trailingComments.length = 0;
      }
    } else if (stack.length > 0) {
      const lastInStack = last(stack);

      if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {
        trailingComments = lastInStack.trailingComments;
        delete lastInStack.trailingComments;
      }
    }

    if (stack.length > 0 && last(stack).start >= node.start) {
      firstChild = stack.pop();
    }

    while (stack.length > 0 && last(stack).start >= node.start) {
      lastChild = stack.pop();
    }

    if (!lastChild && firstChild) lastChild = firstChild;

    if (firstChild) {
      switch (node.type) {
        case "ObjectExpression":
          this.adjustCommentsAfterTrailingComma(node, node.properties);
          break;

        case "ObjectPattern":
          this.adjustCommentsAfterTrailingComma(node, node.properties, true);
          break;

        case "CallExpression":
          this.adjustCommentsAfterTrailingComma(node, node.arguments);
          break;

        case "ArrayExpression":
          this.adjustCommentsAfterTrailingComma(node, node.elements);
          break;

        case "ArrayPattern":
          this.adjustCommentsAfterTrailingComma(node, node.elements, true);
          break;
      }
    } else if (this.state.commentPreviousNode && (this.state.commentPreviousNode.type === "ImportSpecifier" && node.type !== "ImportSpecifier" || this.state.commentPreviousNode.type === "ExportSpecifier" && node.type !== "ExportSpecifier")) {
      this.adjustCommentsAfterTrailingComma(node, [this.state.commentPreviousNode]);
    }

    if (lastChild) {
      if (lastChild.leadingComments) {
        if (lastChild !== node && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node.start) {
          node.leadingComments = lastChild.leadingComments;
          delete lastChild.leadingComments;
        } else {
          for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
            if (lastChild.leadingComments[i].end <= node.start) {
              node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
              break;
            }
          }
        }
      }
    } else if (this.state.leadingComments.length > 0) {
      if (last(this.state.leadingComments).end <= node.start) {
        if (this.state.commentPreviousNode) {
          for (j = 0; j < this.state.leadingComments.length; j++) {
            if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
              this.state.leadingComments.splice(j, 1);
              j--;
            }
          }
        }

        if (this.state.leadingComments.length > 0) {
          node.leadingComments = this.state.leadingComments;
          this.state.leadingComments = [];
        }
      } else {
        for (i = 0; i < this.state.leadingComments.length; i++) {
          if (this.state.leadingComments[i].end > node.start) {
            break;
          }
        }

        const leadingComments = this.state.leadingComments.slice(0, i);

        if (leadingComments.length) {
          node.leadingComments = leadingComments;
        }

        trailingComments = this.state.leadingComments.slice(i);

        if (trailingComments.length === 0) {
          trailingComments = null;
        }
      }
    }

    this.state.commentPreviousNode = node;

    if (trailingComments) {
      if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {
        node.innerComments = trailingComments;
      } else {
        const firstTrailingCommentIndex = trailingComments.findIndex(comment => comment.end >= node.end);

        if (firstTrailingCommentIndex > 0) {
          node.innerComments = trailingComments.slice(0, firstTrailingCommentIndex);
          node.trailingComments = trailingComments.slice(firstTrailingCommentIndex);
        } else {
          node.trailingComments = trailingComments;
        }
      }
    }

    stack.push(node);
  }

}

const ErrorMessages = Object.freeze({
  ArgumentsDisallowedInInitializer: "'arguments' is not allowed in class field initializer",
  AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block",
  AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function",
  AwaitExpressionFormalParameter: "await is not allowed in async function parameters",
  AwaitNotInAsyncFunction: "Can not use keyword 'await' outside an async function",
  BadGetterArity: "getter must not have any formal parameters",
  BadSetterArity: "setter must have exactly one formal parameter",
  BadSetterRestParameter: "setter function argument must not be a rest parameter",
  ConstructorClassField: "Classes may not have a field named 'constructor'",
  ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'",
  ConstructorIsAccessor: "Class constructor may not be an accessor",
  ConstructorIsAsync: "Constructor can't be an async function",
  ConstructorIsGenerator: "Constructor can't be a generator",
  DeclarationMissingInitializer: "%0 require an initialization value",
  DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax",
  DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
  DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
  DecoratorSemicolon: "Decorators must not be followed by a semicolon",
  DeletePrivateField: "Deleting a private field is not allowed",
  DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
  DuplicateConstructor: "Duplicate constructor in the same class",
  DuplicateDefaultExport: "Only one default export allowed per module.",
  DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.",
  DuplicateProto: "Redefinition of __proto__ property",
  DuplicateRegExpFlags: "Duplicate regular expression flag",
  ElementAfterRest: "Rest element must be last element",
  EscapedCharNotAnIdentifier: "Invalid Unicode escape",
  ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'",
  ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
  GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block",
  IllegalBreakContinue: "Unsyntactic %0",
  IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
  IllegalReturn: "'return' outside of function",
  ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments",
  ImportCallArity: "import() requires exactly %0",
  ImportCallNotNewExpression: "Cannot use new with import(...)",
  ImportCallSpreadArgument: "... is not allowed in import()",
  ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`,
  ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'`,
  InvalidBigIntLiteral: "Invalid BigIntLiteral",
  InvalidCodePoint: "Code point out of bounds",
  InvalidDigit: "Expected number in radix %0",
  InvalidEscapeSequence: "Bad character escape sequence",
  InvalidEscapeSequenceTemplate: "Invalid escape sequence in template",
  InvalidEscapedReservedWord: "Escape sequence in keyword %0",
  InvalidIdentifier: "Invalid identifier %0",
  InvalidLhs: "Invalid left-hand side in %0",
  InvalidLhsBinding: "Binding invalid left-hand side in %0",
  InvalidNumber: "Invalid number",
  InvalidOrUnexpectedToken: "Unexpected character '%0'",
  InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern",
  InvalidPrivateFieldResolution: "Private name #%0 is not defined",
  InvalidPropertyBindingPattern: "Binding member expression",
  InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions",
  InvalidRestAssignmentPattern: "Invalid rest operator's argument",
  LabelRedeclaration: "Label '%0' is already declared",
  LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
  MalformedRegExpFlags: "Invalid regular expression flag",
  MissingClassName: "A class name is required",
  MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
  MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX",
  MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators",
  ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`",
  ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values",
  ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes',
  ModuleExportUndefined: "Export '%0' is not defined",
  MultipleDefaultsInSwitch: "Multiple default clauses",
  NewlineAfterThrow: "Illegal newline after throw",
  NoCatchOrFinally: "Missing catch or finally clause",
  NumberIdentifier: "Identifier directly after number",
  NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences",
  ObsoleteAwaitStar: "await* has been removed from the async functions proposal. Use Promise.all() instead.",
  OptionalChainingNoNew: "constructors in/after an Optional Chain are not allowed",
  OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain",
  ParamDupe: "Argument name clash",
  PatternHasAccessor: "Object pattern can't contain getter or setter",
  PatternHasMethod: "Object pattern can't contain methods",
  PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized',
  PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression",
  PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression",
  PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference",
  PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding",
  PrimaryTopicRequiresSmartPipeline: "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.",
  PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`)",
  PrivateNameRedeclaration: "Duplicate private name #%0",
  RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
  RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
  RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'",
  RecordNoProto: "'__proto__' is not allowed in Record expressions",
  RestTrailingComma: "Unexpected trailing comma after rest element",
  SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement",
  StaticPrototype: "Classes may not have static property named prototype",
  StrictDelete: "Deleting local variable in strict mode",
  StrictEvalArguments: "Assigning to '%0' in strict mode",
  StrictEvalArgumentsBinding: "Binding '%0' in strict mode",
  StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
  StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode",
  StrictWith: "'with' in strict mode",
  SuperNotAllowed: "super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
  SuperPrivateField: "Private fields can't be accessed on super",
  TrailingDecorator: "Decorators must be attached to a class element",
  TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
  TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
  TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'",
  UnexpectedArgumentPlaceholder: "Unexpected argument placeholder",
  UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal',
  UnexpectedDigitAfterHash: "Unexpected digit after hash token",
  UnexpectedImportExport: "'import' and 'export' may only appear at the top level",
  UnexpectedKeyword: "Unexpected keyword '%0'",
  UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration",
  UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context",
  UnexpectedNewTarget: "new.target can only be used in functions",
  UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits",
  UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).",
  UnexpectedReservedWord: "Unexpected reserved word '%0'",
  UnexpectedSuper: "super is only allowed in object methods and classes",
  UnexpectedToken: "Unexpected token '%0'",
  UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
  UnsupportedBind: "Binding should be performed on object property.",
  UnsupportedDecoratorExport: "A decorated export must export a class declaration",
  UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
  UnsupportedImport: "import can only be used in import() or import.meta",
  UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1",
  UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters",
  UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties",
  UnsupportedSuper: "super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])",
  UnterminatedComment: "Unterminated comment",
  UnterminatedRegExp: "Unterminated regular expression",
  UnterminatedString: "Unterminated string constant",
  UnterminatedTemplate: "Unterminated template",
  VarRedeclaration: "Identifier '%0' has already been declared",
  YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator",
  YieldInParameter: "yield is not allowed in generator parameters",
  ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0"
});

class ParserError extends CommentsParser {
  getLocationForPosition(pos) {
    let loc;
    if (pos === this.state.start) loc = this.state.startLoc;else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;else if (pos === this.state.end) loc = this.state.endLoc;else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;else loc = getLineInfo(this.input, pos);
    return loc;
  }

  raise(pos, errorTemplate, ...params) {
    return this.raiseWithData(pos, undefined, errorTemplate, ...params);
  }

  raiseWithData(pos, data, errorTemplate, ...params) {
    const loc = this.getLocationForPosition(pos);
    const message = errorTemplate.replace(/%(\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;
    return this._raise(Object.assign({
      loc,
      pos
    }, data), message);
  }

  _raise(errorContext, message) {
    const err = new SyntaxError(message);
    Object.assign(err, errorContext);

    if (this.options.errorRecovery) {
      if (!this.isLookahead) this.state.errors.push(err);
      return err;
    } else {
      throw err;
    }
  }

}

function isSimpleProperty(node) {
  return node != null && node.type === "Property" && node.kind === "init" && node.method === false;
}

var estree = (superClass => class extends superClass {
  estreeParseRegExpLiteral({
    pattern,
    flags
  }) {
    let regex = null;

    try {
      regex = new RegExp(pattern, flags);
    } catch (e) {}

    const node = this.estreeParseLiteral(regex);
    node.regex = {
      pattern,
      flags
    };
    return node;
  }

  estreeParseBigIntLiteral(value) {
    const bigInt = typeof BigInt !== "undefined" ? BigInt(value) : null;
    const node = this.estreeParseLiteral(bigInt);
    node.bigint = String(node.value || value);
    return node;
  }

  estreeParseLiteral(value) {
    return this.parseLiteral(value, "Literal");
  }

  directiveToStmt(directive) {
    const directiveLiteral = directive.value;
    const stmt = this.startNodeAt(directive.start, directive.loc.start);
    const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
    expression.value = directiveLiteral.value;
    expression.raw = directiveLiteral.extra.raw;
    stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
    stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
    return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
  }

  initFunction(node, isAsync) {
    super.initFunction(node, isAsync);
    node.expression = false;
  }

  checkDeclaration(node) {
    if (isSimpleProperty(node)) {
      this.checkDeclaration(node.value);
    } else {
      super.checkDeclaration(node);
    }
  }

  checkGetterSetterParams(method) {
    const prop = method;
    const paramCount = prop.kind === "get" ? 0 : 1;
    const start = prop.start;

    if (prop.value.params.length !== paramCount) {
      if (method.kind === "get") {
        this.raise(start, ErrorMessages.BadGetterArity);
      } else {
        this.raise(start, ErrorMessages.BadSetterArity);
      }
    } else if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
      this.raise(start, ErrorMessages.BadSetterRestParameter);
    }
  }

  checkLVal(expr, bindingType = BIND_NONE, checkClashes, contextDescription, disallowLetBinding) {
    switch (expr.type) {
      case "ObjectPattern":
        expr.properties.forEach(prop => {
          this.checkLVal(prop.type === "Property" ? prop.value : prop, bindingType, checkClashes, "object destructuring pattern", disallowLetBinding);
        });
        break;

      default:
        super.checkLVal(expr, bindingType, checkClashes, contextDescription, disallowLetBinding);
    }
  }

  checkProto(prop, isRecord, protoRef, refExpressionErrors) {
    if (prop.method) {
      return;
    }

    super.checkProto(prop, isRecord, protoRef, refExpressionErrors);
  }

  isValidDirective(stmt) {
    var _stmt$expression$extr;

    return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) == null ? void 0 : _stmt$expression$extr.parenthesized);
  }

  stmtToDirective(stmt) {
    const directive = super.stmtToDirective(stmt);
    const value = stmt.expression.value;
    directive.value.value = value;
    return directive;
  }

  parseBlockBody(node, allowDirectives, topLevel, end) {
    super.parseBlockBody(node, allowDirectives, topLevel, end);
    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));
    node.body = directiveStatements.concat(node.body);
    delete node.directives;
  }

  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
    this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);

    if (method.typeParameters) {
      method.value.typeParameters = method.typeParameters;
      delete method.typeParameters;
    }

    classBody.body.push(method);
  }

  parseExprAtom(refExpressionErrors) {
    switch (this.state.type) {
      case types.num:
      case types.string:
        return this.estreeParseLiteral(this.state.value);

      case types.regexp:
        return this.estreeParseRegExpLiteral(this.state.value);

      case types.bigint:
        return this.estreeParseBigIntLiteral(this.state.value);

      case types._null:
        return this.estreeParseLiteral(null);

      case types._true:
        return this.estreeParseLiteral(true);

      case types._false:
        return this.estreeParseLiteral(false);

      default:
        return super.parseExprAtom(refExpressionErrors);
    }
  }

  parseLiteral(value, type, startPos, startLoc) {
    const node = super.parseLiteral(value, type, startPos, startLoc);
    node.raw = node.extra.raw;
    delete node.extra;
    return node;
  }

  parseFunctionBody(node, allowExpression, isMethod = false) {
    super.parseFunctionBody(node, allowExpression, isMethod);
    node.expression = node.body.type !== "BlockStatement";
  }

  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
    let funcNode = this.startNode();
    funcNode.kind = node.kind;
    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
    funcNode.type = "FunctionExpression";
    delete funcNode.kind;
    node.value = funcNode;
    type = type === "ClassMethod" ? "MethodDefinition" : type;
    return this.finishNode(node, type);
  }

  parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {
    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc);

    if (node) {
      node.type = "Property";
      if (node.kind === "method") node.kind = "init";
      node.shorthand = false;
    }

    return node;
  }

  parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
    const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);

    if (node) {
      node.kind = "init";
      node.type = "Property";
    }

    return node;
  }

  toAssignable(node) {
    if (isSimpleProperty(node)) {
      this.toAssignable(node.value);
      return node;
    }

    return super.toAssignable(node);
  }

  toAssignableObjectExpressionProp(prop, isLast) {
    if (prop.kind === "get" || prop.kind === "set") {
      throw this.raise(prop.key.start, ErrorMessages.PatternHasAccessor);
    } else if (prop.method) {
      throw this.raise(prop.key.start, ErrorMessages.PatternHasMethod);
    } else {
      super.toAssignableObjectExpressionProp(prop, isLast);
    }
  }

  finishCallExpression(node, optional) {
    super.finishCallExpression(node, optional);

    if (node.callee.type === "Import") {
      node.type = "ImportExpression";
      node.source = node.arguments[0];
      delete node.arguments;
      delete node.callee;
    } else if (node.type === "CallExpression") {
      node.optional = false;
    }

    return node;
  }

  toReferencedListDeep(exprList, isParenthesizedExpr) {
    if (!exprList) {
      return;
    }

    super.toReferencedListDeep(exprList, isParenthesizedExpr);
  }

  parseExport(node) {
    super.parseExport(node);

    switch (node.type) {
      case "ExportAllDeclaration":
        node.exported = null;
        break;

      case "ExportNamedDeclaration":
        if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
          node.type = "ExportAllDeclaration";
          node.exported = node.specifiers[0].exported;
          delete node.specifiers;
        }

        break;
    }

    return node;
  }

  parseSubscript(...args) {
    const node = super.parseSubscript(...args);

    if (node.type === "MemberExpression") {
      node.optional = false;
    }

    return node;
  }

});

class TokContext {
  constructor(token, isExpr, preserveSpace, override) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
  }

}
const types$1 = {
  braceStatement: new TokContext("{", false),
  braceExpression: new TokContext("{", true),
  templateQuasi: new TokContext("${", false),
  parenStatement: new TokContext("(", false),
  parenExpression: new TokContext("(", true),
  template: new TokContext("`", true, true, p => p.readTmplToken()),
  functionExpression: new TokContext("function", true),
  functionStatement: new TokContext("function", false)
};

types.parenR.updateContext = types.braceR.updateContext = function () {
  if (this.state.context.length === 1) {
    this.state.exprAllowed = true;
    return;
  }

  let out = this.state.context.pop();

  if (out === types$1.braceStatement && this.curContext().token === "function") {
    out = this.state.context.pop();
  }

  this.state.exprAllowed = !out.isExpr;
};

types.name.updateContext = function (prevType) {
  let allowed = false;

  if (prevType !== types.dot) {
    if (this.state.value === "of" && !this.state.exprAllowed && prevType !== types._function && prevType !== types._class || this.state.value === "yield" && this.prodParam.hasYield) {
      allowed = true;
    }
  }

  this.state.exprAllowed = allowed;

  if (this.state.isIterator) {
    this.state.isIterator = false;
  }
};

types.braceL.updateContext = function (prevType) {
  this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);
  this.state.exprAllowed = true;
};

types.dollarBraceL.updateContext = function () {
  this.state.context.push(types$1.templateQuasi);
  this.state.exprAllowed = true;
};

types.parenL.updateContext = function (prevType) {
  const statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);
  this.state.exprAllowed = true;
};

types.incDec.updateContext = function () {};

types._function.updateContext = types._class.updateContext = function (prevType) {
  if (prevType === types.dot || prevType === types.questionDot) ; else if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {
    this.state.context.push(types$1.functionExpression);
  } else {
    this.state.context.push(types$1.functionStatement);
  }

  this.state.exprAllowed = false;
};

types.backQuote.updateContext = function () {
  if (this.curContext() === types$1.template) {
    this.state.context.pop();
  } else {
    this.state.context.push(types$1.template);
  }

  this.state.exprAllowed = false;
};

types.star.updateContext = function () {
  this.state.exprAllowed = false;
};

let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
let nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
const astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

function isInAstralSet(code, set) {
  let pos = 0x10000;

  for (let i = 0, length = set.length; i < length; i += 2) {
    pos += set[i];
    if (pos > code) return false;
    pos += set[i + 1];
    if (pos >= code) return true;
  }

  return false;
}

function isIdentifierStart(code) {
  if (code < 65) return code === 36;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }

  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  }

  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}

const reservedWords = {
  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
  strictBind: ["eval", "arguments"]
};
const keywords$1 = new Set(reservedWords.keyword);
const reservedWordsStrictSet = new Set(reservedWords.strict);
const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
function isReservedWord(word, inModule) {
  return inModule && word === "await" || word === "enum";
}
function isStrictReservedWord(word, inModule) {
  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}
function isStrictBindOnlyReservedWord(word) {
  return reservedWordsStrictBindSet.has(word);
}
function isStrictBindReservedWord(word, inModule) {
  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
}
function isKeyword(word) {
  return keywords$1.has(word);
}

const keywordRelationalOperator = /^in(stanceof)?$/;
function isIteratorStart(current, next) {
  return current === 64 && next === 64;
}

const reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
const FlowErrors = Object.freeze({
  AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
  AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module",
  AssignReservedType: "Cannot overwrite reserved type %0",
  DeclareClassElement: "The `declare` modifier can only appear on class fields.",
  DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
  DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement",
  EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
  EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
  EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
  EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
  EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
  EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
  EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
  EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
  EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
  EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
  EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
  ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements",
  InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type",
  InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions",
  InexactVariance: "Explicit inexact syntax cannot have variance",
  InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`",
  MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
  NestedDeclareModule: "`declare module` cannot be used inside another `declare module`",
  NestedFlowComment: "Cannot have a flow comment inside another flow comment",
  OptionalBindingPattern: "A binding pattern parameter cannot be optional in an implementation signature.",
  SpreadVariance: "Spread properties cannot have variance",
  TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`",
  TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis",
  UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object",
  UnexpectedReservedType: "Unexpected reserved type %0",
  UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new",
  UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
  UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions",
  UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint"',
  UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration",
  UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead",
  UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module",
  UnterminatedFlowComment: "Unterminated flow-comment"
});

function isEsModuleType(bodyElement) {
  return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
}

function hasTypeImportKind(node) {
  return node.importKind === "type" || node.importKind === "typeof";
}

function isMaybeDefaultImport(state) {
  return (state.type === types.name || !!state.type.keyword) && state.value !== "from";
}

const exportSuggestions = {
  const: "declare export var",
  let: "declare export var",
  type: "export type",
  interface: "export interface"
};

function partition(list, test) {
  const list1 = [];
  const list2 = [];

  for (let i = 0; i < list.length; i++) {
    (test(list[i], i, list) ? list1 : list2).push(list[i]);
  }

  return [list1, list2];
}

const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
var flow = (superClass => class extends superClass {
  constructor(options, input) {
    super(options, input);
    this.flowPragma = undefined;
  }

  shouldParseTypes() {
    return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
  }

  shouldParseEnums() {
    return !!this.getPluginOption("flow", "enums");
  }

  finishToken(type, val) {
    if (type !== types.string && type !== types.semi && type !== types.interpreterDirective) {
      if (this.flowPragma === undefined) {
        this.flowPragma = null;
      }
    }

    return super.finishToken(type, val);
  }

  addComment(comment) {
    if (this.flowPragma === undefined) {
      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);

      if (!matches) ; else if (matches[1] === "flow") {
        this.flowPragma = "flow";
      } else if (matches[1] === "noflow") {
        this.flowPragma = "noflow";
      } else {
        throw new Error("Unexpected flow pragma");
      }
    }

    return super.addComment(comment);
  }

  flowParseTypeInitialiser(tok) {
    const oldInType = this.state.inType;
    this.state.inType = true;
    this.expect(tok || types.colon);
    const type = this.flowParseType();
    this.state.inType = oldInType;
    return type;
  }

  flowParsePredicate() {
    const node = this.startNode();
    const moduloLoc = this.state.startLoc;
    const moduloPos = this.state.start;
    this.expect(types.modulo);
    const checksLoc = this.state.startLoc;
    this.expectContextual("checks");

    if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {
      this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);
    }

    if (this.eat(types.parenL)) {
      node.value = this.parseExpression();
      this.expect(types.parenR);
      return this.finishNode(node, "DeclaredPredicate");
    } else {
      return this.finishNode(node, "InferredPredicate");
    }
  }

  flowParseTypeAndPredicateInitialiser() {
    const oldInType = this.state.inType;
    this.state.inType = true;
    this.expect(types.colon);
    let type = null;
    let predicate = null;

    if (this.match(types.modulo)) {
      this.state.inType = oldInType;
      predicate = this.flowParsePredicate();
    } else {
      type = this.flowParseType();
      this.state.inType = oldInType;

      if (this.match(types.modulo)) {
        predicate = this.flowParsePredicate();
      }
    }

    return [type, predicate];
  }

  flowParseDeclareClass(node) {
    this.next();
    this.flowParseInterfaceish(node, true);
    return this.finishNode(node, "DeclareClass");
  }

  flowParseDeclareFunction(node) {
    this.next();
    const id = node.id = this.parseIdentifier();
    const typeNode = this.startNode();
    const typeContainer = this.startNode();

    if (this.isRelational("<")) {
      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
    } else {
      typeNode.typeParameters = null;
    }

    this.expect(types.parenL);
    const tmp = this.flowParseFunctionTypeParams();
    typeNode.params = tmp.params;
    typeNode.rest = tmp.rest;
    this.expect(types.parenR);
    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
    typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
    id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
    this.resetEndLocation(id);
    this.semicolon();
    return this.finishNode(node, "DeclareFunction");
  }

  flowParseDeclare(node, insideModule) {
    if (this.match(types._class)) {
      return this.flowParseDeclareClass(node);
    } else if (this.match(types._function)) {
      return this.flowParseDeclareFunction(node);
    } else if (this.match(types._var)) {
      return this.flowParseDeclareVariable(node);
    } else if (this.eatContextual("module")) {
      if (this.match(types.dot)) {
        return this.flowParseDeclareModuleExports(node);
      } else {
        if (insideModule) {
          this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);
        }

        return this.flowParseDeclareModule(node);
      }
    } else if (this.isContextual("type")) {
      return this.flowParseDeclareTypeAlias(node);
    } else if (this.isContextual("opaque")) {
      return this.flowParseDeclareOpaqueType(node);
    } else if (this.isContextual("interface")) {
      return this.flowParseDeclareInterface(node);
    } else if (this.match(types._export)) {
      return this.flowParseDeclareExportDeclaration(node, insideModule);
    } else {
      throw this.unexpected();
    }
  }

  flowParseDeclareVariable(node) {
    this.next();
    node.id = this.flowParseTypeAnnotatableIdentifier(true);
    this.scope.declareName(node.id.name, BIND_VAR, node.id.start);
    this.semicolon();
    return this.finishNode(node, "DeclareVariable");
  }

  flowParseDeclareModule(node) {
    this.scope.enter(SCOPE_OTHER);

    if (this.match(types.string)) {
      node.id = this.parseExprAtom();
    } else {
      node.id = this.parseIdentifier();
    }

    const bodyNode = node.body = this.startNode();
    const body = bodyNode.body = [];
    this.expect(types.braceL);

    while (!this.match(types.braceR)) {
      let bodyNode = this.startNode();

      if (this.match(types._import)) {
        this.next();

        if (!this.isContextual("type") && !this.match(types._typeof)) {
          this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule);
        }

        this.parseImport(bodyNode);
      } else {
        this.expectContextual("declare", FlowErrors.UnsupportedStatementInDeclareModule);
        bodyNode = this.flowParseDeclare(bodyNode, true);
      }

      body.push(bodyNode);
    }

    this.scope.exit();
    this.expect(types.braceR);
    this.finishNode(bodyNode, "BlockStatement");
    let kind = null;
    let hasModuleExport = false;
    body.forEach(bodyElement => {
      if (isEsModuleType(bodyElement)) {
        if (kind === "CommonJS") {
          this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
        }

        kind = "ES";
      } else if (bodyElement.type === "DeclareModuleExports") {
        if (hasModuleExport) {
          this.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports);
        }

        if (kind === "ES") {
          this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
        }

        kind = "CommonJS";
        hasModuleExport = true;
      }
    });
    node.kind = kind || "CommonJS";
    return this.finishNode(node, "DeclareModule");
  }

  flowParseDeclareExportDeclaration(node, insideModule) {
    this.expect(types._export);

    if (this.eat(types._default)) {
      if (this.match(types._function) || this.match(types._class)) {
        node.declaration = this.flowParseDeclare(this.startNode());
      } else {
        node.declaration = this.flowParseType();
        this.semicolon();
      }

      node.default = true;
      return this.finishNode(node, "DeclareExportDeclaration");
    } else {
      if (this.match(types._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !insideModule) {
        const label = this.state.value;
        const suggestion = exportSuggestions[label];
        throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);
      }

      if (this.match(types._var) || this.match(types._function) || this.match(types._class) || this.isContextual("opaque")) {
          node.declaration = this.flowParseDeclare(this.startNode());
          node.default = false;
          return this.finishNode(node, "DeclareExportDeclaration");
        } else if (this.match(types.star) || this.match(types.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) {
          node = this.parseExport(node);

          if (node.type === "ExportNamedDeclaration") {
            node.type = "ExportDeclaration";
            node.default = false;
            delete node.exportKind;
          }

          node.type = "Declare" + node.type;
          return node;
        }
    }

    throw this.unexpected();
  }

  flowParseDeclareModuleExports(node) {
    this.next();
    this.expectContextual("exports");
    node.typeAnnotation = this.flowParseTypeAnnotation();
    this.semicolon();
    return this.finishNode(node, "DeclareModuleExports");
  }

  flowParseDeclareTypeAlias(node) {
    this.next();
    this.flowParseTypeAlias(node);
    node.type = "DeclareTypeAlias";
    return node;
  }

  flowParseDeclareOpaqueType(node) {
    this.next();
    this.flowParseOpaqueType(node, true);
    node.type = "DeclareOpaqueType";
    return node;
  }

  flowParseDeclareInterface(node) {
    this.next();
    this.flowParseInterfaceish(node);
    return this.finishNode(node, "DeclareInterface");
  }

  flowParseInterfaceish(node, isClass = false) {
    node.id = this.flowParseRestrictedIdentifier(!isClass, true);
    this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.start);

    if (this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterDeclaration();
    } else {
      node.typeParameters = null;
    }

    node.extends = [];
    node.implements = [];
    node.mixins = [];

    if (this.eat(types._extends)) {
      do {
        node.extends.push(this.flowParseInterfaceExtends());
      } while (!isClass && this.eat(types.comma));
    }

    if (this.isContextual("mixins")) {
      this.next();

      do {
        node.mixins.push(this.flowParseInterfaceExtends());
      } while (this.eat(types.comma));
    }

    if (this.isContextual("implements")) {
      this.next();

      do {
        node.implements.push(this.flowParseInterfaceExtends());
      } while (this.eat(types.comma));
    }

    node.body = this.flowParseObjectType({
      allowStatic: isClass,
      allowExact: false,
      allowSpread: false,
      allowProto: isClass,
      allowInexact: false
    });
  }

  flowParseInterfaceExtends() {
    const node = this.startNode();
    node.id = this.flowParseQualifiedTypeIdentifier();

    if (this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterInstantiation();
    } else {
      node.typeParameters = null;
    }

    return this.finishNode(node, "InterfaceExtends");
  }

  flowParseInterface(node) {
    this.flowParseInterfaceish(node);
    return this.finishNode(node, "InterfaceDeclaration");
  }

  checkNotUnderscore(word) {
    if (word === "_") {
      this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);
    }
  }

  checkReservedType(word, startLoc, declaration) {
    if (!reservedTypes.has(word)) return;
    this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word);
  }

  flowParseRestrictedIdentifier(liberal, declaration) {
    this.checkReservedType(this.state.value, this.state.start, declaration);
    return this.parseIdentifier(liberal);
  }

  flowParseTypeAlias(node) {
    node.id = this.flowParseRestrictedIdentifier(false, true);
    this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

    if (this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterDeclaration();
    } else {
      node.typeParameters = null;
    }

    node.right = this.flowParseTypeInitialiser(types.eq);
    this.semicolon();
    return this.finishNode(node, "TypeAlias");
  }

  flowParseOpaqueType(node, declare) {
    this.expectContextual("type");
    node.id = this.flowParseRestrictedIdentifier(true, true);
    this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

    if (this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterDeclaration();
    } else {
      node.typeParameters = null;
    }

    node.supertype = null;

    if (this.match(types.colon)) {
      node.supertype = this.flowParseTypeInitialiser(types.colon);
    }

    node.impltype = null;

    if (!declare) {
      node.impltype = this.flowParseTypeInitialiser(types.eq);
    }

    this.semicolon();
    return this.finishNode(node, "OpaqueType");
  }

  flowParseTypeParameter(requireDefault = false) {
    const nodeStart = this.state.start;
    const node = this.startNode();
    const variance = this.flowParseVariance();
    const ident = this.flowParseTypeAnnotatableIdentifier();
    node.name = ident.name;
    node.variance = variance;
    node.bound = ident.typeAnnotation;

    if (this.match(types.eq)) {
      this.eat(types.eq);
      node.default = this.flowParseType();
    } else {
      if (requireDefault) {
        this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);
      }
    }

    return this.finishNode(node, "TypeParameter");
  }

  flowParseTypeParameterDeclaration() {
    const oldInType = this.state.inType;
    const node = this.startNode();
    node.params = [];
    this.state.inType = true;

    if (this.isRelational("<") || this.match(types.jsxTagStart)) {
      this.next();
    } else {
      this.unexpected();
    }

    let defaultRequired = false;

    do {
      const typeParameter = this.flowParseTypeParameter(defaultRequired);
      node.params.push(typeParameter);

      if (typeParameter.default) {
        defaultRequired = true;
      }

      if (!this.isRelational(">")) {
        this.expect(types.comma);
      }
    } while (!this.isRelational(">"));

    this.expectRelational(">");
    this.state.inType = oldInType;
    return this.finishNode(node, "TypeParameterDeclaration");
  }

  flowParseTypeParameterInstantiation() {
    const node = this.startNode();
    const oldInType = this.state.inType;
    node.params = [];
    this.state.inType = true;
    this.expectRelational("<");
    const oldNoAnonFunctionType = this.state.noAnonFunctionType;
    this.state.noAnonFunctionType = false;

    while (!this.isRelational(">")) {
      node.params.push(this.flowParseType());

      if (!this.isRelational(">")) {
        this.expect(types.comma);
      }
    }

    this.state.noAnonFunctionType = oldNoAnonFunctionType;
    this.expectRelational(">");
    this.state.inType = oldInType;
    return this.finishNode(node, "TypeParameterInstantiation");
  }

  flowParseTypeParameterInstantiationCallOrNew() {
    const node = this.startNode();
    const oldInType = this.state.inType;
    node.params = [];
    this.state.inType = true;
    this.expectRelational("<");

    while (!this.isRelational(">")) {
      node.params.push(this.flowParseTypeOrImplicitInstantiation());

      if (!this.isRelational(">")) {
        this.expect(types.comma);
      }
    }

    this.expectRelational(">");
    this.state.inType = oldInType;
    return this.finishNode(node, "TypeParameterInstantiation");
  }

  flowParseInterfaceType() {
    const node = this.startNode();
    this.expectContextual("interface");
    node.extends = [];

    if (this.eat(types._extends)) {
      do {
        node.extends.push(this.flowParseInterfaceExtends());
      } while (this.eat(types.comma));
    }

    node.body = this.flowParseObjectType({
      allowStatic: false,
      allowExact: false,
      allowSpread: false,
      allowProto: false,
      allowInexact: false
    });
    return this.finishNode(node, "InterfaceTypeAnnotation");
  }

  flowParseObjectPropertyKey() {
    return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
  }

  flowParseObjectTypeIndexer(node, isStatic, variance) {
    node.static = isStatic;

    if (this.lookahead().type === types.colon) {
      node.id = this.flowParseObjectPropertyKey();
      node.key = this.flowParseTypeInitialiser();
    } else {
      node.id = null;
      node.key = this.flowParseType();
    }

    this.expect(types.bracketR);
    node.value = this.flowParseTypeInitialiser();
    node.variance = variance;
    return this.finishNode(node, "ObjectTypeIndexer");
  }

  flowParseObjectTypeInternalSlot(node, isStatic) {
    node.static = isStatic;
    node.id = this.flowParseObjectPropertyKey();
    this.expect(types.bracketR);
    this.expect(types.bracketR);

    if (this.isRelational("<") || this.match(types.parenL)) {
      node.method = true;
      node.optional = false;
      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
    } else {
      node.method = false;

      if (this.eat(types.question)) {
        node.optional = true;
      }

      node.value = this.flowParseTypeInitialiser();
    }

    return this.finishNode(node, "ObjectTypeInternalSlot");
  }

  flowParseObjectTypeMethodish(node) {
    node.params = [];
    node.rest = null;
    node.typeParameters = null;

    if (this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterDeclaration();
    }

    this.expect(types.parenL);

    while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
      node.params.push(this.flowParseFunctionTypeParam());

      if (!this.match(types.parenR)) {
        this.expect(types.comma);
      }
    }

    if (this.eat(types.ellipsis)) {
      node.rest = this.flowParseFunctionTypeParam();
    }

    this.expect(types.parenR);
    node.returnType = this.flowParseTypeInitialiser();
    return this.finishNode(node, "FunctionTypeAnnotation");
  }

  flowParseObjectTypeCallProperty(node, isStatic) {
    const valueNode = this.startNode();
    node.static = isStatic;
    node.value = this.flowParseObjectTypeMethodish(valueNode);
    return this.finishNode(node, "ObjectTypeCallProperty");
  }

  flowParseObjectType({
    allowStatic,
    allowExact,
    allowSpread,
    allowProto,
    allowInexact
  }) {
    const oldInType = this.state.inType;
    this.state.inType = true;
    const nodeStart = this.startNode();
    nodeStart.callProperties = [];
    nodeStart.properties = [];
    nodeStart.indexers = [];
    nodeStart.internalSlots = [];
    let endDelim;
    let exact;
    let inexact = false;

    if (allowExact && this.match(types.braceBarL)) {
      this.expect(types.braceBarL);
      endDelim = types.braceBarR;
      exact = true;
    } else {
      this.expect(types.braceL);
      endDelim = types.braceR;
      exact = false;
    }

    nodeStart.exact = exact;

    while (!this.match(endDelim)) {
      let isStatic = false;
      let protoStart = null;
      let inexactStart = null;
      const node = this.startNode();

      if (allowProto && this.isContextual("proto")) {
        const lookahead = this.lookahead();

        if (lookahead.type !== types.colon && lookahead.type !== types.question) {
          this.next();
          protoStart = this.state.start;
          allowStatic = false;
        }
      }

      if (allowStatic && this.isContextual("static")) {
        const lookahead = this.lookahead();

        if (lookahead.type !== types.colon && lookahead.type !== types.question) {
          this.next();
          isStatic = true;
        }
      }

      const variance = this.flowParseVariance();

      if (this.eat(types.bracketL)) {
        if (protoStart != null) {
          this.unexpected(protoStart);
        }

        if (this.eat(types.bracketL)) {
          if (variance) {
            this.unexpected(variance.start);
          }

          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
        } else {
          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
        }
      } else if (this.match(types.parenL) || this.isRelational("<")) {
        if (protoStart != null) {
          this.unexpected(protoStart);
        }

        if (variance) {
          this.unexpected(variance.start);
        }

        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
      } else {
        let kind = "init";

        if (this.isContextual("get") || this.isContextual("set")) {
          const lookahead = this.lookahead();

          if (lookahead.type === types.name || lookahead.type === types.string || lookahead.type === types.num) {
            kind = this.state.value;
            this.next();
          }
        }

        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);

        if (propOrInexact === null) {
          inexact = true;
          inexactStart = this.state.lastTokStart;
        } else {
          nodeStart.properties.push(propOrInexact);
        }
      }

      this.flowObjectTypeSemicolon();

      if (inexactStart && !this.match(types.braceR) && !this.match(types.braceBarR)) {
        this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);
      }
    }

    this.expect(endDelim);

    if (allowSpread) {
      nodeStart.inexact = inexact;
    }

    const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
    this.state.inType = oldInType;
    return out;
  }

  flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {
    if (this.eat(types.ellipsis)) {
      const isInexactToken = this.match(types.comma) || this.match(types.semi) || this.match(types.braceR) || this.match(types.braceBarR);

      if (isInexactToken) {
        if (!allowSpread) {
          this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject);
        } else if (!allowInexact) {
          this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);
        }

        if (variance) {
          this.raise(variance.start, FlowErrors.InexactVariance);
        }

        return null;
      }

      if (!allowSpread) {
        this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);
      }

      if (protoStart != null) {
        this.unexpected(protoStart);
      }

      if (variance) {
        this.raise(variance.start, FlowErrors.SpreadVariance);
      }

      node.argument = this.flowParseType();
      return this.finishNode(node, "ObjectTypeSpreadProperty");
    } else {
      node.key = this.flowParseObjectPropertyKey();
      node.static = isStatic;
      node.proto = protoStart != null;
      node.kind = kind;
      let optional = false;

      if (this.isRelational("<") || this.match(types.parenL)) {
        node.method = true;

        if (protoStart != null) {
          this.unexpected(protoStart);
        }

        if (variance) {
          this.unexpected(variance.start);
        }

        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));

        if (kind === "get" || kind === "set") {
          this.flowCheckGetterSetterParams(node);
        }
      } else {
        if (kind !== "init") this.unexpected();
        node.method = false;

        if (this.eat(types.question)) {
          optional = true;
        }

        node.value = this.flowParseTypeInitialiser();
        node.variance = variance;
      }

      node.optional = optional;
      return this.finishNode(node, "ObjectTypeProperty");
    }
  }

  flowCheckGetterSetterParams(property) {
    const paramCount = property.kind === "get" ? 0 : 1;
    const start = property.start;
    const length = property.value.params.length + (property.value.rest ? 1 : 0);

    if (length !== paramCount) {
      if (property.kind === "get") {
        this.raise(start, ErrorMessages.BadGetterArity);
      } else {
        this.raise(start, ErrorMessages.BadSetterArity);
      }
    }

    if (property.kind === "set" && property.value.rest) {
      this.raise(start, ErrorMessages.BadSetterRestParameter);
    }
  }

  flowObjectTypeSemicolon() {
    if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {
      this.unexpected();
    }
  }

  flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
    startPos = startPos || this.state.start;
    startLoc = startLoc || this.state.startLoc;
    let node = id || this.flowParseRestrictedIdentifier(true);

    while (this.eat(types.dot)) {
      const node2 = this.startNodeAt(startPos, startLoc);
      node2.qualification = node;
      node2.id = this.flowParseRestrictedIdentifier(true);
      node = this.finishNode(node2, "QualifiedTypeIdentifier");
    }

    return node;
  }

  flowParseGenericType(startPos, startLoc, id) {
    const node = this.startNodeAt(startPos, startLoc);
    node.typeParameters = null;
    node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

    if (this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterInstantiation();
    }

    return this.finishNode(node, "GenericTypeAnnotation");
  }

  flowParseTypeofType() {
    const node = this.startNode();
    this.expect(types._typeof);
    node.argument = this.flowParsePrimaryType();
    return this.finishNode(node, "TypeofTypeAnnotation");
  }

  flowParseTupleType() {
    const node = this.startNode();
    node.types = [];
    this.expect(types.bracketL);

    while (this.state.pos < this.length && !this.match(types.bracketR)) {
      node.types.push(this.flowParseType());
      if (this.match(types.bracketR)) break;
      this.expect(types.comma);
    }

    this.expect(types.bracketR);
    return this.finishNode(node, "TupleTypeAnnotation");
  }

  flowParseFunctionTypeParam() {
    let name = null;
    let optional = false;
    let typeAnnotation = null;
    const node = this.startNode();
    const lh = this.lookahead();

    if (lh.type === types.colon || lh.type === types.question) {
      name = this.parseIdentifier();

      if (this.eat(types.question)) {
        optional = true;
      }

      typeAnnotation = this.flowParseTypeInitialiser();
    } else {
      typeAnnotation = this.flowParseType();
    }

    node.name = name;
    node.optional = optional;
    node.typeAnnotation = typeAnnotation;
    return this.finishNode(node, "FunctionTypeParam");
  }

  reinterpretTypeAsFunctionTypeParam(type) {
    const node = this.startNodeAt(type.start, type.loc.start);
    node.name = null;
    node.optional = false;
    node.typeAnnotation = type;
    return this.finishNode(node, "FunctionTypeParam");
  }

  flowParseFunctionTypeParams(params = []) {
    let rest = null;

    while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
      params.push(this.flowParseFunctionTypeParam());

      if (!this.match(types.parenR)) {
        this.expect(types.comma);
      }
    }

    if (this.eat(types.ellipsis)) {
      rest = this.flowParseFunctionTypeParam();
    }

    return {
      params,
      rest
    };
  }

  flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
    switch (id.name) {
      case "any":
        return this.finishNode(node, "AnyTypeAnnotation");

      case "bool":
      case "boolean":
        return this.finishNode(node, "BooleanTypeAnnotation");

      case "mixed":
        return this.finishNode(node, "MixedTypeAnnotation");

      case "empty":
        return this.finishNode(node, "EmptyTypeAnnotation");

      case "number":
        return this.finishNode(node, "NumberTypeAnnotation");

      case "string":
        return this.finishNode(node, "StringTypeAnnotation");

      case "symbol":
        return this.finishNode(node, "SymbolTypeAnnotation");

      default:
        this.checkNotUnderscore(id.name);
        return this.flowParseGenericType(startPos, startLoc, id);
    }
  }

  flowParsePrimaryType() {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const node = this.startNode();
    let tmp;
    let type;
    let isGroupedType = false;
    const oldNoAnonFunctionType = this.state.noAnonFunctionType;

    switch (this.state.type) {
      case types.name:
        if (this.isContextual("interface")) {
          return this.flowParseInterfaceType();
        }

        return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());

      case types.braceL:
        return this.flowParseObjectType({
          allowStatic: false,
          allowExact: false,
          allowSpread: true,
          allowProto: false,
          allowInexact: true
        });

      case types.braceBarL:
        return this.flowParseObjectType({
          allowStatic: false,
          allowExact: true,
          allowSpread: true,
          allowProto: false,
          allowInexact: false
        });

      case types.bracketL:
        this.state.noAnonFunctionType = false;
        type = this.flowParseTupleType();
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
        return type;

      case types.relational:
        if (this.state.value === "<") {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
          this.expect(types.parenL);
          tmp = this.flowParseFunctionTypeParams();
          node.params = tmp.params;
          node.rest = tmp.rest;
          this.expect(types.parenR);
          this.expect(types.arrow);
          node.returnType = this.flowParseType();
          return this.finishNode(node, "FunctionTypeAnnotation");
        }

        break;

      case types.parenL:
        this.next();

        if (!this.match(types.parenR) && !this.match(types.ellipsis)) {
          if (this.match(types.name)) {
            const token = this.lookahead().type;
            isGroupedType = token !== types.question && token !== types.colon;
          } else {
            isGroupedType = true;
          }
        }

        if (isGroupedType) {
          this.state.noAnonFunctionType = false;
          type = this.flowParseType();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;

          if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {
            this.expect(types.parenR);
            return type;
          } else {
            this.eat(types.comma);
          }
        }

        if (type) {
          tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
        } else {
          tmp = this.flowParseFunctionTypeParams();
        }

        node.params = tmp.params;
        node.rest = tmp.rest;
        this.expect(types.parenR);
        this.expect(types.arrow);
        node.returnType = this.flowParseType();
        node.typeParameters = null;
        return this.finishNode(node, "FunctionTypeAnnotation");

      case types.string:
        return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");

      case types._true:
      case types._false:
        node.value = this.match(types._true);
        this.next();
        return this.finishNode(node, "BooleanLiteralTypeAnnotation");

      case types.plusMin:
        if (this.state.value === "-") {
          this.next();

          if (this.match(types.num)) {
            return this.parseLiteral(-this.state.value, "NumberLiteralTypeAnnotation", node.start, node.loc.start);
          }

          if (this.match(types.bigint)) {
            return this.parseLiteral(-this.state.value, "BigIntLiteralTypeAnnotation", node.start, node.loc.start);
          }

          throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);
        }

        throw this.unexpected();

      case types.num:
        return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");

      case types.bigint:
        return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");

      case types._void:
        this.next();
        return this.finishNode(node, "VoidTypeAnnotation");

      case types._null:
        this.next();
        return this.finishNode(node, "NullLiteralTypeAnnotation");

      case types._this:
        this.next();
        return this.finishNode(node, "ThisTypeAnnotation");

      case types.star:
        this.next();
        return this.finishNode(node, "ExistsTypeAnnotation");

      default:
        if (this.state.type.keyword === "typeof") {
          return this.flowParseTypeofType();
        } else if (this.state.type.keyword) {
          const label = this.state.type.label;
          this.next();
          return super.createIdentifier(node, label);
        }

    }

    throw this.unexpected();
  }

  flowParsePostfixType() {
    const startPos = this.state.start,
          startLoc = this.state.startLoc;
    let type = this.flowParsePrimaryType();

    while (this.match(types.bracketL) && !this.canInsertSemicolon()) {
      const node = this.startNodeAt(startPos, startLoc);
      node.elementType = type;
      this.expect(types.bracketL);
      this.expect(types.bracketR);
      type = this.finishNode(node, "ArrayTypeAnnotation");
    }

    return type;
  }

  flowParsePrefixType() {
    const node = this.startNode();

    if (this.eat(types.question)) {
      node.typeAnnotation = this.flowParsePrefixType();
      return this.finishNode(node, "NullableTypeAnnotation");
    } else {
      return this.flowParsePostfixType();
    }
  }

  flowParseAnonFunctionWithoutParens() {
    const param = this.flowParsePrefixType();

    if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {
      const node = this.startNodeAt(param.start, param.loc.start);
      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
      node.rest = null;
      node.returnType = this.flowParseType();
      node.typeParameters = null;
      return this.finishNode(node, "FunctionTypeAnnotation");
    }

    return param;
  }

  flowParseIntersectionType() {
    const node = this.startNode();
    this.eat(types.bitwiseAND);
    const type = this.flowParseAnonFunctionWithoutParens();
    node.types = [type];

    while (this.eat(types.bitwiseAND)) {
      node.types.push(this.flowParseAnonFunctionWithoutParens());
    }

    return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
  }

  flowParseUnionType() {
    const node = this.startNode();
    this.eat(types.bitwiseOR);
    const type = this.flowParseIntersectionType();
    node.types = [type];

    while (this.eat(types.bitwiseOR)) {
      node.types.push(this.flowParseIntersectionType());
    }

    return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
  }

  flowParseType() {
    const oldInType = this.state.inType;
    this.state.inType = true;
    const type = this.flowParseUnionType();
    this.state.inType = oldInType;
    this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType;
    return type;
  }

  flowParseTypeOrImplicitInstantiation() {
    if (this.state.type === types.name && this.state.value === "_") {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const node = this.parseIdentifier();
      return this.flowParseGenericType(startPos, startLoc, node);
    } else {
      return this.flowParseType();
    }
  }

  flowParseTypeAnnotation() {
    const node = this.startNode();
    node.typeAnnotation = this.flowParseTypeInitialiser();
    return this.finishNode(node, "TypeAnnotation");
  }

  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();

    if (this.match(types.colon)) {
      ident.typeAnnotation = this.flowParseTypeAnnotation();
      this.resetEndLocation(ident);
    }

    return ident;
  }

  typeCastToParameter(node) {
    node.expression.typeAnnotation = node.typeAnnotation;
    this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
    return node.expression;
  }

  flowParseVariance() {
    let variance = null;

    if (this.match(types.plusMin)) {
      variance = this.startNode();

      if (this.state.value === "+") {
        variance.kind = "plus";
      } else {
        variance.kind = "minus";
      }

      this.next();
      this.finishNode(variance, "Variance");
    }

    return variance;
  }

  parseFunctionBody(node, allowExpressionBody, isMethod = false) {
    if (allowExpressionBody) {
      return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
    }

    return super.parseFunctionBody(node, false, isMethod);
  }

  parseFunctionBodyAndFinish(node, type, isMethod = false) {
    if (this.match(types.colon)) {
      const typeNode = this.startNode();
      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
    }

    super.parseFunctionBodyAndFinish(node, type, isMethod);
  }

  parseStatement(context, topLevel) {
    if (this.state.strict && this.match(types.name) && this.state.value === "interface") {
      const node = this.startNode();
      this.next();
      return this.flowParseInterface(node);
    } else if (this.shouldParseEnums() && this.isContextual("enum")) {
      const node = this.startNode();
      this.next();
      return this.flowParseEnumDeclaration(node);
    } else {
      const stmt = super.parseStatement(context, topLevel);

      if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
        this.flowPragma = null;
      }

      return stmt;
    }
  }

  parseExpressionStatement(node, expr) {
    if (expr.type === "Identifier") {
      if (expr.name === "declare") {
        if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {
          return this.flowParseDeclare(node);
        }
      } else if (this.match(types.name)) {
        if (expr.name === "interface") {
          return this.flowParseInterface(node);
        } else if (expr.name === "type") {
          return this.flowParseTypeAlias(node);
        } else if (expr.name === "opaque") {
          return this.flowParseOpaqueType(node, false);
        }
      }
    }

    return super.parseExpressionStatement(node, expr);
  }

  shouldParseExportDeclaration() {
    return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || super.shouldParseExportDeclaration();
  }

  isExportDefaultSpecifier() {
    if (this.match(types.name) && (this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) {
      return false;
    }

    return super.isExportDefaultSpecifier();
  }

  parseExportDefaultExpression() {
    if (this.shouldParseEnums() && this.isContextual("enum")) {
      const node = this.startNode();
      this.next();
      return this.flowParseEnumDeclaration(node);
    }

    return super.parseExportDefaultExpression();
  }

  parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
    if (!this.match(types.question)) return expr;

    if (refNeedsArrowPos) {
      const result = this.tryParse(() => super.parseConditional(expr, noIn, startPos, startLoc));

      if (!result.node) {
        refNeedsArrowPos.start = result.error.pos || this.state.start;
        return expr;
      }

      if (result.error) this.state = result.failState;
      return result.node;
    }

    this.expect(types.question);
    const state = this.state.clone();
    const originalNoArrowAt = this.state.noArrowAt;
    const node = this.startNodeAt(startPos, startLoc);
    let {
      consequent,
      failed
    } = this.tryParseConditionalConsequent();
    let [valid, invalid] = this.getArrowLikeExpressions(consequent);

    if (failed || invalid.length > 0) {
      const noArrowAt = [...originalNoArrowAt];

      if (invalid.length > 0) {
        this.state = state;
        this.state.noArrowAt = noArrowAt;

        for (let i = 0; i < invalid.length; i++) {
          noArrowAt.push(invalid[i].start);
        }

        ({
          consequent,
          failed
        } = this.tryParseConditionalConsequent());
        [valid, invalid] = this.getArrowLikeExpressions(consequent);
      }

      if (failed && valid.length > 1) {
        this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);
      }

      if (failed && valid.length === 1) {
        this.state = state;
        this.state.noArrowAt = noArrowAt.concat(valid[0].start);
        ({
          consequent,
          failed
        } = this.tryParseConditionalConsequent());
      }
    }

    this.getArrowLikeExpressions(consequent, true);
    this.state.noArrowAt = originalNoArrowAt;
    this.expect(types.colon);
    node.test = expr;
    node.consequent = consequent;
    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(noIn, undefined, undefined, undefined));
    return this.finishNode(node, "ConditionalExpression");
  }

  tryParseConditionalConsequent() {
    this.state.noArrowParamsConversionAt.push(this.state.start);
    const consequent = this.parseMaybeAssign();
    const failed = !this.match(types.colon);
    this.state.noArrowParamsConversionAt.pop();
    return {
      consequent,
      failed
    };
  }

  getArrowLikeExpressions(node, disallowInvalid) {
    const stack = [node];
    const arrows = [];

    while (stack.length !== 0) {
      const node = stack.pop();

      if (node.type === "ArrowFunctionExpression") {
        if (node.typeParameters || !node.returnType) {
          this.finishArrowValidation(node);
        } else {
          arrows.push(node);
        }

        stack.push(node.body);
      } else if (node.type === "ConditionalExpression") {
        stack.push(node.consequent);
        stack.push(node.alternate);
      }
    }

    if (disallowInvalid) {
      arrows.forEach(node => this.finishArrowValidation(node));
      return [arrows, []];
    }

    return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));
  }

  finishArrowValidation(node) {
    var _node$extra;

    this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma);
    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
    super.checkParams(node, false, true);
    this.scope.exit();
  }

  forwardNoArrowParamsConversionAt(node, parse) {
    let result;

    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      result = parse();
      this.state.noArrowParamsConversionAt.pop();
    } else {
      result = parse();
    }

    return result;
  }

  parseParenItem(node, startPos, startLoc) {
    node = super.parseParenItem(node, startPos, startLoc);

    if (this.eat(types.question)) {
      node.optional = true;
      this.resetEndLocation(node);
    }

    if (this.match(types.colon)) {
      const typeCastNode = this.startNodeAt(startPos, startLoc);
      typeCastNode.expression = node;
      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
      return this.finishNode(typeCastNode, "TypeCastExpression");
    }

    return node;
  }

  assertModuleNodeAllowed(node) {
    if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
      return;
    }

    super.assertModuleNodeAllowed(node);
  }

  parseExport(node) {
    const decl = super.parseExport(node);

    if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
      decl.exportKind = decl.exportKind || "value";
    }

    return decl;
  }

  parseExportDeclaration(node) {
    if (this.isContextual("type")) {
      node.exportKind = "type";
      const declarationNode = this.startNode();
      this.next();

      if (this.match(types.braceL)) {
        node.specifiers = this.parseExportSpecifiers();
        this.parseExportFrom(node);
        return null;
      } else {
        return this.flowParseTypeAlias(declarationNode);
      }
    } else if (this.isContextual("opaque")) {
      node.exportKind = "type";
      const declarationNode = this.startNode();
      this.next();
      return this.flowParseOpaqueType(declarationNode, false);
    } else if (this.isContextual("interface")) {
      node.exportKind = "type";
      const declarationNode = this.startNode();
      this.next();
      return this.flowParseInterface(declarationNode);
    } else if (this.shouldParseEnums() && this.isContextual("enum")) {
      node.exportKind = "value";
      const declarationNode = this.startNode();
      this.next();
      return this.flowParseEnumDeclaration(declarationNode);
    } else {
      return super.parseExportDeclaration(node);
    }
  }

  eatExportStar(node) {
    if (super.eatExportStar(...arguments)) return true;

    if (this.isContextual("type") && this.lookahead().type === types.star) {
      node.exportKind = "type";
      this.next();
      this.next();
      return true;
    }

    return false;
  }

  maybeParseExportNamespaceSpecifier(node) {
    const pos = this.state.start;
    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);

    if (hasNamespace && node.exportKind === "type") {
      this.unexpected(pos);
    }

    return hasNamespace;
  }

  parseClassId(node, isStatement, optionalId) {
    super.parseClassId(node, isStatement, optionalId);

    if (this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterDeclaration();
    }
  }

  parseClassMember(classBody, member, state, constructorAllowsSuper) {
    const pos = this.state.start;

    if (this.isContextual("declare")) {
      if (this.parseClassMemberFromModifier(classBody, member)) {
        return;
      }

      member.declare = true;
    }

    super.parseClassMember(classBody, member, state, constructorAllowsSuper);

    if (member.declare) {
      if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty") {
        this.raise(pos, FlowErrors.DeclareClassElement);
      } else if (member.value) {
        this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer);
      }
    }
  }

  getTokenFromCode(code) {
    const next = this.input.charCodeAt(this.state.pos + 1);

    if (code === 123 && next === 124) {
      return this.finishOp(types.braceBarL, 2);
    } else if (this.state.inType && (code === 62 || code === 60)) {
      return this.finishOp(types.relational, 1);
    } else if (isIteratorStart(code, next)) {
      this.state.isIterator = true;
      return super.readWord();
    } else {
      return super.getTokenFromCode(code);
    }
  }

  isAssignable(node, isBinding) {
    switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
        return true;

      case "ObjectExpression":
        {
          const last = node.properties.length - 1;
          return node.properties.every((prop, i) => {
            return prop.type !== "ObjectMethod" && (i === last || prop.type === "SpreadElement") && this.isAssignable(prop);
          });
        }

      case "ObjectProperty":
        return this.isAssignable(node.value);

      case "SpreadElement":
        return this.isAssignable(node.argument);

      case "ArrayExpression":
        return node.elements.every(element => this.isAssignable(element));

      case "AssignmentExpression":
        return node.operator === "=";

      case "ParenthesizedExpression":
      case "TypeCastExpression":
        return this.isAssignable(node.expression);

      case "MemberExpression":
      case "OptionalMemberExpression":
        return !isBinding;

      default:
        return false;
    }
  }

  toAssignable(node) {
    if (node.type === "TypeCastExpression") {
      return super.toAssignable(this.typeCastToParameter(node));
    } else {
      return super.toAssignable(node);
    }
  }

  toAssignableList(exprList, trailingCommaPos) {
    for (let i = 0; i < exprList.length; i++) {
      const expr = exprList[i];

      if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
        exprList[i] = this.typeCastToParameter(expr);
      }
    }

    return super.toAssignableList(exprList, trailingCommaPos);
  }

  toReferencedList(exprList, isParenthesizedExpr) {
    for (let i = 0; i < exprList.length; i++) {
      var _expr$extra;

      const expr = exprList[i];

      if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) == null ? void 0 : _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
        this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);
      }
    }

    return exprList;
  }

  checkLVal(expr, bindingType = BIND_NONE, checkClashes, contextDescription) {
    if (expr.type !== "TypeCastExpression") {
      return super.checkLVal(expr, bindingType, checkClashes, contextDescription);
    }
  }

  parseClassProperty(node) {
    if (this.match(types.colon)) {
      node.typeAnnotation = this.flowParseTypeAnnotation();
    }

    return super.parseClassProperty(node);
  }

  parseClassPrivateProperty(node) {
    if (this.match(types.colon)) {
      node.typeAnnotation = this.flowParseTypeAnnotation();
    }

    return super.parseClassPrivateProperty(node);
  }

  isClassMethod() {
    return this.isRelational("<") || super.isClassMethod();
  }

  isClassProperty() {
    return this.match(types.colon) || super.isClassProperty();
  }

  isNonstaticConstructor(method) {
    return !this.match(types.colon) && super.isNonstaticConstructor(method);
  }

  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
    if (method.variance) {
      this.unexpected(method.variance.start);
    }

    delete method.variance;

    if (this.isRelational("<")) {
      method.typeParameters = this.flowParseTypeParameterDeclaration();
    }

    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
  }

  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
    if (method.variance) {
      this.unexpected(method.variance.start);
    }

    delete method.variance;

    if (this.isRelational("<")) {
      method.typeParameters = this.flowParseTypeParameterDeclaration();
    }

    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
  }

  parseClassSuper(node) {
    super.parseClassSuper(node);

    if (node.superClass && this.isRelational("<")) {
      node.superTypeParameters = this.flowParseTypeParameterInstantiation();
    }

    if (this.isContextual("implements")) {
      this.next();
      const implemented = node.implements = [];

      do {
        const node = this.startNode();
        node.id = this.flowParseRestrictedIdentifier(true);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        } else {
          node.typeParameters = null;
        }

        implemented.push(this.finishNode(node, "ClassImplements"));
      } while (this.eat(types.comma));
    }
  }

  parsePropertyName(node, isPrivateNameAllowed) {
    const variance = this.flowParseVariance();
    const key = super.parsePropertyName(node, isPrivateNameAllowed);
    node.variance = variance;
    return key;
  }

  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc) {
    if (prop.variance) {
      this.unexpected(prop.variance.start);
    }

    delete prop.variance;
    let typeParameters;

    if (this.isRelational("<")) {
      typeParameters = this.flowParseTypeParameterDeclaration();
      if (!this.match(types.parenL)) this.unexpected();
    }

    super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc);

    if (typeParameters) {
      (prop.value || prop).typeParameters = typeParameters;
    }
  }

  parseAssignableListItemTypes(param) {
    if (this.eat(types.question)) {
      if (param.type !== "Identifier") {
        this.raise(param.start, FlowErrors.OptionalBindingPattern);
      }

      param.optional = true;
    }

    if (this.match(types.colon)) {
      param.typeAnnotation = this.flowParseTypeAnnotation();
    }

    this.resetEndLocation(param);
    return param;
  }

  parseMaybeDefault(startPos, startLoc, left) {
    const node = super.parseMaybeDefault(startPos, startLoc, left);

    if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
      this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);
    }

    return node;
  }

  shouldParseDefaultImport(node) {
    if (!hasTypeImportKind(node)) {
      return super.shouldParseDefaultImport(node);
    }

    return isMaybeDefaultImport(this.state);
  }

  parseImportSpecifierLocal(node, specifier, type, contextDescription) {
    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
    this.checkLVal(specifier.local, BIND_LEXICAL, undefined, contextDescription);
    node.specifiers.push(this.finishNode(specifier, type));
  }

  maybeParseDefaultImportSpecifier(node) {
    node.importKind = "value";
    let kind = null;

    if (this.match(types._typeof)) {
      kind = "typeof";
    } else if (this.isContextual("type")) {
      kind = "type";
    }

    if (kind) {
      const lh = this.lookahead();

      if (kind === "type" && lh.type === types.star) {
        this.unexpected(lh.start);
      }

      if (isMaybeDefaultImport(lh) || lh.type === types.braceL || lh.type === types.star) {
        this.next();
        node.importKind = kind;
      }
    }

    return super.maybeParseDefaultImportSpecifier(node);
  }

  parseImportSpecifier(node) {
    const specifier = this.startNode();
    const firstIdentLoc = this.state.start;
    const firstIdent = this.parseIdentifier(true);
    let specifierTypeKind = null;

    if (firstIdent.name === "type") {
      specifierTypeKind = "type";
    } else if (firstIdent.name === "typeof") {
      specifierTypeKind = "typeof";
    }

    let isBinding = false;

    if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
      const as_ident = this.parseIdentifier(true);

      if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {
        specifier.imported = as_ident;
        specifier.importKind = specifierTypeKind;
        specifier.local = as_ident.__clone();
      } else {
        specifier.imported = firstIdent;
        specifier.importKind = null;
        specifier.local = this.parseIdentifier();
      }
    } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {
      specifier.imported = this.parseIdentifier(true);
      specifier.importKind = specifierTypeKind;

      if (this.eatContextual("as")) {
        specifier.local = this.parseIdentifier();
      } else {
        isBinding = true;
        specifier.local = specifier.imported.__clone();
      }
    } else {
      isBinding = true;
      specifier.imported = firstIdent;
      specifier.importKind = null;
      specifier.local = specifier.imported.__clone();
    }

    const nodeIsTypeImport = hasTypeImportKind(node);
    const specifierIsTypeImport = hasTypeImportKind(specifier);

    if (nodeIsTypeImport && specifierIsTypeImport) {
      this.raise(firstIdentLoc, FlowErrors.ImportTypeShorthandOnlyInPureImport);
    }

    if (nodeIsTypeImport || specifierIsTypeImport) {
      this.checkReservedType(specifier.local.name, specifier.local.start, true);
    }

    if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
      this.checkReservedWord(specifier.local.name, specifier.start, true, true);
    }

    this.checkLVal(specifier.local, BIND_LEXICAL, undefined, "import specifier");
    node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
  }

  parseFunctionParams(node, allowModifiers) {
    const kind = node.kind;

    if (kind !== "get" && kind !== "set" && this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterDeclaration();
    }

    super.parseFunctionParams(node, allowModifiers);
  }

  parseVarId(decl, kind) {
    super.parseVarId(decl, kind);

    if (this.match(types.colon)) {
      decl.id.typeAnnotation = this.flowParseTypeAnnotation();
      this.resetEndLocation(decl.id);
    }
  }

  parseAsyncArrowFromCallExpression(node, call) {
    if (this.match(types.colon)) {
      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
      this.state.noAnonFunctionType = true;
      node.returnType = this.flowParseTypeAnnotation();
      this.state.noAnonFunctionType = oldNoAnonFunctionType;
    }

    return super.parseAsyncArrowFromCallExpression(node, call);
  }

  shouldParseAsyncArrow() {
    return this.match(types.colon) || super.shouldParseAsyncArrow();
  }

  parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
    var _jsx;

    let state = null;
    let jsx;

    if (this.hasPlugin("jsx") && (this.match(types.jsxTagStart) || this.isRelational("<"))) {
      state = this.state.clone();
      jsx = this.tryParse(() => super.parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos), state);
      if (!jsx.error) return jsx.node;
      const {
        context
      } = this.state;

      if (context[context.length - 1] === types$1.j_oTag) {
        context.length -= 2;
      } else if (context[context.length - 1] === types$1.j_expr) {
        context.length -= 1;
      }
    }

    if (((_jsx = jsx) == null ? void 0 : _jsx.error) || this.isRelational("<")) {
      var _arrow$node, _jsx2, _jsx3;

      state = state || this.state.clone();
      let typeParameters;
      const arrow = this.tryParse(() => {
        typeParameters = this.flowParseTypeParameterDeclaration();
        const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => super.parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos));
        arrowExpression.typeParameters = typeParameters;
        this.resetStartLocationFromNode(arrowExpression, typeParameters);
        return arrowExpression;
      }, state);
      const arrowExpression = ((_arrow$node = arrow.node) == null ? void 0 : _arrow$node.type) === "ArrowFunctionExpression" ? arrow.node : null;
      if (!arrow.error && arrowExpression) return arrowExpression;

      if ((_jsx2 = jsx) == null ? void 0 : _jsx2.node) {
        this.state = jsx.failState;
        return jsx.node;
      }

      if (arrowExpression) {
        this.state = arrow.failState;
        return arrowExpression;
      }

      if ((_jsx3 = jsx) == null ? void 0 : _jsx3.thrown) throw jsx.error;
      if (arrow.thrown) throw arrow.error;
      throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);
    }

    return super.parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos);
  }

  parseArrow(node) {
    if (this.match(types.colon)) {
      const result = this.tryParse(() => {
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true;
        const typeNode = this.startNode();
        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
        if (this.canInsertSemicolon()) this.unexpected();
        if (!this.match(types.arrow)) this.unexpected();
        return typeNode;
      });
      if (result.thrown) return null;
      if (result.error) this.state = result.failState;
      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
    }

    return super.parseArrow(node);
  }

  shouldParseArrow() {
    return this.match(types.colon) || super.shouldParseArrow();
  }

  setArrowFunctionParameters(node, params) {
    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
      node.params = params;
    } else {
      super.setArrowFunctionParameters(node, params);
    }
  }

  checkParams(node, allowDuplicates, isArrowFunction) {
    if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
      return;
    }

    return super.checkParams(...arguments);
  }

  parseParenAndDistinguishExpression(canBeArrow) {
    return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
  }

  parseSubscripts(base, startPos, startLoc, noCalls) {
    if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
      this.next();
      const node = this.startNodeAt(startPos, startLoc);
      node.callee = base;
      node.arguments = this.parseCallExpressionArguments(types.parenR, false);
      base = this.finishNode(node, "CallExpression");
    } else if (base.type === "Identifier" && base.name === "async" && this.isRelational("<")) {
      const state = this.state.clone();
      const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);
      if (!arrow.error && !arrow.aborted) return arrow.node;
      const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);
      if (result.node && !result.error) return result.node;

      if (arrow.node) {
        this.state = arrow.failState;
        return arrow.node;
      }

      if (result.node) {
        this.state = result.failState;
        return result.node;
      }

      throw arrow.error || result.error;
    }

    return super.parseSubscripts(base, startPos, startLoc, noCalls);
  }

  parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
    if (this.match(types.questionDot) && this.isLookaheadRelational("<")) {
      subscriptState.optionalChainMember = true;

      if (noCalls) {
        subscriptState.stop = true;
        return base;
      }

      this.next();
      const node = this.startNodeAt(startPos, startLoc);
      node.callee = base;
      node.typeArguments = this.flowParseTypeParameterInstantiation();
      this.expect(types.parenL);
      node.arguments = this.parseCallExpressionArguments(types.parenR, false);
      node.optional = true;
      return this.finishCallExpression(node, true);
    } else if (!noCalls && this.shouldParseTypes() && this.isRelational("<")) {
      const node = this.startNodeAt(startPos, startLoc);
      node.callee = base;
      const result = this.tryParse(() => {
        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
        this.expect(types.parenL);
        node.arguments = this.parseCallExpressionArguments(types.parenR, false);
        if (subscriptState.optionalChainMember) node.optional = false;
        return this.finishCallExpression(node, subscriptState.optionalChainMember);
      });

      if (result.node) {
        if (result.error) this.state = result.failState;
        return result.node;
      }
    }

    return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);
  }

  parseNewArguments(node) {
    let targs = null;

    if (this.shouldParseTypes() && this.isRelational("<")) {
      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
    }

    node.typeArguments = targs;
    super.parseNewArguments(node);
  }

  parseAsyncArrowWithTypeParameters(startPos, startLoc) {
    const node = this.startNodeAt(startPos, startLoc);
    this.parseFunctionParams(node);
    if (!this.parseArrow(node)) return;
    return this.parseArrowExpression(node, undefined, true);
  }

  readToken_mult_modulo(code) {
    const next = this.input.charCodeAt(this.state.pos + 1);

    if (code === 42 && next === 47 && this.state.hasFlowComment) {
      this.state.hasFlowComment = false;
      this.state.pos += 2;
      this.nextToken();
      return;
    }

    super.readToken_mult_modulo(code);
  }

  readToken_pipe_amp(code) {
    const next = this.input.charCodeAt(this.state.pos + 1);

    if (code === 124 && next === 125) {
      this.finishOp(types.braceBarR, 2);
      return;
    }

    super.readToken_pipe_amp(code);
  }

  parseTopLevel(file, program) {
    const fileNode = super.parseTopLevel(file, program);

    if (this.state.hasFlowComment) {
      this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);
    }

    return fileNode;
  }

  skipBlockComment() {
    if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
      if (this.state.hasFlowComment) {
        this.unexpected(null, FlowErrors.NestedFlowComment);
      }

      this.hasFlowCommentCompletion();
      this.state.pos += this.skipFlowComment();
      this.state.hasFlowComment = true;
      return;
    }

    if (this.state.hasFlowComment) {
      const end = this.input.indexOf("*-/", this.state.pos += 2);

      if (end === -1) {
        throw this.raise(this.state.pos - 2, ErrorMessages.UnterminatedComment);
      }

      this.state.pos = end + 3;
      return;
    }

    super.skipBlockComment();
  }

  skipFlowComment() {
    const {
      pos
    } = this.state;
    let shiftToFirstNonWhiteSpace = 2;

    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
      shiftToFirstNonWhiteSpace++;
    }

    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);

    if (ch2 === 58 && ch3 === 58) {
      return shiftToFirstNonWhiteSpace + 2;
    }

    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
      return shiftToFirstNonWhiteSpace + 12;
    }

    if (ch2 === 58 && ch3 !== 58) {
      return shiftToFirstNonWhiteSpace;
    }

    return false;
  }

  hasFlowCommentCompletion() {
    const end = this.input.indexOf("*/", this.state.pos);

    if (end === -1) {
      throw this.raise(this.state.pos, ErrorMessages.UnterminatedComment);
    }
  }

  flowEnumErrorBooleanMemberNotInitialized(pos, {
    enumName,
    memberName
  }) {
    this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);
  }

  flowEnumErrorInvalidMemberName(pos, {
    enumName,
    memberName
  }) {
    const suggestion = memberName[0].toUpperCase() + memberName.slice(1);
    this.raise(pos, FlowErrors.EnumInvalidMemberName, memberName, suggestion, enumName);
  }

  flowEnumErrorDuplicateMemberName(pos, {
    enumName,
    memberName
  }) {
    this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);
  }

  flowEnumErrorInconsistentMemberValues(pos, {
    enumName
  }) {
    this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);
  }

  flowEnumErrorInvalidExplicitType(pos, {
    enumName,
    suppliedType
  }) {
    return this.raise(pos, suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName, suppliedType);
  }

  flowEnumErrorInvalidMemberInitializer(pos, {
    enumName,
    explicitType,
    memberName
  }) {
    let message = null;

    switch (explicitType) {
      case "boolean":
      case "number":
      case "string":
        message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;
        break;

      case "symbol":
        message = FlowErrors.EnumInvalidMemberInitializerSymbolType;
        break;

      default:
        message = FlowErrors.EnumInvalidMemberInitializerUnknownType;
    }

    return this.raise(pos, message, enumName, memberName, explicitType);
  }

  flowEnumErrorNumberMemberNotInitialized(pos, {
    enumName,
    memberName
  }) {
    this.raise(pos, FlowErrors.EnumNumberMemberNotInitialized, enumName, memberName);
  }

  flowEnumErrorStringMemberInconsistentlyInitailized(pos, {
    enumName
  }) {
    this.raise(pos, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName);
  }

  flowEnumMemberInit() {
    const startPos = this.state.start;

    const endOfInit = () => this.match(types.comma) || this.match(types.braceR);

    switch (this.state.type) {
      case types.num:
        {
          const literal = this.parseLiteral(this.state.value, "NumericLiteral");

          if (endOfInit()) {
            return {
              type: "number",
              pos: literal.start,
              value: literal
            };
          }

          return {
            type: "invalid",
            pos: startPos
          };
        }

      case types.string:
        {
          const literal = this.parseLiteral(this.state.value, "StringLiteral");

          if (endOfInit()) {
            return {
              type: "string",
              pos: literal.start,
              value: literal
            };
          }

          return {
            type: "invalid",
            pos: startPos
          };
        }

      case types._true:
      case types._false:
        {
          const literal = this.parseBooleanLiteral();

          if (endOfInit()) {
            return {
              type: "boolean",
              pos: literal.start,
              value: literal
            };
          }

          return {
            type: "invalid",
            pos: startPos
          };
        }

      default:
        return {
          type: "invalid",
          pos: startPos
        };
    }
  }

  flowEnumMemberRaw() {
    const pos = this.state.start;
    const id = this.parseIdentifier(true);
    const init = this.eat(types.eq) ? this.flowEnumMemberInit() : {
      type: "none",
      pos
    };
    return {
      id,
      init
    };
  }

  flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {
    const {
      explicitType
    } = context;

    if (explicitType === null) {
      return;
    }

    if (explicitType !== expectedType) {
      this.flowEnumErrorInvalidMemberInitializer(pos, context);
    }
  }

  flowEnumMembers({
    enumName,
    explicitType
  }) {
    const seenNames = new Set();
    const members = {
      booleanMembers: [],
      numberMembers: [],
      stringMembers: [],
      defaultedMembers: []
    };

    while (!this.match(types.braceR)) {
      const memberNode = this.startNode();
      const {
        id,
        init
      } = this.flowEnumMemberRaw();
      const memberName = id.name;

      if (memberName === "") {
        continue;
      }

      if (/^[a-z]/.test(memberName)) {
        this.flowEnumErrorInvalidMemberName(id.start, {
          enumName,
          memberName
        });
      }

      if (seenNames.has(memberName)) {
        this.flowEnumErrorDuplicateMemberName(id.start, {
          enumName,
          memberName
        });
      }

      seenNames.add(memberName);
      const context = {
        enumName,
        explicitType,
        memberName
      };
      memberNode.id = id;

      switch (init.type) {
        case "boolean":
          {
            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "boolean");
            memberNode.init = init.value;
            members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
            break;
          }

        case "number":
          {
            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "number");
            memberNode.init = init.value;
            members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
            break;
          }

        case "string":
          {
            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "string");
            memberNode.init = init.value;
            members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
            break;
          }

        case "invalid":
          {
            throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);
          }

        case "none":
          {
            switch (explicitType) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);
                break;

              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);
                break;

              default:
                members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
            }
          }
      }

      if (!this.match(types.braceR)) {
        this.expect(types.comma);
      }
    }

    return members;
  }

  flowEnumStringMembers(initializedMembers, defaultedMembers, {
    enumName
  }) {
    if (initializedMembers.length === 0) {
      return defaultedMembers;
    } else if (defaultedMembers.length === 0) {
      return initializedMembers;
    } else if (defaultedMembers.length > initializedMembers.length) {
      for (let _i = 0; _i < initializedMembers.length; _i++) {
        const member = initializedMembers[_i];
        this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
          enumName
        });
      }

      return defaultedMembers;
    } else {
      for (let _i2 = 0; _i2 < defaultedMembers.length; _i2++) {
        const member = defaultedMembers[_i2];
        this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
          enumName
        });
      }

      return initializedMembers;
    }
  }

  flowEnumParseExplicitType({
    enumName
  }) {
    if (this.eatContextual("of")) {
      if (!this.match(types.name)) {
        throw this.flowEnumErrorInvalidExplicitType(this.state.start, {
          enumName,
          suppliedType: null
        });
      }

      const {
        value
      } = this.state;
      this.next();

      if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
        this.flowEnumErrorInvalidExplicitType(this.state.start, {
          enumName,
          suppliedType: value
        });
      }

      return value;
    }

    return null;
  }

  flowEnumBody(node, {
    enumName,
    nameLoc
  }) {
    const explicitType = this.flowEnumParseExplicitType({
      enumName
    });
    this.expect(types.braceL);
    const members = this.flowEnumMembers({
      enumName,
      explicitType
    });

    switch (explicitType) {
      case "boolean":
        node.explicitType = true;
        node.members = members.booleanMembers;
        this.expect(types.braceR);
        return this.finishNode(node, "EnumBooleanBody");

      case "number":
        node.explicitType = true;
        node.members = members.numberMembers;
        this.expect(types.braceR);
        return this.finishNode(node, "EnumNumberBody");

      case "string":
        node.explicitType = true;
        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
          enumName
        });
        this.expect(types.braceR);
        return this.finishNode(node, "EnumStringBody");

      case "symbol":
        node.members = members.defaultedMembers;
        this.expect(types.braceR);
        return this.finishNode(node, "EnumSymbolBody");

      default:
        {
          const empty = () => {
            node.members = [];
            this.expect(types.braceR);
            return this.finishNode(node, "EnumStringBody");
          };

          node.explicitType = false;
          const boolsLen = members.booleanMembers.length;
          const numsLen = members.numberMembers.length;
          const strsLen = members.stringMembers.length;
          const defaultedLen = members.defaultedMembers.length;

          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
            return empty();
          } else if (!boolsLen && !numsLen) {
            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName
            });
            this.expect(types.braceR);
            return this.finishNode(node, "EnumStringBody");
          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
            for (let _i3 = 0, _members$defaultedMem = members.defaultedMembers; _i3 < _members$defaultedMem.length; _i3++) {
              const member = _members$defaultedMem[_i3];
              this.flowEnumErrorBooleanMemberNotInitialized(member.start, {
                enumName,
                memberName: member.id.name
              });
            }

            node.members = members.booleanMembers;
            this.expect(types.braceR);
            return this.finishNode(node, "EnumBooleanBody");
          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
            for (let _i4 = 0, _members$defaultedMem2 = members.defaultedMembers; _i4 < _members$defaultedMem2.length; _i4++) {
              const member = _members$defaultedMem2[_i4];
              this.flowEnumErrorNumberMemberNotInitialized(member.start, {
                enumName,
                memberName: member.id.name
              });
            }

            node.members = members.numberMembers;
            this.expect(types.braceR);
            return this.finishNode(node, "EnumNumberBody");
          } else {
            this.flowEnumErrorInconsistentMemberValues(nameLoc, {
              enumName
            });
            return empty();
          }
        }
    }
  }

  flowParseEnumDeclaration(node) {
    const id = this.parseIdentifier();
    node.id = id;
    node.body = this.flowEnumBody(this.startNode(), {
      enumName: id.name,
      nameLoc: id.start
    });
    return this.finishNode(node, "EnumDeclaration");
  }

  updateContext(prevType) {
    if (this.match(types.name) && this.state.value === "of" && prevType === types.name && this.input.slice(this.state.lastTokStart, this.state.lastTokEnd) === "interface") {
      this.state.exprAllowed = false;
    } else {
      super.updateContext(prevType);
    }
  }

});

const entities = {
  quot: "\u0022",
  amp: "&",
  apos: "\u0027",
  lt: "<",
  gt: ">",
  nbsp: "\u00A0",
  iexcl: "\u00A1",
  cent: "\u00A2",
  pound: "\u00A3",
  curren: "\u00A4",
  yen: "\u00A5",
  brvbar: "\u00A6",
  sect: "\u00A7",
  uml: "\u00A8",
  copy: "\u00A9",
  ordf: "\u00AA",
  laquo: "\u00AB",
  not: "\u00AC",
  shy: "\u00AD",
  reg: "\u00AE",
  macr: "\u00AF",
  deg: "\u00B0",
  plusmn: "\u00B1",
  sup2: "\u00B2",
  sup3: "\u00B3",
  acute: "\u00B4",
  micro: "\u00B5",
  para: "\u00B6",
  middot: "\u00B7",
  cedil: "\u00B8",
  sup1: "\u00B9",
  ordm: "\u00BA",
  raquo: "\u00BB",
  frac14: "\u00BC",
  frac12: "\u00BD",
  frac34: "\u00BE",
  iquest: "\u00BF",
  Agrave: "\u00C0",
  Aacute: "\u00C1",
  Acirc: "\u00C2",
  Atilde: "\u00C3",
  Auml: "\u00C4",
  Aring: "\u00C5",
  AElig: "\u00C6",
  Ccedil: "\u00C7",
  Egrave: "\u00C8",
  Eacute: "\u00C9",
  Ecirc: "\u00CA",
  Euml: "\u00CB",
  Igrave: "\u00CC",
  Iacute: "\u00CD",
  Icirc: "\u00CE",
  Iuml: "\u00CF",
  ETH: "\u00D0",
  Ntilde: "\u00D1",
  Ograve: "\u00D2",
  Oacute: "\u00D3",
  Ocirc: "\u00D4",
  Otilde: "\u00D5",
  Ouml: "\u00D6",
  times: "\u00D7",
  Oslash: "\u00D8",
  Ugrave: "\u00D9",
  Uacute: "\u00DA",
  Ucirc: "\u00DB",
  Uuml: "\u00DC",
  Yacute: "\u00DD",
  THORN: "\u00DE",
  szlig: "\u00DF",
  agrave: "\u00E0",
  aacute: "\u00E1",
  acirc: "\u00E2",
  atilde: "\u00E3",
  auml: "\u00E4",
  aring: "\u00E5",
  aelig: "\u00E6",
  ccedil: "\u00E7",
  egrave: "\u00E8",
  eacute: "\u00E9",
  ecirc: "\u00EA",
  euml: "\u00EB",
  igrave: "\u00EC",
  iacute: "\u00ED",
  icirc: "\u00EE",
  iuml: "\u00EF",
  eth: "\u00F0",
  ntilde: "\u00F1",
  ograve: "\u00F2",
  oacute: "\u00F3",
  ocirc: "\u00F4",
  otilde: "\u00F5",
  ouml: "\u00F6",
  divide: "\u00F7",
  oslash: "\u00F8",
  ugrave: "\u00F9",
  uacute: "\u00FA",
  ucirc: "\u00FB",
  uuml: "\u00FC",
  yacute: "\u00FD",
  thorn: "\u00FE",
  yuml: "\u00FF",
  OElig: "\u0152",
  oelig: "\u0153",
  Scaron: "\u0160",
  scaron: "\u0161",
  Yuml: "\u0178",
  fnof: "\u0192",
  circ: "\u02C6",
  tilde: "\u02DC",
  Alpha: "\u0391",
  Beta: "\u0392",
  Gamma: "\u0393",
  Delta: "\u0394",
  Epsilon: "\u0395",
  Zeta: "\u0396",
  Eta: "\u0397",
  Theta: "\u0398",
  Iota: "\u0399",
  Kappa: "\u039A",
  Lambda: "\u039B",
  Mu: "\u039C",
  Nu: "\u039D",
  Xi: "\u039E",
  Omicron: "\u039F",
  Pi: "\u03A0",
  Rho: "\u03A1",
  Sigma: "\u03A3",
  Tau: "\u03A4",
  Upsilon: "\u03A5",
  Phi: "\u03A6",
  Chi: "\u03A7",
  Psi: "\u03A8",
  Omega: "\u03A9",
  alpha: "\u03B1",
  beta: "\u03B2",
  gamma: "\u03B3",
  delta: "\u03B4",
  epsilon: "\u03B5",
  zeta: "\u03B6",
  eta: "\u03B7",
  theta: "\u03B8",
  iota: "\u03B9",
  kappa: "\u03BA",
  lambda: "\u03BB",
  mu: "\u03BC",
  nu: "\u03BD",
  xi: "\u03BE",
  omicron: "\u03BF",
  pi: "\u03C0",
  rho: "\u03C1",
  sigmaf: "\u03C2",
  sigma: "\u03C3",
  tau: "\u03C4",
  upsilon: "\u03C5",
  phi: "\u03C6",
  chi: "\u03C7",
  psi: "\u03C8",
  omega: "\u03C9",
  thetasym: "\u03D1",
  upsih: "\u03D2",
  piv: "\u03D6",
  ensp: "\u2002",
  emsp: "\u2003",
  thinsp: "\u2009",
  zwnj: "\u200C",
  zwj: "\u200D",
  lrm: "\u200E",
  rlm: "\u200F",
  ndash: "\u2013",
  mdash: "\u2014",
  lsquo: "\u2018",
  rsquo: "\u2019",
  sbquo: "\u201A",
  ldquo: "\u201C",
  rdquo: "\u201D",
  bdquo: "\u201E",
  dagger: "\u2020",
  Dagger: "\u2021",
  bull: "\u2022",
  hellip: "\u2026",
  permil: "\u2030",
  prime: "\u2032",
  Prime: "\u2033",
  lsaquo: "\u2039",
  rsaquo: "\u203A",
  oline: "\u203E",
  frasl: "\u2044",
  euro: "\u20AC",
  image: "\u2111",
  weierp: "\u2118",
  real: "\u211C",
  trade: "\u2122",
  alefsym: "\u2135",
  larr: "\u2190",
  uarr: "\u2191",
  rarr: "\u2192",
  darr: "\u2193",
  harr: "\u2194",
  crarr: "\u21B5",
  lArr: "\u21D0",
  uArr: "\u21D1",
  rArr: "\u21D2",
  dArr: "\u21D3",
  hArr: "\u21D4",
  forall: "\u2200",
  part: "\u2202",
  exist: "\u2203",
  empty: "\u2205",
  nabla: "\u2207",
  isin: "\u2208",
  notin: "\u2209",
  ni: "\u220B",
  prod: "\u220F",
  sum: "\u2211",
  minus: "\u2212",
  lowast: "\u2217",
  radic: "\u221A",
  prop: "\u221D",
  infin: "\u221E",
  ang: "\u2220",
  and: "\u2227",
  or: "\u2228",
  cap: "\u2229",
  cup: "\u222A",
  int: "\u222B",
  there4: "\u2234",
  sim: "\u223C",
  cong: "\u2245",
  asymp: "\u2248",
  ne: "\u2260",
  equiv: "\u2261",
  le: "\u2264",
  ge: "\u2265",
  sub: "\u2282",
  sup: "\u2283",
  nsub: "\u2284",
  sube: "\u2286",
  supe: "\u2287",
  oplus: "\u2295",
  otimes: "\u2297",
  perp: "\u22A5",
  sdot: "\u22C5",
  lceil: "\u2308",
  rceil: "\u2309",
  lfloor: "\u230A",
  rfloor: "\u230B",
  lang: "\u2329",
  rang: "\u232A",
  loz: "\u25CA",
  spades: "\u2660",
  clubs: "\u2663",
  hearts: "\u2665",
  diams: "\u2666"
};

const HEX_NUMBER = /^[\da-fA-F]+$/;
const DECIMAL_NUMBER = /^\d+$/;
const JsxErrors = Object.freeze({
  AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression",
  MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>",
  MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>",
  UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text",
  UnterminatedJsxContent: "Unterminated JSX contents",
  UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
});
types$1.j_oTag = new TokContext("<tag", false);
types$1.j_cTag = new TokContext("</tag", false);
types$1.j_expr = new TokContext("<tag>...</tag>", true, true);
types.jsxName = new TokenType("jsxName");
types.jsxText = new TokenType("jsxText", {
  beforeExpr: true
});
types.jsxTagStart = new TokenType("jsxTagStart", {
  startsExpr: true
});
types.jsxTagEnd = new TokenType("jsxTagEnd");

types.jsxTagStart.updateContext = function () {
  this.state.context.push(types$1.j_expr);
  this.state.context.push(types$1.j_oTag);
  this.state.exprAllowed = false;
};

types.jsxTagEnd.updateContext = function (prevType) {
  const out = this.state.context.pop();

  if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {
    this.state.context.pop();
    this.state.exprAllowed = this.curContext() === types$1.j_expr;
  } else {
    this.state.exprAllowed = true;
  }
};

function isFragment(object) {
  return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
}

function getQualifiedJSXName(object) {
  if (object.type === "JSXIdentifier") {
    return object.name;
  }

  if (object.type === "JSXNamespacedName") {
    return object.namespace.name + ":" + object.name.name;
  }

  if (object.type === "JSXMemberExpression") {
    return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
  }

  throw new Error("Node had unexpected type: " + object.type);
}

var jsx = (superClass => class extends superClass {
  jsxReadToken() {
    let out = "";
    let chunkStart = this.state.pos;

    for (;;) {
      if (this.state.pos >= this.length) {
        throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);
      }

      const ch = this.input.charCodeAt(this.state.pos);

      switch (ch) {
        case 60:
        case 123:
          if (this.state.pos === this.state.start) {
            if (ch === 60 && this.state.exprAllowed) {
              ++this.state.pos;
              return this.finishToken(types.jsxTagStart);
            }

            return super.getTokenFromCode(ch);
          }

          out += this.input.slice(chunkStart, this.state.pos);
          return this.finishToken(types.jsxText, out);

        case 38:
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadEntity();
          chunkStart = this.state.pos;
          break;

        default:
          if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadNewLine(true);
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }

      }
    }
  }

  jsxReadNewLine(normalizeCRLF) {
    const ch = this.input.charCodeAt(this.state.pos);
    let out;
    ++this.state.pos;

    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
      ++this.state.pos;
      out = normalizeCRLF ? "\n" : "\r\n";
    } else {
      out = String.fromCharCode(ch);
    }

    ++this.state.curLine;
    this.state.lineStart = this.state.pos;
    return out;
  }

  jsxReadString(quote) {
    let out = "";
    let chunkStart = ++this.state.pos;

    for (;;) {
      if (this.state.pos >= this.length) {
        throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
      }

      const ch = this.input.charCodeAt(this.state.pos);
      if (ch === quote) break;

      if (ch === 38) {
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.jsxReadEntity();
        chunkStart = this.state.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.jsxReadNewLine(false);
        chunkStart = this.state.pos;
      } else {
        ++this.state.pos;
      }
    }

    out += this.input.slice(chunkStart, this.state.pos++);
    return this.finishToken(types.string, out);
  }

  jsxReadEntity() {
    let str = "";
    let count = 0;
    let entity;
    let ch = this.input[this.state.pos];
    const startPos = ++this.state.pos;

    while (this.state.pos < this.length && count++ < 10) {
      ch = this.input[this.state.pos++];

      if (ch === ";") {
        if (str[0] === "#") {
          if (str[1] === "x") {
            str = str.substr(2);

            if (HEX_NUMBER.test(str)) {
              entity = String.fromCodePoint(parseInt(str, 16));
            }
          } else {
            str = str.substr(1);

            if (DECIMAL_NUMBER.test(str)) {
              entity = String.fromCodePoint(parseInt(str, 10));
            }
          }
        } else {
          entity = entities[str];
        }

        break;
      }

      str += ch;
    }

    if (!entity) {
      this.state.pos = startPos;
      return "&";
    }

    return entity;
  }

  jsxReadWord() {
    let ch;
    const start = this.state.pos;

    do {
      ch = this.input.charCodeAt(++this.state.pos);
    } while (isIdentifierChar(ch) || ch === 45);

    return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));
  }

  jsxParseIdentifier() {
    const node = this.startNode();

    if (this.match(types.jsxName)) {
      node.name = this.state.value;
    } else if (this.state.type.keyword) {
      node.name = this.state.type.keyword;
    } else {
      this.unexpected();
    }

    this.next();
    return this.finishNode(node, "JSXIdentifier");
  }

  jsxParseNamespacedName() {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const name = this.jsxParseIdentifier();
    if (!this.eat(types.colon)) return name;
    const node = this.startNodeAt(startPos, startLoc);
    node.namespace = name;
    node.name = this.jsxParseIdentifier();
    return this.finishNode(node, "JSXNamespacedName");
  }

  jsxParseElementName() {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    let node = this.jsxParseNamespacedName();

    if (node.type === "JSXNamespacedName") {
      return node;
    }

    while (this.eat(types.dot)) {
      const newNode = this.startNodeAt(startPos, startLoc);
      newNode.object = node;
      newNode.property = this.jsxParseIdentifier();
      node = this.finishNode(newNode, "JSXMemberExpression");
    }

    return node;
  }

  jsxParseAttributeValue() {
    let node;

    switch (this.state.type) {
      case types.braceL:
        node = this.startNode();
        this.next();
        node = this.jsxParseExpressionContainer(node);

        if (node.expression.type === "JSXEmptyExpression") {
          this.raise(node.start, JsxErrors.AttributeIsEmpty);
        }

        return node;

      case types.jsxTagStart:
      case types.string:
        return this.parseExprAtom();

      default:
        throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);
    }
  }

  jsxParseEmptyExpression() {
    const node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
    return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
  }

  jsxParseSpreadChild(node) {
    this.next();
    node.expression = this.parseExpression();
    this.expect(types.braceR);
    return this.finishNode(node, "JSXSpreadChild");
  }

  jsxParseExpressionContainer(node) {
    if (this.match(types.braceR)) {
      node.expression = this.jsxParseEmptyExpression();
    } else {
      node.expression = this.parseExpression();
    }

    this.expect(types.braceR);
    return this.finishNode(node, "JSXExpressionContainer");
  }

  jsxParseAttribute() {
    const node = this.startNode();

    if (this.eat(types.braceL)) {
      this.expect(types.ellipsis);
      node.argument = this.parseMaybeAssign();
      this.expect(types.braceR);
      return this.finishNode(node, "JSXSpreadAttribute");
    }

    node.name = this.jsxParseNamespacedName();
    node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;
    return this.finishNode(node, "JSXAttribute");
  }

  jsxParseOpeningElementAt(startPos, startLoc) {
    const node = this.startNodeAt(startPos, startLoc);

    if (this.match(types.jsxTagEnd)) {
      this.expect(types.jsxTagEnd);
      return this.finishNode(node, "JSXOpeningFragment");
    }

    node.name = this.jsxParseElementName();
    return this.jsxParseOpeningElementAfterName(node);
  }

  jsxParseOpeningElementAfterName(node) {
    const attributes = [];

    while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {
      attributes.push(this.jsxParseAttribute());
    }

    node.attributes = attributes;
    node.selfClosing = this.eat(types.slash);
    this.expect(types.jsxTagEnd);
    return this.finishNode(node, "JSXOpeningElement");
  }

  jsxParseClosingElementAt(startPos, startLoc) {
    const node = this.startNodeAt(startPos, startLoc);

    if (this.match(types.jsxTagEnd)) {
      this.expect(types.jsxTagEnd);
      return this.finishNode(node, "JSXClosingFragment");
    }

    node.name = this.jsxParseElementName();
    this.expect(types.jsxTagEnd);
    return this.finishNode(node, "JSXClosingElement");
  }

  jsxParseElementAt(startPos, startLoc) {
    const node = this.startNodeAt(startPos, startLoc);
    const children = [];
    const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
    let closingElement = null;

    if (!openingElement.selfClosing) {
      contents: for (;;) {
        switch (this.state.type) {
          case types.jsxTagStart:
            startPos = this.state.start;
            startLoc = this.state.startLoc;
            this.next();

            if (this.eat(types.slash)) {
              closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
              break contents;
            }

            children.push(this.jsxParseElementAt(startPos, startLoc));
            break;

          case types.jsxText:
            children.push(this.parseExprAtom());
            break;

          case types.braceL:
            {
              const node = this.startNode();
              this.next();

              if (this.match(types.ellipsis)) {
                children.push(this.jsxParseSpreadChild(node));
              } else {
                children.push(this.jsxParseExpressionContainer(node));
              }

              break;
            }

          default:
            throw this.unexpected();
        }
      }

      if (isFragment(openingElement) && !isFragment(closingElement)) {
        this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment);
      } else if (!isFragment(openingElement) && isFragment(closingElement)) {
        this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
          this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
        }
      }
    }

    if (isFragment(openingElement)) {
      node.openingFragment = openingElement;
      node.closingFragment = closingElement;
    } else {
      node.openingElement = openingElement;
      node.closingElement = closingElement;
    }

    node.children = children;

    if (this.isRelational("<")) {
      throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);
    }

    return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
  }

  jsxParseElement() {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    this.next();
    return this.jsxParseElementAt(startPos, startLoc);
  }

  parseExprAtom(refExpressionErrors) {
    if (this.match(types.jsxText)) {
      return this.parseLiteral(this.state.value, "JSXText");
    } else if (this.match(types.jsxTagStart)) {
      return this.jsxParseElement();
    } else if (this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33) {
      this.finishToken(types.jsxTagStart);
      return this.jsxParseElement();
    } else {
      return super.parseExprAtom(refExpressionErrors);
    }
  }

  getTokenFromCode(code) {
    if (this.state.inPropertyName) return super.getTokenFromCode(code);
    const context = this.curContext();

    if (context === types$1.j_expr) {
      return this.jsxReadToken();
    }

    if (context === types$1.j_oTag || context === types$1.j_cTag) {
      if (isIdentifierStart(code)) {
        return this.jsxReadWord();
      }

      if (code === 62) {
        ++this.state.pos;
        return this.finishToken(types.jsxTagEnd);
      }

      if ((code === 34 || code === 39) && context === types$1.j_oTag) {
        return this.jsxReadString(code);
      }
    }

    if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {
      ++this.state.pos;
      return this.finishToken(types.jsxTagStart);
    }

    return super.getTokenFromCode(code);
  }

  updateContext(prevType) {
    if (this.match(types.braceL)) {
      const curContext = this.curContext();

      if (curContext === types$1.j_oTag) {
        this.state.context.push(types$1.braceExpression);
      } else if (curContext === types$1.j_expr) {
        this.state.context.push(types$1.templateQuasi);
      } else {
        super.updateContext(prevType);
      }

      this.state.exprAllowed = true;
    } else if (this.match(types.slash) && prevType === types.jsxTagStart) {
      this.state.context.length -= 2;
      this.state.context.push(types$1.j_cTag);
      this.state.exprAllowed = false;
    } else {
      return super.updateContext(prevType);
    }
  }

});

class Scope {
  constructor(flags) {
    this.var = [];
    this.lexical = [];
    this.functions = [];
    this.flags = flags;
  }

}
class ScopeHandler {
  constructor(raise, inModule) {
    this.scopeStack = [];
    this.undefinedExports = new Map();
    this.undefinedPrivateNames = new Map();
    this.raise = raise;
    this.inModule = inModule;
  }

  get inFunction() {
    return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
  }

  get allowSuper() {
    return (this.currentThisScope().flags & SCOPE_SUPER) > 0;
  }

  get allowDirectSuper() {
    return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
  }

  get inClass() {
    return (this.currentThisScope().flags & SCOPE_CLASS) > 0;
  }

  get inNonArrowFunction() {
    return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;
  }

  get treatFunctionsAsVar() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  }

  createScope(flags) {
    return new Scope(flags);
  }

  enter(flags) {
    this.scopeStack.push(this.createScope(flags));
  }

  exit() {
    this.scopeStack.pop();
  }

  treatFunctionsAsVarInScope(scope) {
    return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);
  }

  declareName(name, bindingType, pos) {
    let scope = this.currentScope();

    if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
      this.checkRedeclarationInScope(scope, name, bindingType, pos);

      if (bindingType & BIND_SCOPE_FUNCTION) {
        scope.functions.push(name);
      } else {
        scope.lexical.push(name);
      }

      if (bindingType & BIND_SCOPE_LEXICAL) {
        this.maybeExportDefined(scope, name);
      }
    } else if (bindingType & BIND_SCOPE_VAR) {
      for (let i = this.scopeStack.length - 1; i >= 0; --i) {
        scope = this.scopeStack[i];
        this.checkRedeclarationInScope(scope, name, bindingType, pos);
        scope.var.push(name);
        this.maybeExportDefined(scope, name);
        if (scope.flags & SCOPE_VAR) break;
      }
    }

    if (this.inModule && scope.flags & SCOPE_PROGRAM) {
      this.undefinedExports.delete(name);
    }
  }

  maybeExportDefined(scope, name) {
    if (this.inModule && scope.flags & SCOPE_PROGRAM) {
      this.undefinedExports.delete(name);
    }
  }

  checkRedeclarationInScope(scope, name, bindingType, pos) {
    if (this.isRedeclaredInScope(scope, name, bindingType)) {
      this.raise(pos, ErrorMessages.VarRedeclaration, name);
    }
  }

  isRedeclaredInScope(scope, name, bindingType) {
    if (!(bindingType & BIND_KIND_VALUE)) return false;

    if (bindingType & BIND_SCOPE_LEXICAL) {
      return scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    }

    if (bindingType & BIND_SCOPE_FUNCTION) {
      return scope.lexical.indexOf(name) > -1 || !this.treatFunctionsAsVarInScope(scope) && scope.var.indexOf(name) > -1;
    }

    return scope.lexical.indexOf(name) > -1 && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.indexOf(name) > -1;
  }

  checkLocalExport(id) {
    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1 && this.scopeStack[0].functions.indexOf(id.name) === -1) {
      this.undefinedExports.set(id.name, id.start);
    }
  }

  currentScope() {
    return this.scopeStack[this.scopeStack.length - 1];
  }

  currentVarScope() {
    for (let i = this.scopeStack.length - 1;; i--) {
      const scope = this.scopeStack[i];

      if (scope.flags & SCOPE_VAR) {
        return scope;
      }
    }
  }

  currentThisScope() {
    for (let i = this.scopeStack.length - 1;; i--) {
      const scope = this.scopeStack[i];

      if ((scope.flags & SCOPE_VAR || scope.flags & SCOPE_CLASS) && !(scope.flags & SCOPE_ARROW)) {
        return scope;
      }
    }
  }

}

class TypeScriptScope extends Scope {
  constructor(...args) {
    super(...args);
    this.types = [];
    this.enums = [];
    this.constEnums = [];
    this.classes = [];
    this.exportOnlyBindings = [];
  }

}

class TypeScriptScopeHandler extends ScopeHandler {
  createScope(flags) {
    return new TypeScriptScope(flags);
  }

  declareName(name, bindingType, pos) {
    const scope = this.currentScope();

    if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
      this.maybeExportDefined(scope, name);
      scope.exportOnlyBindings.push(name);
      return;
    }

    super.declareName(...arguments);

    if (bindingType & BIND_KIND_TYPE) {
      if (!(bindingType & BIND_KIND_VALUE)) {
        this.checkRedeclarationInScope(scope, name, bindingType, pos);
        this.maybeExportDefined(scope, name);
      }

      scope.types.push(name);
    }

    if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.push(name);
    if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);
    if (bindingType & BIND_FLAGS_CLASS) scope.classes.push(name);
  }

  isRedeclaredInScope(scope, name, bindingType) {
    if (scope.enums.indexOf(name) > -1) {
      if (bindingType & BIND_FLAGS_TS_ENUM) {
        const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
        const wasConst = scope.constEnums.indexOf(name) > -1;
        return isConst !== wasConst;
      }

      return true;
    }

    if (bindingType & BIND_FLAGS_CLASS && scope.classes.indexOf(name) > -1) {
      if (scope.lexical.indexOf(name) > -1) {
        return !!(bindingType & BIND_KIND_VALUE);
      } else {
        return false;
      }
    }

    if (bindingType & BIND_KIND_TYPE && scope.types.indexOf(name) > -1) {
      return true;
    }

    return super.isRedeclaredInScope(...arguments);
  }

  checkLocalExport(id) {
    if (this.scopeStack[0].types.indexOf(id.name) === -1 && this.scopeStack[0].exportOnlyBindings.indexOf(id.name) === -1) {
      super.checkLocalExport(id);
    }
  }

}

const PARAM = 0b000,
      PARAM_YIELD = 0b001,
      PARAM_AWAIT = 0b010,
      PARAM_RETURN = 0b100;
class ProductionParameterHandler {
  constructor() {
    this.stacks = [];
  }

  enter(flags) {
    this.stacks.push(flags);
  }

  exit() {
    this.stacks.pop();
  }

  currentFlags() {
    return this.stacks[this.stacks.length - 1];
  }

  get hasAwait() {
    return (this.currentFlags() & PARAM_AWAIT) > 0;
  }

  get hasYield() {
    return (this.currentFlags() & PARAM_YIELD) > 0;
  }

  get hasReturn() {
    return (this.currentFlags() & PARAM_RETURN) > 0;
  }

}
function functionFlags(isAsync, isGenerator) {
  return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
}

function nonNull(x) {
  if (x == null) {
    throw new Error(`Unexpected ${x} value.`);
  }

  return x;
}

function assert(x) {
  if (!x) {
    throw new Error("Assert fail");
  }
}

const TSErrors = Object.freeze({
  ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier",
  ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier",
  DeclareClassFieldHasInitializer: "'declare' class fields cannot have an initializer",
  DuplicateModifier: "Duplicate modifier: '%0'",
  EmptyHeritageClauseType: "'%0' list cannot be empty.",
  IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier",
  IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0')",
  IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier",
  OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
  PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
  PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0')",
  TemplateTypeHasSubstitution: "Template literal types cannot have any substitution",
  TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`",
  UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
  UnsupportedImportTypeArgument: "Argument in a type import must be a string literal",
  UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
  UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0"
});

function keywordTypeFromName(value) {
  switch (value) {
    case "any":
      return "TSAnyKeyword";

    case "boolean":
      return "TSBooleanKeyword";

    case "bigint":
      return "TSBigIntKeyword";

    case "never":
      return "TSNeverKeyword";

    case "number":
      return "TSNumberKeyword";

    case "object":
      return "TSObjectKeyword";

    case "string":
      return "TSStringKeyword";

    case "symbol":
      return "TSSymbolKeyword";

    case "undefined":
      return "TSUndefinedKeyword";

    case "unknown":
      return "TSUnknownKeyword";

    default:
      return undefined;
  }
}

var typescript = (superClass => class extends superClass {
  getScopeHandler() {
    return TypeScriptScopeHandler;
  }

  tsIsIdentifier() {
    return this.match(types.name);
  }

  tsNextTokenCanFollowModifier() {
    this.next();
    return !this.hasPrecedingLineBreak() && !this.match(types.parenL) && !this.match(types.parenR) && !this.match(types.colon) && !this.match(types.eq) && !this.match(types.question) && !this.match(types.bang);
  }

  tsParseModifier(allowedModifiers) {
    if (!this.match(types.name)) {
      return undefined;
    }

    const modifier = this.state.value;

    if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
      return modifier;
    }

    return undefined;
  }

  tsParseModifiers(modified, allowedModifiers) {
    for (;;) {
      const startPos = this.state.start;
      const modifier = this.tsParseModifier(allowedModifiers);
      if (!modifier) break;

      if (Object.hasOwnProperty.call(modified, modifier)) {
        this.raise(startPos, TSErrors.DuplicateModifier, modifier);
      }

      modified[modifier] = true;
    }
  }

  tsIsListTerminator(kind) {
    switch (kind) {
      case "EnumMembers":
      case "TypeMembers":
        return this.match(types.braceR);

      case "HeritageClauseElement":
        return this.match(types.braceL);

      case "TupleElementTypes":
        return this.match(types.bracketR);

      case "TypeParametersOrArguments":
        return this.isRelational(">");
    }

    throw new Error("Unreachable");
  }

  tsParseList(kind, parseElement) {
    const result = [];

    while (!this.tsIsListTerminator(kind)) {
      result.push(parseElement());
    }

    return result;
  }

  tsParseDelimitedList(kind, parseElement) {
    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));
  }

  tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {
    const result = [];

    for (;;) {
      if (this.tsIsListTerminator(kind)) {
        break;
      }

      const element = parseElement();

      if (element == null) {
        return undefined;
      }

      result.push(element);

      if (this.eat(types.comma)) {
        continue;
      }

      if (this.tsIsListTerminator(kind)) {
        break;
      }

      if (expectSuccess) {
        this.expect(types.comma);
      }

      return undefined;
    }

    return result;
  }

  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {
    if (!skipFirstToken) {
      if (bracket) {
        this.expect(types.bracketL);
      } else {
        this.expectRelational("<");
      }
    }

    const result = this.tsParseDelimitedList(kind, parseElement);

    if (bracket) {
      this.expect(types.bracketR);
    } else {
      this.expectRelational(">");
    }

    return result;
  }

  tsParseImportType() {
    const node = this.startNode();
    this.expect(types._import);
    this.expect(types.parenL);

    if (!this.match(types.string)) {
      this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);
    }

    node.argument = this.parseExprAtom();
    this.expect(types.parenR);

    if (this.eat(types.dot)) {
      node.qualifier = this.tsParseEntityName(true);
    }

    if (this.isRelational("<")) {
      node.typeParameters = this.tsParseTypeArguments();
    }

    return this.finishNode(node, "TSImportType");
  }

  tsParseEntityName(allowReservedWords) {
    let entity = this.parseIdentifier();

    while (this.eat(types.dot)) {
      const node = this.startNodeAtNode(entity);
      node.left = entity;
      node.right = this.parseIdentifier(allowReservedWords);
      entity = this.finishNode(node, "TSQualifiedName");
    }

    return entity;
  }

  tsParseTypeReference() {
    const node = this.startNode();
    node.typeName = this.tsParseEntityName(false);

    if (!this.hasPrecedingLineBreak() && this.isRelational("<")) {
      node.typeParameters = this.tsParseTypeArguments();
    }

    return this.finishNode(node, "TSTypeReference");
  }

  tsParseThisTypePredicate(lhs) {
    this.next();
    const node = this.startNodeAtNode(lhs);
    node.parameterName = lhs;
    node.typeAnnotation = this.tsParseTypeAnnotation(false);
    return this.finishNode(node, "TSTypePredicate");
  }

  tsParseThisTypeNode() {
    const node = this.startNode();
    this.next();
    return this.finishNode(node, "TSThisType");
  }

  tsParseTypeQuery() {
    const node = this.startNode();
    this.expect(types._typeof);

    if (this.match(types._import)) {
      node.exprName = this.tsParseImportType();
    } else {
      node.exprName = this.tsParseEntityName(true);
    }

    return this.finishNode(node, "TSTypeQuery");
  }

  tsParseTypeParameter() {
    const node = this.startNode();
    node.name = this.parseIdentifierName(node.start);
    node.constraint = this.tsEatThenParseType(types._extends);
    node.default = this.tsEatThenParseType(types.eq);
    return this.finishNode(node, "TSTypeParameter");
  }

  tsTryParseTypeParameters() {
    if (this.isRelational("<")) {
      return this.tsParseTypeParameters();
    }
  }

  tsParseTypeParameters() {
    const node = this.startNode();

    if (this.isRelational("<") || this.match(types.jsxTagStart)) {
      this.next();
    } else {
      this.unexpected();
    }

    node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true);
    return this.finishNode(node, "TSTypeParameterDeclaration");
  }

  tsTryNextParseConstantContext() {
    if (this.lookahead().type === types._const) {
      this.next();
      return this.tsParseTypeReference();
    }

    return null;
  }

  tsFillSignature(returnToken, signature) {
    const returnTokenRequired = returnToken === types.arrow;
    signature.typeParameters = this.tsTryParseTypeParameters();
    this.expect(types.parenL);
    signature.parameters = this.tsParseBindingListForSignature();

    if (returnTokenRequired) {
      signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
    } else if (this.match(returnToken)) {
      signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
    }
  }

  tsParseBindingListForSignature() {
    return this.parseBindingList(types.parenR, 41).map(pattern => {
      if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
        this.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type);
      }

      return pattern;
    });
  }

  tsParseTypeMemberSemicolon() {
    if (!this.eat(types.comma)) {
      this.semicolon();
    }
  }

  tsParseSignatureMember(kind, node) {
    this.tsFillSignature(types.colon, node);
    this.tsParseTypeMemberSemicolon();
    return this.finishNode(node, kind);
  }

  tsIsUnambiguouslyIndexSignature() {
    this.next();
    return this.eat(types.name) && this.match(types.colon);
  }

  tsTryParseIndexSignature(node) {
    if (!(this.match(types.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
      return undefined;
    }

    this.expect(types.bracketL);
    const id = this.parseIdentifier();
    id.typeAnnotation = this.tsParseTypeAnnotation();
    this.resetEndLocation(id);
    this.expect(types.bracketR);
    node.parameters = [id];
    const type = this.tsTryParseTypeAnnotation();
    if (type) node.typeAnnotation = type;
    this.tsParseTypeMemberSemicolon();
    return this.finishNode(node, "TSIndexSignature");
  }

  tsParsePropertyOrMethodSignature(node, readonly) {
    if (this.eat(types.question)) node.optional = true;
    const nodeAny = node;

    if (!readonly && (this.match(types.parenL) || this.isRelational("<"))) {
      const method = nodeAny;
      this.tsFillSignature(types.colon, method);
      this.tsParseTypeMemberSemicolon();
      return this.finishNode(method, "TSMethodSignature");
    } else {
      const property = nodeAny;
      if (readonly) property.readonly = true;
      const type = this.tsTryParseTypeAnnotation();
      if (type) property.typeAnnotation = type;
      this.tsParseTypeMemberSemicolon();
      return this.finishNode(property, "TSPropertySignature");
    }
  }

  tsParseTypeMember() {
    const node = this.startNode();

    if (this.match(types.parenL) || this.isRelational("<")) {
      return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
    }

    if (this.match(types._new)) {
      const id = this.startNode();
      this.next();

      if (this.match(types.parenL) || this.isRelational("<")) {
        return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
      } else {
        node.key = this.createIdentifier(id, "new");
        return this.tsParsePropertyOrMethodSignature(node, false);
      }
    }

    const readonly = !!this.tsParseModifier(["readonly"]);
    const idx = this.tsTryParseIndexSignature(node);

    if (idx) {
      if (readonly) node.readonly = true;
      return idx;
    }

    this.parsePropertyName(node, false);
    return this.tsParsePropertyOrMethodSignature(node, readonly);
  }

  tsParseTypeLiteral() {
    const node = this.startNode();
    node.members = this.tsParseObjectTypeMembers();
    return this.finishNode(node, "TSTypeLiteral");
  }

  tsParseObjectTypeMembers() {
    this.expect(types.braceL);
    const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
    this.expect(types.braceR);
    return members;
  }

  tsIsStartOfMappedType() {
    this.next();

    if (this.eat(types.plusMin)) {
      return this.isContextual("readonly");
    }

    if (this.isContextual("readonly")) {
      this.next();
    }

    if (!this.match(types.bracketL)) {
      return false;
    }

    this.next();

    if (!this.tsIsIdentifier()) {
      return false;
    }

    this.next();
    return this.match(types._in);
  }

  tsParseMappedTypeParameter() {
    const node = this.startNode();
    node.name = this.parseIdentifierName(node.start);
    node.constraint = this.tsExpectThenParseType(types._in);
    return this.finishNode(node, "TSTypeParameter");
  }

  tsParseMappedType() {
    const node = this.startNode();
    this.expect(types.braceL);

    if (this.match(types.plusMin)) {
      node.readonly = this.state.value;
      this.next();
      this.expectContextual("readonly");
    } else if (this.eatContextual("readonly")) {
      node.readonly = true;
    }

    this.expect(types.bracketL);
    node.typeParameter = this.tsParseMappedTypeParameter();
    this.expect(types.bracketR);

    if (this.match(types.plusMin)) {
      node.optional = this.state.value;
      this.next();
      this.expect(types.question);
    } else if (this.eat(types.question)) {
      node.optional = true;
    }

    node.typeAnnotation = this.tsTryParseType();
    this.semicolon();
    this.expect(types.braceR);
    return this.finishNode(node, "TSMappedType");
  }

  tsParseTupleType() {
    const node = this.startNode();
    node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
    let seenOptionalElement = false;
    node.elementTypes.forEach(elementNode => {
      if (elementNode.type === "TSOptionalType") {
        seenOptionalElement = true;
      } else if (seenOptionalElement && elementNode.type !== "TSRestType") {
        this.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);
      }
    });
    return this.finishNode(node, "TSTupleType");
  }

  tsParseTupleElementType() {
    if (this.match(types.ellipsis)) {
      const restNode = this.startNode();
      this.next();
      restNode.typeAnnotation = this.tsParseType();

      if (this.match(types.comma) && this.lookaheadCharCode() !== 93) {
        this.raiseRestNotLast(this.state.start);
      }

      return this.finishNode(restNode, "TSRestType");
    }

    const type = this.tsParseType();

    if (this.eat(types.question)) {
      const optionalTypeNode = this.startNodeAtNode(type);
      optionalTypeNode.typeAnnotation = type;
      return this.finishNode(optionalTypeNode, "TSOptionalType");
    }

    return type;
  }

  tsParseParenthesizedType() {
    const node = this.startNode();
    this.expect(types.parenL);
    node.typeAnnotation = this.tsParseType();
    this.expect(types.parenR);
    return this.finishNode(node, "TSParenthesizedType");
  }

  tsParseFunctionOrConstructorType(type) {
    const node = this.startNode();

    if (type === "TSConstructorType") {
      this.expect(types._new);
    }

    this.tsFillSignature(types.arrow, node);
    return this.finishNode(node, type);
  }

  tsParseLiteralTypeNode() {
    const node = this.startNode();

    node.literal = (() => {
      switch (this.state.type) {
        case types.num:
        case types.bigint:
        case types.string:
        case types._true:
        case types._false:
          return this.parseExprAtom();

        default:
          throw this.unexpected();
      }
    })();

    return this.finishNode(node, "TSLiteralType");
  }

  tsParseTemplateLiteralType() {
    const node = this.startNode();
    const templateNode = this.parseTemplate(false);

    if (templateNode.expressions.length > 0) {
      this.raise(templateNode.expressions[0].start, TSErrors.TemplateTypeHasSubstitution);
    }

    node.literal = templateNode;
    return this.finishNode(node, "TSLiteralType");
  }

  tsParseThisTypeOrThisTypePredicate() {
    const thisKeyword = this.tsParseThisTypeNode();

    if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
      return this.tsParseThisTypePredicate(thisKeyword);
    } else {
      return thisKeyword;
    }
  }

  tsParseNonArrayType() {
    switch (this.state.type) {
      case types.name:
      case types._void:
      case types._null:
        {
          const type = this.match(types._void) ? "TSVoidKeyword" : this.match(types._null) ? "TSNullKeyword" : keywordTypeFromName(this.state.value);

          if (type !== undefined && this.lookaheadCharCode() !== 46) {
            const node = this.startNode();
            this.next();
            return this.finishNode(node, type);
          }

          return this.tsParseTypeReference();
        }

      case types.string:
      case types.num:
      case types.bigint:
      case types._true:
      case types._false:
        return this.tsParseLiteralTypeNode();

      case types.plusMin:
        if (this.state.value === "-") {
          const node = this.startNode();
          const nextToken = this.lookahead();

          if (nextToken.type !== types.num && nextToken.type !== types.bigint) {
            throw this.unexpected();
          }

          node.literal = this.parseMaybeUnary();
          return this.finishNode(node, "TSLiteralType");
        }

        break;

      case types._this:
        return this.tsParseThisTypeOrThisTypePredicate();

      case types._typeof:
        return this.tsParseTypeQuery();

      case types._import:
        return this.tsParseImportType();

      case types.braceL:
        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();

      case types.bracketL:
        return this.tsParseTupleType();

      case types.parenL:
        return this.tsParseParenthesizedType();

      case types.backQuote:
        return this.tsParseTemplateLiteralType();
    }

    throw this.unexpected();
  }

  tsParseArrayTypeOrHigher() {
    let type = this.tsParseNonArrayType();

    while (!this.hasPrecedingLineBreak() && this.eat(types.bracketL)) {
      if (this.match(types.bracketR)) {
        const node = this.startNodeAtNode(type);
        node.elementType = type;
        this.expect(types.bracketR);
        type = this.finishNode(node, "TSArrayType");
      } else {
        const node = this.startNodeAtNode(type);
        node.objectType = type;
        node.indexType = this.tsParseType();
        this.expect(types.bracketR);
        type = this.finishNode(node, "TSIndexedAccessType");
      }
    }

    return type;
  }

  tsParseTypeOperator(operator) {
    const node = this.startNode();
    this.expectContextual(operator);
    node.operator = operator;
    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();

    if (operator === "readonly") {
      this.tsCheckTypeAnnotationForReadOnly(node);
    }

    return this.finishNode(node, "TSTypeOperator");
  }

  tsCheckTypeAnnotationForReadOnly(node) {
    switch (node.typeAnnotation.type) {
      case "TSTupleType":
      case "TSArrayType":
        return;

      default:
        this.raise(node.start, TSErrors.UnexpectedReadonly);
    }
  }

  tsParseInferType() {
    const node = this.startNode();
    this.expectContextual("infer");
    const typeParameter = this.startNode();
    typeParameter.name = this.parseIdentifierName(typeParameter.start);
    node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
    return this.finishNode(node, "TSInferType");
  }

  tsParseTypeOperatorOrHigher() {
    const operator = ["keyof", "unique", "readonly"].find(kw => this.isContextual(kw));
    return operator ? this.tsParseTypeOperator(operator) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
  }

  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
    this.eat(operator);
    let type = parseConstituentType();

    if (this.match(operator)) {
      const types = [type];

      while (this.eat(operator)) {
        types.push(parseConstituentType());
      }

      const node = this.startNodeAtNode(type);
      node.types = types;
      type = this.finishNode(node, kind);
    }

    return type;
  }

  tsParseIntersectionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), types.bitwiseAND);
  }

  tsParseUnionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), types.bitwiseOR);
  }

  tsIsStartOfFunctionType() {
    if (this.isRelational("<")) {
      return true;
    }

    return this.match(types.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
  }

  tsSkipParameterStart() {
    if (this.match(types.name) || this.match(types._this)) {
      this.next();
      return true;
    }

    if (this.match(types.braceL)) {
      let braceStackCounter = 1;
      this.next();

      while (braceStackCounter > 0) {
        if (this.match(types.braceL)) {
          ++braceStackCounter;
        } else if (this.match(types.braceR)) {
          --braceStackCounter;
        }

        this.next();
      }

      return true;
    }

    if (this.match(types.bracketL)) {
      let braceStackCounter = 1;
      this.next();

      while (braceStackCounter > 0) {
        if (this.match(types.bracketL)) {
          ++braceStackCounter;
        } else if (this.match(types.bracketR)) {
          --braceStackCounter;
        }

        this.next();
      }

      return true;
    }

    return false;
  }

  tsIsUnambiguouslyStartOfFunctionType() {
    this.next();

    if (this.match(types.parenR) || this.match(types.ellipsis)) {
      return true;
    }

    if (this.tsSkipParameterStart()) {
      if (this.match(types.colon) || this.match(types.comma) || this.match(types.question) || this.match(types.eq)) {
        return true;
      }

      if (this.match(types.parenR)) {
        this.next();

        if (this.match(types.arrow)) {
          return true;
        }
      }
    }

    return false;
  }

  tsParseTypeOrTypePredicateAnnotation(returnToken) {
    return this.tsInType(() => {
      const t = this.startNode();
      this.expect(returnToken);
      const asserts = this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));

      if (asserts && this.match(types._this)) {
        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();

        if (thisTypePredicate.type === "TSThisType") {
          const node = this.startNodeAtNode(t);
          node.parameterName = thisTypePredicate;
          node.asserts = true;
          thisTypePredicate = this.finishNode(node, "TSTypePredicate");
        } else {
          thisTypePredicate.asserts = true;
        }

        t.typeAnnotation = thisTypePredicate;
        return this.finishNode(t, "TSTypeAnnotation");
      }

      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));

      if (!typePredicateVariable) {
        if (!asserts) {
          return this.tsParseTypeAnnotation(false, t);
        }

        const node = this.startNodeAtNode(t);
        node.parameterName = this.parseIdentifier();
        node.asserts = asserts;
        t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
        return this.finishNode(t, "TSTypeAnnotation");
      }

      const type = this.tsParseTypeAnnotation(false);
      const node = this.startNodeAtNode(t);
      node.parameterName = typePredicateVariable;
      node.typeAnnotation = type;
      node.asserts = asserts;
      t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
      return this.finishNode(t, "TSTypeAnnotation");
    });
  }

  tsTryParseTypeOrTypePredicateAnnotation() {
    return this.match(types.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types.colon) : undefined;
  }

  tsTryParseTypeAnnotation() {
    return this.match(types.colon) ? this.tsParseTypeAnnotation() : undefined;
  }

  tsTryParseType() {
    return this.tsEatThenParseType(types.colon);
  }

  tsParseTypePredicatePrefix() {
    const id = this.parseIdentifier();

    if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
      this.next();
      return id;
    }
  }

  tsParseTypePredicateAsserts() {
    if (!this.match(types.name) || this.state.value !== "asserts" || this.hasPrecedingLineBreak()) {
      return false;
    }

    const containsEsc = this.state.containsEsc;
    this.next();

    if (!this.match(types.name) && !this.match(types._this)) {
      return false;
    }

    if (containsEsc) {
      this.raise(this.state.lastTokStart, ErrorMessages.InvalidEscapedReservedWord, "asserts");
    }

    return true;
  }

  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
    this.tsInType(() => {
      if (eatColon) this.expect(types.colon);
      t.typeAnnotation = this.tsParseType();
    });
    return this.finishNode(t, "TSTypeAnnotation");
  }

  tsParseType() {
    assert(this.state.inType);
    const type = this.tsParseNonConditionalType();

    if (this.hasPrecedingLineBreak() || !this.eat(types._extends)) {
      return type;
    }

    const node = this.startNodeAtNode(type);
    node.checkType = type;
    node.extendsType = this.tsParseNonConditionalType();
    this.expect(types.question);
    node.trueType = this.tsParseType();
    this.expect(types.colon);
    node.falseType = this.tsParseType();
    return this.finishNode(node, "TSConditionalType");
  }

  tsParseNonConditionalType() {
    if (this.tsIsStartOfFunctionType()) {
      return this.tsParseFunctionOrConstructorType("TSFunctionType");
    }

    if (this.match(types._new)) {
      return this.tsParseFunctionOrConstructorType("TSConstructorType");
    }

    return this.tsParseUnionTypeOrHigher();
  }

  tsParseTypeAssertion() {
    const node = this.startNode();

    const _const = this.tsTryNextParseConstantContext();

    node.typeAnnotation = _const || this.tsNextThenParseType();
    this.expectRelational(">");
    node.expression = this.parseMaybeUnary();
    return this.finishNode(node, "TSTypeAssertion");
  }

  tsParseHeritageClause(descriptor) {
    const originalStart = this.state.start;
    const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));

    if (!delimitedList.length) {
      this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);
    }

    return delimitedList;
  }

  tsParseExpressionWithTypeArguments() {
    const node = this.startNode();
    node.expression = this.tsParseEntityName(false);

    if (this.isRelational("<")) {
      node.typeParameters = this.tsParseTypeArguments();
    }

    return this.finishNode(node, "TSExpressionWithTypeArguments");
  }

  tsParseInterfaceDeclaration(node) {
    node.id = this.parseIdentifier();
    this.checkLVal(node.id, BIND_TS_INTERFACE, undefined, "typescript interface declaration");
    node.typeParameters = this.tsTryParseTypeParameters();

    if (this.eat(types._extends)) {
      node.extends = this.tsParseHeritageClause("extends");
    }

    const body = this.startNode();
    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
    node.body = this.finishNode(body, "TSInterfaceBody");
    return this.finishNode(node, "TSInterfaceDeclaration");
  }

  tsParseTypeAliasDeclaration(node) {
    node.id = this.parseIdentifier();
    this.checkLVal(node.id, BIND_TS_TYPE, undefined, "typescript type alias");
    node.typeParameters = this.tsTryParseTypeParameters();
    node.typeAnnotation = this.tsExpectThenParseType(types.eq);
    this.semicolon();
    return this.finishNode(node, "TSTypeAliasDeclaration");
  }

  tsInNoContext(cb) {
    const oldContext = this.state.context;
    this.state.context = [oldContext[0]];

    try {
      return cb();
    } finally {
      this.state.context = oldContext;
    }
  }

  tsInType(cb) {
    const oldInType = this.state.inType;
    this.state.inType = true;

    try {
      return cb();
    } finally {
      this.state.inType = oldInType;
    }
  }

  tsEatThenParseType(token) {
    return !this.match(token) ? undefined : this.tsNextThenParseType();
  }

  tsExpectThenParseType(token) {
    return this.tsDoThenParseType(() => this.expect(token));
  }

  tsNextThenParseType() {
    return this.tsDoThenParseType(() => this.next());
  }

  tsDoThenParseType(cb) {
    return this.tsInType(() => {
      cb();
      return this.tsParseType();
    });
  }

  tsParseEnumMember() {
    const node = this.startNode();
    node.id = this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);

    if (this.eat(types.eq)) {
      node.initializer = this.parseMaybeAssign();
    }

    return this.finishNode(node, "TSEnumMember");
  }

  tsParseEnumDeclaration(node, isConst) {
    if (isConst) node.const = true;
    node.id = this.parseIdentifier();
    this.checkLVal(node.id, isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM, undefined, "typescript enum declaration");
    this.expect(types.braceL);
    node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
    this.expect(types.braceR);
    return this.finishNode(node, "TSEnumDeclaration");
  }

  tsParseModuleBlock() {
    const node = this.startNode();
    this.scope.enter(SCOPE_OTHER);
    this.expect(types.braceL);
    this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, types.braceR);
    this.scope.exit();
    return this.finishNode(node, "TSModuleBlock");
  }

  tsParseModuleOrNamespaceDeclaration(node, nested = false) {
    node.id = this.parseIdentifier();

    if (!nested) {
      this.checkLVal(node.id, BIND_TS_NAMESPACE, null, "module or namespace declaration");
    }

    if (this.eat(types.dot)) {
      const inner = this.startNode();
      this.tsParseModuleOrNamespaceDeclaration(inner, true);
      node.body = inner;
    } else {
      this.scope.enter(SCOPE_TS_MODULE);
      this.prodParam.enter(PARAM);
      node.body = this.tsParseModuleBlock();
      this.prodParam.exit();
      this.scope.exit();
    }

    return this.finishNode(node, "TSModuleDeclaration");
  }

  tsParseAmbientExternalModuleDeclaration(node) {
    if (this.isContextual("global")) {
      node.global = true;
      node.id = this.parseIdentifier();
    } else if (this.match(types.string)) {
      node.id = this.parseExprAtom();
    } else {
      this.unexpected();
    }

    if (this.match(types.braceL)) {
      this.scope.enter(SCOPE_TS_MODULE);
      this.prodParam.enter(PARAM);
      node.body = this.tsParseModuleBlock();
      this.prodParam.exit();
      this.scope.exit();
    } else {
      this.semicolon();
    }

    return this.finishNode(node, "TSModuleDeclaration");
  }

  tsParseImportEqualsDeclaration(node, isExport) {
    node.isExport = isExport || false;
    node.id = this.parseIdentifier();
    this.checkLVal(node.id, BIND_LEXICAL, undefined, "import equals declaration");
    this.expect(types.eq);
    node.moduleReference = this.tsParseModuleReference();
    this.semicolon();
    return this.finishNode(node, "TSImportEqualsDeclaration");
  }

  tsIsExternalModuleReference() {
    return this.isContextual("require") && this.lookaheadCharCode() === 40;
  }

  tsParseModuleReference() {
    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
  }

  tsParseExternalModuleReference() {
    const node = this.startNode();
    this.expectContextual("require");
    this.expect(types.parenL);

    if (!this.match(types.string)) {
      throw this.unexpected();
    }

    node.expression = this.parseExprAtom();
    this.expect(types.parenR);
    return this.finishNode(node, "TSExternalModuleReference");
  }

  tsLookAhead(f) {
    const state = this.state.clone();
    const res = f();
    this.state = state;
    return res;
  }

  tsTryParseAndCatch(f) {
    const result = this.tryParse(abort => f() || abort());
    if (result.aborted || !result.node) return undefined;
    if (result.error) this.state = result.failState;
    return result.node;
  }

  tsTryParse(f) {
    const state = this.state.clone();
    const result = f();

    if (result !== undefined && result !== false) {
      return result;
    } else {
      this.state = state;
      return undefined;
    }
  }

  tsTryParseDeclare(nany) {
    if (this.isLineTerminator()) {
      return;
    }

    let starttype = this.state.type;
    let kind;

    if (this.isContextual("let")) {
      starttype = types._var;
      kind = "let";
    }

    switch (starttype) {
      case types._function:
        return this.parseFunctionStatement(nany, false, true);

      case types._class:
        nany.declare = true;
        return this.parseClass(nany, true, false);

      case types._const:
        if (this.match(types._const) && this.isLookaheadContextual("enum")) {
          this.expect(types._const);
          this.expectContextual("enum");
          return this.tsParseEnumDeclaration(nany, true);
        }

      case types._var:
        kind = kind || this.state.value;
        return this.parseVarStatement(nany, kind);

      case types.name:
        {
          const value = this.state.value;

          if (value === "global") {
            return this.tsParseAmbientExternalModuleDeclaration(nany);
          } else {
            return this.tsParseDeclaration(nany, value, true);
          }
        }
    }
  }

  tsTryParseExportDeclaration() {
    return this.tsParseDeclaration(this.startNode(), this.state.value, true);
  }

  tsParseExpressionStatement(node, expr) {
    switch (expr.name) {
      case "declare":
        {
          const declaration = this.tsTryParseDeclare(node);

          if (declaration) {
            declaration.declare = true;
            return declaration;
          }

          break;
        }

      case "global":
        if (this.match(types.braceL)) {
          this.scope.enter(SCOPE_TS_MODULE);
          this.prodParam.enter(PARAM);
          const mod = node;
          mod.global = true;
          mod.id = expr;
          mod.body = this.tsParseModuleBlock();
          this.scope.exit();
          this.prodParam.exit();
          return this.finishNode(mod, "TSModuleDeclaration");
        }

        break;

      default:
        return this.tsParseDeclaration(node, expr.name, false);
    }
  }

  tsParseDeclaration(node, value, next) {
    switch (value) {
      case "abstract":
        if (this.tsCheckLineTerminatorAndMatch(types._class, next)) {
          const cls = node;
          cls.abstract = true;

          if (next) {
            this.next();

            if (!this.match(types._class)) {
              this.unexpected(null, types._class);
            }
          }

          return this.parseClass(cls, true, false);
        }

        break;

      case "enum":
        if (next || this.match(types.name)) {
          if (next) this.next();
          return this.tsParseEnumDeclaration(node, false);
        }

        break;

      case "interface":
        if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
          if (next) this.next();
          return this.tsParseInterfaceDeclaration(node);
        }

        break;

      case "module":
        if (next) this.next();

        if (this.match(types.string)) {
          return this.tsParseAmbientExternalModuleDeclaration(node);
        } else if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
          return this.tsParseModuleOrNamespaceDeclaration(node);
        }

        break;

      case "namespace":
        if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
          if (next) this.next();
          return this.tsParseModuleOrNamespaceDeclaration(node);
        }

        break;

      case "type":
        if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
          if (next) this.next();
          return this.tsParseTypeAliasDeclaration(node);
        }

        break;
    }
  }

  tsCheckLineTerminatorAndMatch(tokenType, next) {
    return (next || this.match(tokenType)) && !this.isLineTerminator();
  }

  tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
    if (!this.isRelational("<")) {
      return undefined;
    }

    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
    const oldYieldPos = this.state.yieldPos;
    const oldAwaitPos = this.state.awaitPos;
    this.state.maybeInArrowParameters = true;
    this.state.yieldPos = -1;
    this.state.awaitPos = -1;
    const res = this.tsTryParseAndCatch(() => {
      const node = this.startNodeAt(startPos, startLoc);
      node.typeParameters = this.tsParseTypeParameters();
      super.parseFunctionParams(node);
      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
      this.expect(types.arrow);
      return node;
    });
    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    this.state.yieldPos = oldYieldPos;
    this.state.awaitPos = oldAwaitPos;

    if (!res) {
      return undefined;
    }

    return this.parseArrowExpression(res, null, true);
  }

  tsParseTypeArguments() {
    const node = this.startNode();
    node.params = this.tsInType(() => this.tsInNoContext(() => {
      this.expectRelational("<");
      return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
    }));
    this.state.exprAllowed = false;
    this.expectRelational(">");
    return this.finishNode(node, "TSTypeParameterInstantiation");
  }

  tsIsDeclarationStart() {
    if (this.match(types.name)) {
      switch (this.state.value) {
        case "abstract":
        case "declare":
        case "enum":
        case "interface":
        case "module":
        case "namespace":
        case "type":
          return true;
      }
    }

    return false;
  }

  isExportDefaultSpecifier() {
    if (this.tsIsDeclarationStart()) return false;
    return super.isExportDefaultSpecifier();
  }

  parseAssignableListItem(allowModifiers, decorators) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    let accessibility;
    let readonly = false;

    if (allowModifiers) {
      accessibility = this.parseAccessModifier();
      readonly = !!this.tsParseModifier(["readonly"]);
    }

    const left = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(left);
    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);

    if (accessibility || readonly) {
      const pp = this.startNodeAt(startPos, startLoc);

      if (decorators.length) {
        pp.decorators = decorators;
      }

      if (accessibility) pp.accessibility = accessibility;
      if (readonly) pp.readonly = readonly;

      if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
        this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);
      }

      pp.parameter = elt;
      return this.finishNode(pp, "TSParameterProperty");
    }

    if (decorators.length) {
      left.decorators = decorators;
    }

    return elt;
  }

  parseFunctionBodyAndFinish(node, type, isMethod = false) {
    if (this.match(types.colon)) {
      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);
    }

    const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" ? "TSDeclareMethod" : undefined;

    if (bodilessType && !this.match(types.braceL) && this.isLineTerminator()) {
      this.finishNode(node, bodilessType);
      return;
    }

    super.parseFunctionBodyAndFinish(node, type, isMethod);
  }

  registerFunctionStatementId(node) {
    if (!node.body && node.id) {
      this.checkLVal(node.id, BIND_TS_AMBIENT, null, "function name");
    } else {
      super.registerFunctionStatementId(...arguments);
    }
  }

  parseSubscript(base, startPos, startLoc, noCalls, state) {
    if (!this.hasPrecedingLineBreak() && this.match(types.bang)) {
      this.state.exprAllowed = false;
      this.next();
      const nonNullExpression = this.startNodeAt(startPos, startLoc);
      nonNullExpression.expression = base;
      return this.finishNode(nonNullExpression, "TSNonNullExpression");
    }

    if (this.isRelational("<")) {
      const result = this.tsTryParseAndCatch(() => {
        if (!noCalls && this.atPossibleAsyncArrow(base)) {
          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);

          if (asyncArrowFn) {
            return asyncArrowFn;
          }
        }

        const node = this.startNodeAt(startPos, startLoc);
        node.callee = base;
        const typeArguments = this.tsParseTypeArguments();

        if (typeArguments) {
          if (!noCalls && this.eat(types.parenL)) {
            node.arguments = this.parseCallExpressionArguments(types.parenR, false);
            node.typeParameters = typeArguments;
            return this.finishCallExpression(node, state.optionalChainMember);
          } else if (this.match(types.backQuote)) {
            return this.parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments);
          }
        }

        this.unexpected();
      });
      if (result) return result;
    }

    return super.parseSubscript(base, startPos, startLoc, noCalls, state);
  }

  parseNewArguments(node) {
    if (this.isRelational("<")) {
      const typeParameters = this.tsTryParseAndCatch(() => {
        const args = this.tsParseTypeArguments();
        if (!this.match(types.parenL)) this.unexpected();
        return args;
      });

      if (typeParameters) {
        node.typeParameters = typeParameters;
      }
    }

    super.parseNewArguments(node);
  }

  parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {
    if (nonNull(types._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
      const node = this.startNodeAt(leftStartPos, leftStartLoc);
      node.expression = left;

      const _const = this.tsTryNextParseConstantContext();

      if (_const) {
        node.typeAnnotation = _const;
      } else {
        node.typeAnnotation = this.tsNextThenParseType();
      }

      this.finishNode(node, "TSAsExpression");
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
    }

    return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn);
  }

  checkReservedWord(word, startLoc, checkKeywords, isBinding) {}

  checkDuplicateExports() {}

  parseImport(node) {
    if (this.match(types.name) || this.match(types.star) || this.match(types.braceL)) {
      const ahead = this.lookahead();

      if (this.match(types.name) && ahead.type === types.eq) {
        return this.tsParseImportEqualsDeclaration(node);
      }

      if (this.isContextual("type") && ahead.type !== types.comma && !(ahead.type === types.name && ahead.value === "from")) {
        node.importKind = "type";
        this.next();
      } else {
        node.importKind = "value";
      }
    }

    const importNode = super.parseImport(node);

    if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
      this.raise(importNode.start, "A type-only import can specify a default import or named bindings, but not both.");
    }

    return importNode;
  }

  parseExport(node) {
    if (this.match(types._import)) {
      this.expect(types._import);
      return this.tsParseImportEqualsDeclaration(node, true);
    } else if (this.eat(types.eq)) {
      const assign = node;
      assign.expression = this.parseExpression();
      this.semicolon();
      return this.finishNode(assign, "TSExportAssignment");
    } else if (this.eatContextual("as")) {
      const decl = node;
      this.expectContextual("namespace");
      decl.id = this.parseIdentifier();
      this.semicolon();
      return this.finishNode(decl, "TSNamespaceExportDeclaration");
    } else {
      if (this.isContextual("type") && this.lookahead().type === types.braceL) {
        this.next();
        node.exportKind = "type";
      } else {
        node.exportKind = "value";
      }

      return super.parseExport(node);
    }
  }

  isAbstractClass() {
    return this.isContextual("abstract") && this.lookahead().type === types._class;
  }

  parseExportDefaultExpression() {
    if (this.isAbstractClass()) {
      const cls = this.startNode();
      this.next();
      this.parseClass(cls, true, true);
      cls.abstract = true;
      return cls;
    }

    if (this.state.value === "interface") {
      const result = this.tsParseDeclaration(this.startNode(), this.state.value, true);
      if (result) return result;
    }

    return super.parseExportDefaultExpression();
  }

  parseStatementContent(context, topLevel) {
    if (this.state.type === types._const) {
      const ahead = this.lookahead();

      if (ahead.type === types.name && ahead.value === "enum") {
        const node = this.startNode();
        this.expect(types._const);
        this.expectContextual("enum");
        return this.tsParseEnumDeclaration(node, true);
      }
    }

    return super.parseStatementContent(context, topLevel);
  }

  parseAccessModifier() {
    return this.tsParseModifier(["public", "protected", "private"]);
  }

  parseClassMember(classBody, member, state, constructorAllowsSuper) {
    this.tsParseModifiers(member, ["declare"]);
    const accessibility = this.parseAccessModifier();
    if (accessibility) member.accessibility = accessibility;
    this.tsParseModifiers(member, ["declare"]);
    super.parseClassMember(classBody, member, state, constructorAllowsSuper);
  }

  parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper) {
    this.tsParseModifiers(member, ["abstract", "readonly", "declare"]);
    const idx = this.tsTryParseIndexSignature(member);

    if (idx) {
      classBody.body.push(idx);

      if (member.abstract) {
        this.raise(member.start, TSErrors.IndexSignatureHasAbstract);
      }

      if (isStatic) {
        this.raise(member.start, TSErrors.IndexSignatureHasStatic);
      }

      if (member.accessibility) {
        this.raise(member.start, TSErrors.IndexSignatureHasAccessibility, member.accessibility);
      }

      return;
    }

    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper);
  }

  parsePostMemberNameModifiers(methodOrProp) {
    const optional = this.eat(types.question);
    if (optional) methodOrProp.optional = true;

    if (methodOrProp.readonly && this.match(types.parenL)) {
      this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);
    }

    if (methodOrProp.declare && this.match(types.parenL)) {
      this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);
    }
  }

  parseExpressionStatement(node, expr) {
    const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : undefined;
    return decl || super.parseExpressionStatement(node, expr);
  }

  shouldParseExportDeclaration() {
    if (this.tsIsDeclarationStart()) return true;
    return super.shouldParseExportDeclaration();
  }

  parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
    if (!refNeedsArrowPos || !this.match(types.question)) {
      return super.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);
    }

    const result = this.tryParse(() => super.parseConditional(expr, noIn, startPos, startLoc));

    if (!result.node) {
      refNeedsArrowPos.start = result.error.pos || this.state.start;
      return expr;
    }

    if (result.error) this.state = result.failState;
    return result.node;
  }

  parseParenItem(node, startPos, startLoc) {
    node = super.parseParenItem(node, startPos, startLoc);

    if (this.eat(types.question)) {
      node.optional = true;
      this.resetEndLocation(node);
    }

    if (this.match(types.colon)) {
      const typeCastNode = this.startNodeAt(startPos, startLoc);
      typeCastNode.expression = node;
      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
      return this.finishNode(typeCastNode, "TSTypeCastExpression");
    }

    return node;
  }

  parseExportDeclaration(node) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const isDeclare = this.eatContextual("declare");
    let declaration;

    if (this.match(types.name)) {
      declaration = this.tsTryParseExportDeclaration();
    }

    if (!declaration) {
      declaration = super.parseExportDeclaration(node);
    }

    if (declaration && (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare)) {
      node.exportKind = "type";
    }

    if (declaration && isDeclare) {
      this.resetStartLocation(declaration, startPos, startLoc);
      declaration.declare = true;
    }

    return declaration;
  }

  parseClassId(node, isStatement, optionalId) {
    if ((!isStatement || optionalId) && this.isContextual("implements")) {
      return;
    }

    super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);
    const typeParameters = this.tsTryParseTypeParameters();
    if (typeParameters) node.typeParameters = typeParameters;
  }

  parseClassPropertyAnnotation(node) {
    if (!node.optional && this.eat(types.bang)) {
      node.definite = true;
    }

    const type = this.tsTryParseTypeAnnotation();
    if (type) node.typeAnnotation = type;
  }

  parseClassProperty(node) {
    this.parseClassPropertyAnnotation(node);

    if (node.declare && this.match(types.equal)) {
      this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);
    }

    return super.parseClassProperty(node);
  }

  parseClassPrivateProperty(node) {
    if (node.abstract) {
      this.raise(node.start, TSErrors.PrivateElementHasAbstract);
    }

    if (node.accessibility) {
      this.raise(node.start, TSErrors.PrivateElementHasAccessibility, node.accessibility);
    }

    this.parseClassPropertyAnnotation(node);
    return super.parseClassPrivateProperty(node);
  }

  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
    const typeParameters = this.tsTryParseTypeParameters();
    if (typeParameters) method.typeParameters = typeParameters;
    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
  }

  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
    const typeParameters = this.tsTryParseTypeParameters();
    if (typeParameters) method.typeParameters = typeParameters;
    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
  }

  parseClassSuper(node) {
    super.parseClassSuper(node);

    if (node.superClass && this.isRelational("<")) {
      node.superTypeParameters = this.tsParseTypeArguments();
    }

    if (this.eatContextual("implements")) {
      node.implements = this.tsParseHeritageClause("implements");
    }
  }

  parseObjPropValue(prop, ...args) {
    const typeParameters = this.tsTryParseTypeParameters();
    if (typeParameters) prop.typeParameters = typeParameters;
    super.parseObjPropValue(prop, ...args);
  }

  parseFunctionParams(node, allowModifiers) {
    const typeParameters = this.tsTryParseTypeParameters();
    if (typeParameters) node.typeParameters = typeParameters;
    super.parseFunctionParams(node, allowModifiers);
  }

  parseVarId(decl, kind) {
    super.parseVarId(decl, kind);

    if (decl.id.type === "Identifier" && this.eat(types.bang)) {
      decl.definite = true;
    }

    const type = this.tsTryParseTypeAnnotation();

    if (type) {
      decl.id.typeAnnotation = type;
      this.resetEndLocation(decl.id);
    }
  }

  parseAsyncArrowFromCallExpression(node, call) {
    if (this.match(types.colon)) {
      node.returnType = this.tsParseTypeAnnotation();
    }

    return super.parseAsyncArrowFromCallExpression(node, call);
  }

  parseMaybeAssign(...args) {
    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;

    let state;
    let jsx;
    let typeCast;

    if (this.match(types.jsxTagStart)) {
      state = this.state.clone();
      jsx = this.tryParse(() => super.parseMaybeAssign(...args), state);
      if (!jsx.error) return jsx.node;
      const {
        context
      } = this.state;

      if (context[context.length - 1] === types$1.j_oTag) {
        context.length -= 2;
      } else if (context[context.length - 1] === types$1.j_expr) {
        context.length -= 1;
      }
    }

    if (!((_jsx = jsx) == null ? void 0 : _jsx.error) && !this.isRelational("<")) {
      return super.parseMaybeAssign(...args);
    }

    let typeParameters;
    state = state || this.state.clone();
    const arrow = this.tryParse(abort => {
      var _typeParameters;

      typeParameters = this.tsParseTypeParameters();
      const expr = super.parseMaybeAssign(...args);

      if (expr.type !== "ArrowFunctionExpression" || expr.extra && expr.extra.parenthesized) {
        abort();
      }

      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
        this.resetStartLocationFromNode(expr, typeParameters);
      }

      expr.typeParameters = typeParameters;
      return expr;
    }, state);
    if (!arrow.error && !arrow.aborted) return arrow.node;

    if (!jsx) {
      assert(!this.hasPlugin("jsx"));
      typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state);
      if (!typeCast.error) return typeCast.node;
    }

    if ((_jsx2 = jsx) == null ? void 0 : _jsx2.node) {
      this.state = jsx.failState;
      return jsx.node;
    }

    if (arrow.node) {
      this.state = arrow.failState;
      return arrow.node;
    }

    if ((_typeCast = typeCast) == null ? void 0 : _typeCast.node) {
      this.state = typeCast.failState;
      return typeCast.node;
    }

    if ((_jsx3 = jsx) == null ? void 0 : _jsx3.thrown) throw jsx.error;
    if (arrow.thrown) throw arrow.error;
    if ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.thrown) throw typeCast.error;
    throw ((_jsx4 = jsx) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
  }

  parseMaybeUnary(refExpressionErrors) {
    if (!this.hasPlugin("jsx") && this.isRelational("<")) {
      return this.tsParseTypeAssertion();
    } else {
      return super.parseMaybeUnary(refExpressionErrors);
    }
  }

  parseArrow(node) {
    if (this.match(types.colon)) {
      const result = this.tryParse(abort => {
        const returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);
        if (this.canInsertSemicolon() || !this.match(types.arrow)) abort();
        return returnType;
      });
      if (result.aborted) return;

      if (!result.thrown) {
        if (result.error) this.state = result.failState;
        node.returnType = result.node;
      }
    }

    return super.parseArrow(node);
  }

  parseAssignableListItemTypes(param) {
    if (this.eat(types.question)) {
      if (param.type !== "Identifier") {
        this.raise(param.start, TSErrors.PatternIsOptional);
      }

      param.optional = true;
    }

    const type = this.tsTryParseTypeAnnotation();
    if (type) param.typeAnnotation = type;
    this.resetEndLocation(param);
    return param;
  }

  toAssignable(node) {
    switch (node.type) {
      case "TSTypeCastExpression":
        return super.toAssignable(this.typeCastToParameter(node));

      case "TSParameterProperty":
        return super.toAssignable(node);

      case "TSAsExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
        node.expression = this.toAssignable(node.expression);
        return node;

      default:
        return super.toAssignable(node);
    }
  }

  checkLVal(expr, bindingType = BIND_NONE, checkClashes, contextDescription) {
    switch (expr.type) {
      case "TSTypeCastExpression":
        return;

      case "TSParameterProperty":
        this.checkLVal(expr.parameter, bindingType, checkClashes, "parameter property");
        return;

      case "TSAsExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
        this.checkLVal(expr.expression, bindingType, checkClashes, contextDescription);
        return;

      default:
        super.checkLVal(expr, bindingType, checkClashes, contextDescription);
        return;
    }
  }

  parseBindingAtom() {
    switch (this.state.type) {
      case types._this:
        return this.parseIdentifier(true);

      default:
        return super.parseBindingAtom();
    }
  }

  parseMaybeDecoratorArguments(expr) {
    if (this.isRelational("<")) {
      const typeArguments = this.tsParseTypeArguments();

      if (this.match(types.parenL)) {
        const call = super.parseMaybeDecoratorArguments(expr);
        call.typeParameters = typeArguments;
        return call;
      }

      this.unexpected(this.state.start, types.parenL);
    }

    return super.parseMaybeDecoratorArguments(expr);
  }

  isClassMethod() {
    return this.isRelational("<") || super.isClassMethod();
  }

  isClassProperty() {
    return this.match(types.bang) || this.match(types.colon) || super.isClassProperty();
  }

  parseMaybeDefault(...args) {
    const node = super.parseMaybeDefault(...args);

    if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
      this.raise(node.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign);
    }

    return node;
  }

  getTokenFromCode(code) {
    if (this.state.inType && (code === 62 || code === 60)) {
      return this.finishOp(types.relational, 1);
    } else {
      return super.getTokenFromCode(code);
    }
  }

  toAssignableList(exprList) {
    for (let i = 0; i < exprList.length; i++) {
      const expr = exprList[i];
      if (!expr) continue;

      switch (expr.type) {
        case "TSTypeCastExpression":
          exprList[i] = this.typeCastToParameter(expr);
          break;

        case "TSAsExpression":
        case "TSTypeAssertion":
          if (!this.state.maybeInArrowParameters) {
            exprList[i] = this.typeCastToParameter(expr);
          } else {
            this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);
          }

          break;
      }
    }

    return super.toAssignableList(...arguments);
  }

  typeCastToParameter(node) {
    node.expression.typeAnnotation = node.typeAnnotation;
    this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
    return node.expression;
  }

  toReferencedList(exprList, isInParens) {
    for (let i = 0; i < exprList.length; i++) {
      const expr = exprList[i];

      if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") {
        this.raise(expr.start, TSErrors.UnexpectedTypeAnnotation);
      }
    }

    return exprList;
  }

  shouldParseArrow() {
    return this.match(types.colon) || super.shouldParseArrow();
  }

  shouldParseAsyncArrow() {
    return this.match(types.colon) || super.shouldParseAsyncArrow();
  }

  canHaveLeadingDecorator() {
    return super.canHaveLeadingDecorator() || this.isAbstractClass();
  }

  jsxParseOpeningElementAfterName(node) {
    if (this.isRelational("<")) {
      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());
      if (typeArguments) node.typeParameters = typeArguments;
    }

    return super.jsxParseOpeningElementAfterName(node);
  }

  getGetterSetterExpectedParamCount(method) {
    const baseCount = super.getGetterSetterExpectedParamCount(method);
    const firstParam = method.params[0];
    const hasContextParam = firstParam && firstParam.type === "Identifier" && firstParam.name === "this";
    return hasContextParam ? baseCount + 1 : baseCount;
  }

});

types.placeholder = new TokenType("%%", {
  startsExpr: true
});
var placeholders = (superClass => class extends superClass {
  parsePlaceholder(expectedNode) {
    if (this.match(types.placeholder)) {
      const node = this.startNode();
      this.next();
      this.assertNoSpace("Unexpected space in placeholder.");
      node.name = super.parseIdentifier(true);
      this.assertNoSpace("Unexpected space in placeholder.");
      this.expect(types.placeholder);
      return this.finishPlaceholder(node, expectedNode);
    }
  }

  finishPlaceholder(node, expectedNode) {
    const isFinished = !!(node.expectedNode && node.type === "Placeholder");
    node.expectedNode = expectedNode;
    return isFinished ? node : this.finishNode(node, "Placeholder");
  }

  getTokenFromCode(code) {
    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
      return this.finishOp(types.placeholder, 2);
    }

    return super.getTokenFromCode(...arguments);
  }

  parseExprAtom() {
    return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
  }

  parseIdentifier() {
    return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
  }

  checkReservedWord(word) {
    if (word !== undefined) super.checkReservedWord(...arguments);
  }

  parseBindingAtom() {
    return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
  }

  checkLVal(expr) {
    if (expr.type !== "Placeholder") super.checkLVal(...arguments);
  }

  toAssignable(node) {
    if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
      node.expectedNode = "Pattern";
      return node;
    }

    return super.toAssignable(...arguments);
  }

  verifyBreakContinue(node) {
    if (node.label && node.label.type === "Placeholder") return;
    super.verifyBreakContinue(...arguments);
  }

  parseExpressionStatement(node, expr) {
    if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
      return super.parseExpressionStatement(...arguments);
    }

    if (this.match(types.colon)) {
      const stmt = node;
      stmt.label = this.finishPlaceholder(expr, "Identifier");
      this.next();
      stmt.body = this.parseStatement("label");
      return this.finishNode(stmt, "LabeledStatement");
    }

    this.semicolon();
    node.name = expr.name;
    return this.finishPlaceholder(node, "Statement");
  }

  parseBlock() {
    return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
  }

  parseFunctionId() {
    return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
  }

  parseClass(node, isStatement, optionalId) {
    const type = isStatement ? "ClassDeclaration" : "ClassExpression";
    this.next();
    this.takeDecorators(node);
    const placeholder = this.parsePlaceholder("Identifier");

    if (placeholder) {
      if (this.match(types._extends) || this.match(types.placeholder) || this.match(types.braceL)) {
        node.id = placeholder;
      } else if (optionalId || !isStatement) {
        node.id = null;
        node.body = this.finishPlaceholder(placeholder, "ClassBody");
        return this.finishNode(node, type);
      } else {
        this.unexpected(null, "A class name is required");
      }
    } else {
      this.parseClassId(node, isStatement, optionalId);
    }

    this.parseClassSuper(node);
    node.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node.superClass);
    return this.finishNode(node, type);
  }

  parseExport(node) {
    const placeholder = this.parsePlaceholder("Identifier");
    if (!placeholder) return super.parseExport(...arguments);

    if (!this.isContextual("from") && !this.match(types.comma)) {
      node.specifiers = [];
      node.source = null;
      node.declaration = this.finishPlaceholder(placeholder, "Declaration");
      return this.finishNode(node, "ExportNamedDeclaration");
    }

    this.expectPlugin("exportDefaultFrom");
    const specifier = this.startNode();
    specifier.exported = placeholder;
    node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
    return super.parseExport(node);
  }

  isExportDefaultSpecifier() {
    if (this.match(types._default)) {
      const next = this.nextTokenStart();

      if (this.isUnparsedContextual(next, "from")) {
        if (this.input.startsWith(types.placeholder.label, this.nextTokenStartSince(next + 4))) {
          return true;
        }
      }
    }

    return super.isExportDefaultSpecifier();
  }

  maybeParseExportDefaultSpecifier(node) {
    if (node.specifiers && node.specifiers.length > 0) {
      return true;
    }

    return super.maybeParseExportDefaultSpecifier(...arguments);
  }

  checkExport(node) {
    const {
      specifiers
    } = node;

    if (specifiers == null ? void 0 : specifiers.length) {
      node.specifiers = specifiers.filter(node => node.exported.type === "Placeholder");
    }

    super.checkExport(node);
    node.specifiers = specifiers;
  }

  parseImport(node) {
    const placeholder = this.parsePlaceholder("Identifier");
    if (!placeholder) return super.parseImport(...arguments);
    node.specifiers = [];

    if (!this.isContextual("from") && !this.match(types.comma)) {
      node.source = this.finishPlaceholder(placeholder, "StringLiteral");
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    }

    const specifier = this.startNodeAtNode(placeholder);
    specifier.local = placeholder;
    this.finishNode(specifier, "ImportDefaultSpecifier");
    node.specifiers.push(specifier);

    if (this.eat(types.comma)) {
      const hasStarImport = this.maybeParseStarImportSpecifier(node);
      if (!hasStarImport) this.parseNamedImportSpecifiers(node);
    }

    this.expectContextual("from");
    node.source = this.parseImportSource();
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration");
  }

  parseImportSource() {
    return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
  }

});

var v8intrinsic = (superClass => class extends superClass {
  parseV8Intrinsic() {
    if (this.match(types.modulo)) {
      const v8IntrinsicStart = this.state.start;
      const node = this.startNode();
      this.eat(types.modulo);

      if (this.match(types.name)) {
        const name = this.parseIdentifierName(this.state.start);
        const identifier = this.createIdentifier(node, name);
        identifier.type = "V8IntrinsicIdentifier";

        if (this.match(types.parenL)) {
          return identifier;
        }
      }

      this.unexpected(v8IntrinsicStart);
    }
  }

  parseExprAtom() {
    return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
  }

});

function hasPlugin(plugins, name) {
  return plugins.some(plugin => {
    if (Array.isArray(plugin)) {
      return plugin[0] === name;
    } else {
      return plugin === name;
    }
  });
}
function getPluginOption(plugins, name, option) {
  const plugin = plugins.find(plugin => {
    if (Array.isArray(plugin)) {
      return plugin[0] === name;
    } else {
      return plugin === name;
    }
  });

  if (plugin && Array.isArray(plugin)) {
    return plugin[1][option];
  }

  return null;
}
const PIPELINE_PROPOSALS = ["minimal", "smart", "fsharp"];
const RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
function validatePlugins(plugins) {
  if (hasPlugin(plugins, "decorators")) {
    if (hasPlugin(plugins, "decorators-legacy")) {
      throw new Error("Cannot use the decorators and decorators-legacy plugin together");
    }

    const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");

    if (decoratorsBeforeExport == null) {
      throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option," + " whose value must be a boolean. If you are migrating from" + " Babylon/Babel 6 or want to use the old decorators proposal, you" + " should use the 'decorators-legacy' plugin instead of 'decorators'.");
    } else if (typeof decoratorsBeforeExport !== "boolean") {
      throw new Error("'decoratorsBeforeExport' must be a boolean.");
    }
  }

  if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
    throw new Error("Cannot combine flow and typescript plugins.");
  }

  if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
    throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
  }

  if (hasPlugin(plugins, "pipelineOperator") && !PIPELINE_PROPOSALS.includes(getPluginOption(plugins, "pipelineOperator", "proposal"))) {
    throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + PIPELINE_PROPOSALS.map(p => `'${p}'`).join(", "));
  }

  if (hasPlugin(plugins, "moduleAttributes")) {
    const moduleAttributesVerionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");

    if (moduleAttributesVerionPluginOption !== "may-2020") {
      throw new Error("The 'moduleAttributes' plugin requires a 'version' option," + " representing the last proposal update. Currently, the" + " only supported value is 'may-2020'.");
    }
  }

  if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
    throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(", "));
  }
}
const mixinPlugins = {
  estree,
  jsx,
  flow,
  typescript,
  v8intrinsic,
  placeholders
};
const mixinPluginNames = Object.keys(mixinPlugins);

const defaultOptions = {
  sourceType: "script",
  sourceFilename: undefined,
  startLine: 1,
  allowAwaitOutsideFunction: false,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowSuperOutsideMethod: false,
  allowUndeclaredExports: false,
  plugins: [],
  strictMode: null,
  ranges: false,
  tokens: false,
  createParenthesizedExpressions: false,
  errorRecovery: false
};
function getOptions(opts) {
  const options = {};

  for (let _i = 0, _Object$keys = Object.keys(defaultOptions); _i < _Object$keys.length; _i++) {
    const key = _Object$keys[_i];
    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
  }

  return options;
}

class State {
  constructor() {
    this.errors = [];
    this.potentialArrowAt = -1;
    this.noArrowAt = [];
    this.noArrowParamsConversionAt = [];
    this.inParameters = false;
    this.maybeInArrowParameters = false;
    this.maybeInAsyncArrowHead = false;
    this.inPipeline = false;
    this.inType = false;
    this.noAnonFunctionType = false;
    this.inPropertyName = false;
    this.hasFlowComment = false;
    this.isIterator = false;
    this.topicContext = {
      maxNumOfResolvableTopics: 0,
      maxTopicIndex: null
    };
    this.soloAwait = false;
    this.inFSharpPipelineDirectBody = false;
    this.labels = [];
    this.decoratorStack = [[]];
    this.yieldPos = -1;
    this.awaitPos = -1;
    this.comments = [];
    this.trailingComments = [];
    this.leadingComments = [];
    this.commentStack = [];
    this.commentPreviousNode = null;
    this.pos = 0;
    this.lineStart = 0;
    this.type = types.eof;
    this.value = null;
    this.start = 0;
    this.end = 0;
    this.lastTokEndLoc = null;
    this.lastTokStartLoc = null;
    this.lastTokStart = 0;
    this.lastTokEnd = 0;
    this.context = [types$1.braceStatement];
    this.exprAllowed = true;
    this.containsEsc = false;
    this.octalPositions = [];
    this.exportedIdentifiers = [];
    this.tokensLength = 0;
  }

  init(options) {
    this.strict = options.strictMode === false ? false : options.sourceType === "module";
    this.curLine = options.startLine;
    this.startLoc = this.endLoc = this.curPosition();
  }

  curPosition() {
    return new Position(this.curLine, this.pos - this.lineStart);
  }

  clone(skipArrays) {
    const state = new State();
    const keys = Object.keys(this);

    for (let i = 0, length = keys.length; i < length; i++) {
      const key = keys[i];
      let val = this[key];

      if (!skipArrays && Array.isArray(val)) {
        val = val.slice();
      }

      state[key] = val;
    }

    return state;
  }

}

var _isDigit = function isDigit(code) {
  return code >= 48 && code <= 57;
};
const VALID_REGEX_FLAGS = new Set(["g", "m", "s", "i", "y", "u"]);
const forbiddenNumericSeparatorSiblings = {
  decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
  hex: [46, 88, 95, 120]
};
const allowedNumericSeparatorSiblings = {};
allowedNumericSeparatorSiblings.bin = [48, 49];
allowedNumericSeparatorSiblings.oct = [...allowedNumericSeparatorSiblings.bin, 50, 51, 52, 53, 54, 55];
allowedNumericSeparatorSiblings.dec = [...allowedNumericSeparatorSiblings.oct, 56, 57];
allowedNumericSeparatorSiblings.hex = [...allowedNumericSeparatorSiblings.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
class Token {
  constructor(state) {
    this.type = state.type;
    this.value = state.value;
    this.start = state.start;
    this.end = state.end;
    this.loc = new SourceLocation(state.startLoc, state.endLoc);
  }

}
class Tokenizer extends ParserError {
  constructor(options, input) {
    super();
    this.tokens = [];
    this.state = new State();
    this.state.init(options);
    this.input = input;
    this.length = input.length;
    this.isLookahead = false;
  }

  pushToken(token) {
    this.tokens.length = this.state.tokensLength;
    this.tokens.push(token);
    ++this.state.tokensLength;
  }

  next() {
    if (!this.isLookahead) {
      this.checkKeywordEscapes();

      if (this.options.tokens) {
        this.pushToken(new Token(this.state));
      }
    }

    this.state.lastTokEnd = this.state.end;
    this.state.lastTokStart = this.state.start;
    this.state.lastTokEndLoc = this.state.endLoc;
    this.state.lastTokStartLoc = this.state.startLoc;
    this.nextToken();
  }

  eat(type) {
    if (this.match(type)) {
      this.next();
      return true;
    } else {
      return false;
    }
  }

  match(type) {
    return this.state.type === type;
  }

  lookahead() {
    const old = this.state;
    this.state = old.clone(true);
    this.isLookahead = true;
    this.next();
    this.isLookahead = false;
    const curr = this.state;
    this.state = old;
    return curr;
  }

  nextTokenStart() {
    return this.nextTokenStartSince(this.state.pos);
  }

  nextTokenStartSince(pos) {
    skipWhiteSpace.lastIndex = pos;
    const skip = skipWhiteSpace.exec(this.input);
    return pos + skip[0].length;
  }

  lookaheadCharCode() {
    return this.input.charCodeAt(this.nextTokenStart());
  }

  setStrict(strict) {
    this.state.strict = strict;
    if (!this.match(types.num) && !this.match(types.string)) return;
    this.state.pos = this.state.start;

    while (this.state.pos < this.state.lineStart) {
      this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1;
      --this.state.curLine;
    }

    this.nextToken();
  }

  curContext() {
    return this.state.context[this.state.context.length - 1];
  }

  nextToken() {
    const curContext = this.curContext();
    if (!(curContext == null ? void 0 : curContext.preserveSpace)) this.skipSpace();
    this.state.octalPositions = [];
    this.state.start = this.state.pos;
    this.state.startLoc = this.state.curPosition();

    if (this.state.pos >= this.length) {
      this.finishToken(types.eof);
      return;
    }

    const override = curContext == null ? void 0 : curContext.override;

    if (override) {
      override(this);
    } else {
      this.getTokenFromCode(this.input.codePointAt(this.state.pos));
    }
  }

  pushComment(block, text, start, end, startLoc, endLoc) {
    const comment = {
      type: block ? "CommentBlock" : "CommentLine",
      value: text,
      start: start,
      end: end,
      loc: new SourceLocation(startLoc, endLoc)
    };
    if (this.options.tokens) this.pushToken(comment);
    this.state.comments.push(comment);
    this.addComment(comment);
  }

  skipBlockComment() {
    const startLoc = this.state.curPosition();
    const start = this.state.pos;
    const end = this.input.indexOf("*/", this.state.pos + 2);
    if (end === -1) throw this.raise(start, ErrorMessages.UnterminatedComment);
    this.state.pos = end + 2;
    lineBreakG.lastIndex = start;
    let match;

    while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {
      ++this.state.curLine;
      this.state.lineStart = match.index + match[0].length;
    }

    if (this.isLookahead) return;
    this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
  }

  skipLineComment(startSkip) {
    const start = this.state.pos;
    const startLoc = this.state.curPosition();
    let ch = this.input.charCodeAt(this.state.pos += startSkip);

    if (this.state.pos < this.length) {
      while (!isNewLine(ch) && ++this.state.pos < this.length) {
        ch = this.input.charCodeAt(this.state.pos);
      }
    }

    if (this.isLookahead) return;
    this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
  }

  skipSpace() {
    loop: while (this.state.pos < this.length) {
      const ch = this.input.charCodeAt(this.state.pos);

      switch (ch) {
        case 32:
        case 160:
        case 9:
          ++this.state.pos;
          break;

        case 13:
          if (this.input.charCodeAt(this.state.pos + 1) === 10) {
            ++this.state.pos;
          }

        case 10:
        case 8232:
        case 8233:
          ++this.state.pos;
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          break;

        case 47:
          switch (this.input.charCodeAt(this.state.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;

            case 47:
              this.skipLineComment(2);
              break;

            default:
              break loop;
          }

          break;

        default:
          if (isWhitespace(ch)) {
            ++this.state.pos;
          } else {
            break loop;
          }

      }
    }
  }

  finishToken(type, val) {
    this.state.end = this.state.pos;
    this.state.endLoc = this.state.curPosition();
    const prevType = this.state.type;
    this.state.type = type;
    this.state.value = val;
    if (!this.isLookahead) this.updateContext(prevType);
  }

  readToken_numberSign() {
    if (this.state.pos === 0 && this.readToken_interpreter()) {
      return;
    }

    const nextPos = this.state.pos + 1;
    const next = this.input.charCodeAt(nextPos);

    if (next >= 48 && next <= 57) {
      throw this.raise(this.state.pos, ErrorMessages.UnexpectedDigitAfterHash);
    }

    if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
      this.expectPlugin("recordAndTuple");

      if (this.getPluginOption("recordAndTuple", "syntaxType") !== "hash") {
        throw this.raise(this.state.pos, next === 123 ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType);
      }

      if (next === 123) {
        this.finishToken(types.braceHashL);
      } else {
        this.finishToken(types.bracketHashL);
      }

      this.state.pos += 2;
    } else {
      this.finishOp(types.hash, 1);
    }
  }

  readToken_dot() {
    const next = this.input.charCodeAt(this.state.pos + 1);

    if (next >= 48 && next <= 57) {
      this.readNumber(true);
      return;
    }

    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
      this.state.pos += 3;
      this.finishToken(types.ellipsis);
    } else {
      ++this.state.pos;
      this.finishToken(types.dot);
    }
  }

  readToken_slash() {
    if (this.state.exprAllowed && !this.state.inType) {
      ++this.state.pos;
      this.readRegexp();
      return;
    }

    const next = this.input.charCodeAt(this.state.pos + 1);

    if (next === 61) {
      this.finishOp(types.assign, 2);
    } else {
      this.finishOp(types.slash, 1);
    }
  }

  readToken_interpreter() {
    if (this.state.pos !== 0 || this.length < 2) return false;
    let ch = this.input.charCodeAt(this.state.pos + 1);
    if (ch !== 33) return false;
    const start = this.state.pos;
    this.state.pos += 1;

    while (!isNewLine(ch) && ++this.state.pos < this.length) {
      ch = this.input.charCodeAt(this.state.pos);
    }

    const value = this.input.slice(start + 2, this.state.pos);
    this.finishToken(types.interpreterDirective, value);
    return true;
  }

  readToken_mult_modulo(code) {
    let type = code === 42 ? types.star : types.modulo;
    let width = 1;
    let next = this.input.charCodeAt(this.state.pos + 1);
    const exprAllowed = this.state.exprAllowed;

    if (code === 42 && next === 42) {
      width++;
      next = this.input.charCodeAt(this.state.pos + 2);
      type = types.exponent;
    }

    if (next === 61 && !exprAllowed) {
      width++;
      type = types.assign;
    }

    this.finishOp(type, width);
  }

  readToken_pipe_amp(code) {
    const next = this.input.charCodeAt(this.state.pos + 1);

    if (next === code) {
      if (this.input.charCodeAt(this.state.pos + 2) === 61) {
        this.finishOp(types.assign, 3);
      } else {
        this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
      }

      return;
    }

    if (code === 124) {
      if (next === 62) {
        this.finishOp(types.pipeline, 2);
        return;
      }

      if (this.hasPlugin("recordAndTuple") && next === 125) {
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
          throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType);
        }

        this.finishOp(types.braceBarR, 2);
        return;
      }

      if (this.hasPlugin("recordAndTuple") && next === 93) {
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
          throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType);
        }

        this.finishOp(types.bracketBarR, 2);
        return;
      }
    }

    if (next === 61) {
      this.finishOp(types.assign, 2);
      return;
    }

    this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
  }

  readToken_caret() {
    const next = this.input.charCodeAt(this.state.pos + 1);

    if (next === 61) {
      this.finishOp(types.assign, 2);
    } else {
      this.finishOp(types.bitwiseXOR, 1);
    }
  }

  readToken_plus_min(code) {
    const next = this.input.charCodeAt(this.state.pos + 1);

    if (next === code) {
      if (next === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && (this.state.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos)))) {
        this.skipLineComment(3);
        this.skipSpace();
        this.nextToken();
        return;
      }

      this.finishOp(types.incDec, 2);
      return;
    }

    if (next === 61) {
      this.finishOp(types.assign, 2);
    } else {
      this.finishOp(types.plusMin, 1);
    }
  }

  readToken_lt_gt(code) {
    const next = this.input.charCodeAt(this.state.pos + 1);
    let size = 1;

    if (next === code) {
      size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;

      if (this.input.charCodeAt(this.state.pos + size) === 61) {
        this.finishOp(types.assign, size + 1);
        return;
      }

      this.finishOp(types.bitShift, size);
      return;
    }

    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
      this.skipLineComment(4);
      this.skipSpace();
      this.nextToken();
      return;
    }

    if (next === 61) {
      size = 2;
    }

    this.finishOp(types.relational, size);
  }

  readToken_eq_excl(code) {
    const next = this.input.charCodeAt(this.state.pos + 1);

    if (next === 61) {
      this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
      return;
    }

    if (code === 61 && next === 62) {
      this.state.pos += 2;
      this.finishToken(types.arrow);
      return;
    }

    this.finishOp(code === 61 ? types.eq : types.bang, 1);
  }

  readToken_question() {
    const next = this.input.charCodeAt(this.state.pos + 1);
    const next2 = this.input.charCodeAt(this.state.pos + 2);

    if (next === 63 && !this.state.inType) {
      if (next2 === 61) {
        this.finishOp(types.assign, 3);
      } else {
        this.finishOp(types.nullishCoalescing, 2);
      }
    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
      this.state.pos += 2;
      this.finishToken(types.questionDot);
    } else {
      ++this.state.pos;
      this.finishToken(types.question);
    }
  }

  getTokenFromCode(code) {
    switch (code) {
      case 46:
        this.readToken_dot();
        return;

      case 40:
        ++this.state.pos;
        this.finishToken(types.parenL);
        return;

      case 41:
        ++this.state.pos;
        this.finishToken(types.parenR);
        return;

      case 59:
        ++this.state.pos;
        this.finishToken(types.semi);
        return;

      case 44:
        ++this.state.pos;
        this.finishToken(types.comma);
        return;

      case 91:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType);
          }

          this.finishToken(types.bracketBarL);
          this.state.pos += 2;
        } else {
          ++this.state.pos;
          this.finishToken(types.bracketL);
        }

        return;

      case 93:
        ++this.state.pos;
        this.finishToken(types.bracketR);
        return;

      case 123:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType);
          }

          this.finishToken(types.braceBarL);
          this.state.pos += 2;
        } else {
          ++this.state.pos;
          this.finishToken(types.braceL);
        }

        return;

      case 125:
        ++this.state.pos;
        this.finishToken(types.braceR);
        return;

      case 58:
        if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
          this.finishOp(types.doubleColon, 2);
        } else {
          ++this.state.pos;
          this.finishToken(types.colon);
        }

        return;

      case 63:
        this.readToken_question();
        return;

      case 96:
        ++this.state.pos;
        this.finishToken(types.backQuote);
        return;

      case 48:
        {
          const next = this.input.charCodeAt(this.state.pos + 1);

          if (next === 120 || next === 88) {
            this.readRadixNumber(16);
            return;
          }

          if (next === 111 || next === 79) {
            this.readRadixNumber(8);
            return;
          }

          if (next === 98 || next === 66) {
            this.readRadixNumber(2);
            return;
          }
        }

      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        this.readNumber(false);
        return;

      case 34:
      case 39:
        this.readString(code);
        return;

      case 47:
        this.readToken_slash();
        return;

      case 37:
      case 42:
        this.readToken_mult_modulo(code);
        return;

      case 124:
      case 38:
        this.readToken_pipe_amp(code);
        return;

      case 94:
        this.readToken_caret();
        return;

      case 43:
      case 45:
        this.readToken_plus_min(code);
        return;

      case 60:
      case 62:
        this.readToken_lt_gt(code);
        return;

      case 61:
      case 33:
        this.readToken_eq_excl(code);
        return;

      case 126:
        this.finishOp(types.tilde, 1);
        return;

      case 64:
        ++this.state.pos;
        this.finishToken(types.at);
        return;

      case 35:
        this.readToken_numberSign();
        return;

      case 92:
        this.readWord();
        return;

      default:
        if (isIdentifierStart(code)) {
          this.readWord();
          return;
        }

    }

    throw this.raise(this.state.pos, ErrorMessages.InvalidOrUnexpectedToken, String.fromCodePoint(code));
  }

  finishOp(type, size) {
    const str = this.input.slice(this.state.pos, this.state.pos + size);
    this.state.pos += size;
    this.finishToken(type, str);
  }

  readRegexp() {
    const start = this.state.pos;
    let escaped, inClass;

    for (;;) {
      if (this.state.pos >= this.length) {
        throw this.raise(start, ErrorMessages.UnterminatedRegExp);
      }

      const ch = this.input.charAt(this.state.pos);

      if (lineBreak.test(ch)) {
        throw this.raise(start, ErrorMessages.UnterminatedRegExp);
      }

      if (escaped) {
        escaped = false;
      } else {
        if (ch === "[") {
          inClass = true;
        } else if (ch === "]" && inClass) {
          inClass = false;
        } else if (ch === "/" && !inClass) {
          break;
        }

        escaped = ch === "\\";
      }

      ++this.state.pos;
    }

    const content = this.input.slice(start, this.state.pos);
    ++this.state.pos;
    let mods = "";

    while (this.state.pos < this.length) {
      const char = this.input[this.state.pos];
      const charCode = this.input.codePointAt(this.state.pos);

      if (VALID_REGEX_FLAGS.has(char)) {
        if (mods.indexOf(char) > -1) {
          this.raise(this.state.pos + 1, ErrorMessages.DuplicateRegExpFlags);
        }
      } else if (isIdentifierChar(charCode) || charCode === 92) {
        this.raise(this.state.pos + 1, ErrorMessages.MalformedRegExpFlags);
      } else {
        break;
      }

      ++this.state.pos;
      mods += char;
    }

    this.finishToken(types.regexp, {
      pattern: content,
      flags: mods
    });
  }

  readInt(radix, len, forceLen, allowNumSeparator = true) {
    const start = this.state.pos;
    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
    const allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
    let invalid = false;
    let total = 0;

    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      const code = this.input.charCodeAt(this.state.pos);
      let val;

      if (this.hasPlugin("numericSeparator")) {
        if (code === 95) {
          const prev = this.input.charCodeAt(this.state.pos - 1);
          const next = this.input.charCodeAt(this.state.pos + 1);

          if (allowedSiblings.indexOf(next) === -1) {
            this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
          } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {
            this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
          }

          if (!allowNumSeparator) {
            this.raise(this.state.pos, ErrorMessages.NumericSeparatorInEscapeSequence);
          }

          ++this.state.pos;
          continue;
        }
      }

      if (code >= 97) {
        val = code - 97 + 10;
      } else if (code >= 65) {
        val = code - 65 + 10;
      } else if (_isDigit(code)) {
        val = code - 48;
      } else {
        val = Infinity;
      }

      if (val >= radix) {
        if (this.options.errorRecovery && val <= 9) {
          val = 0;
          this.raise(this.state.start + i + 2, ErrorMessages.InvalidDigit, radix);
        } else if (forceLen) {
          val = 0;
          invalid = true;
        } else {
          break;
        }
      }

      ++this.state.pos;
      total = total * radix + val;
    }

    if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {
      return null;
    }

    return total;
  }

  readRadixNumber(radix) {
    const start = this.state.pos;
    let isBigInt = false;
    this.state.pos += 2;
    const val = this.readInt(radix);

    if (val == null) {
      this.raise(this.state.start + 2, ErrorMessages.InvalidDigit, radix);
    }

    const next = this.input.charCodeAt(this.state.pos);

    if (next === 95) {
      this.expectPlugin("numericSeparator", this.state.pos);
    }

    if (next === 110) {
      ++this.state.pos;
      isBigInt = true;
    }

    if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
      throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
    }

    if (isBigInt) {
      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
      this.finishToken(types.bigint, str);
      return;
    }

    this.finishToken(types.num, val);
  }

  readNumber(startsWithDot) {
    const start = this.state.pos;
    let isFloat = false;
    let isBigInt = false;
    let isNonOctalDecimalInt = false;

    if (!startsWithDot && this.readInt(10) === null) {
      this.raise(start, ErrorMessages.InvalidNumber);
    }

    let octal = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;

    if (octal) {
      if (this.state.strict) {
        this.raise(start, ErrorMessages.StrictOctalLiteral);
      }

      if (/[89]/.test(this.input.slice(start, this.state.pos))) {
        octal = false;
        isNonOctalDecimalInt = true;
      }
    }

    let next = this.input.charCodeAt(this.state.pos);

    if (next === 46 && !octal) {
      ++this.state.pos;
      this.readInt(10);
      isFloat = true;
      next = this.input.charCodeAt(this.state.pos);
    }

    if ((next === 69 || next === 101) && !octal) {
      next = this.input.charCodeAt(++this.state.pos);

      if (next === 43 || next === 45) {
        ++this.state.pos;
      }

      if (this.readInt(10) === null) this.raise(start, ErrorMessages.InvalidNumber);
      isFloat = true;
      next = this.input.charCodeAt(this.state.pos);
    }

    if (this.hasPlugin("numericSeparator") && (octal || isNonOctalDecimalInt)) {
      const underscorePos = this.input.slice(start, this.state.pos).indexOf("_");

      if (underscorePos > 0) {
        this.raise(underscorePos + start, ErrorMessages.ZeroDigitNumericSeparator);
      }
    }

    if (next === 95) {
      this.expectPlugin("numericSeparator", this.state.pos);
    }

    if (next === 110) {
      if (isFloat || octal || isNonOctalDecimalInt) {
        this.raise(start, ErrorMessages.InvalidBigIntLiteral);
      }

      ++this.state.pos;
      isBigInt = true;
    }

    if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
      throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
    }

    const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");

    if (isBigInt) {
      this.finishToken(types.bigint, str);
      return;
    }

    const val = octal ? parseInt(str, 8) : parseFloat(str);
    this.finishToken(types.num, val);
  }

  readCodePoint(throwOnInvalid) {
    const ch = this.input.charCodeAt(this.state.pos);
    let code;

    if (ch === 123) {
      const codePos = ++this.state.pos;
      code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, throwOnInvalid);
      ++this.state.pos;

      if (code !== null && code > 0x10ffff) {
        if (throwOnInvalid) {
          this.raise(codePos, ErrorMessages.InvalidCodePoint);
        } else {
          return null;
        }
      }
    } else {
      code = this.readHexChar(4, false, throwOnInvalid);
    }

    return code;
  }

  readString(quote) {
    let out = "",
        chunkStart = ++this.state.pos;

    for (;;) {
      if (this.state.pos >= this.length) {
        throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
      }

      const ch = this.input.charCodeAt(this.state.pos);
      if (ch === quote) break;

      if (ch === 92) {
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.state.pos;
      } else if (ch === 8232 || ch === 8233) {
        ++this.state.pos;
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
      } else if (isNewLine(ch)) {
        throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
      } else {
        ++this.state.pos;
      }
    }

    out += this.input.slice(chunkStart, this.state.pos++);
    this.finishToken(types.string, out);
  }

  readTmplToken() {
    let out = "",
        chunkStart = this.state.pos,
        containsInvalid = false;

    for (;;) {
      if (this.state.pos >= this.length) {
        throw this.raise(this.state.start, ErrorMessages.UnterminatedTemplate);
      }

      const ch = this.input.charCodeAt(this.state.pos);

      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
        if (this.state.pos === this.state.start && this.match(types.template)) {
          if (ch === 36) {
            this.state.pos += 2;
            this.finishToken(types.dollarBraceL);
            return;
          } else {
            ++this.state.pos;
            this.finishToken(types.backQuote);
            return;
          }
        }

        out += this.input.slice(chunkStart, this.state.pos);
        this.finishToken(types.template, containsInvalid ? null : out);
        return;
      }

      if (ch === 92) {
        out += this.input.slice(chunkStart, this.state.pos);
        const escaped = this.readEscapedChar(true);

        if (escaped === null) {
          containsInvalid = true;
        } else {
          out += escaped;
        }

        chunkStart = this.state.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.state.pos);
        ++this.state.pos;

        switch (ch) {
          case 13:
            if (this.input.charCodeAt(this.state.pos) === 10) {
              ++this.state.pos;
            }

          case 10:
            out += "\n";
            break;

          default:
            out += String.fromCharCode(ch);
            break;
        }

        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        chunkStart = this.state.pos;
      } else {
        ++this.state.pos;
      }
    }
  }

  readEscapedChar(inTemplate) {
    const throwOnInvalid = !inTemplate;
    const ch = this.input.charCodeAt(++this.state.pos);
    ++this.state.pos;

    switch (ch) {
      case 110:
        return "\n";

      case 114:
        return "\r";

      case 120:
        {
          const code = this.readHexChar(2, false, throwOnInvalid);
          return code === null ? null : String.fromCharCode(code);
        }

      case 117:
        {
          const code = this.readCodePoint(throwOnInvalid);
          return code === null ? null : String.fromCodePoint(code);
        }

      case 116:
        return "\t";

      case 98:
        return "\b";

      case 118:
        return "\u000b";

      case 102:
        return "\f";

      case 13:
        if (this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos;
        }

      case 10:
        this.state.lineStart = this.state.pos;
        ++this.state.curLine;

      case 8232:
      case 8233:
        return "";

      case 56:
      case 57:
        if (inTemplate) {
          return null;
        }

      default:
        if (ch >= 48 && ch <= 55) {
          const codePos = this.state.pos - 1;
          const match = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/);
          let octalStr = match[0];
          let octal = parseInt(octalStr, 8);

          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }

          this.state.pos += octalStr.length - 1;
          const next = this.input.charCodeAt(this.state.pos);

          if (octalStr !== "0" || next === 56 || next === 57) {
            if (inTemplate) {
              return null;
            } else if (this.state.strict) {
              this.raise(codePos, ErrorMessages.StrictOctalLiteral);
            } else {
              this.state.octalPositions.push(codePos);
            }
          }

          return String.fromCharCode(octal);
        }

        return String.fromCharCode(ch);
    }
  }

  readHexChar(len, forceLen, throwOnInvalid) {
    const codePos = this.state.pos;
    const n = this.readInt(16, len, forceLen, false);

    if (n === null) {
      if (throwOnInvalid) {
        this.raise(codePos, ErrorMessages.InvalidEscapeSequence);
      } else {
        this.state.pos = codePos - 1;
      }
    }

    return n;
  }

  readWord1() {
    let word = "";
    this.state.containsEsc = false;
    const start = this.state.pos;
    let chunkStart = this.state.pos;

    while (this.state.pos < this.length) {
      const ch = this.input.codePointAt(this.state.pos);

      if (isIdentifierChar(ch)) {
        this.state.pos += ch <= 0xffff ? 1 : 2;
      } else if (this.state.isIterator && ch === 64) {
        ++this.state.pos;
      } else if (ch === 92) {
        this.state.containsEsc = true;
        word += this.input.slice(chunkStart, this.state.pos);
        const escStart = this.state.pos;
        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;

        if (this.input.charCodeAt(++this.state.pos) !== 117) {
          this.raise(this.state.pos, ErrorMessages.MissingUnicodeEscape);
          continue;
        }

        ++this.state.pos;
        const esc = this.readCodePoint(true);

        if (esc !== null) {
          if (!identifierCheck(esc)) {
            this.raise(escStart, ErrorMessages.EscapedCharNotAnIdentifier);
          }

          word += String.fromCodePoint(esc);
        }

        chunkStart = this.state.pos;
      } else {
        break;
      }
    }

    return word + this.input.slice(chunkStart, this.state.pos);
  }

  isIterator(word) {
    return word === "@@iterator" || word === "@@asyncIterator";
  }

  readWord() {
    const word = this.readWord1();
    const type = keywords.get(word) || types.name;

    if (this.state.isIterator && (!this.isIterator(word) || !this.state.inType)) {
      this.raise(this.state.pos, ErrorMessages.InvalidIdentifier, word);
    }

    this.finishToken(type, word);
  }

  checkKeywordEscapes() {
    const kw = this.state.type.keyword;

    if (kw && this.state.containsEsc) {
      this.raise(this.state.start, ErrorMessages.InvalidEscapedReservedWord, kw);
    }
  }

  braceIsBlock(prevType) {
    const parent = this.curContext();

    if (parent === types$1.functionExpression || parent === types$1.functionStatement) {
      return true;
    }

    if (prevType === types.colon && (parent === types$1.braceStatement || parent === types$1.braceExpression)) {
      return !parent.isExpr;
    }

    if (prevType === types._return || prevType === types.name && this.state.exprAllowed) {
      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    }

    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {
      return true;
    }

    if (prevType === types.braceL) {
      return parent === types$1.braceStatement;
    }

    if (prevType === types._var || prevType === types._const || prevType === types.name) {
      return false;
    }

    if (prevType === types.relational) {
      return true;
    }

    return !this.state.exprAllowed;
  }

  updateContext(prevType) {
    const type = this.state.type;
    let update;

    if (type.keyword && (prevType === types.dot || prevType === types.questionDot)) {
      this.state.exprAllowed = false;
    } else if (update = type.updateContext) {
      update.call(this, prevType);
    } else {
      this.state.exprAllowed = type.beforeExpr;
    }
  }

}

class UtilParser extends Tokenizer {
  addExtra(node, key, val) {
    if (!node) return;
    const extra = node.extra = node.extra || {};
    extra[key] = val;
  }

  isRelational(op) {
    return this.match(types.relational) && this.state.value === op;
  }

  isLookaheadRelational(op) {
    const next = this.nextTokenStart();

    if (this.input.charAt(next) === op) {
      if (next + 1 === this.input.length) {
        return true;
      }

      const afterNext = this.input.charCodeAt(next + 1);
      return afterNext !== op.charCodeAt(0) && afterNext !== 61;
    }

    return false;
  }

  expectRelational(op) {
    if (this.isRelational(op)) {
      this.next();
    } else {
      this.unexpected(null, types.relational);
    }
  }

  isContextual(name) {
    return this.match(types.name) && this.state.value === name && !this.state.containsEsc;
  }

  isUnparsedContextual(nameStart, name) {
    const nameEnd = nameStart + name.length;
    return this.input.slice(nameStart, nameEnd) === name && (nameEnd === this.input.length || !isIdentifierChar(this.input.charCodeAt(nameEnd)));
  }

  isLookaheadContextual(name) {
    const next = this.nextTokenStart();
    return this.isUnparsedContextual(next, name);
  }

  eatContextual(name) {
    return this.isContextual(name) && this.eat(types.name);
  }

  expectContextual(name, message) {
    if (!this.eatContextual(name)) this.unexpected(null, message);
  }

  canInsertSemicolon() {
    return this.match(types.eof) || this.match(types.braceR) || this.hasPrecedingLineBreak();
  }

  hasPrecedingLineBreak() {
    return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
  }

  isLineTerminator() {
    return this.eat(types.semi) || this.canInsertSemicolon();
  }

  semicolon() {
    if (!this.isLineTerminator()) this.unexpected(null, types.semi);
  }

  expect(type, pos) {
    this.eat(type) || this.unexpected(pos, type);
  }

  assertNoSpace(message = "Unexpected space.") {
    if (this.state.start > this.state.lastTokEnd) {
      this.raise(this.state.lastTokEnd, message);
    }
  }

  unexpected(pos, messageOrType = "Unexpected token") {
    if (typeof messageOrType !== "string") {
      messageOrType = `Unexpected token, expected "${messageOrType.label}"`;
    }

    throw this.raise(pos != null ? pos : this.state.start, messageOrType);
  }

  expectPlugin(name, pos) {
    if (!this.hasPlugin(name)) {
      throw this.raiseWithData(pos != null ? pos : this.state.start, {
        missingPlugin: [name]
      }, `This experimental syntax requires enabling the parser plugin: '${name}'`);
    }

    return true;
  }

  expectOnePlugin(names, pos) {
    if (!names.some(n => this.hasPlugin(n))) {
      throw this.raiseWithData(pos != null ? pos : this.state.start, {
        missingPlugin: names
      }, `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(", ")}'`);
    }
  }

  checkYieldAwaitInDefaultParams() {
    if (this.state.yieldPos !== -1 && (this.state.awaitPos === -1 || this.state.yieldPos < this.state.awaitPos)) {
      this.raise(this.state.yieldPos, ErrorMessages.YieldBindingIdentifier);
    }

    if (this.state.awaitPos !== -1) {
      this.raise(this.state.awaitPos, ErrorMessages.AwaitBindingIdentifier);
    }
  }

  tryParse(fn, oldState = this.state.clone()) {
    const abortSignal = {
      node: null
    };

    try {
      const node = fn((node = null) => {
        abortSignal.node = node;
        throw abortSignal;
      });

      if (this.state.errors.length > oldState.errors.length) {
        const failState = this.state;
        this.state = oldState;
        return {
          node,
          error: failState.errors[oldState.errors.length],
          thrown: false,
          aborted: false,
          failState
        };
      }

      return {
        node,
        error: null,
        thrown: false,
        aborted: false,
        failState: null
      };
    } catch (error) {
      const failState = this.state;
      this.state = oldState;

      if (error instanceof SyntaxError) {
        return {
          node: null,
          error,
          thrown: true,
          aborted: false,
          failState
        };
      }

      if (error === abortSignal) {
        return {
          node: abortSignal.node,
          error: null,
          thrown: false,
          aborted: true,
          failState
        };
      }

      throw error;
    }
  }

  checkExpressionErrors(refExpressionErrors, andThrow) {
    if (!refExpressionErrors) return false;
    const {
      shorthandAssign,
      doubleProto
    } = refExpressionErrors;
    if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;

    if (shorthandAssign >= 0) {
      this.unexpected(shorthandAssign);
    }

    if (doubleProto >= 0) {
      this.raise(doubleProto, ErrorMessages.DuplicateProto);
    }
  }

  isLiteralPropertyName() {
    return this.match(types.name) || !!this.state.type.keyword || this.match(types.string) || this.match(types.num) || this.match(types.bigint);
  }

}
class ExpressionErrors {
  constructor() {
    this.shorthandAssign = -1;
    this.doubleProto = -1;
  }

}

class Node {
  constructor(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    this.loc = new SourceLocation(loc);
    if (parser == null ? void 0 : parser.options.ranges) this.range = [pos, 0];
    if (parser == null ? void 0 : parser.filename) this.loc.filename = parser.filename;
  }

  __clone() {
    const newNode = new Node();
    const keys = Object.keys(this);

    for (let i = 0, length = keys.length; i < length; i++) {
      const key = keys[i];

      if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
        newNode[key] = this[key];
      }
    }

    return newNode;
  }

}

class NodeUtils extends UtilParser {
  startNode() {
    return new Node(this, this.state.start, this.state.startLoc);
  }

  startNodeAt(pos, loc) {
    return new Node(this, pos, loc);
  }

  startNodeAtNode(type) {
    return this.startNodeAt(type.start, type.loc.start);
  }

  finishNode(node, type) {
    return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
  }

  finishNodeAt(node, type, pos, loc) {

    node.type = type;
    node.end = pos;
    node.loc.end = loc;
    if (this.options.ranges) node.range[1] = pos;
    this.processComment(node);
    return node;
  }

  resetStartLocation(node, start, startLoc) {
    node.start = start;
    node.loc.start = startLoc;
    if (this.options.ranges) node.range[0] = start;
  }

  resetEndLocation(node, end = this.state.lastTokEnd, endLoc = this.state.lastTokEndLoc) {
    node.end = end;
    node.loc.end = endLoc;
    if (this.options.ranges) node.range[1] = end;
  }

  resetStartLocationFromNode(node, locationNode) {
    this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
  }

}

const unwrapParenthesizedExpression = node => {
  return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
};

class LValParser extends NodeUtils {
  toAssignable(node) {
    var _node$extra, _node$extra3;

    let parenthesized = undefined;

    if (node.type === "ParenthesizedExpression" || ((_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized)) {
      parenthesized = unwrapParenthesizedExpression(node);

      if (parenthesized.type !== "Identifier" && parenthesized.type !== "MemberExpression") {
        this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);
      }
    }

    switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
        break;

      case "ObjectExpression":
        node.type = "ObjectPattern";

        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
          var _node$extra2;

          const prop = node.properties[i];
          const isLast = i === last;
          this.toAssignableObjectExpressionProp(prop, isLast);

          if (isLast && prop.type === "RestElement" && ((_node$extra2 = node.extra) == null ? void 0 : _node$extra2.trailingComma)) {
            this.raiseRestNotLast(node.extra.trailingComma);
          }
        }

        break;

      case "ObjectProperty":
        this.toAssignable(node.value);
        break;

      case "SpreadElement":
        {
          this.checkToRestConversion(node);
          node.type = "RestElement";
          const arg = node.argument;
          this.toAssignable(arg);
          break;
        }

      case "ArrayExpression":
        node.type = "ArrayPattern";
        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingComma);
        break;

      case "AssignmentExpression":
        if (node.operator !== "=") {
          this.raise(node.left.end, ErrorMessages.MissingEqInAssignment);
        }

        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left);
        break;

      case "ParenthesizedExpression":
        this.toAssignable(parenthesized);
        break;
    }

    return node;
  }

  toAssignableObjectExpressionProp(prop, isLast) {
    if (prop.type === "ObjectMethod") {
      const error = prop.kind === "get" || prop.kind === "set" ? ErrorMessages.PatternHasAccessor : ErrorMessages.PatternHasMethod;
      this.raise(prop.key.start, error);
    } else if (prop.type === "SpreadElement" && !isLast) {
      this.raiseRestNotLast(prop.start);
    } else {
      this.toAssignable(prop);
    }
  }

  toAssignableList(exprList, trailingCommaPos) {
    let end = exprList.length;

    if (end) {
      const last = exprList[end - 1];

      if ((last == null ? void 0 : last.type) === "RestElement") {
        --end;
      } else if ((last == null ? void 0 : last.type) === "SpreadElement") {
        last.type = "RestElement";
        const arg = last.argument;
        this.toAssignable(arg);

        if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern") {
          this.unexpected(arg.start);
        }

        if (trailingCommaPos) {
          this.raiseTrailingCommaAfterRest(trailingCommaPos);
        }

        --end;
      }
    }

    for (let i = 0; i < end; i++) {
      const elt = exprList[i];

      if (elt) {
        this.toAssignable(elt);

        if (elt.type === "RestElement") {
          this.raiseRestNotLast(elt.start);
        }
      }
    }

    return exprList;
  }

  toReferencedList(exprList, isParenthesizedExpr) {
    return exprList;
  }

  toReferencedListDeep(exprList, isParenthesizedExpr) {
    this.toReferencedList(exprList, isParenthesizedExpr);

    for (let _i = 0; _i < exprList.length; _i++) {
      const expr = exprList[_i];

      if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
        this.toReferencedListDeep(expr.elements);
      }
    }
  }

  parseSpread(refExpressionErrors, refNeedsArrowPos) {
    const node = this.startNode();
    this.next();
    node.argument = this.parseMaybeAssign(false, refExpressionErrors, undefined, refNeedsArrowPos);
    return this.finishNode(node, "SpreadElement");
  }

  parseRestBinding() {
    const node = this.startNode();
    this.next();
    node.argument = this.parseBindingAtom();
    return this.finishNode(node, "RestElement");
  }

  parseBindingAtom() {
    switch (this.state.type) {
      case types.bracketL:
        {
          const node = this.startNode();
          this.next();
          node.elements = this.parseBindingList(types.bracketR, 93, true);
          return this.finishNode(node, "ArrayPattern");
        }

      case types.braceL:
        return this.parseObj(types.braceR, true);
    }

    return this.parseIdentifier();
  }

  parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
    const elts = [];
    let first = true;

    while (!this.eat(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(types.comma);
      }

      if (allowEmpty && this.match(types.comma)) {
        elts.push(null);
      } else if (this.eat(close)) {
        break;
      } else if (this.match(types.ellipsis)) {
        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
        this.checkCommaAfterRest(closeCharCode);
        this.expect(close);
        break;
      } else {
        const decorators = [];

        if (this.match(types.at) && this.hasPlugin("decorators")) {
          this.raise(this.state.start, ErrorMessages.UnsupportedParameterDecorator);
        }

        while (this.match(types.at)) {
          decorators.push(this.parseDecorator());
        }

        elts.push(this.parseAssignableListItem(allowModifiers, decorators));
      }
    }

    return elts;
  }

  parseAssignableListItem(allowModifiers, decorators) {
    const left = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(left);
    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);

    if (decorators.length) {
      left.decorators = decorators;
    }

    return elt;
  }

  parseAssignableListItemTypes(param) {
    return param;
  }

  parseMaybeDefault(startPos, startLoc, left) {
    startLoc = startLoc || this.state.startLoc;
    startPos = startPos || this.state.start;
    left = left || this.parseBindingAtom();
    if (!this.eat(types.eq)) return left;
    const node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.right = this.parseMaybeAssign();
    return this.finishNode(node, "AssignmentPattern");
  }

  checkLVal(expr, bindingType = BIND_NONE, checkClashes, contextDescription, disallowLetBinding, strictModeChanged = false) {
    switch (expr.type) {
      case "Identifier":
        if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(expr.name, this.inModule) : isStrictBindOnlyReservedWord(expr.name))) {
          this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.StrictEvalArguments : ErrorMessages.StrictEvalArgumentsBinding, expr.name);
        }

        if (checkClashes) {
          const key = `_${expr.name}`;

          if (checkClashes[key]) {
            this.raise(expr.start, ErrorMessages.ParamDupe);
          } else {
            checkClashes[key] = true;
          }
        }

        if (disallowLetBinding && expr.name === "let") {
          this.raise(expr.start, ErrorMessages.LetInLexicalBinding);
        }

        if (!(bindingType & BIND_NONE)) {
          this.scope.declareName(expr.name, bindingType, expr.start);
        }

        break;

      case "MemberExpression":
        if (bindingType !== BIND_NONE) {
          this.raise(expr.start, ErrorMessages.InvalidPropertyBindingPattern);
        }

        break;

      case "ObjectPattern":
        for (let _i2 = 0, _expr$properties = expr.properties; _i2 < _expr$properties.length; _i2++) {
          let prop = _expr$properties[_i2];
          if (prop.type === "ObjectProperty") prop = prop.value;else if (prop.type === "ObjectMethod") continue;
          this.checkLVal(prop, bindingType, checkClashes, "object destructuring pattern", disallowLetBinding);
        }

        break;

      case "ArrayPattern":
        for (let _i3 = 0, _expr$elements = expr.elements; _i3 < _expr$elements.length; _i3++) {
          const elem = _expr$elements[_i3];

          if (elem) {
            this.checkLVal(elem, bindingType, checkClashes, "array destructuring pattern", disallowLetBinding);
          }
        }

        break;

      case "AssignmentPattern":
        this.checkLVal(expr.left, bindingType, checkClashes, "assignment pattern");
        break;

      case "RestElement":
        this.checkLVal(expr.argument, bindingType, checkClashes, "rest element");
        break;

      case "ParenthesizedExpression":
        this.checkLVal(expr.expression, bindingType, checkClashes, "parenthesized expression");
        break;

      default:
        {
          this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.InvalidLhs : ErrorMessages.InvalidLhsBinding, contextDescription);
        }
    }
  }

  checkToRestConversion(node) {
    if (node.argument.type !== "Identifier" && node.argument.type !== "MemberExpression") {
      this.raise(node.argument.start, ErrorMessages.InvalidRestAssignmentPattern);
    }
  }

  checkCommaAfterRest(close) {
    if (this.match(types.comma)) {
      if (this.lookaheadCharCode() === close) {
        this.raiseTrailingCommaAfterRest(this.state.start);
      } else {
        this.raiseRestNotLast(this.state.start);
      }
    }
  }

  raiseRestNotLast(pos) {
    throw this.raise(pos, ErrorMessages.ElementAfterRest);
  }

  raiseTrailingCommaAfterRest(pos) {
    this.raise(pos, ErrorMessages.RestTrailingComma);
  }

}

class ExpressionParser extends LValParser {
  checkProto(prop, isRecord, protoRef, refExpressionErrors) {
    if (prop.type === "SpreadElement" || prop.type === "ObjectMethod" || prop.computed || prop.shorthand) {
      return;
    }

    const key = prop.key;
    const name = key.type === "Identifier" ? key.name : key.value;

    if (name === "__proto__") {
      if (isRecord) {
        this.raise(key.start, ErrorMessages.RecordNoProto);
        return;
      }

      if (protoRef.used) {
        if (refExpressionErrors) {
          if (refExpressionErrors.doubleProto === -1) {
            refExpressionErrors.doubleProto = key.start;
          }
        } else {
          this.raise(key.start, ErrorMessages.DuplicateProto);
        }
      }

      protoRef.used = true;
    }
  }

  getExpression() {
    let paramFlags = PARAM;

    if (this.hasPlugin("topLevelAwait") && this.inModule) {
      paramFlags |= PARAM_AWAIT;
    }

    this.scope.enter(SCOPE_PROGRAM);
    this.prodParam.enter(paramFlags);
    this.nextToken();
    const expr = this.parseExpression();

    if (!this.match(types.eof)) {
      this.unexpected();
    }

    expr.comments = this.state.comments;
    expr.errors = this.state.errors;
    return expr;
  }

  parseExpression(noIn, refExpressionErrors) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const expr = this.parseMaybeAssign(noIn, refExpressionErrors);

    if (this.match(types.comma)) {
      const node = this.startNodeAt(startPos, startLoc);
      node.expressions = [expr];

      while (this.eat(types.comma)) {
        node.expressions.push(this.parseMaybeAssign(noIn, refExpressionErrors));
      }

      this.toReferencedList(node.expressions);
      return this.finishNode(node, "SequenceExpression");
    }

    return expr;
  }

  parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;

    if (this.isContextual("yield")) {
      if (this.prodParam.hasYield) {
        let left = this.parseYield(noIn);

        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }

        return left;
      } else {
        this.state.exprAllowed = false;
      }
    }

    let ownExpressionErrors;

    if (refExpressionErrors) {
      ownExpressionErrors = false;
    } else {
      refExpressionErrors = new ExpressionErrors();
      ownExpressionErrors = true;
    }

    if (this.match(types.parenL) || this.match(types.name)) {
      this.state.potentialArrowAt = this.state.start;
    }

    let left = this.parseMaybeConditional(noIn, refExpressionErrors, refNeedsArrowPos);

    if (afterLeftParse) {
      left = afterLeftParse.call(this, left, startPos, startLoc);
    }

    if (this.state.type.isAssign) {
      const node = this.startNodeAt(startPos, startLoc);
      const operator = this.state.value;
      node.operator = operator;

      if (operator === "??=") {
        this.expectPlugin("logicalAssignment");
      }

      if (operator === "||=" || operator === "&&=") {
        this.expectPlugin("logicalAssignment");
      }

      if (this.match(types.eq)) {
        node.left = this.toAssignable(left);
        refExpressionErrors.doubleProto = -1;
      } else {
        node.left = left;
      }

      if (refExpressionErrors.shorthandAssign >= node.left.start) {
        refExpressionErrors.shorthandAssign = -1;
      }

      this.checkLVal(left, undefined, undefined, "assignment expression");
      this.next();
      node.right = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "AssignmentExpression");
    } else if (ownExpressionErrors) {
      this.checkExpressionErrors(refExpressionErrors, true);
    }

    return left;
  }

  parseMaybeConditional(noIn, refExpressionErrors, refNeedsArrowPos) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const potentialArrowAt = this.state.potentialArrowAt;
    const expr = this.parseExprOps(noIn, refExpressionErrors);

    if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
      return expr;
    }

    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;
    return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);
  }

  parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
    if (this.eat(types.question)) {
      const node = this.startNodeAt(startPos, startLoc);
      node.test = expr;
      node.consequent = this.parseMaybeAssign();
      this.expect(types.colon);
      node.alternate = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "ConditionalExpression");
    }

    return expr;
  }

  parseExprOps(noIn, refExpressionErrors) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const potentialArrowAt = this.state.potentialArrowAt;
    const expr = this.parseMaybeUnary(refExpressionErrors);

    if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
      return expr;
    }

    if (this.checkExpressionErrors(refExpressionErrors, false)) {
      return expr;
    }

    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
  }

  parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {
    let prec = this.state.type.binop;

    if (prec != null && (!noIn || !this.match(types._in))) {
      if (prec > minPrec) {
        const operator = this.state.value;

        if (operator === "|>" && this.state.inFSharpPipelineDirectBody) {
          return left;
        }

        const node = this.startNodeAt(leftStartPos, leftStartLoc);
        node.left = left;
        node.operator = operator;

        if (operator === "**" && left.type === "UnaryExpression" && (this.options.createParenthesizedExpressions || !(left.extra && left.extra.parenthesized))) {
          this.raise(left.argument.start, ErrorMessages.UnexpectedTokenUnaryExponentiation);
        }

        const op = this.state.type;
        const logical = op === types.logicalOR || op === types.logicalAND;
        const coalesce = op === types.nullishCoalescing;

        if (op === types.pipeline) {
          this.expectPlugin("pipelineOperator");
          this.state.inPipeline = true;
          this.checkPipelineAtInfixOperator(left, leftStartPos);
        } else if (coalesce) {
          prec = types.logicalAND.binop;
        }

        this.next();

        if (op === types.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal") {
          if (this.match(types.name) && this.state.value === "await" && this.prodParam.hasAwait) {
            throw this.raise(this.state.start, ErrorMessages.UnexpectedAwaitAfterPipelineBody);
          }
        }

        node.right = this.parseExprOpRightExpr(op, prec, noIn);
        this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
        const nextOp = this.state.type;

        if (coalesce && (nextOp === types.logicalOR || nextOp === types.logicalAND) || logical && nextOp === types.nullishCoalescing) {
          throw this.raise(this.state.start, ErrorMessages.MixingCoalesceWithLogical);
        }

        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
      }
    }

    return left;
  }

  parseExprOpRightExpr(op, prec, noIn) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;

    switch (op) {
      case types.pipeline:
        switch (this.getPluginOption("pipelineOperator", "proposal")) {
          case "smart":
            return this.withTopicPermittingContext(() => {
              return this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(op, prec, noIn), startPos, startLoc);
            });

          case "fsharp":
            return this.withSoloAwaitPermittingContext(() => {
              return this.parseFSharpPipelineBody(prec, noIn);
            });
        }

      default:
        return this.parseExprOpBaseRightExpr(op, prec, noIn);
    }
  }

  parseExprOpBaseRightExpr(op, prec, noIn) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);
  }

  parseMaybeUnary(refExpressionErrors) {
    if (this.isContextual("await") && this.isAwaitAllowed()) {
      return this.parseAwait();
    } else if (this.state.type.prefix) {
      const node = this.startNode();
      const update = this.match(types.incDec);
      node.operator = this.state.value;
      node.prefix = true;

      if (node.operator === "throw") {
        this.expectPlugin("throwExpressions");
      }

      this.next();
      node.argument = this.parseMaybeUnary();
      this.checkExpressionErrors(refExpressionErrors, true);

      if (update) {
        this.checkLVal(node.argument, undefined, undefined, "prefix operation");
      } else if (this.state.strict && node.operator === "delete") {
        const arg = node.argument;

        if (arg.type === "Identifier") {
          this.raise(node.start, ErrorMessages.StrictDelete);
        } else if ((arg.type === "MemberExpression" || arg.type === "OptionalMemberExpression") && arg.property.type === "PrivateName") {
          this.raise(node.start, ErrorMessages.DeletePrivateField);
        }
      }

      return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    }

    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    let expr = this.parseExprSubscripts(refExpressionErrors);
    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;

    while (this.state.type.postfix && !this.canInsertSemicolon()) {
      const node = this.startNodeAt(startPos, startLoc);
      node.operator = this.state.value;
      node.prefix = false;
      node.argument = expr;
      this.checkLVal(expr, undefined, undefined, "postfix operation");
      this.next();
      expr = this.finishNode(node, "UpdateExpression");
    }

    return expr;
  }

  parseExprSubscripts(refExpressionErrors) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const potentialArrowAt = this.state.potentialArrowAt;
    const expr = this.parseExprAtom(refExpressionErrors);

    if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
      return expr;
    }

    return this.parseSubscripts(expr, startPos, startLoc);
  }

  parseSubscripts(base, startPos, startLoc, noCalls) {
    const state = {
      optionalChainMember: false,
      maybeAsyncArrow: this.atPossibleAsyncArrow(base),
      stop: false
    };

    do {
      const oldMaybeInAsyncArrowHead = this.state.maybeInAsyncArrowHead;

      if (state.maybeAsyncArrow) {
        this.state.maybeInAsyncArrowHead = true;
      }

      base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
      state.maybeAsyncArrow = false;
      this.state.maybeInAsyncArrowHead = oldMaybeInAsyncArrowHead;
    } while (!state.stop);

    return base;
  }

  parseSubscript(base, startPos, startLoc, noCalls, state) {
    if (!noCalls && this.eat(types.doubleColon)) {
      const node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.callee = this.parseNoCallExpr();
      state.stop = true;
      return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
    }

    let optional = false;

    if (this.match(types.questionDot)) {
      state.optionalChainMember = optional = true;

      if (noCalls && this.lookaheadCharCode() === 40) {
        state.stop = true;
        return base;
      }

      this.next();
    }

    const computed = this.eat(types.bracketL);

    if (optional && !this.match(types.parenL) && !this.match(types.backQuote) || computed || this.eat(types.dot)) {
      const node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = computed ? this.parseExpression() : this.parseMaybePrivateName(true);
      node.computed = computed;

      if (node.property.type === "PrivateName") {
        if (node.object.type === "Super") {
          this.raise(startPos, ErrorMessages.SuperPrivateField);
        }

        this.classScope.usePrivateName(node.property.id.name, node.property.start);
      }

      if (computed) {
        this.expect(types.bracketR);
      }

      if (state.optionalChainMember) {
        node.optional = optional;
        return this.finishNode(node, "OptionalMemberExpression");
      } else {
        return this.finishNode(node, "MemberExpression");
      }
    } else if (!noCalls && this.match(types.parenL)) {
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      const oldYieldPos = this.state.yieldPos;
      const oldAwaitPos = this.state.awaitPos;
      this.state.maybeInArrowParameters = true;
      this.state.yieldPos = -1;
      this.state.awaitPos = -1;
      this.next();
      let node = this.startNodeAt(startPos, startLoc);
      node.callee = base;

      if (state.optionalChainMember) {
        node.optional = optional;
      }

      if (optional) {
        node.arguments = this.parseCallExpressionArguments(types.parenR, false);
      } else {
        node.arguments = this.parseCallExpressionArguments(types.parenR, state.maybeAsyncArrow, base.type === "Import", base.type !== "Super", node);
      }

      this.finishCallExpression(node, state.optionalChainMember);

      if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
        state.stop = true;
        node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node);
        this.checkYieldAwaitInDefaultParams();
        this.state.yieldPos = oldYieldPos;
        this.state.awaitPos = oldAwaitPos;
      } else {
        this.toReferencedListDeep(node.arguments);
        if (oldYieldPos !== -1) this.state.yieldPos = oldYieldPos;

        if (!this.isAwaitAllowed() && !oldMaybeInArrowParameters || oldAwaitPos !== -1) {
          this.state.awaitPos = oldAwaitPos;
        }
      }

      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return node;
    } else if (this.match(types.backQuote)) {
      return this.parseTaggedTemplateExpression(startPos, startLoc, base, state);
    } else {
      state.stop = true;
      return base;
    }
  }

  parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments) {
    const node = this.startNodeAt(startPos, startLoc);
    node.tag = base;
    node.quasi = this.parseTemplate(true);
    if (typeArguments) node.typeParameters = typeArguments;

    if (state.optionalChainMember) {
      this.raise(startPos, ErrorMessages.OptionalChainingNoTemplate);
    }

    return this.finishNode(node, "TaggedTemplateExpression");
  }

  atPossibleAsyncArrow(base) {
    return base.type === "Identifier" && base.name === "async" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
  }

  finishCallExpression(node, optional) {
    if (node.callee.type === "Import") {
      if (node.arguments.length === 2) {
        this.expectPlugin("moduleAttributes");
      }

      if (node.arguments.length === 0 || node.arguments.length > 2) {
        this.raise(node.start, ErrorMessages.ImportCallArity, this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
      } else {
        for (let _i = 0, _node$arguments = node.arguments; _i < _node$arguments.length; _i++) {
          const arg = _node$arguments[_i];

          if (arg.type === "SpreadElement") {
            this.raise(arg.start, ErrorMessages.ImportCallSpreadArgument);
          }
        }
      }
    }

    return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
  }

  parseCallExpressionArguments(close, possibleAsyncArrow, dynamicImport, allowPlaceholder, nodeForExtra) {
    const elts = [];
    let innerParenStart;
    let first = true;
    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = false;

    while (!this.eat(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(types.comma);

        if (this.match(close)) {
          if (dynamicImport && !this.hasPlugin("moduleAttributes")) {
            this.raise(this.state.lastTokStart, ErrorMessages.ImportCallArgumentTrailingComma);
          }

          if (nodeForExtra) {
            this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
          }

          this.next();
          break;
        }
      }

      if (this.match(types.parenL) && !innerParenStart) {
        innerParenStart = this.state.start;
      }

      elts.push(this.parseExprListItem(false, possibleAsyncArrow ? new ExpressionErrors() : undefined, possibleAsyncArrow ? {
        start: 0
      } : undefined, allowPlaceholder));
    }

    if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {
      this.unexpected();
    }

    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
    return elts;
  }

  shouldParseAsyncArrow() {
    return this.match(types.arrow) && !this.canInsertSemicolon();
  }

  parseAsyncArrowFromCallExpression(node, call) {
    var _call$extra;

    this.expect(types.arrow);
    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);
    return node;
  }

  parseNoCallExpr() {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  }

  parseExprAtom(refExpressionErrors) {
    if (this.state.type === types.slash) this.readRegexp();
    const canBeArrow = this.state.potentialArrowAt === this.state.start;
    let node;

    switch (this.state.type) {
      case types._super:
        node = this.startNode();
        this.next();

        if (this.match(types.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
          this.raise(node.start, ErrorMessages.SuperNotAllowed);
        } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
          this.raise(node.start, ErrorMessages.UnexpectedSuper);
        }

        if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {
          this.raise(node.start, ErrorMessages.UnsupportedSuper);
        }

        return this.finishNode(node, "Super");

      case types._import:
        node = this.startNode();
        this.next();

        if (this.match(types.dot)) {
          return this.parseImportMetaProperty(node);
        }

        if (!this.match(types.parenL)) {
          this.raise(this.state.lastTokStart, ErrorMessages.UnsupportedImport);
        }

        return this.finishNode(node, "Import");

      case types._this:
        node = this.startNode();
        this.next();
        return this.finishNode(node, "ThisExpression");

      case types.name:
        {
          node = this.startNode();
          const containsEsc = this.state.containsEsc;
          const id = this.parseIdentifier();

          if (!containsEsc && id.name === "async" && this.match(types._function) && !this.canInsertSemicolon()) {
            const last = this.state.context.length - 1;

            if (this.state.context[last] !== types$1.functionStatement) {
              throw new Error("Internal error");
            }

            this.state.context[last] = types$1.functionExpression;
            this.next();
            return this.parseFunction(node, undefined, true);
          } else if (canBeArrow && !containsEsc && id.name === "async" && this.match(types.name) && !this.canInsertSemicolon()) {
            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            const oldMaybeInAsyncArrowHead = this.state.maybeInAsyncArrowHead;
            const oldYieldPos = this.state.yieldPos;
            const oldAwaitPos = this.state.awaitPos;
            this.state.maybeInArrowParameters = true;
            this.state.maybeInAsyncArrowHead = true;
            this.state.yieldPos = -1;
            this.state.awaitPos = -1;
            const params = [this.parseIdentifier()];
            this.expect(types.arrow);
            this.checkYieldAwaitInDefaultParams();
            this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
            this.state.maybeInAsyncArrowHead = oldMaybeInAsyncArrowHead;
            this.state.yieldPos = oldYieldPos;
            this.state.awaitPos = oldAwaitPos;
            this.parseArrowExpression(node, params, true);
            return node;
          }

          if (canBeArrow && this.match(types.arrow) && !this.canInsertSemicolon()) {
            this.next();
            this.parseArrowExpression(node, [id], false);
            return node;
          }

          return id;
        }

      case types._do:
        {
          this.expectPlugin("doExpressions");
          const node = this.startNode();
          this.next();
          const oldLabels = this.state.labels;
          this.state.labels = [];
          node.body = this.parseBlock();
          this.state.labels = oldLabels;
          return this.finishNode(node, "DoExpression");
        }

      case types.regexp:
        {
          const value = this.state.value;
          node = this.parseLiteral(value.value, "RegExpLiteral");
          node.pattern = value.pattern;
          node.flags = value.flags;
          return node;
        }

      case types.num:
        return this.parseLiteral(this.state.value, "NumericLiteral");

      case types.bigint:
        return this.parseLiteral(this.state.value, "BigIntLiteral");

      case types.string:
        return this.parseLiteral(this.state.value, "StringLiteral");

      case types._null:
        node = this.startNode();
        this.next();
        return this.finishNode(node, "NullLiteral");

      case types._true:
      case types._false:
        return this.parseBooleanLiteral();

      case types.parenL:
        return this.parseParenAndDistinguishExpression(canBeArrow);

      case types.bracketBarL:
      case types.bracketHashL:
        {
          this.expectPlugin("recordAndTuple");
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          const close = this.state.type === types.bracketBarL ? types.bracketBarR : types.bracketR;
          this.state.inFSharpPipelineDirectBody = false;
          node = this.startNode();
          this.next();
          node.elements = this.parseExprList(close, false, refExpressionErrors, node);
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return this.finishNode(node, "TupleExpression");
        }

      case types.bracketL:
        {
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          node = this.startNode();
          this.next();
          node.elements = this.parseExprList(types.bracketR, true, refExpressionErrors, node);

          if (!this.state.maybeInArrowParameters) {
            this.toReferencedList(node.elements);
          }

          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return this.finishNode(node, "ArrayExpression");
        }

      case types.braceBarL:
      case types.braceHashL:
        {
          this.expectPlugin("recordAndTuple");
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          const close = this.state.type === types.braceBarL ? types.braceBarR : types.braceR;
          this.state.inFSharpPipelineDirectBody = false;
          const ret = this.parseObj(close, false, true, refExpressionErrors);
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return ret;
        }

      case types.braceL:
        {
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          const ret = this.parseObj(types.braceR, false, false, refExpressionErrors);
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return ret;
        }

      case types._function:
        return this.parseFunctionExpression();

      case types.at:
        this.parseDecorators();

      case types._class:
        node = this.startNode();
        this.takeDecorators(node);
        return this.parseClass(node, false);

      case types._new:
        return this.parseNew();

      case types.backQuote:
        return this.parseTemplate(false);

      case types.doubleColon:
        {
          node = this.startNode();
          this.next();
          node.object = null;
          const callee = node.callee = this.parseNoCallExpr();

          if (callee.type === "MemberExpression") {
            return this.finishNode(node, "BindExpression");
          } else {
            throw this.raise(callee.start, ErrorMessages.UnsupportedBind);
          }
        }

      case types.hash:
        {
          if (this.state.inPipeline) {
            node = this.startNode();

            if (this.getPluginOption("pipelineOperator", "proposal") !== "smart") {
              this.raise(node.start, ErrorMessages.PrimaryTopicRequiresSmartPipeline);
            }

            this.next();

            if (!this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {
              this.raise(node.start, ErrorMessages.PrimaryTopicNotAllowed);
            }

            this.registerTopicReference();
            return this.finishNode(node, "PipelinePrimaryTopicReference");
          }

          const nextCh = this.input.codePointAt(this.state.end);

          if (isIdentifierStart(nextCh) || nextCh === 92) {
            const start = this.state.start;
            node = this.parseMaybePrivateName(true);

            if (this.match(types._in)) {
              this.expectPlugin("privateIn");
              this.classScope.usePrivateName(node.id.name, node.start);
            } else if (this.hasPlugin("privateIn")) {
              this.raise(this.state.start, ErrorMessages.PrivateInExpectedIn, node.id.name);
            } else {
              throw this.unexpected(start);
            }

            return node;
          }
        }

      case types.relational:
        {
          if (this.state.value === "<") {
            const lookaheadCh = this.input.codePointAt(this.nextTokenStart());

            if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
                this.expectOnePlugin(["jsx", "flow", "typescript"]);
              }
          }
        }

      default:
        throw this.unexpected();
    }
  }

  parseBooleanLiteral() {
    const node = this.startNode();
    node.value = this.match(types._true);
    this.next();
    return this.finishNode(node, "BooleanLiteral");
  }

  parseMaybePrivateName(isPrivateNameAllowed) {
    const isPrivate = this.match(types.hash);

    if (isPrivate) {
      this.expectOnePlugin(["classPrivateProperties", "classPrivateMethods"]);

      if (!isPrivateNameAllowed) {
        this.raise(this.state.pos, ErrorMessages.UnexpectedPrivateField);
      }

      const node = this.startNode();
      this.next();
      this.assertNoSpace("Unexpected space between # and identifier");
      node.id = this.parseIdentifier(true);
      return this.finishNode(node, "PrivateName");
    } else {
      return this.parseIdentifier(true);
    }
  }

  parseFunctionExpression() {
    const node = this.startNode();
    let meta = this.startNode();
    this.next();
    meta = this.createIdentifier(meta, "function");

    if (this.prodParam.hasYield && this.eat(types.dot)) {
      return this.parseMetaProperty(node, meta, "sent");
    }

    return this.parseFunction(node);
  }

  parseMetaProperty(node, meta, propertyName) {
    node.meta = meta;

    if (meta.name === "function" && propertyName === "sent") {
      if (this.isContextual(propertyName)) {
        this.expectPlugin("functionSent");
      } else if (!this.hasPlugin("functionSent")) {
        this.unexpected();
      }
    }

    const containsEsc = this.state.containsEsc;
    node.property = this.parseIdentifier(true);

    if (node.property.name !== propertyName || containsEsc) {
      this.raise(node.property.start, ErrorMessages.UnsupportedMetaProperty, meta.name, propertyName);
    }

    return this.finishNode(node, "MetaProperty");
  }

  parseImportMetaProperty(node) {
    const id = this.createIdentifier(this.startNodeAtNode(node), "import");
    this.expect(types.dot);

    if (this.isContextual("meta")) {
      if (!this.inModule) {
        this.raiseWithData(id.start, {
          code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
        }, ErrorMessages.ImportMetaOutsideModule);
      }

      this.sawUnambiguousESM = true;
    }

    return this.parseMetaProperty(node, id, "meta");
  }

  parseLiteral(value, type, startPos, startLoc) {
    startPos = startPos || this.state.start;
    startLoc = startLoc || this.state.startLoc;
    const node = this.startNodeAt(startPos, startLoc);
    this.addExtra(node, "rawValue", value);
    this.addExtra(node, "raw", this.input.slice(startPos, this.state.end));
    node.value = value;
    this.next();
    return this.finishNode(node, type);
  }

  parseParenAndDistinguishExpression(canBeArrow) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    let val;
    this.expect(types.parenL);
    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
    const oldYieldPos = this.state.yieldPos;
    const oldAwaitPos = this.state.awaitPos;
    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
    this.state.maybeInArrowParameters = true;
    this.state.yieldPos = -1;
    this.state.awaitPos = -1;
    this.state.inFSharpPipelineDirectBody = false;
    const innerStartPos = this.state.start;
    const innerStartLoc = this.state.startLoc;
    const exprList = [];
    const refExpressionErrors = new ExpressionErrors();
    const refNeedsArrowPos = {
      start: 0
    };
    let first = true;
    let spreadStart;
    let optionalCommaStart;

    while (!this.match(types.parenR)) {
      if (first) {
        first = false;
      } else {
        this.expect(types.comma, refNeedsArrowPos.start || null);

        if (this.match(types.parenR)) {
          optionalCommaStart = this.state.start;
          break;
        }
      }

      if (this.match(types.ellipsis)) {
        const spreadNodeStartPos = this.state.start;
        const spreadNodeStartLoc = this.state.startLoc;
        spreadStart = this.state.start;
        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
        this.checkCommaAfterRest(41);
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refExpressionErrors, this.parseParenItem, refNeedsArrowPos));
      }
    }

    const innerEndPos = this.state.start;
    const innerEndLoc = this.state.startLoc;
    this.expect(types.parenR);
    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
    let arrowNode = this.startNodeAt(startPos, startLoc);

    if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
      if (!this.isAwaitAllowed() && !this.state.maybeInAsyncArrowHead) {
        this.state.awaitPos = oldAwaitPos;
      }

      this.checkYieldAwaitInDefaultParams();
      this.state.yieldPos = oldYieldPos;
      this.state.awaitPos = oldAwaitPos;

      for (let _i2 = 0; _i2 < exprList.length; _i2++) {
        const param = exprList[_i2];

        if (param.extra && param.extra.parenthesized) {
          this.unexpected(param.extra.parenStart);
        }
      }

      this.parseArrowExpression(arrowNode, exprList, false);
      return arrowNode;
    }

    if (oldYieldPos !== -1) this.state.yieldPos = oldYieldPos;
    if (oldAwaitPos !== -1) this.state.awaitPos = oldAwaitPos;

    if (!exprList.length) {
      this.unexpected(this.state.lastTokStart);
    }

    if (optionalCommaStart) this.unexpected(optionalCommaStart);
    if (spreadStart) this.unexpected(spreadStart);
    this.checkExpressionErrors(refExpressionErrors, true);
    if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);
    this.toReferencedListDeep(exprList, true);

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }

    if (!this.options.createParenthesizedExpressions) {
      this.addExtra(val, "parenthesized", true);
      this.addExtra(val, "parenStart", startPos);
      return val;
    }

    const parenExpression = this.startNodeAt(startPos, startLoc);
    parenExpression.expression = val;
    this.finishNode(parenExpression, "ParenthesizedExpression");
    return parenExpression;
  }

  shouldParseArrow() {
    return !this.canInsertSemicolon();
  }

  parseArrow(node) {
    if (this.eat(types.arrow)) {
      return node;
    }
  }

  parseParenItem(node, startPos, startLoc) {
    return node;
  }

  parseNew() {
    const node = this.startNode();
    let meta = this.startNode();
    this.next();
    meta = this.createIdentifier(meta, "new");

    if (this.eat(types.dot)) {
      const metaProp = this.parseMetaProperty(node, meta, "target");

      if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
        let error = ErrorMessages.UnexpectedNewTarget;

        if (this.hasPlugin("classProperties")) {
          error += " or class properties";
        }

        this.raise(metaProp.start, error);
      }

      return metaProp;
    }

    node.callee = this.parseNoCallExpr();

    if (node.callee.type === "Import") {
      this.raise(node.callee.start, ErrorMessages.ImportCallNotNewExpression);
    } else if (node.callee.type === "OptionalMemberExpression" || node.callee.type === "OptionalCallExpression") {
      this.raise(this.state.lastTokEnd, ErrorMessages.OptionalChainingNoNew);
    } else if (this.eat(types.questionDot)) {
      this.raise(this.state.start, ErrorMessages.OptionalChainingNoNew);
    }

    this.parseNewArguments(node);
    return this.finishNode(node, "NewExpression");
  }

  parseNewArguments(node) {
    if (this.eat(types.parenL)) {
      const args = this.parseExprList(types.parenR);
      this.toReferencedList(args);
      node.arguments = args;
    } else {
      node.arguments = [];
    }
  }

  parseTemplateElement(isTagged) {
    const elem = this.startNode();

    if (this.state.value === null) {
      if (!isTagged) {
        this.raise(this.state.start + 1, ErrorMessages.InvalidEscapeSequenceTemplate);
      }
    }

    elem.value = {
      raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
      cooked: this.state.value
    };
    this.next();
    elem.tail = this.match(types.backQuote);
    return this.finishNode(elem, "TemplateElement");
  }

  parseTemplate(isTagged) {
    const node = this.startNode();
    this.next();
    node.expressions = [];
    let curElt = this.parseTemplateElement(isTagged);
    node.quasis = [curElt];

    while (!curElt.tail) {
      this.expect(types.dollarBraceL);
      node.expressions.push(this.parseExpression());
      this.expect(types.braceR);
      node.quasis.push(curElt = this.parseTemplateElement(isTagged));
    }

    this.next();
    return this.finishNode(node, "TemplateLiteral");
  }

  parseObj(close, isPattern, isRecord, refExpressionErrors) {
    const propHash = Object.create(null);
    let first = true;
    const node = this.startNode();
    node.properties = [];
    this.next();

    while (!this.eat(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(types.comma);

        if (this.match(close)) {
          this.addExtra(node, "trailingComma", this.state.lastTokStart);
          this.next();
          break;
        }
      }

      const prop = this.parseObjectMember(isPattern, refExpressionErrors);

      if (!isPattern) {
        this.checkProto(prop, isRecord, propHash, refExpressionErrors);
      }

      if (isRecord && prop.type !== "ObjectProperty" && prop.type !== "SpreadElement") {
        this.raise(prop.start, ErrorMessages.InvalidRecordProperty);
      }

      if (prop.shorthand) {
        this.addExtra(prop, "shorthand", true);
      }

      node.properties.push(prop);
    }

    let type = "ObjectExpression";

    if (isPattern) {
      type = "ObjectPattern";
    } else if (isRecord) {
      type = "RecordExpression";
    }

    return this.finishNode(node, type);
  }

  isAsyncProp(prop) {
    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.isLiteralPropertyName() || this.match(types.bracketL) || this.match(types.star)) && !this.hasPrecedingLineBreak();
  }

  parseObjectMember(isPattern, refExpressionErrors) {
    let decorators = [];

    if (this.match(types.at)) {
      if (this.hasPlugin("decorators")) {
        this.raise(this.state.start, ErrorMessages.UnsupportedPropertyDecorator);
      }

      while (this.match(types.at)) {
        decorators.push(this.parseDecorator());
      }
    }

    const prop = this.startNode();
    let isGenerator = false;
    let isAsync = false;
    let startPos;
    let startLoc;

    if (this.match(types.ellipsis)) {
      if (decorators.length) this.unexpected();

      if (isPattern) {
        this.next();
        prop.argument = this.parseIdentifier();
        this.checkCommaAfterRest(125);
        return this.finishNode(prop, "RestElement");
      }

      return this.parseSpread();
    }

    if (decorators.length) {
      prop.decorators = decorators;
      decorators = [];
    }

    prop.method = false;

    if (isPattern || refExpressionErrors) {
      startPos = this.state.start;
      startLoc = this.state.startLoc;
    }

    if (!isPattern) {
      isGenerator = this.eat(types.star);
    }

    const containsEsc = this.state.containsEsc;
    this.parsePropertyName(prop, false);

    if (!isPattern && !containsEsc && !isGenerator && this.isAsyncProp(prop)) {
      isAsync = true;
      isGenerator = this.eat(types.star);
      this.parsePropertyName(prop, false);
    } else {
      isAsync = false;
    }

    this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc);
    return prop;
  }

  isGetterOrSetterMethod(prop, isPattern) {
    return !isPattern && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.isLiteralPropertyName() || this.match(types.bracketL));
  }

  getGetterSetterExpectedParamCount(method) {
    return method.kind === "get" ? 0 : 1;
  }

  checkGetterSetterParams(method) {
    const paramCount = this.getGetterSetterExpectedParamCount(method);
    const start = method.start;

    if (method.params.length !== paramCount) {
      if (method.kind === "get") {
        this.raise(start, ErrorMessages.BadGetterArity);
      } else {
        this.raise(start, ErrorMessages.BadSetterArity);
      }
    }

    if (method.kind === "set" && method.params[method.params.length - 1].type === "RestElement") {
      this.raise(start, ErrorMessages.BadSetterRestParameter);
    }
  }

  parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {
    if (isAsync || isGenerator || this.match(types.parenL)) {
      if (isPattern) this.unexpected();
      prop.kind = "method";
      prop.method = true;
      return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
    }

    if (!containsEsc && this.isGetterOrSetterMethod(prop, isPattern)) {
      if (isGenerator || isAsync) this.unexpected();
      prop.kind = prop.key.name;
      this.parsePropertyName(prop, false);
      this.parseMethod(prop, false, false, false, false, "ObjectMethod");
      this.checkGetterSetterParams(prop);
      return prop;
    }
  }

  parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
    prop.shorthand = false;

    if (this.eat(types.colon)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refExpressionErrors);
      return this.finishNode(prop, "ObjectProperty");
    }

    if (!prop.computed && prop.key.type === "Identifier") {
      this.checkReservedWord(prop.key.name, prop.key.start, true, true);

      if (isPattern) {
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
      } else if (this.match(types.eq) && refExpressionErrors) {
        if (refExpressionErrors.shorthandAssign === -1) {
          refExpressionErrors.shorthandAssign = this.state.start;
        }

        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
      } else {
        prop.value = prop.key.__clone();
      }

      prop.shorthand = true;
      return this.finishNode(prop, "ObjectProperty");
    }
  }

  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc) {
    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
    if (!node) this.unexpected();
    return node;
  }

  parsePropertyName(prop, isPrivateNameAllowed) {
    if (this.eat(types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types.bracketR);
    } else {
      const oldInPropertyName = this.state.inPropertyName;
      this.state.inPropertyName = true;
      prop.key = this.match(types.num) || this.match(types.string) || this.match(types.bigint) ? this.parseExprAtom() : this.parseMaybePrivateName(isPrivateNameAllowed);

      if (prop.key.type !== "PrivateName") {
        prop.computed = false;
      }

      this.state.inPropertyName = oldInPropertyName;
    }

    return prop.key;
  }

  initFunction(node, isAsync) {
    node.id = null;
    node.generator = false;
    node.async = !!isAsync;
  }

  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
    const oldYieldPos = this.state.yieldPos;
    const oldAwaitPos = this.state.awaitPos;
    this.state.yieldPos = -1;
    this.state.awaitPos = -1;
    this.initFunction(node, isAsync);
    node.generator = !!isGenerator;
    const allowModifiers = isConstructor;
    this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
    this.prodParam.enter(functionFlags(isAsync, node.generator));
    this.parseFunctionParams(node, allowModifiers);
    this.parseFunctionBodyAndFinish(node, type, true);
    this.prodParam.exit();
    this.scope.exit();
    this.state.yieldPos = oldYieldPos;
    this.state.awaitPos = oldAwaitPos;
    return node;
  }

  parseArrowExpression(node, params, isAsync, trailingCommaPos) {
    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
    this.prodParam.enter(functionFlags(isAsync, false));
    this.initFunction(node, isAsync);
    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
    const oldYieldPos = this.state.yieldPos;
    const oldAwaitPos = this.state.awaitPos;

    if (params) {
      this.state.maybeInArrowParameters = true;
      this.setArrowFunctionParameters(node, params, trailingCommaPos);
    }

    this.state.maybeInArrowParameters = false;
    this.state.yieldPos = -1;
    this.state.awaitPos = -1;
    this.parseFunctionBody(node, true);
    this.prodParam.exit();
    this.scope.exit();
    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    this.state.yieldPos = oldYieldPos;
    this.state.awaitPos = oldAwaitPos;
    return this.finishNode(node, "ArrowFunctionExpression");
  }

  setArrowFunctionParameters(node, params, trailingCommaPos) {
    node.params = this.toAssignableList(params, trailingCommaPos);
  }

  parseFunctionBodyAndFinish(node, type, isMethod = false) {
    this.parseFunctionBody(node, false, isMethod);
    this.finishNode(node, type);
  }

  parseFunctionBody(node, allowExpression, isMethod = false) {
    const isExpression = allowExpression && !this.match(types.braceL);
    const oldInParameters = this.state.inParameters;
    this.state.inParameters = false;

    if (isExpression) {
      node.body = this.parseMaybeAssign();
      this.checkParams(node, false, allowExpression, false);
    } else {
      const oldStrict = this.state.strict;
      const oldLabels = this.state.labels;
      this.state.labels = [];
      this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
      node.body = this.parseBlock(true, false, hasStrictModeDirective => {
        const nonSimple = !this.isSimpleParamList(node.params);

        if (hasStrictModeDirective && nonSimple) {
          const errorPos = (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.end : node.start;
          this.raise(errorPos, ErrorMessages.IllegalLanguageModeDirective);
        }

        const strictModeChanged = !oldStrict && this.state.strict;
        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);

        if (this.state.strict && node.id) {
          this.checkLVal(node.id, BIND_OUTSIDE, undefined, "function name", undefined, strictModeChanged);
        }
      });
      this.prodParam.exit();
      this.state.labels = oldLabels;
    }

    this.state.inParameters = oldInParameters;
  }

  isSimpleParamList(params) {
    for (let i = 0, len = params.length; i < len; i++) {
      if (params[i].type !== "Identifier") return false;
    }

    return true;
  }

  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
    const nameHash = Object.create(null);

    for (let i = 0; i < node.params.length; i++) {
      this.checkLVal(node.params[i], BIND_VAR, allowDuplicates ? null : nameHash, "function parameter list", undefined, strictModeChanged);
    }
  }

  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
    const elts = [];
    let first = true;

    while (!this.eat(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(types.comma);

        if (this.match(close)) {
          if (nodeForExtra) {
            this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
          }

          this.next();
          break;
        }
      }

      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
    }

    return elts;
  }

  parseExprListItem(allowEmpty, refExpressionErrors, refNeedsArrowPos, allowPlaceholder) {
    let elt;

    if (this.match(types.comma)) {
      if (!allowEmpty) {
        this.raise(this.state.pos, ErrorMessages.UnexpectedToken, ",");
      }

      elt = null;
    } else if (this.match(types.ellipsis)) {
      const spreadNodeStartPos = this.state.start;
      const spreadNodeStartLoc = this.state.startLoc;
      elt = this.parseParenItem(this.parseSpread(refExpressionErrors, refNeedsArrowPos), spreadNodeStartPos, spreadNodeStartLoc);
    } else if (this.match(types.question)) {
      this.expectPlugin("partialApplication");

      if (!allowPlaceholder) {
        this.raise(this.state.start, ErrorMessages.UnexpectedArgumentPlaceholder);
      }

      const node = this.startNode();
      this.next();
      elt = this.finishNode(node, "ArgumentPlaceholder");
    } else {
      elt = this.parseMaybeAssign(false, refExpressionErrors, this.parseParenItem, refNeedsArrowPos);
    }

    return elt;
  }

  parseIdentifier(liberal) {
    const node = this.startNode();
    const name = this.parseIdentifierName(node.start, liberal);
    return this.createIdentifier(node, name);
  }

  createIdentifier(node, name) {
    node.name = name;
    node.loc.identifierName = name;
    return this.finishNode(node, "Identifier");
  }

  parseIdentifierName(pos, liberal) {
    let name;

    if (this.match(types.name)) {
      name = this.state.value;
    } else if (this.state.type.keyword) {
      name = this.state.type.keyword;
      const context = this.state.context;

      if ((name === "class" || name === "function") && context[context.length - 1].token === "function") {
        context.pop();
      }
    } else {
      throw this.unexpected();
    }

    if (liberal) {
      this.state.type = types.name;
    } else {
      this.checkReservedWord(name, this.state.start, !!this.state.type.keyword, false);
    }

    this.next();
    return name;
  }

  checkReservedWord(word, startLoc, checkKeywords, isBinding) {
    if (this.prodParam.hasYield && word === "yield") {
      this.raise(startLoc, ErrorMessages.YieldBindingIdentifier);
      return;
    }

    if (word === "await") {
      if (this.prodParam.hasAwait) {
        this.raise(startLoc, ErrorMessages.AwaitBindingIdentifier);
        return;
      }

      if (this.state.awaitPos === -1 && (this.state.maybeInAsyncArrowHead || this.isAwaitAllowed())) {
        this.state.awaitPos = this.state.start;
      }
    }

    if (this.scope.inClass && !this.scope.inNonArrowFunction && word === "arguments") {
      this.raise(startLoc, ErrorMessages.ArgumentsDisallowedInInitializer);
      return;
    }

    if (checkKeywords && isKeyword(word)) {
      this.raise(startLoc, ErrorMessages.UnexpectedKeyword, word);
      return;
    }

    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;

    if (reservedTest(word, this.inModule)) {
      if (!this.prodParam.hasAwait && word === "await") {
        this.raise(startLoc, ErrorMessages.AwaitNotInAsyncFunction);
      } else {
        this.raise(startLoc, ErrorMessages.UnexpectedReservedWord, word);
      }
    }
  }

  isAwaitAllowed() {
    if (this.scope.inFunction) return this.prodParam.hasAwait;
    if (this.options.allowAwaitOutsideFunction) return true;

    if (this.hasPlugin("topLevelAwait")) {
      return this.inModule && this.prodParam.hasAwait;
    }

    return false;
  }

  parseAwait() {
    const node = this.startNode();
    this.next();

    if (this.state.inParameters) {
      this.raise(node.start, ErrorMessages.AwaitExpressionFormalParameter);
    } else if (this.state.awaitPos === -1) {
      this.state.awaitPos = node.start;
    }

    if (this.eat(types.star)) {
      this.raise(node.start, ErrorMessages.ObsoleteAwaitStar);
    }

    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
      if (this.hasPrecedingLineBreak() || this.match(types.plusMin) || this.match(types.parenL) || this.match(types.bracketL) || this.match(types.backQuote) || this.match(types.regexp) || this.match(types.slash) || this.hasPlugin("v8intrinsic") && this.match(types.modulo)) {
        this.ambiguousScriptDifferentAst = true;
      } else {
        this.sawUnambiguousESM = true;
      }
    }

    if (!this.state.soloAwait) {
      node.argument = this.parseMaybeUnary();
    }

    return this.finishNode(node, "AwaitExpression");
  }

  parseYield(noIn) {
    const node = this.startNode();

    if (this.state.inParameters) {
      this.raise(node.start, ErrorMessages.YieldInParameter);
    } else if (this.state.yieldPos === -1) {
      this.state.yieldPos = node.start;
    }

    this.next();

    if (this.match(types.semi) || !this.match(types.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak()) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = this.eat(types.star);
      node.argument = this.parseMaybeAssign(noIn);
    }

    return this.finishNode(node, "YieldExpression");
  }

  checkPipelineAtInfixOperator(left, leftStartPos) {
    if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
      if (left.type === "SequenceExpression") {
        this.raise(leftStartPos, ErrorMessages.PipelineHeadSequenceExpression);
      }
    }
  }

  parseSmartPipelineBody(childExpression, startPos, startLoc) {
    const pipelineStyle = this.checkSmartPipelineBodyStyle(childExpression);
    this.checkSmartPipelineBodyEarlyErrors(childExpression, pipelineStyle, startPos);
    return this.parseSmartPipelineBodyInStyle(childExpression, pipelineStyle, startPos, startLoc);
  }

  checkSmartPipelineBodyEarlyErrors(childExpression, pipelineStyle, startPos) {
    if (this.match(types.arrow)) {
      throw this.raise(this.state.start, ErrorMessages.PipelineBodyNoArrow);
    } else if (pipelineStyle === "PipelineTopicExpression" && childExpression.type === "SequenceExpression") {
      this.raise(startPos, ErrorMessages.PipelineBodySequenceExpression);
    }
  }

  parseSmartPipelineBodyInStyle(childExpression, pipelineStyle, startPos, startLoc) {
    const bodyNode = this.startNodeAt(startPos, startLoc);

    switch (pipelineStyle) {
      case "PipelineBareFunction":
        bodyNode.callee = childExpression;
        break;

      case "PipelineBareConstructor":
        bodyNode.callee = childExpression.callee;
        break;

      case "PipelineBareAwaitedFunction":
        bodyNode.callee = childExpression.argument;
        break;

      case "PipelineTopicExpression":
        if (!this.topicReferenceWasUsedInCurrentTopicContext()) {
          this.raise(startPos, ErrorMessages.PipelineTopicUnused);
        }

        bodyNode.expression = childExpression;
        break;

      default:
        throw new Error(`Internal @babel/parser error: Unknown pipeline style (${pipelineStyle})`);
    }

    return this.finishNode(bodyNode, pipelineStyle);
  }

  checkSmartPipelineBodyStyle(expression) {
    switch (expression.type) {
      default:
        return this.isSimpleReference(expression) ? "PipelineBareFunction" : "PipelineTopicExpression";
    }
  }

  isSimpleReference(expression) {
    switch (expression.type) {
      case "MemberExpression":
        return !expression.computed && this.isSimpleReference(expression.object);

      case "Identifier":
        return true;

      default:
        return false;
    }
  }

  withTopicPermittingContext(callback) {
    const outerContextTopicState = this.state.topicContext;
    this.state.topicContext = {
      maxNumOfResolvableTopics: 1,
      maxTopicIndex: null
    };

    try {
      return callback();
    } finally {
      this.state.topicContext = outerContextTopicState;
    }
  }

  withTopicForbiddingContext(callback) {
    const outerContextTopicState = this.state.topicContext;
    this.state.topicContext = {
      maxNumOfResolvableTopics: 0,
      maxTopicIndex: null
    };

    try {
      return callback();
    } finally {
      this.state.topicContext = outerContextTopicState;
    }
  }

  withSoloAwaitPermittingContext(callback) {
    const outerContextSoloAwaitState = this.state.soloAwait;
    this.state.soloAwait = true;

    try {
      return callback();
    } finally {
      this.state.soloAwait = outerContextSoloAwaitState;
    }
  }

  registerTopicReference() {
    this.state.topicContext.maxTopicIndex = 0;
  }

  primaryTopicReferenceIsAllowedInCurrentTopicContext() {
    return this.state.topicContext.maxNumOfResolvableTopics >= 1;
  }

  topicReferenceWasUsedInCurrentTopicContext() {
    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
  }

  parseFSharpPipelineBody(prec, noIn) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    this.state.potentialArrowAt = this.state.start;
    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = true;
    const ret = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn);
    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
    return ret;
  }

}

const loopLabel = {
  kind: "loop"
},
      switchLabel = {
  kind: "switch"
};
const FUNC_NO_FLAGS = 0b000,
      FUNC_STATEMENT = 0b001,
      FUNC_HANGING_STATEMENT = 0b010,
      FUNC_NULLABLE_ID = 0b100;
class StatementParser extends ExpressionParser {
  parseTopLevel(file, program) {
    program.sourceType = this.options.sourceType;
    program.interpreter = this.parseInterpreterDirective();
    this.parseBlockBody(program, true, true, types.eof);

    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
      for (let _i = 0, _Array$from = Array.from(this.scope.undefinedExports); _i < _Array$from.length; _i++) {
        const [name] = _Array$from[_i];
        const pos = this.scope.undefinedExports.get(name);
        this.raise(pos, ErrorMessages.ModuleExportUndefined, name);
      }
    }

    file.program = this.finishNode(program, "Program");
    file.comments = this.state.comments;
    if (this.options.tokens) file.tokens = this.tokens;
    return this.finishNode(file, "File");
  }

  stmtToDirective(stmt) {
    const expr = stmt.expression;
    const directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
    const directive = this.startNodeAt(stmt.start, stmt.loc.start);
    const raw = this.input.slice(expr.start, expr.end);
    const val = directiveLiteral.value = raw.slice(1, -1);
    this.addExtra(directiveLiteral, "raw", raw);
    this.addExtra(directiveLiteral, "rawValue", val);
    directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr.end, expr.loc.end);
    return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
  }

  parseInterpreterDirective() {
    if (!this.match(types.interpreterDirective)) {
      return null;
    }

    const node = this.startNode();
    node.value = this.state.value;
    this.next();
    return this.finishNode(node, "InterpreterDirective");
  }

  isLet(context) {
    if (!this.isContextual("let")) {
      return false;
    }

    const next = this.nextTokenStart();
    const nextCh = this.input.charCodeAt(next);
    if (nextCh === 91) return true;
    if (context) return false;
    if (nextCh === 123) return true;

    if (isIdentifierStart(nextCh)) {
      let pos = next + 1;

      while (isIdentifierChar(this.input.charCodeAt(pos))) {
        ++pos;
      }

      const ident = this.input.slice(next, pos);
      if (!keywordRelationalOperator.test(ident)) return true;
    }

    return false;
  }

  parseStatement(context, topLevel) {
    if (this.match(types.at)) {
      this.parseDecorators(true);
    }

    return this.parseStatementContent(context, topLevel);
  }

  parseStatementContent(context, topLevel) {
    let starttype = this.state.type;
    const node = this.startNode();
    let kind;

    if (this.isLet(context)) {
      starttype = types._var;
      kind = "let";
    }

    switch (starttype) {
      case types._break:
      case types._continue:
        return this.parseBreakContinueStatement(node, starttype.keyword);

      case types._debugger:
        return this.parseDebuggerStatement(node);

      case types._do:
        return this.parseDoStatement(node);

      case types._for:
        return this.parseForStatement(node);

      case types._function:
        if (this.lookaheadCharCode() === 46) break;

        if (context) {
          if (this.state.strict) {
            this.raise(this.state.start, ErrorMessages.StrictFunction);
          } else if (context !== "if" && context !== "label") {
            this.raise(this.state.start, ErrorMessages.SloppyFunction);
          }
        }

        return this.parseFunctionStatement(node, false, !context);

      case types._class:
        if (context) this.unexpected();
        return this.parseClass(node, true);

      case types._if:
        return this.parseIfStatement(node);

      case types._return:
        return this.parseReturnStatement(node);

      case types._switch:
        return this.parseSwitchStatement(node);

      case types._throw:
        return this.parseThrowStatement(node);

      case types._try:
        return this.parseTryStatement(node);

      case types._const:
      case types._var:
        kind = kind || this.state.value;

        if (context && kind !== "var") {
          this.raise(this.state.start, ErrorMessages.UnexpectedLexicalDeclaration);
        }

        return this.parseVarStatement(node, kind);

      case types._while:
        return this.parseWhileStatement(node);

      case types._with:
        return this.parseWithStatement(node);

      case types.braceL:
        return this.parseBlock();

      case types.semi:
        return this.parseEmptyStatement(node);

      case types._export:
      case types._import:
        {
          const nextTokenCharCode = this.lookaheadCharCode();

          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
            break;
          }

          if (!this.options.allowImportExportEverywhere && !topLevel) {
            this.raise(this.state.start, ErrorMessages.UnexpectedImportExport);
          }

          this.next();
          let result;

          if (starttype === types._import) {
            result = this.parseImport(node);

            if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
              this.sawUnambiguousESM = true;
            }
          } else {
            result = this.parseExport(node);

            if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
              this.sawUnambiguousESM = true;
            }
          }

          this.assertModuleNodeAllowed(node);
          return result;
        }

      default:
        {
          if (this.isAsyncFunction()) {
            if (context) {
              this.raise(this.state.start, ErrorMessages.AsyncFunctionInSingleStatementContext);
            }

            this.next();
            return this.parseFunctionStatement(node, true, !context);
          }
        }
    }

    const maybeName = this.state.value;
    const expr = this.parseExpression();

    if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
      return this.parseLabeledStatement(node, maybeName, expr, context);
    } else {
      return this.parseExpressionStatement(node, expr);
    }
  }

  assertModuleNodeAllowed(node) {
    if (!this.options.allowImportExportEverywhere && !this.inModule) {
      this.raiseWithData(node.start, {
        code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
      }, ErrorMessages.ImportOutsideModule);
    }
  }

  takeDecorators(node) {
    const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

    if (decorators.length) {
      node.decorators = decorators;
      this.resetStartLocationFromNode(node, decorators[0]);
      this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
    }
  }

  canHaveLeadingDecorator() {
    return this.match(types._class);
  }

  parseDecorators(allowExport) {
    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

    while (this.match(types.at)) {
      const decorator = this.parseDecorator();
      currentContextDecorators.push(decorator);
    }

    if (this.match(types._export)) {
      if (!allowExport) {
        this.unexpected();
      }

      if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
        this.raise(this.state.start, ErrorMessages.DecoratorExportClass);
      }
    } else if (!this.canHaveLeadingDecorator()) {
      throw this.raise(this.state.start, ErrorMessages.UnexpectedLeadingDecorator);
    }
  }

  parseDecorator() {
    this.expectOnePlugin(["decorators-legacy", "decorators"]);
    const node = this.startNode();
    this.next();

    if (this.hasPlugin("decorators")) {
      this.state.decoratorStack.push([]);
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      let expr;

      if (this.eat(types.parenL)) {
        expr = this.parseExpression();
        this.expect(types.parenR);
      } else {
        expr = this.parseIdentifier(false);

        while (this.eat(types.dot)) {
          const node = this.startNodeAt(startPos, startLoc);
          node.object = expr;
          node.property = this.parseIdentifier(true);
          node.computed = false;
          expr = this.finishNode(node, "MemberExpression");
        }
      }

      node.expression = this.parseMaybeDecoratorArguments(expr);
      this.state.decoratorStack.pop();
    } else {
      node.expression = this.parseExprSubscripts();
    }

    return this.finishNode(node, "Decorator");
  }

  parseMaybeDecoratorArguments(expr) {
    if (this.eat(types.parenL)) {
      const node = this.startNodeAtNode(expr);
      node.callee = expr;
      node.arguments = this.parseCallExpressionArguments(types.parenR, false);
      this.toReferencedList(node.arguments);
      return this.finishNode(node, "CallExpression");
    }

    return expr;
  }

  parseBreakContinueStatement(node, keyword) {
    const isBreak = keyword === "break";
    this.next();

    if (this.isLineTerminator()) {
      node.label = null;
    } else {
      node.label = this.parseIdentifier();
      this.semicolon();
    }

    this.verifyBreakContinue(node, keyword);
    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
  }

  verifyBreakContinue(node, keyword) {
    const isBreak = keyword === "break";
    let i;

    for (i = 0; i < this.state.labels.length; ++i) {
      const lab = this.state.labels[i];

      if (node.label == null || lab.name === node.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
        if (node.label && isBreak) break;
      }
    }

    if (i === this.state.labels.length) {
      this.raise(node.start, ErrorMessages.IllegalBreakContinue, keyword);
    }
  }

  parseDebuggerStatement(node) {
    this.next();
    this.semicolon();
    return this.finishNode(node, "DebuggerStatement");
  }

  parseHeaderExpression() {
    this.expect(types.parenL);
    const val = this.parseExpression();
    this.expect(types.parenR);
    return val;
  }

  parseDoStatement(node) {
    this.next();
    this.state.labels.push(loopLabel);
    node.body = this.withTopicForbiddingContext(() => this.parseStatement("do"));
    this.state.labels.pop();
    this.expect(types._while);
    node.test = this.parseHeaderExpression();
    this.eat(types.semi);
    return this.finishNode(node, "DoWhileStatement");
  }

  parseForStatement(node) {
    this.next();
    this.state.labels.push(loopLabel);
    let awaitAt = -1;

    if (this.isAwaitAllowed() && this.eatContextual("await")) {
      awaitAt = this.state.lastTokStart;
    }

    this.scope.enter(SCOPE_OTHER);
    this.expect(types.parenL);

    if (this.match(types.semi)) {
      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }

      return this.parseFor(node, null);
    }

    const isLet = this.isLet();

    if (this.match(types._var) || this.match(types._const) || isLet) {
      const init = this.startNode();
      const kind = isLet ? "let" : this.state.value;
      this.next();
      this.parseVar(init, true, kind);
      this.finishNode(init, "VariableDeclaration");

      if ((this.match(types._in) || this.isContextual("of")) && init.declarations.length === 1) {
        return this.parseForIn(node, init, awaitAt);
      }

      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }

      return this.parseFor(node, init);
    }

    const refExpressionErrors = new ExpressionErrors();
    const init = this.parseExpression(true, refExpressionErrors);

    if (this.match(types._in) || this.isContextual("of")) {
      this.toAssignable(init);
      const description = this.isContextual("of") ? "for-of statement" : "for-in statement";
      this.checkLVal(init, undefined, undefined, description);
      return this.parseForIn(node, init, awaitAt);
    } else {
      this.checkExpressionErrors(refExpressionErrors, true);
    }

    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }

    return this.parseFor(node, init);
  }

  parseFunctionStatement(node, isAsync, declarationPosition) {
    this.next();
    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
  }

  parseIfStatement(node) {
    this.next();
    node.test = this.parseHeaderExpression();
    node.consequent = this.parseStatement("if");
    node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
    return this.finishNode(node, "IfStatement");
  }

  parseReturnStatement(node) {
    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
      this.raise(this.state.start, ErrorMessages.IllegalReturn);
    }

    this.next();

    if (this.isLineTerminator()) {
      node.argument = null;
    } else {
      node.argument = this.parseExpression();
      this.semicolon();
    }

    return this.finishNode(node, "ReturnStatement");
  }

  parseSwitchStatement(node) {
    this.next();
    node.discriminant = this.parseHeaderExpression();
    const cases = node.cases = [];
    this.expect(types.braceL);
    this.state.labels.push(switchLabel);
    this.scope.enter(SCOPE_OTHER);
    let cur;

    for (let sawDefault; !this.match(types.braceR);) {
      if (this.match(types._case) || this.match(types._default)) {
        const isCase = this.match(types._case);
        if (cur) this.finishNode(cur, "SwitchCase");
        cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();

        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault) {
            this.raise(this.state.lastTokStart, ErrorMessages.MultipleDefaultsInSwitch);
          }

          sawDefault = true;
          cur.test = null;
        }

        this.expect(types.colon);
      } else {
        if (cur) {
          cur.consequent.push(this.parseStatement(null));
        } else {
          this.unexpected();
        }
      }
    }

    this.scope.exit();
    if (cur) this.finishNode(cur, "SwitchCase");
    this.next();
    this.state.labels.pop();
    return this.finishNode(node, "SwitchStatement");
  }

  parseThrowStatement(node) {
    this.next();

    if (lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) {
      this.raise(this.state.lastTokEnd, ErrorMessages.NewlineAfterThrow);
    }

    node.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, "ThrowStatement");
  }

  parseTryStatement(node) {
    this.next();
    node.block = this.parseBlock();
    node.handler = null;

    if (this.match(types._catch)) {
      const clause = this.startNode();
      this.next();

      if (this.match(types.parenL)) {
        this.expect(types.parenL);
        clause.param = this.parseBindingAtom();
        const simple = clause.param.type === "Identifier";
        this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLVal(clause.param, BIND_LEXICAL, null, "catch clause");
        this.expect(types.parenR);
      } else {
        clause.param = null;
        this.scope.enter(SCOPE_OTHER);
      }

      clause.body = this.withTopicForbiddingContext(() => this.parseBlock(false, false));
      this.scope.exit();
      node.handler = this.finishNode(clause, "CatchClause");
    }

    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;

    if (!node.handler && !node.finalizer) {
      this.raise(node.start, ErrorMessages.NoCatchOrFinally);
    }

    return this.finishNode(node, "TryStatement");
  }

  parseVarStatement(node, kind) {
    this.next();
    this.parseVar(node, false, kind);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration");
  }

  parseWhileStatement(node) {
    this.next();
    node.test = this.parseHeaderExpression();
    this.state.labels.push(loopLabel);
    node.body = this.withTopicForbiddingContext(() => this.parseStatement("while"));
    this.state.labels.pop();
    return this.finishNode(node, "WhileStatement");
  }

  parseWithStatement(node) {
    if (this.state.strict) {
      this.raise(this.state.start, ErrorMessages.StrictWith);
    }

    this.next();
    node.object = this.parseHeaderExpression();
    node.body = this.withTopicForbiddingContext(() => this.parseStatement("with"));
    return this.finishNode(node, "WithStatement");
  }

  parseEmptyStatement(node) {
    this.next();
    return this.finishNode(node, "EmptyStatement");
  }

  parseLabeledStatement(node, maybeName, expr, context) {
    for (let _i2 = 0, _this$state$labels = this.state.labels; _i2 < _this$state$labels.length; _i2++) {
      const label = _this$state$labels[_i2];

      if (label.name === maybeName) {
        this.raise(expr.start, ErrorMessages.LabelRedeclaration, maybeName);
      }
    }

    const kind = this.state.type.isLoop ? "loop" : this.match(types._switch) ? "switch" : null;

    for (let i = this.state.labels.length - 1; i >= 0; i--) {
      const label = this.state.labels[i];

      if (label.statementStart === node.start) {
        label.statementStart = this.state.start;
        label.kind = kind;
      } else {
        break;
      }
    }

    this.state.labels.push({
      name: maybeName,
      kind: kind,
      statementStart: this.state.start
    });
    node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
    this.state.labels.pop();
    node.label = expr;
    return this.finishNode(node, "LabeledStatement");
  }

  parseExpressionStatement(node, expr) {
    node.expression = expr;
    this.semicolon();
    return this.finishNode(node, "ExpressionStatement");
  }

  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
    const node = this.startNode();
    this.expect(types.braceL);

    if (createNewLexicalScope) {
      this.scope.enter(SCOPE_OTHER);
    }

    this.parseBlockBody(node, allowDirectives, false, types.braceR, afterBlockParse);

    if (createNewLexicalScope) {
      this.scope.exit();
    }

    return this.finishNode(node, "BlockStatement");
  }

  isValidDirective(stmt) {
    return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
  }

  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
    const body = node.body = [];
    const directives = node.directives = [];
    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);
  }

  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
    const octalPositions = [];
    const oldStrict = this.state.strict;
    let hasStrictModeDirective = false;
    let parsedNonDirective = false;

    while (!this.match(end)) {
      if (!parsedNonDirective && this.state.octalPositions.length) {
        octalPositions.push(...this.state.octalPositions);
      }

      const stmt = this.parseStatement(null, topLevel);

      if (directives && !parsedNonDirective && this.isValidDirective(stmt)) {
        const directive = this.stmtToDirective(stmt);
        directives.push(directive);

        if (!hasStrictModeDirective && directive.value.value === "use strict") {
          hasStrictModeDirective = true;
          this.setStrict(true);
        }

        continue;
      }

      parsedNonDirective = true;
      body.push(stmt);
    }

    if (this.state.strict && octalPositions.length) {
      for (let _i3 = 0; _i3 < octalPositions.length; _i3++) {
        const pos = octalPositions[_i3];
        this.raise(pos, ErrorMessages.StrictOctalLiteral);
      }
    }

    if (afterBlockParse) {
      afterBlockParse.call(this, hasStrictModeDirective);
    }

    if (!oldStrict) {
      this.setStrict(false);
    }

    this.next();
  }

  parseFor(node, init) {
    node.init = init;
    this.expect(types.semi);
    node.test = this.match(types.semi) ? null : this.parseExpression();
    this.expect(types.semi);
    node.update = this.match(types.parenR) ? null : this.parseExpression();
    this.expect(types.parenR);
    node.body = this.withTopicForbiddingContext(() => this.parseStatement("for"));
    this.scope.exit();
    this.state.labels.pop();
    return this.finishNode(node, "ForStatement");
  }

  parseForIn(node, init, awaitAt) {
    const isForIn = this.match(types._in);
    this.next();

    if (isForIn) {
      if (awaitAt > -1) this.unexpected(awaitAt);
    } else {
      node.await = awaitAt > -1;
    }

    if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
      this.raise(init.start, ErrorMessages.ForInOfLoopInitializer, isForIn ? "for-in" : "for-of");
    } else if (init.type === "AssignmentPattern") {
      this.raise(init.start, ErrorMessages.InvalidLhs, "for-loop");
    }

    node.left = init;
    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
    this.expect(types.parenR);
    node.body = this.withTopicForbiddingContext(() => this.parseStatement("for"));
    this.scope.exit();
    this.state.labels.pop();
    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
  }

  parseVar(node, isFor, kind) {
    const declarations = node.declarations = [];
    const isTypescript = this.hasPlugin("typescript");
    node.kind = kind;

    for (;;) {
      const decl = this.startNode();
      this.parseVarId(decl, kind);

      if (this.eat(types.eq)) {
        decl.init = this.parseMaybeAssign(isFor);
      } else {
        if (kind === "const" && !(this.match(types._in) || this.isContextual("of"))) {
          if (!isTypescript) {
            this.unexpected();
          }
        } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types._in) || this.isContextual("of")))) {
          this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Complex binding patterns");
        }

        decl.init = null;
      }

      declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(types.comma)) break;
    }

    return node;
  }

  parseVarId(decl, kind) {
    decl.id = this.parseBindingAtom();
    this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, undefined, "variable declaration", kind !== "var");
  }

  parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {
    const isStatement = statement & FUNC_STATEMENT;
    const isHangingStatement = statement & FUNC_HANGING_STATEMENT;
    const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
    this.initFunction(node, isAsync);

    if (this.match(types.star) && isHangingStatement) {
      this.raise(this.state.start, ErrorMessages.GeneratorInSingleStatementContext);
    }

    node.generator = this.eat(types.star);

    if (isStatement) {
      node.id = this.parseFunctionId(requireId);
    }

    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
    const oldYieldPos = this.state.yieldPos;
    const oldAwaitPos = this.state.awaitPos;
    this.state.maybeInArrowParameters = false;
    this.state.yieldPos = -1;
    this.state.awaitPos = -1;
    this.scope.enter(SCOPE_FUNCTION);
    this.prodParam.enter(functionFlags(isAsync, node.generator));

    if (!isStatement) {
      node.id = this.parseFunctionId();
    }

    this.parseFunctionParams(node);
    this.withTopicForbiddingContext(() => {
      this.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
    });
    this.prodParam.exit();
    this.scope.exit();

    if (isStatement && !isHangingStatement) {
      this.registerFunctionStatementId(node);
    }

    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    this.state.yieldPos = oldYieldPos;
    this.state.awaitPos = oldAwaitPos;
    return node;
  }

  parseFunctionId(requireId) {
    return requireId || this.match(types.name) ? this.parseIdentifier() : null;
  }

  parseFunctionParams(node, allowModifiers) {
    const oldInParameters = this.state.inParameters;
    this.state.inParameters = true;
    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, 41, false, allowModifiers);
    this.state.inParameters = oldInParameters;
    this.checkYieldAwaitInDefaultParams();
  }

  registerFunctionStatementId(node) {
    if (!node.id) return;
    this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.start);
  }

  parseClass(node, isStatement, optionalId) {
    this.next();
    this.takeDecorators(node);
    const oldStrict = this.state.strict;
    this.state.strict = true;
    this.parseClassId(node, isStatement, optionalId);
    this.parseClassSuper(node);
    node.body = this.parseClassBody(!!node.superClass, oldStrict);
    this.state.strict = oldStrict;
    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
  }

  isClassProperty() {
    return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);
  }

  isClassMethod() {
    return this.match(types.parenL);
  }

  isNonstaticConstructor(method) {
    return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
  }

  parseClassBody(constructorAllowsSuper, oldStrict) {
    this.classScope.enter();
    const state = {
      hadConstructor: false
    };
    let decorators = [];
    const classBody = this.startNode();
    classBody.body = [];
    this.expect(types.braceL);
    this.withTopicForbiddingContext(() => {
      while (!this.match(types.braceR)) {
        if (this.eat(types.semi)) {
          if (decorators.length > 0) {
            throw this.raise(this.state.lastTokEnd, ErrorMessages.DecoratorSemicolon);
          }

          continue;
        }

        if (this.match(types.at)) {
          decorators.push(this.parseDecorator());
          continue;
        }

        const member = this.startNode();

        if (decorators.length) {
          member.decorators = decorators;
          this.resetStartLocationFromNode(member, decorators[0]);
          decorators = [];
        }

        this.parseClassMember(classBody, member, state, constructorAllowsSuper);

        if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
          this.raise(member.start, ErrorMessages.DecoratorConstructor);
        }
      }
    });

    if (!oldStrict) {
      this.state.strict = false;
    }

    this.next();

    if (decorators.length) {
      throw this.raise(this.state.start, ErrorMessages.TrailingDecorator);
    }

    this.classScope.exit();
    return this.finishNode(classBody, "ClassBody");
  }

  parseClassMemberFromModifier(classBody, member) {
    const containsEsc = this.state.containsEsc;
    const key = this.parseIdentifier(true);

    if (this.isClassMethod()) {
      const method = member;
      method.kind = "method";
      method.computed = false;
      method.key = key;
      method.static = false;
      this.pushClassMethod(classBody, method, false, false, false, false);
      return true;
    } else if (this.isClassProperty()) {
      const prop = member;
      prop.computed = false;
      prop.key = key;
      prop.static = false;
      classBody.body.push(this.parseClassProperty(prop));
      return true;
    } else if (containsEsc) {
      throw this.unexpected();
    }

    return false;
  }

  parseClassMember(classBody, member, state, constructorAllowsSuper) {
    const isStatic = this.isContextual("static");

    if (isStatic && this.parseClassMemberFromModifier(classBody, member)) {
      return;
    }

    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper);
  }

  parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper) {
    const publicMethod = member;
    const privateMethod = member;
    const publicProp = member;
    const privateProp = member;
    const method = publicMethod;
    const publicMember = publicMethod;
    member.static = isStatic;

    if (this.eat(types.star)) {
      method.kind = "method";
      this.parseClassPropertyName(method);

      if (method.key.type === "PrivateName") {
        this.pushClassPrivateMethod(classBody, privateMethod, true, false);
        return;
      }

      if (this.isNonstaticConstructor(publicMethod)) {
        this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsGenerator);
      }

      this.pushClassMethod(classBody, publicMethod, true, false, false, false);
      return;
    }

    const containsEsc = this.state.containsEsc;
    const key = this.parseClassPropertyName(member);
    const isPrivate = key.type === "PrivateName";
    const isSimple = key.type === "Identifier";
    const maybeQuestionTokenStart = this.state.start;
    this.parsePostMemberNameModifiers(publicMember);

    if (this.isClassMethod()) {
      method.kind = "method";

      if (isPrivate) {
        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        return;
      }

      const isConstructor = this.isNonstaticConstructor(publicMethod);
      let allowsDirectSuper = false;

      if (isConstructor) {
        publicMethod.kind = "constructor";

        if (state.hadConstructor && !this.hasPlugin("typescript")) {
          this.raise(key.start, ErrorMessages.DuplicateConstructor);
        }

        state.hadConstructor = true;
        allowsDirectSuper = constructorAllowsSuper;
      }

      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
    } else if (this.isClassProperty()) {
      if (isPrivate) {
        this.pushClassPrivateProperty(classBody, privateProp);
      } else {
        this.pushClassProperty(classBody, publicProp);
      }
    } else if (isSimple && key.name === "async" && !containsEsc && !this.isLineTerminator()) {
      const isGenerator = this.eat(types.star);

      if (publicMember.optional) {
        this.unexpected(maybeQuestionTokenStart);
      }

      method.kind = "method";
      this.parseClassPropertyName(method);
      this.parsePostMemberNameModifiers(publicMember);

      if (method.key.type === "PrivateName") {
        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
      } else {
        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAsync);
        }

        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
      }
    } else if (isSimple && (key.name === "get" || key.name === "set") && !containsEsc && !(this.match(types.star) && this.isLineTerminator())) {
      method.kind = key.name;
      this.parseClassPropertyName(publicMethod);

      if (method.key.type === "PrivateName") {
        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
      } else {
        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAccessor);
        }

        this.pushClassMethod(classBody, publicMethod, false, false, false, false);
      }

      this.checkGetterSetterParams(publicMethod);
    } else if (this.isLineTerminator()) {
      if (isPrivate) {
        this.pushClassPrivateProperty(classBody, privateProp);
      } else {
        this.pushClassProperty(classBody, publicProp);
      }
    } else {
      this.unexpected();
    }
  }

  parseClassPropertyName(member) {
    const key = this.parsePropertyName(member, true);

    if (!member.computed && member.static && (key.name === "prototype" || key.value === "prototype")) {
      this.raise(key.start, ErrorMessages.StaticPrototype);
    }

    if (key.type === "PrivateName" && key.id.name === "constructor") {
      this.raise(key.start, ErrorMessages.ConstructorClassPrivateField);
    }

    return key;
  }

  pushClassProperty(classBody, prop) {
    if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
      this.raise(prop.key.start, ErrorMessages.ConstructorClassField);
    }

    classBody.body.push(this.parseClassProperty(prop));
  }

  pushClassPrivateProperty(classBody, prop) {
    this.expectPlugin("classPrivateProperties", prop.key.start);
    const node = this.parseClassPrivateProperty(prop);
    classBody.body.push(node);
    this.classScope.declarePrivateName(node.key.id.name, CLASS_ELEMENT_OTHER, node.key.start);
  }

  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
  }

  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
    this.expectPlugin("classPrivateMethods", method.key.start);
    const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
    classBody.body.push(node);
    const kind = node.kind === "get" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
    this.classScope.declarePrivateName(node.key.id.name, kind, node.key.start);
  }

  parsePostMemberNameModifiers(methodOrProp) {}

  parseAccessModifier() {
    return undefined;
  }

  parseClassPrivateProperty(node) {
    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
    this.prodParam.enter(PARAM);
    node.value = this.eat(types.eq) ? this.parseMaybeAssign() : null;
    this.semicolon();
    this.prodParam.exit();
    this.scope.exit();
    return this.finishNode(node, "ClassPrivateProperty");
  }

  parseClassProperty(node) {
    if (!node.typeAnnotation) {
      this.expectPlugin("classProperties");
    }

    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
    this.prodParam.enter(PARAM);

    if (this.match(types.eq)) {
      this.expectPlugin("classProperties");
      this.next();
      node.value = this.parseMaybeAssign();
    } else {
      node.value = null;
    }

    this.semicolon();
    this.prodParam.exit();
    this.scope.exit();
    return this.finishNode(node, "ClassProperty");
  }

  parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {
    if (this.match(types.name)) {
      node.id = this.parseIdentifier();

      if (isStatement) {
        this.checkLVal(node.id, bindingType, undefined, "class name");
      }
    } else {
      if (optionalId || !isStatement) {
        node.id = null;
      } else {
        this.unexpected(null, ErrorMessages.MissingClassName);
      }
    }
  }

  parseClassSuper(node) {
    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
  }

  parseExport(node) {
    const hasDefault = this.maybeParseExportDefaultSpecifier(node);
    const parseAfterDefault = !hasDefault || this.eat(types.comma);
    const hasStar = parseAfterDefault && this.eatExportStar(node);
    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types.comma));
    const isFromRequired = hasDefault || hasStar;

    if (hasStar && !hasNamespace) {
      if (hasDefault) this.unexpected();
      this.parseExportFrom(node, true);
      return this.finishNode(node, "ExportAllDeclaration");
    }

    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);

    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
      throw this.unexpected(null, types.braceL);
    }

    let hasDeclaration;

    if (isFromRequired || hasSpecifiers) {
      hasDeclaration = false;
      this.parseExportFrom(node, isFromRequired);
    } else {
      hasDeclaration = this.maybeParseExportDeclaration(node);
    }

    if (isFromRequired || hasSpecifiers || hasDeclaration) {
      this.checkExport(node, true, false, !!node.source);
      return this.finishNode(node, "ExportNamedDeclaration");
    }

    if (this.eat(types._default)) {
      node.declaration = this.parseExportDefaultExpression();
      this.checkExport(node, true, true);
      return this.finishNode(node, "ExportDefaultDeclaration");
    }

    throw this.unexpected(null, types.braceL);
  }

  eatExportStar(node) {
    return this.eat(types.star);
  }

  maybeParseExportDefaultSpecifier(node) {
    if (this.isExportDefaultSpecifier()) {
      this.expectPlugin("exportDefaultFrom");
      const specifier = this.startNode();
      specifier.exported = this.parseIdentifier(true);
      node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
      return true;
    }

    return false;
  }

  maybeParseExportNamespaceSpecifier(node) {
    if (this.isContextual("as")) {
      if (!node.specifiers) node.specifiers = [];
      const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
      this.next();
      specifier.exported = this.parseIdentifier(true);
      node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
      return true;
    }

    return false;
  }

  maybeParseExportNamedSpecifiers(node) {
    if (this.match(types.braceL)) {
      if (!node.specifiers) node.specifiers = [];
      node.specifiers.push(...this.parseExportSpecifiers());
      node.source = null;
      node.declaration = null;
      return true;
    }

    return false;
  }

  maybeParseExportDeclaration(node) {
    if (this.shouldParseExportDeclaration()) {
      if (this.isContextual("async")) {
        const next = this.nextTokenStart();

        if (!this.isUnparsedContextual(next, "function")) {
          this.unexpected(next, types._function);
        }
      }

      node.specifiers = [];
      node.source = null;
      node.declaration = this.parseExportDeclaration(node);
      return true;
    }

    return false;
  }

  isAsyncFunction() {
    if (!this.isContextual("async")) return false;
    const next = this.nextTokenStart();
    return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
  }

  parseExportDefaultExpression() {
    const expr = this.startNode();
    const isAsync = this.isAsyncFunction();

    if (this.match(types._function) || isAsync) {
      this.next();

      if (isAsync) {
        this.next();
      }

      return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
    } else if (this.match(types._class)) {
      return this.parseClass(expr, true, true);
    } else if (this.match(types.at)) {
      if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
        this.raise(this.state.start, ErrorMessages.DecoratorBeforeExport);
      }

      this.parseDecorators(false);
      return this.parseClass(expr, true, true);
    } else if (this.match(types._const) || this.match(types._var) || this.isLet()) {
      throw this.raise(this.state.start, ErrorMessages.UnsupportedDefaultExport);
    } else {
      const res = this.parseMaybeAssign();
      this.semicolon();
      return res;
    }
  }

  parseExportDeclaration(node) {
    return this.parseStatement(null);
  }

  isExportDefaultSpecifier() {
    if (this.match(types.name)) {
      const value = this.state.value;

      if (value === "async" || value === "let") {
        return false;
      }

      if ((value === "type" || value === "interface") && !this.state.containsEsc) {
        const l = this.lookahead();

        if (l.type === types.name && l.value !== "from" || l.type === types.braceL) {
          this.expectOnePlugin(["flow", "typescript"]);
          return false;
        }
      }
    } else if (!this.match(types._default)) {
      return false;
    }

    const next = this.nextTokenStart();
    const hasFrom = this.isUnparsedContextual(next, "from");

    if (this.input.charCodeAt(next) === 44 || this.match(types.name) && hasFrom) {
      return true;
    }

    if (this.match(types._default) && hasFrom) {
      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
      return nextAfterFrom === 34 || nextAfterFrom === 39;
    }

    return false;
  }

  parseExportFrom(node, expect) {
    if (this.eatContextual("from")) {
      node.source = this.parseImportSource();
      this.checkExport(node);
    } else {
      if (expect) {
        this.unexpected();
      } else {
        node.source = null;
      }
    }

    this.semicolon();
  }

  shouldParseExportDeclaration() {
    if (this.match(types.at)) {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);

      if (this.hasPlugin("decorators")) {
        if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.unexpected(this.state.start, ErrorMessages.DecoratorBeforeExport);
        } else {
          return true;
        }
      }
    }

    return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
  }

  checkExport(node, checkNames, isDefault, isFrom) {
    if (checkNames) {
      if (isDefault) {
        this.checkDuplicateExports(node, "default");

        if (this.hasPlugin("exportDefaultFrom")) {
          var _declaration$extra;

          const declaration = node.declaration;

          if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) == null ? void 0 : _declaration$extra.parenthesized)) {
            this.raise(declaration.start, ErrorMessages.ExportDefaultFromAsIdentifier);
          }
        }
      } else if (node.specifiers && node.specifiers.length) {
        for (let _i4 = 0, _node$specifiers = node.specifiers; _i4 < _node$specifiers.length; _i4++) {
          const specifier = _node$specifiers[_i4];
          this.checkDuplicateExports(specifier, specifier.exported.name);

          if (!isFrom && specifier.local) {
            this.checkReservedWord(specifier.local.name, specifier.local.start, true, false);
            this.scope.checkLocalExport(specifier.local);
          }
        }
      } else if (node.declaration) {
        if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
          const id = node.declaration.id;
          if (!id) throw new Error("Assertion failure");
          this.checkDuplicateExports(node, id.name);
        } else if (node.declaration.type === "VariableDeclaration") {
          for (let _i5 = 0, _node$declaration$dec = node.declaration.declarations; _i5 < _node$declaration$dec.length; _i5++) {
            const declaration = _node$declaration$dec[_i5];
            this.checkDeclaration(declaration.id);
          }
        }
      }
    }

    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

    if (currentContextDecorators.length) {
      const isClass = node.declaration && (node.declaration.type === "ClassDeclaration" || node.declaration.type === "ClassExpression");

      if (!node.declaration || !isClass) {
        throw this.raise(node.start, ErrorMessages.UnsupportedDecoratorExport);
      }

      this.takeDecorators(node.declaration);
    }
  }

  checkDeclaration(node) {
    if (node.type === "Identifier") {
      this.checkDuplicateExports(node, node.name);
    } else if (node.type === "ObjectPattern") {
      for (let _i6 = 0, _node$properties = node.properties; _i6 < _node$properties.length; _i6++) {
        const prop = _node$properties[_i6];
        this.checkDeclaration(prop);
      }
    } else if (node.type === "ArrayPattern") {
      for (let _i7 = 0, _node$elements = node.elements; _i7 < _node$elements.length; _i7++) {
        const elem = _node$elements[_i7];

        if (elem) {
          this.checkDeclaration(elem);
        }
      }
    } else if (node.type === "ObjectProperty") {
      this.checkDeclaration(node.value);
    } else if (node.type === "RestElement") {
      this.checkDeclaration(node.argument);
    } else if (node.type === "AssignmentPattern") {
      this.checkDeclaration(node.left);
    }
  }

  checkDuplicateExports(node, name) {
    if (this.state.exportedIdentifiers.indexOf(name) > -1) {
      this.raise(node.start, name === "default" ? ErrorMessages.DuplicateDefaultExport : ErrorMessages.DuplicateExport, name);
    }

    this.state.exportedIdentifiers.push(name);
  }

  parseExportSpecifiers() {
    const nodes = [];
    let first = true;
    this.expect(types.braceL);

    while (!this.eat(types.braceR)) {
      if (first) {
        first = false;
      } else {
        this.expect(types.comma);
        if (this.eat(types.braceR)) break;
      }

      const node = this.startNode();
      node.local = this.parseIdentifier(true);
      node.exported = this.eatContextual("as") ? this.parseIdentifier(true) : node.local.__clone();
      nodes.push(this.finishNode(node, "ExportSpecifier"));
    }

    return nodes;
  }

  parseImport(node) {
    node.specifiers = [];

    if (!this.match(types.string)) {
      const hasDefault = this.maybeParseDefaultImportSpecifier(node);
      const parseNext = !hasDefault || this.eat(types.comma);
      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
      this.expectContextual("from");
    }

    node.source = this.parseImportSource();
    const attributes = this.maybeParseModuleAttributes();

    if (attributes) {
      node.attributes = attributes;
    }

    this.semicolon();
    return this.finishNode(node, "ImportDeclaration");
  }

  parseImportSource() {
    if (!this.match(types.string)) this.unexpected();
    return this.parseExprAtom();
  }

  shouldParseDefaultImport(node) {
    return this.match(types.name);
  }

  parseImportSpecifierLocal(node, specifier, type, contextDescription) {
    specifier.local = this.parseIdentifier();
    this.checkLVal(specifier.local, BIND_LEXICAL, undefined, contextDescription);
    node.specifiers.push(this.finishNode(specifier, type));
  }

  maybeParseModuleAttributes() {
    if (this.match(types._with) && !this.hasPrecedingLineBreak()) {
      this.expectPlugin("moduleAttributes");
      this.next();
    } else {
      if (this.hasPlugin("moduleAttributes")) return [];
      return null;
    }

    const attrs = [];
    const attributes = new Set();

    do {
      const node = this.startNode();
      node.key = this.parseIdentifier(true);

      if (node.key.name !== "type") {
        this.raise(node.key.start, ErrorMessages.ModuleAttributeDifferentFromType, node.key.name);
      }

      if (attributes.has(node.key.name)) {
        this.raise(node.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, node.key.name);
      }

      attributes.add(node.key.name);
      this.expect(types.colon);

      if (!this.match(types.string)) {
        throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
      }

      node.value = this.parseLiteral(this.state.value, "StringLiteral");
      this.finishNode(node, "ImportAttribute");
      attrs.push(node);
    } while (this.eat(types.comma));

    return attrs;
  }

  maybeParseDefaultImportSpecifier(node) {
    if (this.shouldParseDefaultImport(node)) {
      this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
      return true;
    }

    return false;
  }

  maybeParseStarImportSpecifier(node) {
    if (this.match(types.star)) {
      const specifier = this.startNode();
      this.next();
      this.expectContextual("as");
      this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier", "import namespace specifier");
      return true;
    }

    return false;
  }

  parseNamedImportSpecifiers(node) {
    let first = true;
    this.expect(types.braceL);

    while (!this.eat(types.braceR)) {
      if (first) {
        first = false;
      } else {
        if (this.eat(types.colon)) {
          throw this.raise(this.state.start, ErrorMessages.DestructureNamedImport);
        }

        this.expect(types.comma);
        if (this.eat(types.braceR)) break;
      }

      this.parseImportSpecifier(node);
    }
  }

  parseImportSpecifier(node) {
    const specifier = this.startNode();
    specifier.imported = this.parseIdentifier(true);

    if (this.eatContextual("as")) {
      specifier.local = this.parseIdentifier();
    } else {
      this.checkReservedWord(specifier.imported.name, specifier.start, true, true);
      specifier.local = specifier.imported.__clone();
    }

    this.checkLVal(specifier.local, BIND_LEXICAL, undefined, "import specifier");
    node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
  }

}

class ClassScope {
  constructor() {
    this.privateNames = new Set();
    this.loneAccessors = new Map();
    this.undefinedPrivateNames = new Map();
  }

}
class ClassScopeHandler {
  constructor(raise) {
    this.stack = [];
    this.undefinedPrivateNames = new Map();
    this.raise = raise;
  }

  current() {
    return this.stack[this.stack.length - 1];
  }

  enter() {
    this.stack.push(new ClassScope());
  }

  exit() {
    const oldClassScope = this.stack.pop();
    const current = this.current();

    for (let _i = 0, _Array$from = Array.from(oldClassScope.undefinedPrivateNames); _i < _Array$from.length; _i++) {
      const [name, pos] = _Array$from[_i];

      if (current) {
        if (!current.undefinedPrivateNames.has(name)) {
          current.undefinedPrivateNames.set(name, pos);
        }
      } else {
        this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
      }
    }
  }

  declarePrivateName(name, elementType, pos) {
    const classScope = this.current();
    let redefined = classScope.privateNames.has(name);

    if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
      const accessor = redefined && classScope.loneAccessors.get(name);

      if (accessor) {
        const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
        const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
        const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
        const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
        redefined = oldKind === newKind || oldStatic !== newStatic;
        if (!redefined) classScope.loneAccessors.delete(name);
      } else if (!redefined) {
        classScope.loneAccessors.set(name, elementType);
      }
    }

    if (redefined) {
      this.raise(pos, ErrorMessages.PrivateNameRedeclaration, name);
    }

    classScope.privateNames.add(name);
    classScope.undefinedPrivateNames.delete(name);
  }

  usePrivateName(name, pos) {
    let classScope;

    for (let _i2 = 0, _this$stack = this.stack; _i2 < _this$stack.length; _i2++) {
      classScope = _this$stack[_i2];
      if (classScope.privateNames.has(name)) return;
    }

    if (classScope) {
      classScope.undefinedPrivateNames.set(name, pos);
    } else {
      this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
    }
  }

}

class Parser extends StatementParser {
  constructor(options, input) {
    options = getOptions(options);
    super(options, input);
    const ScopeHandler = this.getScopeHandler();
    this.options = options;
    this.inModule = this.options.sourceType === "module";
    this.scope = new ScopeHandler(this.raise.bind(this), this.inModule);
    this.prodParam = new ProductionParameterHandler();
    this.classScope = new ClassScopeHandler(this.raise.bind(this));
    this.plugins = pluginsMap(this.options.plugins);
    this.filename = options.sourceFilename;
  }

  getScopeHandler() {
    return ScopeHandler;
  }

  parse() {
    let paramFlags = PARAM;

    if (this.hasPlugin("topLevelAwait") && this.inModule) {
      paramFlags |= PARAM_AWAIT;
    }

    this.scope.enter(SCOPE_PROGRAM);
    this.prodParam.enter(paramFlags);
    const file = this.startNode();
    const program = this.startNode();
    this.nextToken();
    file.errors = null;
    this.parseTopLevel(file, program);
    file.errors = this.state.errors;
    return file;
  }

}

function pluginsMap(plugins) {
  const pluginMap = new Map();

  for (let _i = 0; _i < plugins.length; _i++) {
    const plugin = plugins[_i];
    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];
    if (!pluginMap.has(name)) pluginMap.set(name, options || {});
  }

  return pluginMap;
}

function parse(input, options) {
  var _options;

  if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
    options = Object.assign({}, options);

    try {
      options.sourceType = "module";
      const parser = getParser(options, input);
      const ast = parser.parse();

      if (parser.sawUnambiguousESM) {
        return ast;
      }

      if (parser.ambiguousScriptDifferentAst) {
        try {
          options.sourceType = "script";
          return getParser(options, input).parse();
        } catch (_unused) {}
      } else {
        ast.program.sourceType = "script";
      }

      return ast;
    } catch (moduleError) {
      try {
        options.sourceType = "script";
        return getParser(options, input).parse();
      } catch (_unused2) {}

      throw moduleError;
    }
  } else {
    return getParser(options, input).parse();
  }
}
function parseExpression(input, options) {
  const parser = getParser(options, input);

  if (parser.options.strictMode) {
    parser.state.strict = true;
  }

  return parser.getExpression();
}

function getParser(options, input) {
  let cls = Parser;

  if (options == null ? void 0 : options.plugins) {
    validatePlugins(options.plugins);
    cls = getParserClass(options.plugins);
  }

  return new cls(options, input);
}

const parserClassCache = {};

function getParserClass(pluginsFromOptions) {
  const pluginList = mixinPluginNames.filter(name => hasPlugin(pluginsFromOptions, name));
  const key = pluginList.join("/");
  let cls = parserClassCache[key];

  if (!cls) {
    cls = Parser;

    for (let _i = 0; _i < pluginList.length; _i++) {
      const plugin = pluginList[_i];
      cls = mixinPlugins[plugin](cls);
    }

    parserClassCache[key] = cls;
  }

  return cls;
}

exports.parse = parse;
exports.parseExpression = parseExpression;
exports.tokTypes = types;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@babel/types/lib/asserts/assertNode.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/types/lib/asserts/assertNode.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assertNode;

var _isNode = _interopRequireDefault(__webpack_require__(/*! ../validators/isNode */ "./node_modules/@babel/types/lib/validators/isNode.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function assertNode(node) {
  if (!(0, _isNode.default)(node)) {
    var _node$type;

    const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
    throw new TypeError(`Not a valid node of type "${type}"`);
  }
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/asserts/generated/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/asserts/generated/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assertArrayExpression = assertArrayExpression;
exports.assertAssignmentExpression = assertAssignmentExpression;
exports.assertBinaryExpression = assertBinaryExpression;
exports.assertInterpreterDirective = assertInterpreterDirective;
exports.assertDirective = assertDirective;
exports.assertDirectiveLiteral = assertDirectiveLiteral;
exports.assertBlockStatement = assertBlockStatement;
exports.assertBreakStatement = assertBreakStatement;
exports.assertCallExpression = assertCallExpression;
exports.assertCatchClause = assertCatchClause;
exports.assertConditionalExpression = assertConditionalExpression;
exports.assertContinueStatement = assertContinueStatement;
exports.assertDebuggerStatement = assertDebuggerStatement;
exports.assertDoWhileStatement = assertDoWhileStatement;
exports.assertEmptyStatement = assertEmptyStatement;
exports.assertExpressionStatement = assertExpressionStatement;
exports.assertFile = assertFile;
exports.assertForInStatement = assertForInStatement;
exports.assertForStatement = assertForStatement;
exports.assertFunctionDeclaration = assertFunctionDeclaration;
exports.assertFunctionExpression = assertFunctionExpression;
exports.assertIdentifier = assertIdentifier;
exports.assertIfStatement = assertIfStatement;
exports.assertLabeledStatement = assertLabeledStatement;
exports.assertStringLiteral = assertStringLiteral;
exports.assertNumericLiteral = assertNumericLiteral;
exports.assertNullLiteral = assertNullLiteral;
exports.assertBooleanLiteral = assertBooleanLiteral;
exports.assertRegExpLiteral = assertRegExpLiteral;
exports.assertLogicalExpression = assertLogicalExpression;
exports.assertMemberExpression = assertMemberExpression;
exports.assertNewExpression = assertNewExpression;
exports.assertProgram = assertProgram;
exports.assertObjectExpression = assertObjectExpression;
exports.assertObjectMethod = assertObjectMethod;
exports.assertObjectProperty = assertObjectProperty;
exports.assertRestElement = assertRestElement;
exports.assertReturnStatement = assertReturnStatement;
exports.assertSequenceExpression = assertSequenceExpression;
exports.assertParenthesizedExpression = assertParenthesizedExpression;
exports.assertSwitchCase = assertSwitchCase;
exports.assertSwitchStatement = assertSwitchStatement;
exports.assertThisExpression = assertThisExpression;
exports.assertThrowStatement = assertThrowStatement;
exports.assertTryStatement = assertTryStatement;
exports.assertUnaryExpression = assertUnaryExpression;
exports.assertUpdateExpression = assertUpdateExpression;
exports.assertVariableDeclaration = assertVariableDeclaration;
exports.assertVariableDeclarator = assertVariableDeclarator;
exports.assertWhileStatement = assertWhileStatement;
exports.assertWithStatement = assertWithStatement;
exports.assertAssignmentPattern = assertAssignmentPattern;
exports.assertArrayPattern = assertArrayPattern;
exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
exports.assertClassBody = assertClassBody;
exports.assertClassExpression = assertClassExpression;
exports.assertClassDeclaration = assertClassDeclaration;
exports.assertExportAllDeclaration = assertExportAllDeclaration;
exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
exports.assertExportSpecifier = assertExportSpecifier;
exports.assertForOfStatement = assertForOfStatement;
exports.assertImportDeclaration = assertImportDeclaration;
exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
exports.assertImportSpecifier = assertImportSpecifier;
exports.assertMetaProperty = assertMetaProperty;
exports.assertClassMethod = assertClassMethod;
exports.assertObjectPattern = assertObjectPattern;
exports.assertSpreadElement = assertSpreadElement;
exports.assertSuper = assertSuper;
exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
exports.assertTemplateElement = assertTemplateElement;
exports.assertTemplateLiteral = assertTemplateLiteral;
exports.assertYieldExpression = assertYieldExpression;
exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
exports.assertClassImplements = assertClassImplements;
exports.assertDeclareClass = assertDeclareClass;
exports.assertDeclareFunction = assertDeclareFunction;
exports.assertDeclareInterface = assertDeclareInterface;
exports.assertDeclareModule = assertDeclareModule;
exports.assertDeclareModuleExports = assertDeclareModuleExports;
exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
exports.assertDeclareVariable = assertDeclareVariable;
exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
exports.assertDeclaredPredicate = assertDeclaredPredicate;
exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
exports.assertFunctionTypeParam = assertFunctionTypeParam;
exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
exports.assertInferredPredicate = assertInferredPredicate;
exports.assertInterfaceExtends = assertInterfaceExtends;
exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
exports.assertObjectTypeProperty = assertObjectTypeProperty;
exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
exports.assertOpaqueType = assertOpaqueType;
exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
exports.assertTypeAlias = assertTypeAlias;
exports.assertTypeAnnotation = assertTypeAnnotation;
exports.assertTypeCastExpression = assertTypeCastExpression;
exports.assertTypeParameter = assertTypeParameter;
exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
exports.assertVariance = assertVariance;
exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
exports.assertEnumDeclaration = assertEnumDeclaration;
exports.assertEnumBooleanBody = assertEnumBooleanBody;
exports.assertEnumNumberBody = assertEnumNumberBody;
exports.assertEnumStringBody = assertEnumStringBody;
exports.assertEnumSymbolBody = assertEnumSymbolBody;
exports.assertEnumBooleanMember = assertEnumBooleanMember;
exports.assertEnumNumberMember = assertEnumNumberMember;
exports.assertEnumStringMember = assertEnumStringMember;
exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
exports.assertJSXAttribute = assertJSXAttribute;
exports.assertJSXClosingElement = assertJSXClosingElement;
exports.assertJSXElement = assertJSXElement;
exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
exports.assertJSXSpreadChild = assertJSXSpreadChild;
exports.assertJSXIdentifier = assertJSXIdentifier;
exports.assertJSXMemberExpression = assertJSXMemberExpression;
exports.assertJSXNamespacedName = assertJSXNamespacedName;
exports.assertJSXOpeningElement = assertJSXOpeningElement;
exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
exports.assertJSXText = assertJSXText;
exports.assertJSXFragment = assertJSXFragment;
exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
exports.assertJSXClosingFragment = assertJSXClosingFragment;
exports.assertNoop = assertNoop;
exports.assertPlaceholder = assertPlaceholder;
exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
exports.assertAwaitExpression = assertAwaitExpression;
exports.assertBindExpression = assertBindExpression;
exports.assertClassProperty = assertClassProperty;
exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
exports.assertPipelineBareFunction = assertPipelineBareFunction;
exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
exports.assertOptionalCallExpression = assertOptionalCallExpression;
exports.assertClassPrivateProperty = assertClassPrivateProperty;
exports.assertClassPrivateMethod = assertClassPrivateMethod;
exports.assertImport = assertImport;
exports.assertImportAttribute = assertImportAttribute;
exports.assertDecorator = assertDecorator;
exports.assertDoExpression = assertDoExpression;
exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
exports.assertPrivateName = assertPrivateName;
exports.assertBigIntLiteral = assertBigIntLiteral;
exports.assertRecordExpression = assertRecordExpression;
exports.assertTupleExpression = assertTupleExpression;
exports.assertTSParameterProperty = assertTSParameterProperty;
exports.assertTSDeclareFunction = assertTSDeclareFunction;
exports.assertTSDeclareMethod = assertTSDeclareMethod;
exports.assertTSQualifiedName = assertTSQualifiedName;
exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
exports.assertTSPropertySignature = assertTSPropertySignature;
exports.assertTSMethodSignature = assertTSMethodSignature;
exports.assertTSIndexSignature = assertTSIndexSignature;
exports.assertTSAnyKeyword = assertTSAnyKeyword;
exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
exports.assertTSNeverKeyword = assertTSNeverKeyword;
exports.assertTSNullKeyword = assertTSNullKeyword;
exports.assertTSNumberKeyword = assertTSNumberKeyword;
exports.assertTSObjectKeyword = assertTSObjectKeyword;
exports.assertTSStringKeyword = assertTSStringKeyword;
exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
exports.assertTSVoidKeyword = assertTSVoidKeyword;
exports.assertTSThisType = assertTSThisType;
exports.assertTSFunctionType = assertTSFunctionType;
exports.assertTSConstructorType = assertTSConstructorType;
exports.assertTSTypeReference = assertTSTypeReference;
exports.assertTSTypePredicate = assertTSTypePredicate;
exports.assertTSTypeQuery = assertTSTypeQuery;
exports.assertTSTypeLiteral = assertTSTypeLiteral;
exports.assertTSArrayType = assertTSArrayType;
exports.assertTSTupleType = assertTSTupleType;
exports.assertTSOptionalType = assertTSOptionalType;
exports.assertTSRestType = assertTSRestType;
exports.assertTSUnionType = assertTSUnionType;
exports.assertTSIntersectionType = assertTSIntersectionType;
exports.assertTSConditionalType = assertTSConditionalType;
exports.assertTSInferType = assertTSInferType;
exports.assertTSParenthesizedType = assertTSParenthesizedType;
exports.assertTSTypeOperator = assertTSTypeOperator;
exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
exports.assertTSMappedType = assertTSMappedType;
exports.assertTSLiteralType = assertTSLiteralType;
exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
exports.assertTSInterfaceBody = assertTSInterfaceBody;
exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
exports.assertTSAsExpression = assertTSAsExpression;
exports.assertTSTypeAssertion = assertTSTypeAssertion;
exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
exports.assertTSEnumMember = assertTSEnumMember;
exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
exports.assertTSModuleBlock = assertTSModuleBlock;
exports.assertTSImportType = assertTSImportType;
exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
exports.assertTSNonNullExpression = assertTSNonNullExpression;
exports.assertTSExportAssignment = assertTSExportAssignment;
exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
exports.assertTSTypeParameter = assertTSTypeParameter;
exports.assertExpression = assertExpression;
exports.assertBinary = assertBinary;
exports.assertScopable = assertScopable;
exports.assertBlockParent = assertBlockParent;
exports.assertBlock = assertBlock;
exports.assertStatement = assertStatement;
exports.assertTerminatorless = assertTerminatorless;
exports.assertCompletionStatement = assertCompletionStatement;
exports.assertConditional = assertConditional;
exports.assertLoop = assertLoop;
exports.assertWhile = assertWhile;
exports.assertExpressionWrapper = assertExpressionWrapper;
exports.assertFor = assertFor;
exports.assertForXStatement = assertForXStatement;
exports.assertFunction = assertFunction;
exports.assertFunctionParent = assertFunctionParent;
exports.assertPureish = assertPureish;
exports.assertDeclaration = assertDeclaration;
exports.assertPatternLike = assertPatternLike;
exports.assertLVal = assertLVal;
exports.assertTSEntityName = assertTSEntityName;
exports.assertLiteral = assertLiteral;
exports.assertImmutable = assertImmutable;
exports.assertUserWhitespacable = assertUserWhitespacable;
exports.assertMethod = assertMethod;
exports.assertObjectMember = assertObjectMember;
exports.assertProperty = assertProperty;
exports.assertUnaryLike = assertUnaryLike;
exports.assertPattern = assertPattern;
exports.assertClass = assertClass;
exports.assertModuleDeclaration = assertModuleDeclaration;
exports.assertExportDeclaration = assertExportDeclaration;
exports.assertModuleSpecifier = assertModuleSpecifier;
exports.assertFlow = assertFlow;
exports.assertFlowType = assertFlowType;
exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
exports.assertFlowDeclaration = assertFlowDeclaration;
exports.assertFlowPredicate = assertFlowPredicate;
exports.assertEnumBody = assertEnumBody;
exports.assertEnumMember = assertEnumMember;
exports.assertJSX = assertJSX;
exports.assertPrivate = assertPrivate;
exports.assertTSTypeElement = assertTSTypeElement;
exports.assertTSType = assertTSType;
exports.assertTSBaseType = assertTSBaseType;
exports.assertNumberLiteral = assertNumberLiteral;
exports.assertRegexLiteral = assertRegexLiteral;
exports.assertRestProperty = assertRestProperty;
exports.assertSpreadProperty = assertSpreadProperty;

var _is = _interopRequireDefault(__webpack_require__(/*! ../../validators/is */ "./node_modules/@babel/types/lib/validators/is.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function assert(type, node, opts) {
  if (!(0, _is.default)(type, node, opts)) {
    throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, ` + `but instead got "${node.type}".`);
  }
}

function assertArrayExpression(node, opts = {}) {
  assert("ArrayExpression", node, opts);
}

function assertAssignmentExpression(node, opts = {}) {
  assert("AssignmentExpression", node, opts);
}

function assertBinaryExpression(node, opts = {}) {
  assert("BinaryExpression", node, opts);
}

function assertInterpreterDirective(node, opts = {}) {
  assert("InterpreterDirective", node, opts);
}

function assertDirective(node, opts = {}) {
  assert("Directive", node, opts);
}

function assertDirectiveLiteral(node, opts = {}) {
  assert("DirectiveLiteral", node, opts);
}

function assertBlockStatement(node, opts = {}) {
  assert("BlockStatement", node, opts);
}

function assertBreakStatement(node, opts = {}) {
  assert("BreakStatement", node, opts);
}

function assertCallExpression(node, opts = {}) {
  assert("CallExpression", node, opts);
}

function assertCatchClause(node, opts = {}) {
  assert("CatchClause", node, opts);
}

function assertConditionalExpression(node, opts = {}) {
  assert("ConditionalExpression", node, opts);
}

function assertContinueStatement(node, opts = {}) {
  assert("ContinueStatement", node, opts);
}

function assertDebuggerStatement(node, opts = {}) {
  assert("DebuggerStatement", node, opts);
}

function assertDoWhileStatement(node, opts = {}) {
  assert("DoWhileStatement", node, opts);
}

function assertEmptyStatement(node, opts = {}) {
  assert("EmptyStatement", node, opts);
}

function assertExpressionStatement(node, opts = {}) {
  assert("ExpressionStatement", node, opts);
}

function assertFile(node, opts = {}) {
  assert("File", node, opts);
}

function assertForInStatement(node, opts = {}) {
  assert("ForInStatement", node, opts);
}

function assertForStatement(node, opts = {}) {
  assert("ForStatement", node, opts);
}

function assertFunctionDeclaration(node, opts = {}) {
  assert("FunctionDeclaration", node, opts);
}

function assertFunctionExpression(node, opts = {}) {
  assert("FunctionExpression", node, opts);
}

function assertIdentifier(node, opts = {}) {
  assert("Identifier", node, opts);
}

function assertIfStatement(node, opts = {}) {
  assert("IfStatement", node, opts);
}

function assertLabeledStatement(node, opts = {}) {
  assert("LabeledStatement", node, opts);
}

function assertStringLiteral(node, opts = {}) {
  assert("StringLiteral", node, opts);
}

function assertNumericLiteral(node, opts = {}) {
  assert("NumericLiteral", node, opts);
}

function assertNullLiteral(node, opts = {}) {
  assert("NullLiteral", node, opts);
}

function assertBooleanLiteral(node, opts = {}) {
  assert("BooleanLiteral", node, opts);
}

function assertRegExpLiteral(node, opts = {}) {
  assert("RegExpLiteral", node, opts);
}

function assertLogicalExpression(node, opts = {}) {
  assert("LogicalExpression", node, opts);
}

function assertMemberExpression(node, opts = {}) {
  assert("MemberExpression", node, opts);
}

function assertNewExpression(node, opts = {}) {
  assert("NewExpression", node, opts);
}

function assertProgram(node, opts = {}) {
  assert("Program", node, opts);
}

function assertObjectExpression(node, opts = {}) {
  assert("ObjectExpression", node, opts);
}

function assertObjectMethod(node, opts = {}) {
  assert("ObjectMethod", node, opts);
}

function assertObjectProperty(node, opts = {}) {
  assert("ObjectProperty", node, opts);
}

function assertRestElement(node, opts = {}) {
  assert("RestElement", node, opts);
}

function assertReturnStatement(node, opts = {}) {
  assert("ReturnStatement", node, opts);
}

function assertSequenceExpression(node, opts = {}) {
  assert("SequenceExpression", node, opts);
}

function assertParenthesizedExpression(node, opts = {}) {
  assert("ParenthesizedExpression", node, opts);
}

function assertSwitchCase(node, opts = {}) {
  assert("SwitchCase", node, opts);
}

function assertSwitchStatement(node, opts = {}) {
  assert("SwitchStatement", node, opts);
}

function assertThisExpression(node, opts = {}) {
  assert("ThisExpression", node, opts);
}

function assertThrowStatement(node, opts = {}) {
  assert("ThrowStatement", node, opts);
}

function assertTryStatement(node, opts = {}) {
  assert("TryStatement", node, opts);
}

function assertUnaryExpression(node, opts = {}) {
  assert("UnaryExpression", node, opts);
}

function assertUpdateExpression(node, opts = {}) {
  assert("UpdateExpression", node, opts);
}

function assertVariableDeclaration(node, opts = {}) {
  assert("VariableDeclaration", node, opts);
}

function assertVariableDeclarator(node, opts = {}) {
  assert("VariableDeclarator", node, opts);
}

function assertWhileStatement(node, opts = {}) {
  assert("WhileStatement", node, opts);
}

function assertWithStatement(node, opts = {}) {
  assert("WithStatement", node, opts);
}

function assertAssignmentPattern(node, opts = {}) {
  assert("AssignmentPattern", node, opts);
}

function assertArrayPattern(node, opts = {}) {
  assert("ArrayPattern", node, opts);
}

function assertArrowFunctionExpression(node, opts = {}) {
  assert("ArrowFunctionExpression", node, opts);
}

function assertClassBody(node, opts = {}) {
  assert("ClassBody", node, opts);
}

function assertClassExpression(node, opts = {}) {
  assert("ClassExpression", node, opts);
}

function assertClassDeclaration(node, opts = {}) {
  assert("ClassDeclaration", node, opts);
}

function assertExportAllDeclaration(node, opts = {}) {
  assert("ExportAllDeclaration", node, opts);
}

function assertExportDefaultDeclaration(node, opts = {}) {
  assert("ExportDefaultDeclaration", node, opts);
}

function assertExportNamedDeclaration(node, opts = {}) {
  assert("ExportNamedDeclaration", node, opts);
}

function assertExportSpecifier(node, opts = {}) {
  assert("ExportSpecifier", node, opts);
}

function assertForOfStatement(node, opts = {}) {
  assert("ForOfStatement", node, opts);
}

function assertImportDeclaration(node, opts = {}) {
  assert("ImportDeclaration", node, opts);
}

function assertImportDefaultSpecifier(node, opts = {}) {
  assert("ImportDefaultSpecifier", node, opts);
}

function assertImportNamespaceSpecifier(node, opts = {}) {
  assert("ImportNamespaceSpecifier", node, opts);
}

function assertImportSpecifier(node, opts = {}) {
  assert("ImportSpecifier", node, opts);
}

function assertMetaProperty(node, opts = {}) {
  assert("MetaProperty", node, opts);
}

function assertClassMethod(node, opts = {}) {
  assert("ClassMethod", node, opts);
}

function assertObjectPattern(node, opts = {}) {
  assert("ObjectPattern", node, opts);
}

function assertSpreadElement(node, opts = {}) {
  assert("SpreadElement", node, opts);
}

function assertSuper(node, opts = {}) {
  assert("Super", node, opts);
}

function assertTaggedTemplateExpression(node, opts = {}) {
  assert("TaggedTemplateExpression", node, opts);
}

function assertTemplateElement(node, opts = {}) {
  assert("TemplateElement", node, opts);
}

function assertTemplateLiteral(node, opts = {}) {
  assert("TemplateLiteral", node, opts);
}

function assertYieldExpression(node, opts = {}) {
  assert("YieldExpression", node, opts);
}

function assertAnyTypeAnnotation(node, opts = {}) {
  assert("AnyTypeAnnotation", node, opts);
}

function assertArrayTypeAnnotation(node, opts = {}) {
  assert("ArrayTypeAnnotation", node, opts);
}

function assertBooleanTypeAnnotation(node, opts = {}) {
  assert("BooleanTypeAnnotation", node, opts);
}

function assertBooleanLiteralTypeAnnotation(node, opts = {}) {
  assert("BooleanLiteralTypeAnnotation", node, opts);
}

function assertNullLiteralTypeAnnotation(node, opts = {}) {
  assert("NullLiteralTypeAnnotation", node, opts);
}

function assertClassImplements(node, opts = {}) {
  assert("ClassImplements", node, opts);
}

function assertDeclareClass(node, opts = {}) {
  assert("DeclareClass", node, opts);
}

function assertDeclareFunction(node, opts = {}) {
  assert("DeclareFunction", node, opts);
}

function assertDeclareInterface(node, opts = {}) {
  assert("DeclareInterface", node, opts);
}

function assertDeclareModule(node, opts = {}) {
  assert("DeclareModule", node, opts);
}

function assertDeclareModuleExports(node, opts = {}) {
  assert("DeclareModuleExports", node, opts);
}

function assertDeclareTypeAlias(node, opts = {}) {
  assert("DeclareTypeAlias", node, opts);
}

function assertDeclareOpaqueType(node, opts = {}) {
  assert("DeclareOpaqueType", node, opts);
}

function assertDeclareVariable(node, opts = {}) {
  assert("DeclareVariable", node, opts);
}

function assertDeclareExportDeclaration(node, opts = {}) {
  assert("DeclareExportDeclaration", node, opts);
}

function assertDeclareExportAllDeclaration(node, opts = {}) {
  assert("DeclareExportAllDeclaration", node, opts);
}

function assertDeclaredPredicate(node, opts = {}) {
  assert("DeclaredPredicate", node, opts);
}

function assertExistsTypeAnnotation(node, opts = {}) {
  assert("ExistsTypeAnnotation", node, opts);
}

function assertFunctionTypeAnnotation(node, opts = {}) {
  assert("FunctionTypeAnnotation", node, opts);
}

function assertFunctionTypeParam(node, opts = {}) {
  assert("FunctionTypeParam", node, opts);
}

function assertGenericTypeAnnotation(node, opts = {}) {
  assert("GenericTypeAnnotation", node, opts);
}

function assertInferredPredicate(node, opts = {}) {
  assert("InferredPredicate", node, opts);
}

function assertInterfaceExtends(node, opts = {}) {
  assert("InterfaceExtends", node, opts);
}

function assertInterfaceDeclaration(node, opts = {}) {
  assert("InterfaceDeclaration", node, opts);
}

function assertInterfaceTypeAnnotation(node, opts = {}) {
  assert("InterfaceTypeAnnotation", node, opts);
}

function assertIntersectionTypeAnnotation(node, opts = {}) {
  assert("IntersectionTypeAnnotation", node, opts);
}

function assertMixedTypeAnnotation(node, opts = {}) {
  assert("MixedTypeAnnotation", node, opts);
}

function assertEmptyTypeAnnotation(node, opts = {}) {
  assert("EmptyTypeAnnotation", node, opts);
}

function assertNullableTypeAnnotation(node, opts = {}) {
  assert("NullableTypeAnnotation", node, opts);
}

function assertNumberLiteralTypeAnnotation(node, opts = {}) {
  assert("NumberLiteralTypeAnnotation", node, opts);
}

function assertNumberTypeAnnotation(node, opts = {}) {
  assert("NumberTypeAnnotation", node, opts);
}

function assertObjectTypeAnnotation(node, opts = {}) {
  assert("ObjectTypeAnnotation", node, opts);
}

function assertObjectTypeInternalSlot(node, opts = {}) {
  assert("ObjectTypeInternalSlot", node, opts);
}

function assertObjectTypeCallProperty(node, opts = {}) {
  assert("ObjectTypeCallProperty", node, opts);
}

function assertObjectTypeIndexer(node, opts = {}) {
  assert("ObjectTypeIndexer", node, opts);
}

function assertObjectTypeProperty(node, opts = {}) {
  assert("ObjectTypeProperty", node, opts);
}

function assertObjectTypeSpreadProperty(node, opts = {}) {
  assert("ObjectTypeSpreadProperty", node, opts);
}

function assertOpaqueType(node, opts = {}) {
  assert("OpaqueType", node, opts);
}

function assertQualifiedTypeIdentifier(node, opts = {}) {
  assert("QualifiedTypeIdentifier", node, opts);
}

function assertStringLiteralTypeAnnotation(node, opts = {}) {
  assert("StringLiteralTypeAnnotation", node, opts);
}

function assertStringTypeAnnotation(node, opts = {}) {
  assert("StringTypeAnnotation", node, opts);
}

function assertSymbolTypeAnnotation(node, opts = {}) {
  assert("SymbolTypeAnnotation", node, opts);
}

function assertThisTypeAnnotation(node, opts = {}) {
  assert("ThisTypeAnnotation", node, opts);
}

function assertTupleTypeAnnotation(node, opts = {}) {
  assert("TupleTypeAnnotation", node, opts);
}

function assertTypeofTypeAnnotation(node, opts = {}) {
  assert("TypeofTypeAnnotation", node, opts);
}

function assertTypeAlias(node, opts = {}) {
  assert("TypeAlias", node, opts);
}

function assertTypeAnnotation(node, opts = {}) {
  assert("TypeAnnotation", node, opts);
}

function assertTypeCastExpression(node, opts = {}) {
  assert("TypeCastExpression", node, opts);
}

function assertTypeParameter(node, opts = {}) {
  assert("TypeParameter", node, opts);
}

function assertTypeParameterDeclaration(node, opts = {}) {
  assert("TypeParameterDeclaration", node, opts);
}

function assertTypeParameterInstantiation(node, opts = {}) {
  assert("TypeParameterInstantiation", node, opts);
}

function assertUnionTypeAnnotation(node, opts = {}) {
  assert("UnionTypeAnnotation", node, opts);
}

function assertVariance(node, opts = {}) {
  assert("Variance", node, opts);
}

function assertVoidTypeAnnotation(node, opts = {}) {
  assert("VoidTypeAnnotation", node, opts);
}

function assertEnumDeclaration(node, opts = {}) {
  assert("EnumDeclaration", node, opts);
}

function assertEnumBooleanBody(node, opts = {}) {
  assert("EnumBooleanBody", node, opts);
}

function assertEnumNumberBody(node, opts = {}) {
  assert("EnumNumberBody", node, opts);
}

function assertEnumStringBody(node, opts = {}) {
  assert("EnumStringBody", node, opts);
}

function assertEnumSymbolBody(node, opts = {}) {
  assert("EnumSymbolBody", node, opts);
}

function assertEnumBooleanMember(node, opts = {}) {
  assert("EnumBooleanMember", node, opts);
}

function assertEnumNumberMember(node, opts = {}) {
  assert("EnumNumberMember", node, opts);
}

function assertEnumStringMember(node, opts = {}) {
  assert("EnumStringMember", node, opts);
}

function assertEnumDefaultedMember(node, opts = {}) {
  assert("EnumDefaultedMember", node, opts);
}

function assertJSXAttribute(node, opts = {}) {
  assert("JSXAttribute", node, opts);
}

function assertJSXClosingElement(node, opts = {}) {
  assert("JSXClosingElement", node, opts);
}

function assertJSXElement(node, opts = {}) {
  assert("JSXElement", node, opts);
}

function assertJSXEmptyExpression(node, opts = {}) {
  assert("JSXEmptyExpression", node, opts);
}

function assertJSXExpressionContainer(node, opts = {}) {
  assert("JSXExpressionContainer", node, opts);
}

function assertJSXSpreadChild(node, opts = {}) {
  assert("JSXSpreadChild", node, opts);
}

function assertJSXIdentifier(node, opts = {}) {
  assert("JSXIdentifier", node, opts);
}

function assertJSXMemberExpression(node, opts = {}) {
  assert("JSXMemberExpression", node, opts);
}

function assertJSXNamespacedName(node, opts = {}) {
  assert("JSXNamespacedName", node, opts);
}

function assertJSXOpeningElement(node, opts = {}) {
  assert("JSXOpeningElement", node, opts);
}

function assertJSXSpreadAttribute(node, opts = {}) {
  assert("JSXSpreadAttribute", node, opts);
}

function assertJSXText(node, opts = {}) {
  assert("JSXText", node, opts);
}

function assertJSXFragment(node, opts = {}) {
  assert("JSXFragment", node, opts);
}

function assertJSXOpeningFragment(node, opts = {}) {
  assert("JSXOpeningFragment", node, opts);
}

function assertJSXClosingFragment(node, opts = {}) {
  assert("JSXClosingFragment", node, opts);
}

function assertNoop(node, opts = {}) {
  assert("Noop", node, opts);
}

function assertPlaceholder(node, opts = {}) {
  assert("Placeholder", node, opts);
}

function assertV8IntrinsicIdentifier(node, opts = {}) {
  assert("V8IntrinsicIdentifier", node, opts);
}

function assertArgumentPlaceholder(node, opts = {}) {
  assert("ArgumentPlaceholder", node, opts);
}

function assertAwaitExpression(node, opts = {}) {
  assert("AwaitExpression", node, opts);
}

function assertBindExpression(node, opts = {}) {
  assert("BindExpression", node, opts);
}

function assertClassProperty(node, opts = {}) {
  assert("ClassProperty", node, opts);
}

function assertOptionalMemberExpression(node, opts = {}) {
  assert("OptionalMemberExpression", node, opts);
}

function assertPipelineTopicExpression(node, opts = {}) {
  assert("PipelineTopicExpression", node, opts);
}

function assertPipelineBareFunction(node, opts = {}) {
  assert("PipelineBareFunction", node, opts);
}

function assertPipelinePrimaryTopicReference(node, opts = {}) {
  assert("PipelinePrimaryTopicReference", node, opts);
}

function assertOptionalCallExpression(node, opts = {}) {
  assert("OptionalCallExpression", node, opts);
}

function assertClassPrivateProperty(node, opts = {}) {
  assert("ClassPrivateProperty", node, opts);
}

function assertClassPrivateMethod(node, opts = {}) {
  assert("ClassPrivateMethod", node, opts);
}

function assertImport(node, opts = {}) {
  assert("Import", node, opts);
}

function assertImportAttribute(node, opts = {}) {
  assert("ImportAttribute", node, opts);
}

function assertDecorator(node, opts = {}) {
  assert("Decorator", node, opts);
}

function assertDoExpression(node, opts = {}) {
  assert("DoExpression", node, opts);
}

function assertExportDefaultSpecifier(node, opts = {}) {
  assert("ExportDefaultSpecifier", node, opts);
}

function assertExportNamespaceSpecifier(node, opts = {}) {
  assert("ExportNamespaceSpecifier", node, opts);
}

function assertPrivateName(node, opts = {}) {
  assert("PrivateName", node, opts);
}

function assertBigIntLiteral(node, opts = {}) {
  assert("BigIntLiteral", node, opts);
}

function assertRecordExpression(node, opts = {}) {
  assert("RecordExpression", node, opts);
}

function assertTupleExpression(node, opts = {}) {
  assert("TupleExpression", node, opts);
}

function assertTSParameterProperty(node, opts = {}) {
  assert("TSParameterProperty", node, opts);
}

function assertTSDeclareFunction(node, opts = {}) {
  assert("TSDeclareFunction", node, opts);
}

function assertTSDeclareMethod(node, opts = {}) {
  assert("TSDeclareMethod", node, opts);
}

function assertTSQualifiedName(node, opts = {}) {
  assert("TSQualifiedName", node, opts);
}

function assertTSCallSignatureDeclaration(node, opts = {}) {
  assert("TSCallSignatureDeclaration", node, opts);
}

function assertTSConstructSignatureDeclaration(node, opts = {}) {
  assert("TSConstructSignatureDeclaration", node, opts);
}

function assertTSPropertySignature(node, opts = {}) {
  assert("TSPropertySignature", node, opts);
}

function assertTSMethodSignature(node, opts = {}) {
  assert("TSMethodSignature", node, opts);
}

function assertTSIndexSignature(node, opts = {}) {
  assert("TSIndexSignature", node, opts);
}

function assertTSAnyKeyword(node, opts = {}) {
  assert("TSAnyKeyword", node, opts);
}

function assertTSBooleanKeyword(node, opts = {}) {
  assert("TSBooleanKeyword", node, opts);
}

function assertTSBigIntKeyword(node, opts = {}) {
  assert("TSBigIntKeyword", node, opts);
}

function assertTSNeverKeyword(node, opts = {}) {
  assert("TSNeverKeyword", node, opts);
}

function assertTSNullKeyword(node, opts = {}) {
  assert("TSNullKeyword", node, opts);
}

function assertTSNumberKeyword(node, opts = {}) {
  assert("TSNumberKeyword", node, opts);
}

function assertTSObjectKeyword(node, opts = {}) {
  assert("TSObjectKeyword", node, opts);
}

function assertTSStringKeyword(node, opts = {}) {
  assert("TSStringKeyword", node, opts);
}

function assertTSSymbolKeyword(node, opts = {}) {
  assert("TSSymbolKeyword", node, opts);
}

function assertTSUndefinedKeyword(node, opts = {}) {
  assert("TSUndefinedKeyword", node, opts);
}

function assertTSUnknownKeyword(node, opts = {}) {
  assert("TSUnknownKeyword", node, opts);
}

function assertTSVoidKeyword(node, opts = {}) {
  assert("TSVoidKeyword", node, opts);
}

function assertTSThisType(node, opts = {}) {
  assert("TSThisType", node, opts);
}

function assertTSFunctionType(node, opts = {}) {
  assert("TSFunctionType", node, opts);
}

function assertTSConstructorType(node, opts = {}) {
  assert("TSConstructorType", node, opts);
}

function assertTSTypeReference(node, opts = {}) {
  assert("TSTypeReference", node, opts);
}

function assertTSTypePredicate(node, opts = {}) {
  assert("TSTypePredicate", node, opts);
}

function assertTSTypeQuery(node, opts = {}) {
  assert("TSTypeQuery", node, opts);
}

function assertTSTypeLiteral(node, opts = {}) {
  assert("TSTypeLiteral", node, opts);
}

function assertTSArrayType(node, opts = {}) {
  assert("TSArrayType", node, opts);
}

function assertTSTupleType(node, opts = {}) {
  assert("TSTupleType", node, opts);
}

function assertTSOptionalType(node, opts = {}) {
  assert("TSOptionalType", node, opts);
}

function assertTSRestType(node, opts = {}) {
  assert("TSRestType", node, opts);
}

function assertTSUnionType(node, opts = {}) {
  assert("TSUnionType", node, opts);
}

function assertTSIntersectionType(node, opts = {}) {
  assert("TSIntersectionType", node, opts);
}

function assertTSConditionalType(node, opts = {}) {
  assert("TSConditionalType", node, opts);
}

function assertTSInferType(node, opts = {}) {
  assert("TSInferType", node, opts);
}

function assertTSParenthesizedType(node, opts = {}) {
  assert("TSParenthesizedType", node, opts);
}

function assertTSTypeOperator(node, opts = {}) {
  assert("TSTypeOperator", node, opts);
}

function assertTSIndexedAccessType(node, opts = {}) {
  assert("TSIndexedAccessType", node, opts);
}

function assertTSMappedType(node, opts = {}) {
  assert("TSMappedType", node, opts);
}

function assertTSLiteralType(node, opts = {}) {
  assert("TSLiteralType", node, opts);
}

function assertTSExpressionWithTypeArguments(node, opts = {}) {
  assert("TSExpressionWithTypeArguments", node, opts);
}

function assertTSInterfaceDeclaration(node, opts = {}) {
  assert("TSInterfaceDeclaration", node, opts);
}

function assertTSInterfaceBody(node, opts = {}) {
  assert("TSInterfaceBody", node, opts);
}

function assertTSTypeAliasDeclaration(node, opts = {}) {
  assert("TSTypeAliasDeclaration", node, opts);
}

function assertTSAsExpression(node, opts = {}) {
  assert("TSAsExpression", node, opts);
}

function assertTSTypeAssertion(node, opts = {}) {
  assert("TSTypeAssertion", node, opts);
}

function assertTSEnumDeclaration(node, opts = {}) {
  assert("TSEnumDeclaration", node, opts);
}

function assertTSEnumMember(node, opts = {}) {
  assert("TSEnumMember", node, opts);
}

function assertTSModuleDeclaration(node, opts = {}) {
  assert("TSModuleDeclaration", node, opts);
}

function assertTSModuleBlock(node, opts = {}) {
  assert("TSModuleBlock", node, opts);
}

function assertTSImportType(node, opts = {}) {
  assert("TSImportType", node, opts);
}

function assertTSImportEqualsDeclaration(node, opts = {}) {
  assert("TSImportEqualsDeclaration", node, opts);
}

function assertTSExternalModuleReference(node, opts = {}) {
  assert("TSExternalModuleReference", node, opts);
}

function assertTSNonNullExpression(node, opts = {}) {
  assert("TSNonNullExpression", node, opts);
}

function assertTSExportAssignment(node, opts = {}) {
  assert("TSExportAssignment", node, opts);
}

function assertTSNamespaceExportDeclaration(node, opts = {}) {
  assert("TSNamespaceExportDeclaration", node, opts);
}

function assertTSTypeAnnotation(node, opts = {}) {
  assert("TSTypeAnnotation", node, opts);
}

function assertTSTypeParameterInstantiation(node, opts = {}) {
  assert("TSTypeParameterInstantiation", node, opts);
}

function assertTSTypeParameterDeclaration(node, opts = {}) {
  assert("TSTypeParameterDeclaration", node, opts);
}

function assertTSTypeParameter(node, opts = {}) {
  assert("TSTypeParameter", node, opts);
}

function assertExpression(node, opts = {}) {
  assert("Expression", node, opts);
}

function assertBinary(node, opts = {}) {
  assert("Binary", node, opts);
}

function assertScopable(node, opts = {}) {
  assert("Scopable", node, opts);
}

function assertBlockParent(node, opts = {}) {
  assert("BlockParent", node, opts);
}

function assertBlock(node, opts = {}) {
  assert("Block", node, opts);
}

function assertStatement(node, opts = {}) {
  assert("Statement", node, opts);
}

function assertTerminatorless(node, opts = {}) {
  assert("Terminatorless", node, opts);
}

function assertCompletionStatement(node, opts = {}) {
  assert("CompletionStatement", node, opts);
}

function assertConditional(node, opts = {}) {
  assert("Conditional", node, opts);
}

function assertLoop(node, opts = {}) {
  assert("Loop", node, opts);
}

function assertWhile(node, opts = {}) {
  assert("While", node, opts);
}

function assertExpressionWrapper(node, opts = {}) {
  assert("ExpressionWrapper", node, opts);
}

function assertFor(node, opts = {}) {
  assert("For", node, opts);
}

function assertForXStatement(node, opts = {}) {
  assert("ForXStatement", node, opts);
}

function assertFunction(node, opts = {}) {
  assert("Function", node, opts);
}

function assertFunctionParent(node, opts = {}) {
  assert("FunctionParent", node, opts);
}

function assertPureish(node, opts = {}) {
  assert("Pureish", node, opts);
}

function assertDeclaration(node, opts = {}) {
  assert("Declaration", node, opts);
}

function assertPatternLike(node, opts = {}) {
  assert("PatternLike", node, opts);
}

function assertLVal(node, opts = {}) {
  assert("LVal", node, opts);
}

function assertTSEntityName(node, opts = {}) {
  assert("TSEntityName", node, opts);
}

function assertLiteral(node, opts = {}) {
  assert("Literal", node, opts);
}

function assertImmutable(node, opts = {}) {
  assert("Immutable", node, opts);
}

function assertUserWhitespacable(node, opts = {}) {
  assert("UserWhitespacable", node, opts);
}

function assertMethod(node, opts = {}) {
  assert("Method", node, opts);
}

function assertObjectMember(node, opts = {}) {
  assert("ObjectMember", node, opts);
}

function assertProperty(node, opts = {}) {
  assert("Property", node, opts);
}

function assertUnaryLike(node, opts = {}) {
  assert("UnaryLike", node, opts);
}

function assertPattern(node, opts = {}) {
  assert("Pattern", node, opts);
}

function assertClass(node, opts = {}) {
  assert("Class", node, opts);
}

function assertModuleDeclaration(node, opts = {}) {
  assert("ModuleDeclaration", node, opts);
}

function assertExportDeclaration(node, opts = {}) {
  assert("ExportDeclaration", node, opts);
}

function assertModuleSpecifier(node, opts = {}) {
  assert("ModuleSpecifier", node, opts);
}

function assertFlow(node, opts = {}) {
  assert("Flow", node, opts);
}

function assertFlowType(node, opts = {}) {
  assert("FlowType", node, opts);
}

function assertFlowBaseAnnotation(node, opts = {}) {
  assert("FlowBaseAnnotation", node, opts);
}

function assertFlowDeclaration(node, opts = {}) {
  assert("FlowDeclaration", node, opts);
}

function assertFlowPredicate(node, opts = {}) {
  assert("FlowPredicate", node, opts);
}

function assertEnumBody(node, opts = {}) {
  assert("EnumBody", node, opts);
}

function assertEnumMember(node, opts = {}) {
  assert("EnumMember", node, opts);
}

function assertJSX(node, opts = {}) {
  assert("JSX", node, opts);
}

function assertPrivate(node, opts = {}) {
  assert("Private", node, opts);
}

function assertTSTypeElement(node, opts = {}) {
  assert("TSTypeElement", node, opts);
}

function assertTSType(node, opts = {}) {
  assert("TSType", node, opts);
}

function assertTSBaseType(node, opts = {}) {
  assert("TSBaseType", node, opts);
}

function assertNumberLiteral(node, opts) {
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
  assert("NumberLiteral", node, opts);
}

function assertRegexLiteral(node, opts) {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  assert("RegexLiteral", node, opts);
}

function assertRestProperty(node, opts) {
  console.trace("The node type RestProperty has been renamed to RestElement");
  assert("RestProperty", node, opts);
}

function assertSpreadProperty(node, opts) {
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
  assert("SpreadProperty", node, opts);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/builders/builder.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/types/lib/builders/builder.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = builder;

var _clone = _interopRequireDefault(__webpack_require__(/*! lodash/clone */ "./node_modules/lodash/clone.js"));

var _definitions = __webpack_require__(/*! ../definitions */ "./node_modules/@babel/types/lib/definitions/index.js");

var _validate = _interopRequireDefault(__webpack_require__(/*! ../validators/validate */ "./node_modules/@babel/types/lib/validators/validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function builder(type, ...args) {
  const keys = _definitions.BUILDER_KEYS[type];
  const countArgs = args.length;

  if (countArgs > keys.length) {
    throw new Error(`${type}: Too many arguments passed. Received ${countArgs} but can receive no more than ${keys.length}`);
  }

  const node = {
    type
  };
  let i = 0;
  keys.forEach(key => {
    const field = _definitions.NODE_FIELDS[type][key];
    let arg;
    if (i < countArgs) arg = args[i];
    if (arg === undefined) arg = (0, _clone.default)(field.default);
    node[key] = arg;
    i++;
  });

  for (const key of Object.keys(node)) {
    (0, _validate.default)(node, key, node[key]);
  }

  return node;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createFlowUnionType;

var _generated = __webpack_require__(/*! ../generated */ "./node_modules/@babel/types/lib/builders/generated/index.js");

var _removeTypeDuplicates = _interopRequireDefault(__webpack_require__(/*! ../../modifications/flow/removeTypeDuplicates */ "./node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createFlowUnionType(types) {
  const flattened = (0, _removeTypeDuplicates.default)(types);

  if (flattened.length === 1) {
    return flattened[0];
  } else {
    return (0, _generated.unionTypeAnnotation)(flattened);
  }
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createTypeAnnotationBasedOnTypeof;

var _generated = __webpack_require__(/*! ../generated */ "./node_modules/@babel/types/lib/builders/generated/index.js");

function createTypeAnnotationBasedOnTypeof(type) {
  if (type === "string") {
    return (0, _generated.stringTypeAnnotation)();
  } else if (type === "number") {
    return (0, _generated.numberTypeAnnotation)();
  } else if (type === "undefined") {
    return (0, _generated.voidTypeAnnotation)();
  } else if (type === "boolean") {
    return (0, _generated.booleanTypeAnnotation)();
  } else if (type === "function") {
    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));
  } else if (type === "object") {
    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));
  } else if (type === "symbol") {
    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));
  } else {
    throw new Error("Invalid typeof value");
  }
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/builders/generated/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/builders/generated/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrayExpression = exports.arrayExpression = arrayExpression;
exports.AssignmentExpression = exports.assignmentExpression = assignmentExpression;
exports.BinaryExpression = exports.binaryExpression = binaryExpression;
exports.InterpreterDirective = exports.interpreterDirective = interpreterDirective;
exports.Directive = exports.directive = directive;
exports.DirectiveLiteral = exports.directiveLiteral = directiveLiteral;
exports.BlockStatement = exports.blockStatement = blockStatement;
exports.BreakStatement = exports.breakStatement = breakStatement;
exports.CallExpression = exports.callExpression = callExpression;
exports.CatchClause = exports.catchClause = catchClause;
exports.ConditionalExpression = exports.conditionalExpression = conditionalExpression;
exports.ContinueStatement = exports.continueStatement = continueStatement;
exports.DebuggerStatement = exports.debuggerStatement = debuggerStatement;
exports.DoWhileStatement = exports.doWhileStatement = doWhileStatement;
exports.EmptyStatement = exports.emptyStatement = emptyStatement;
exports.ExpressionStatement = exports.expressionStatement = expressionStatement;
exports.File = exports.file = file;
exports.ForInStatement = exports.forInStatement = forInStatement;
exports.ForStatement = exports.forStatement = forStatement;
exports.FunctionDeclaration = exports.functionDeclaration = functionDeclaration;
exports.FunctionExpression = exports.functionExpression = functionExpression;
exports.Identifier = exports.identifier = identifier;
exports.IfStatement = exports.ifStatement = ifStatement;
exports.LabeledStatement = exports.labeledStatement = labeledStatement;
exports.StringLiteral = exports.stringLiteral = stringLiteral;
exports.NumericLiteral = exports.numericLiteral = numericLiteral;
exports.NullLiteral = exports.nullLiteral = nullLiteral;
exports.BooleanLiteral = exports.booleanLiteral = booleanLiteral;
exports.RegExpLiteral = exports.regExpLiteral = regExpLiteral;
exports.LogicalExpression = exports.logicalExpression = logicalExpression;
exports.MemberExpression = exports.memberExpression = memberExpression;
exports.NewExpression = exports.newExpression = newExpression;
exports.Program = exports.program = program;
exports.ObjectExpression = exports.objectExpression = objectExpression;
exports.ObjectMethod = exports.objectMethod = objectMethod;
exports.ObjectProperty = exports.objectProperty = objectProperty;
exports.RestElement = exports.restElement = restElement;
exports.ReturnStatement = exports.returnStatement = returnStatement;
exports.SequenceExpression = exports.sequenceExpression = sequenceExpression;
exports.ParenthesizedExpression = exports.parenthesizedExpression = parenthesizedExpression;
exports.SwitchCase = exports.switchCase = switchCase;
exports.SwitchStatement = exports.switchStatement = switchStatement;
exports.ThisExpression = exports.thisExpression = thisExpression;
exports.ThrowStatement = exports.throwStatement = throwStatement;
exports.TryStatement = exports.tryStatement = tryStatement;
exports.UnaryExpression = exports.unaryExpression = unaryExpression;
exports.UpdateExpression = exports.updateExpression = updateExpression;
exports.VariableDeclaration = exports.variableDeclaration = variableDeclaration;
exports.VariableDeclarator = exports.variableDeclarator = variableDeclarator;
exports.WhileStatement = exports.whileStatement = whileStatement;
exports.WithStatement = exports.withStatement = withStatement;
exports.AssignmentPattern = exports.assignmentPattern = assignmentPattern;
exports.ArrayPattern = exports.arrayPattern = arrayPattern;
exports.ArrowFunctionExpression = exports.arrowFunctionExpression = arrowFunctionExpression;
exports.ClassBody = exports.classBody = classBody;
exports.ClassExpression = exports.classExpression = classExpression;
exports.ClassDeclaration = exports.classDeclaration = classDeclaration;
exports.ExportAllDeclaration = exports.exportAllDeclaration = exportAllDeclaration;
exports.ExportDefaultDeclaration = exports.exportDefaultDeclaration = exportDefaultDeclaration;
exports.ExportNamedDeclaration = exports.exportNamedDeclaration = exportNamedDeclaration;
exports.ExportSpecifier = exports.exportSpecifier = exportSpecifier;
exports.ForOfStatement = exports.forOfStatement = forOfStatement;
exports.ImportDeclaration = exports.importDeclaration = importDeclaration;
exports.ImportDefaultSpecifier = exports.importDefaultSpecifier = importDefaultSpecifier;
exports.ImportNamespaceSpecifier = exports.importNamespaceSpecifier = importNamespaceSpecifier;
exports.ImportSpecifier = exports.importSpecifier = importSpecifier;
exports.MetaProperty = exports.metaProperty = metaProperty;
exports.ClassMethod = exports.classMethod = classMethod;
exports.ObjectPattern = exports.objectPattern = objectPattern;
exports.SpreadElement = exports.spreadElement = spreadElement;
exports.super = exports.Super = _super;
exports.TaggedTemplateExpression = exports.taggedTemplateExpression = taggedTemplateExpression;
exports.TemplateElement = exports.templateElement = templateElement;
exports.TemplateLiteral = exports.templateLiteral = templateLiteral;
exports.YieldExpression = exports.yieldExpression = yieldExpression;
exports.AnyTypeAnnotation = exports.anyTypeAnnotation = anyTypeAnnotation;
exports.ArrayTypeAnnotation = exports.arrayTypeAnnotation = arrayTypeAnnotation;
exports.BooleanTypeAnnotation = exports.booleanTypeAnnotation = booleanTypeAnnotation;
exports.BooleanLiteralTypeAnnotation = exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
exports.NullLiteralTypeAnnotation = exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
exports.ClassImplements = exports.classImplements = classImplements;
exports.DeclareClass = exports.declareClass = declareClass;
exports.DeclareFunction = exports.declareFunction = declareFunction;
exports.DeclareInterface = exports.declareInterface = declareInterface;
exports.DeclareModule = exports.declareModule = declareModule;
exports.DeclareModuleExports = exports.declareModuleExports = declareModuleExports;
exports.DeclareTypeAlias = exports.declareTypeAlias = declareTypeAlias;
exports.DeclareOpaqueType = exports.declareOpaqueType = declareOpaqueType;
exports.DeclareVariable = exports.declareVariable = declareVariable;
exports.DeclareExportDeclaration = exports.declareExportDeclaration = declareExportDeclaration;
exports.DeclareExportAllDeclaration = exports.declareExportAllDeclaration = declareExportAllDeclaration;
exports.DeclaredPredicate = exports.declaredPredicate = declaredPredicate;
exports.ExistsTypeAnnotation = exports.existsTypeAnnotation = existsTypeAnnotation;
exports.FunctionTypeAnnotation = exports.functionTypeAnnotation = functionTypeAnnotation;
exports.FunctionTypeParam = exports.functionTypeParam = functionTypeParam;
exports.GenericTypeAnnotation = exports.genericTypeAnnotation = genericTypeAnnotation;
exports.InferredPredicate = exports.inferredPredicate = inferredPredicate;
exports.InterfaceExtends = exports.interfaceExtends = interfaceExtends;
exports.InterfaceDeclaration = exports.interfaceDeclaration = interfaceDeclaration;
exports.InterfaceTypeAnnotation = exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
exports.IntersectionTypeAnnotation = exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
exports.MixedTypeAnnotation = exports.mixedTypeAnnotation = mixedTypeAnnotation;
exports.EmptyTypeAnnotation = exports.emptyTypeAnnotation = emptyTypeAnnotation;
exports.NullableTypeAnnotation = exports.nullableTypeAnnotation = nullableTypeAnnotation;
exports.NumberLiteralTypeAnnotation = exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
exports.NumberTypeAnnotation = exports.numberTypeAnnotation = numberTypeAnnotation;
exports.ObjectTypeAnnotation = exports.objectTypeAnnotation = objectTypeAnnotation;
exports.ObjectTypeInternalSlot = exports.objectTypeInternalSlot = objectTypeInternalSlot;
exports.ObjectTypeCallProperty = exports.objectTypeCallProperty = objectTypeCallProperty;
exports.ObjectTypeIndexer = exports.objectTypeIndexer = objectTypeIndexer;
exports.ObjectTypeProperty = exports.objectTypeProperty = objectTypeProperty;
exports.ObjectTypeSpreadProperty = exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
exports.OpaqueType = exports.opaqueType = opaqueType;
exports.QualifiedTypeIdentifier = exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
exports.StringLiteralTypeAnnotation = exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
exports.StringTypeAnnotation = exports.stringTypeAnnotation = stringTypeAnnotation;
exports.SymbolTypeAnnotation = exports.symbolTypeAnnotation = symbolTypeAnnotation;
exports.ThisTypeAnnotation = exports.thisTypeAnnotation = thisTypeAnnotation;
exports.TupleTypeAnnotation = exports.tupleTypeAnnotation = tupleTypeAnnotation;
exports.TypeofTypeAnnotation = exports.typeofTypeAnnotation = typeofTypeAnnotation;
exports.TypeAlias = exports.typeAlias = typeAlias;
exports.TypeAnnotation = exports.typeAnnotation = typeAnnotation;
exports.TypeCastExpression = exports.typeCastExpression = typeCastExpression;
exports.TypeParameter = exports.typeParameter = typeParameter;
exports.TypeParameterDeclaration = exports.typeParameterDeclaration = typeParameterDeclaration;
exports.TypeParameterInstantiation = exports.typeParameterInstantiation = typeParameterInstantiation;
exports.UnionTypeAnnotation = exports.unionTypeAnnotation = unionTypeAnnotation;
exports.Variance = exports.variance = variance;
exports.VoidTypeAnnotation = exports.voidTypeAnnotation = voidTypeAnnotation;
exports.EnumDeclaration = exports.enumDeclaration = enumDeclaration;
exports.EnumBooleanBody = exports.enumBooleanBody = enumBooleanBody;
exports.EnumNumberBody = exports.enumNumberBody = enumNumberBody;
exports.EnumStringBody = exports.enumStringBody = enumStringBody;
exports.EnumSymbolBody = exports.enumSymbolBody = enumSymbolBody;
exports.EnumBooleanMember = exports.enumBooleanMember = enumBooleanMember;
exports.EnumNumberMember = exports.enumNumberMember = enumNumberMember;
exports.EnumStringMember = exports.enumStringMember = enumStringMember;
exports.EnumDefaultedMember = exports.enumDefaultedMember = enumDefaultedMember;
exports.jSXAttribute = exports.JSXAttribute = exports.jsxAttribute = jsxAttribute;
exports.jSXClosingElement = exports.JSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
exports.jSXElement = exports.JSXElement = exports.jsxElement = jsxElement;
exports.jSXEmptyExpression = exports.JSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
exports.jSXExpressionContainer = exports.JSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
exports.jSXSpreadChild = exports.JSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
exports.jSXIdentifier = exports.JSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
exports.jSXMemberExpression = exports.JSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
exports.jSXNamespacedName = exports.JSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
exports.jSXOpeningElement = exports.JSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
exports.jSXSpreadAttribute = exports.JSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
exports.jSXText = exports.JSXText = exports.jsxText = jsxText;
exports.jSXFragment = exports.JSXFragment = exports.jsxFragment = jsxFragment;
exports.jSXOpeningFragment = exports.JSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
exports.jSXClosingFragment = exports.JSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
exports.Noop = exports.noop = noop;
exports.Placeholder = exports.placeholder = placeholder;
exports.V8IntrinsicIdentifier = exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
exports.ArgumentPlaceholder = exports.argumentPlaceholder = argumentPlaceholder;
exports.AwaitExpression = exports.awaitExpression = awaitExpression;
exports.BindExpression = exports.bindExpression = bindExpression;
exports.ClassProperty = exports.classProperty = classProperty;
exports.OptionalMemberExpression = exports.optionalMemberExpression = optionalMemberExpression;
exports.PipelineTopicExpression = exports.pipelineTopicExpression = pipelineTopicExpression;
exports.PipelineBareFunction = exports.pipelineBareFunction = pipelineBareFunction;
exports.PipelinePrimaryTopicReference = exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
exports.OptionalCallExpression = exports.optionalCallExpression = optionalCallExpression;
exports.ClassPrivateProperty = exports.classPrivateProperty = classPrivateProperty;
exports.ClassPrivateMethod = exports.classPrivateMethod = classPrivateMethod;
exports.import = exports.Import = _import;
exports.ImportAttribute = exports.importAttribute = importAttribute;
exports.Decorator = exports.decorator = decorator;
exports.DoExpression = exports.doExpression = doExpression;
exports.ExportDefaultSpecifier = exports.exportDefaultSpecifier = exportDefaultSpecifier;
exports.ExportNamespaceSpecifier = exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
exports.PrivateName = exports.privateName = privateName;
exports.BigIntLiteral = exports.bigIntLiteral = bigIntLiteral;
exports.RecordExpression = exports.recordExpression = recordExpression;
exports.TupleExpression = exports.tupleExpression = tupleExpression;
exports.tSParameterProperty = exports.TSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
exports.tSDeclareFunction = exports.TSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
exports.tSDeclareMethod = exports.TSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
exports.tSQualifiedName = exports.TSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
exports.tSCallSignatureDeclaration = exports.TSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
exports.tSConstructSignatureDeclaration = exports.TSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
exports.tSPropertySignature = exports.TSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
exports.tSMethodSignature = exports.TSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
exports.tSIndexSignature = exports.TSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
exports.tSAnyKeyword = exports.TSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
exports.tSBooleanKeyword = exports.TSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
exports.tSBigIntKeyword = exports.TSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
exports.tSNeverKeyword = exports.TSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
exports.tSNullKeyword = exports.TSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
exports.tSNumberKeyword = exports.TSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
exports.tSObjectKeyword = exports.TSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
exports.tSStringKeyword = exports.TSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
exports.tSSymbolKeyword = exports.TSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
exports.tSUndefinedKeyword = exports.TSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
exports.tSUnknownKeyword = exports.TSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
exports.tSVoidKeyword = exports.TSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
exports.tSThisType = exports.TSThisType = exports.tsThisType = tsThisType;
exports.tSFunctionType = exports.TSFunctionType = exports.tsFunctionType = tsFunctionType;
exports.tSConstructorType = exports.TSConstructorType = exports.tsConstructorType = tsConstructorType;
exports.tSTypeReference = exports.TSTypeReference = exports.tsTypeReference = tsTypeReference;
exports.tSTypePredicate = exports.TSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
exports.tSTypeQuery = exports.TSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
exports.tSTypeLiteral = exports.TSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
exports.tSArrayType = exports.TSArrayType = exports.tsArrayType = tsArrayType;
exports.tSTupleType = exports.TSTupleType = exports.tsTupleType = tsTupleType;
exports.tSOptionalType = exports.TSOptionalType = exports.tsOptionalType = tsOptionalType;
exports.tSRestType = exports.TSRestType = exports.tsRestType = tsRestType;
exports.tSUnionType = exports.TSUnionType = exports.tsUnionType = tsUnionType;
exports.tSIntersectionType = exports.TSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
exports.tSConditionalType = exports.TSConditionalType = exports.tsConditionalType = tsConditionalType;
exports.tSInferType = exports.TSInferType = exports.tsInferType = tsInferType;
exports.tSParenthesizedType = exports.TSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
exports.tSTypeOperator = exports.TSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
exports.tSIndexedAccessType = exports.TSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
exports.tSMappedType = exports.TSMappedType = exports.tsMappedType = tsMappedType;
exports.tSLiteralType = exports.TSLiteralType = exports.tsLiteralType = tsLiteralType;
exports.tSExpressionWithTypeArguments = exports.TSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
exports.tSInterfaceDeclaration = exports.TSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
exports.tSInterfaceBody = exports.TSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
exports.tSTypeAliasDeclaration = exports.TSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
exports.tSAsExpression = exports.TSAsExpression = exports.tsAsExpression = tsAsExpression;
exports.tSTypeAssertion = exports.TSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
exports.tSEnumDeclaration = exports.TSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
exports.tSEnumMember = exports.TSEnumMember = exports.tsEnumMember = tsEnumMember;
exports.tSModuleDeclaration = exports.TSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
exports.tSModuleBlock = exports.TSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
exports.tSImportType = exports.TSImportType = exports.tsImportType = tsImportType;
exports.tSImportEqualsDeclaration = exports.TSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
exports.tSExternalModuleReference = exports.TSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
exports.tSNonNullExpression = exports.TSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
exports.tSExportAssignment = exports.TSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
exports.tSNamespaceExportDeclaration = exports.TSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
exports.tSTypeAnnotation = exports.TSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
exports.tSTypeParameterInstantiation = exports.TSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
exports.tSTypeParameterDeclaration = exports.TSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
exports.tSTypeParameter = exports.TSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
exports.numberLiteral = exports.NumberLiteral = NumberLiteral;
exports.regexLiteral = exports.RegexLiteral = RegexLiteral;
exports.restProperty = exports.RestProperty = RestProperty;
exports.spreadProperty = exports.SpreadProperty = SpreadProperty;

var _builder = _interopRequireDefault(__webpack_require__(/*! ../builder */ "./node_modules/@babel/types/lib/builders/builder.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function arrayExpression(...args) {
  return (0, _builder.default)("ArrayExpression", ...args);
}

function assignmentExpression(...args) {
  return (0, _builder.default)("AssignmentExpression", ...args);
}

function binaryExpression(...args) {
  return (0, _builder.default)("BinaryExpression", ...args);
}

function interpreterDirective(...args) {
  return (0, _builder.default)("InterpreterDirective", ...args);
}

function directive(...args) {
  return (0, _builder.default)("Directive", ...args);
}

function directiveLiteral(...args) {
  return (0, _builder.default)("DirectiveLiteral", ...args);
}

function blockStatement(...args) {
  return (0, _builder.default)("BlockStatement", ...args);
}

function breakStatement(...args) {
  return (0, _builder.default)("BreakStatement", ...args);
}

function callExpression(...args) {
  return (0, _builder.default)("CallExpression", ...args);
}

function catchClause(...args) {
  return (0, _builder.default)("CatchClause", ...args);
}

function conditionalExpression(...args) {
  return (0, _builder.default)("ConditionalExpression", ...args);
}

function continueStatement(...args) {
  return (0, _builder.default)("ContinueStatement", ...args);
}

function debuggerStatement(...args) {
  return (0, _builder.default)("DebuggerStatement", ...args);
}

function doWhileStatement(...args) {
  return (0, _builder.default)("DoWhileStatement", ...args);
}

function emptyStatement(...args) {
  return (0, _builder.default)("EmptyStatement", ...args);
}

function expressionStatement(...args) {
  return (0, _builder.default)("ExpressionStatement", ...args);
}

function file(...args) {
  return (0, _builder.default)("File", ...args);
}

function forInStatement(...args) {
  return (0, _builder.default)("ForInStatement", ...args);
}

function forStatement(...args) {
  return (0, _builder.default)("ForStatement", ...args);
}

function functionDeclaration(...args) {
  return (0, _builder.default)("FunctionDeclaration", ...args);
}

function functionExpression(...args) {
  return (0, _builder.default)("FunctionExpression", ...args);
}

function identifier(...args) {
  return (0, _builder.default)("Identifier", ...args);
}

function ifStatement(...args) {
  return (0, _builder.default)("IfStatement", ...args);
}

function labeledStatement(...args) {
  return (0, _builder.default)("LabeledStatement", ...args);
}

function stringLiteral(...args) {
  return (0, _builder.default)("StringLiteral", ...args);
}

function numericLiteral(...args) {
  return (0, _builder.default)("NumericLiteral", ...args);
}

function nullLiteral(...args) {
  return (0, _builder.default)("NullLiteral", ...args);
}

function booleanLiteral(...args) {
  return (0, _builder.default)("BooleanLiteral", ...args);
}

function regExpLiteral(...args) {
  return (0, _builder.default)("RegExpLiteral", ...args);
}

function logicalExpression(...args) {
  return (0, _builder.default)("LogicalExpression", ...args);
}

function memberExpression(...args) {
  return (0, _builder.default)("MemberExpression", ...args);
}

function newExpression(...args) {
  return (0, _builder.default)("NewExpression", ...args);
}

function program(...args) {
  return (0, _builder.default)("Program", ...args);
}

function objectExpression(...args) {
  return (0, _builder.default)("ObjectExpression", ...args);
}

function objectMethod(...args) {
  return (0, _builder.default)("ObjectMethod", ...args);
}

function objectProperty(...args) {
  return (0, _builder.default)("ObjectProperty", ...args);
}

function restElement(...args) {
  return (0, _builder.default)("RestElement", ...args);
}

function returnStatement(...args) {
  return (0, _builder.default)("ReturnStatement", ...args);
}

function sequenceExpression(...args) {
  return (0, _builder.default)("SequenceExpression", ...args);
}

function parenthesizedExpression(...args) {
  return (0, _builder.default)("ParenthesizedExpression", ...args);
}

function switchCase(...args) {
  return (0, _builder.default)("SwitchCase", ...args);
}

function switchStatement(...args) {
  return (0, _builder.default)("SwitchStatement", ...args);
}

function thisExpression(...args) {
  return (0, _builder.default)("ThisExpression", ...args);
}

function throwStatement(...args) {
  return (0, _builder.default)("ThrowStatement", ...args);
}

function tryStatement(...args) {
  return (0, _builder.default)("TryStatement", ...args);
}

function unaryExpression(...args) {
  return (0, _builder.default)("UnaryExpression", ...args);
}

function updateExpression(...args) {
  return (0, _builder.default)("UpdateExpression", ...args);
}

function variableDeclaration(...args) {
  return (0, _builder.default)("VariableDeclaration", ...args);
}

function variableDeclarator(...args) {
  return (0, _builder.default)("VariableDeclarator", ...args);
}

function whileStatement(...args) {
  return (0, _builder.default)("WhileStatement", ...args);
}

function withStatement(...args) {
  return (0, _builder.default)("WithStatement", ...args);
}

function assignmentPattern(...args) {
  return (0, _builder.default)("AssignmentPattern", ...args);
}

function arrayPattern(...args) {
  return (0, _builder.default)("ArrayPattern", ...args);
}

function arrowFunctionExpression(...args) {
  return (0, _builder.default)("ArrowFunctionExpression", ...args);
}

function classBody(...args) {
  return (0, _builder.default)("ClassBody", ...args);
}

function classExpression(...args) {
  return (0, _builder.default)("ClassExpression", ...args);
}

function classDeclaration(...args) {
  return (0, _builder.default)("ClassDeclaration", ...args);
}

function exportAllDeclaration(...args) {
  return (0, _builder.default)("ExportAllDeclaration", ...args);
}

function exportDefaultDeclaration(...args) {
  return (0, _builder.default)("ExportDefaultDeclaration", ...args);
}

function exportNamedDeclaration(...args) {
  return (0, _builder.default)("ExportNamedDeclaration", ...args);
}

function exportSpecifier(...args) {
  return (0, _builder.default)("ExportSpecifier", ...args);
}

function forOfStatement(...args) {
  return (0, _builder.default)("ForOfStatement", ...args);
}

function importDeclaration(...args) {
  return (0, _builder.default)("ImportDeclaration", ...args);
}

function importDefaultSpecifier(...args) {
  return (0, _builder.default)("ImportDefaultSpecifier", ...args);
}

function importNamespaceSpecifier(...args) {
  return (0, _builder.default)("ImportNamespaceSpecifier", ...args);
}

function importSpecifier(...args) {
  return (0, _builder.default)("ImportSpecifier", ...args);
}

function metaProperty(...args) {
  return (0, _builder.default)("MetaProperty", ...args);
}

function classMethod(...args) {
  return (0, _builder.default)("ClassMethod", ...args);
}

function objectPattern(...args) {
  return (0, _builder.default)("ObjectPattern", ...args);
}

function spreadElement(...args) {
  return (0, _builder.default)("SpreadElement", ...args);
}

function _super(...args) {
  return (0, _builder.default)("Super", ...args);
}

function taggedTemplateExpression(...args) {
  return (0, _builder.default)("TaggedTemplateExpression", ...args);
}

function templateElement(...args) {
  return (0, _builder.default)("TemplateElement", ...args);
}

function templateLiteral(...args) {
  return (0, _builder.default)("TemplateLiteral", ...args);
}

function yieldExpression(...args) {
  return (0, _builder.default)("YieldExpression", ...args);
}

function anyTypeAnnotation(...args) {
  return (0, _builder.default)("AnyTypeAnnotation", ...args);
}

function arrayTypeAnnotation(...args) {
  return (0, _builder.default)("ArrayTypeAnnotation", ...args);
}

function booleanTypeAnnotation(...args) {
  return (0, _builder.default)("BooleanTypeAnnotation", ...args);
}

function booleanLiteralTypeAnnotation(...args) {
  return (0, _builder.default)("BooleanLiteralTypeAnnotation", ...args);
}

function nullLiteralTypeAnnotation(...args) {
  return (0, _builder.default)("NullLiteralTypeAnnotation", ...args);
}

function classImplements(...args) {
  return (0, _builder.default)("ClassImplements", ...args);
}

function declareClass(...args) {
  return (0, _builder.default)("DeclareClass", ...args);
}

function declareFunction(...args) {
  return (0, _builder.default)("DeclareFunction", ...args);
}

function declareInterface(...args) {
  return (0, _builder.default)("DeclareInterface", ...args);
}

function declareModule(...args) {
  return (0, _builder.default)("DeclareModule", ...args);
}

function declareModuleExports(...args) {
  return (0, _builder.default)("DeclareModuleExports", ...args);
}

function declareTypeAlias(...args) {
  return (0, _builder.default)("DeclareTypeAlias", ...args);
}

function declareOpaqueType(...args) {
  return (0, _builder.default)("DeclareOpaqueType", ...args);
}

function declareVariable(...args) {
  return (0, _builder.default)("DeclareVariable", ...args);
}

function declareExportDeclaration(...args) {
  return (0, _builder.default)("DeclareExportDeclaration", ...args);
}

function declareExportAllDeclaration(...args) {
  return (0, _builder.default)("DeclareExportAllDeclaration", ...args);
}

function declaredPredicate(...args) {
  return (0, _builder.default)("DeclaredPredicate", ...args);
}

function existsTypeAnnotation(...args) {
  return (0, _builder.default)("ExistsTypeAnnotation", ...args);
}

function functionTypeAnnotation(...args) {
  return (0, _builder.default)("FunctionTypeAnnotation", ...args);
}

function functionTypeParam(...args) {
  return (0, _builder.default)("FunctionTypeParam", ...args);
}

function genericTypeAnnotation(...args) {
  return (0, _builder.default)("GenericTypeAnnotation", ...args);
}

function inferredPredicate(...args) {
  return (0, _builder.default)("InferredPredicate", ...args);
}

function interfaceExtends(...args) {
  return (0, _builder.default)("InterfaceExtends", ...args);
}

function interfaceDeclaration(...args) {
  return (0, _builder.default)("InterfaceDeclaration", ...args);
}

function interfaceTypeAnnotation(...args) {
  return (0, _builder.default)("InterfaceTypeAnnotation", ...args);
}

function intersectionTypeAnnotation(...args) {
  return (0, _builder.default)("IntersectionTypeAnnotation", ...args);
}

function mixedTypeAnnotation(...args) {
  return (0, _builder.default)("MixedTypeAnnotation", ...args);
}

function emptyTypeAnnotation(...args) {
  return (0, _builder.default)("EmptyTypeAnnotation", ...args);
}

function nullableTypeAnnotation(...args) {
  return (0, _builder.default)("NullableTypeAnnotation", ...args);
}

function numberLiteralTypeAnnotation(...args) {
  return (0, _builder.default)("NumberLiteralTypeAnnotation", ...args);
}

function numberTypeAnnotation(...args) {
  return (0, _builder.default)("NumberTypeAnnotation", ...args);
}

function objectTypeAnnotation(...args) {
  return (0, _builder.default)("ObjectTypeAnnotation", ...args);
}

function objectTypeInternalSlot(...args) {
  return (0, _builder.default)("ObjectTypeInternalSlot", ...args);
}

function objectTypeCallProperty(...args) {
  return (0, _builder.default)("ObjectTypeCallProperty", ...args);
}

function objectTypeIndexer(...args) {
  return (0, _builder.default)("ObjectTypeIndexer", ...args);
}

function objectTypeProperty(...args) {
  return (0, _builder.default)("ObjectTypeProperty", ...args);
}

function objectTypeSpreadProperty(...args) {
  return (0, _builder.default)("ObjectTypeSpreadProperty", ...args);
}

function opaqueType(...args) {
  return (0, _builder.default)("OpaqueType", ...args);
}

function qualifiedTypeIdentifier(...args) {
  return (0, _builder.default)("QualifiedTypeIdentifier", ...args);
}

function stringLiteralTypeAnnotation(...args) {
  return (0, _builder.default)("StringLiteralTypeAnnotation", ...args);
}

function stringTypeAnnotation(...args) {
  return (0, _builder.default)("StringTypeAnnotation", ...args);
}

function symbolTypeAnnotation(...args) {
  return (0, _builder.default)("SymbolTypeAnnotation", ...args);
}

function thisTypeAnnotation(...args) {
  return (0, _builder.default)("ThisTypeAnnotation", ...args);
}

function tupleTypeAnnotation(...args) {
  return (0, _builder.default)("TupleTypeAnnotation", ...args);
}

function typeofTypeAnnotation(...args) {
  return (0, _builder.default)("TypeofTypeAnnotation", ...args);
}

function typeAlias(...args) {
  return (0, _builder.default)("TypeAlias", ...args);
}

function typeAnnotation(...args) {
  return (0, _builder.default)("TypeAnnotation", ...args);
}

function typeCastExpression(...args) {
  return (0, _builder.default)("TypeCastExpression", ...args);
}

function typeParameter(...args) {
  return (0, _builder.default)("TypeParameter", ...args);
}

function typeParameterDeclaration(...args) {
  return (0, _builder.default)("TypeParameterDeclaration", ...args);
}

function typeParameterInstantiation(...args) {
  return (0, _builder.default)("TypeParameterInstantiation", ...args);
}

function unionTypeAnnotation(...args) {
  return (0, _builder.default)("UnionTypeAnnotation", ...args);
}

function variance(...args) {
  return (0, _builder.default)("Variance", ...args);
}

function voidTypeAnnotation(...args) {
  return (0, _builder.default)("VoidTypeAnnotation", ...args);
}

function enumDeclaration(...args) {
  return (0, _builder.default)("EnumDeclaration", ...args);
}

function enumBooleanBody(...args) {
  return (0, _builder.default)("EnumBooleanBody", ...args);
}

function enumNumberBody(...args) {
  return (0, _builder.default)("EnumNumberBody", ...args);
}

function enumStringBody(...args) {
  return (0, _builder.default)("EnumStringBody", ...args);
}

function enumSymbolBody(...args) {
  return (0, _builder.default)("EnumSymbolBody", ...args);
}

function enumBooleanMember(...args) {
  return (0, _builder.default)("EnumBooleanMember", ...args);
}

function enumNumberMember(...args) {
  return (0, _builder.default)("EnumNumberMember", ...args);
}

function enumStringMember(...args) {
  return (0, _builder.default)("EnumStringMember", ...args);
}

function enumDefaultedMember(...args) {
  return (0, _builder.default)("EnumDefaultedMember", ...args);
}

function jsxAttribute(...args) {
  return (0, _builder.default)("JSXAttribute", ...args);
}

function jsxClosingElement(...args) {
  return (0, _builder.default)("JSXClosingElement", ...args);
}

function jsxElement(...args) {
  return (0, _builder.default)("JSXElement", ...args);
}

function jsxEmptyExpression(...args) {
  return (0, _builder.default)("JSXEmptyExpression", ...args);
}

function jsxExpressionContainer(...args) {
  return (0, _builder.default)("JSXExpressionContainer", ...args);
}

function jsxSpreadChild(...args) {
  return (0, _builder.default)("JSXSpreadChild", ...args);
}

function jsxIdentifier(...args) {
  return (0, _builder.default)("JSXIdentifier", ...args);
}

function jsxMemberExpression(...args) {
  return (0, _builder.default)("JSXMemberExpression", ...args);
}

function jsxNamespacedName(...args) {
  return (0, _builder.default)("JSXNamespacedName", ...args);
}

function jsxOpeningElement(...args) {
  return (0, _builder.default)("JSXOpeningElement", ...args);
}

function jsxSpreadAttribute(...args) {
  return (0, _builder.default)("JSXSpreadAttribute", ...args);
}

function jsxText(...args) {
  return (0, _builder.default)("JSXText", ...args);
}

function jsxFragment(...args) {
  return (0, _builder.default)("JSXFragment", ...args);
}

function jsxOpeningFragment(...args) {
  return (0, _builder.default)("JSXOpeningFragment", ...args);
}

function jsxClosingFragment(...args) {
  return (0, _builder.default)("JSXClosingFragment", ...args);
}

function noop(...args) {
  return (0, _builder.default)("Noop", ...args);
}

function placeholder(...args) {
  return (0, _builder.default)("Placeholder", ...args);
}

function v8IntrinsicIdentifier(...args) {
  return (0, _builder.default)("V8IntrinsicIdentifier", ...args);
}

function argumentPlaceholder(...args) {
  return (0, _builder.default)("ArgumentPlaceholder", ...args);
}

function awaitExpression(...args) {
  return (0, _builder.default)("AwaitExpression", ...args);
}

function bindExpression(...args) {
  return (0, _builder.default)("BindExpression", ...args);
}

function classProperty(...args) {
  return (0, _builder.default)("ClassProperty", ...args);
}

function optionalMemberExpression(...args) {
  return (0, _builder.default)("OptionalMemberExpression", ...args);
}

function pipelineTopicExpression(...args) {
  return (0, _builder.default)("PipelineTopicExpression", ...args);
}

function pipelineBareFunction(...args) {
  return (0, _builder.default)("PipelineBareFunction", ...args);
}

function pipelinePrimaryTopicReference(...args) {
  return (0, _builder.default)("PipelinePrimaryTopicReference", ...args);
}

function optionalCallExpression(...args) {
  return (0, _builder.default)("OptionalCallExpression", ...args);
}

function classPrivateProperty(...args) {
  return (0, _builder.default)("ClassPrivateProperty", ...args);
}

function classPrivateMethod(...args) {
  return (0, _builder.default)("ClassPrivateMethod", ...args);
}

function _import(...args) {
  return (0, _builder.default)("Import", ...args);
}

function importAttribute(...args) {
  return (0, _builder.default)("ImportAttribute", ...args);
}

function decorator(...args) {
  return (0, _builder.default)("Decorator", ...args);
}

function doExpression(...args) {
  return (0, _builder.default)("DoExpression", ...args);
}

function exportDefaultSpecifier(...args) {
  return (0, _builder.default)("ExportDefaultSpecifier", ...args);
}

function exportNamespaceSpecifier(...args) {
  return (0, _builder.default)("ExportNamespaceSpecifier", ...args);
}

function privateName(...args) {
  return (0, _builder.default)("PrivateName", ...args);
}

function bigIntLiteral(...args) {
  return (0, _builder.default)("BigIntLiteral", ...args);
}

function recordExpression(...args) {
  return (0, _builder.default)("RecordExpression", ...args);
}

function tupleExpression(...args) {
  return (0, _builder.default)("TupleExpression", ...args);
}

function tsParameterProperty(...args) {
  return (0, _builder.default)("TSParameterProperty", ...args);
}

function tsDeclareFunction(...args) {
  return (0, _builder.default)("TSDeclareFunction", ...args);
}

function tsDeclareMethod(...args) {
  return (0, _builder.default)("TSDeclareMethod", ...args);
}

function tsQualifiedName(...args) {
  return (0, _builder.default)("TSQualifiedName", ...args);
}

function tsCallSignatureDeclaration(...args) {
  return (0, _builder.default)("TSCallSignatureDeclaration", ...args);
}

function tsConstructSignatureDeclaration(...args) {
  return (0, _builder.default)("TSConstructSignatureDeclaration", ...args);
}

function tsPropertySignature(...args) {
  return (0, _builder.default)("TSPropertySignature", ...args);
}

function tsMethodSignature(...args) {
  return (0, _builder.default)("TSMethodSignature", ...args);
}

function tsIndexSignature(...args) {
  return (0, _builder.default)("TSIndexSignature", ...args);
}

function tsAnyKeyword(...args) {
  return (0, _builder.default)("TSAnyKeyword", ...args);
}

function tsBooleanKeyword(...args) {
  return (0, _builder.default)("TSBooleanKeyword", ...args);
}

function tsBigIntKeyword(...args) {
  return (0, _builder.default)("TSBigIntKeyword", ...args);
}

function tsNeverKeyword(...args) {
  return (0, _builder.default)("TSNeverKeyword", ...args);
}

function tsNullKeyword(...args) {
  return (0, _builder.default)("TSNullKeyword", ...args);
}

function tsNumberKeyword(...args) {
  return (0, _builder.default)("TSNumberKeyword", ...args);
}

function tsObjectKeyword(...args) {
  return (0, _builder.default)("TSObjectKeyword", ...args);
}

function tsStringKeyword(...args) {
  return (0, _builder.default)("TSStringKeyword", ...args);
}

function tsSymbolKeyword(...args) {
  return (0, _builder.default)("TSSymbolKeyword", ...args);
}

function tsUndefinedKeyword(...args) {
  return (0, _builder.default)("TSUndefinedKeyword", ...args);
}

function tsUnknownKeyword(...args) {
  return (0, _builder.default)("TSUnknownKeyword", ...args);
}

function tsVoidKeyword(...args) {
  return (0, _builder.default)("TSVoidKeyword", ...args);
}

function tsThisType(...args) {
  return (0, _builder.default)("TSThisType", ...args);
}

function tsFunctionType(...args) {
  return (0, _builder.default)("TSFunctionType", ...args);
}

function tsConstructorType(...args) {
  return (0, _builder.default)("TSConstructorType", ...args);
}

function tsTypeReference(...args) {
  return (0, _builder.default)("TSTypeReference", ...args);
}

function tsTypePredicate(...args) {
  return (0, _builder.default)("TSTypePredicate", ...args);
}

function tsTypeQuery(...args) {
  return (0, _builder.default)("TSTypeQuery", ...args);
}

function tsTypeLiteral(...args) {
  return (0, _builder.default)("TSTypeLiteral", ...args);
}

function tsArrayType(...args) {
  return (0, _builder.default)("TSArrayType", ...args);
}

function tsTupleType(...args) {
  return (0, _builder.default)("TSTupleType", ...args);
}

function tsOptionalType(...args) {
  return (0, _builder.default)("TSOptionalType", ...args);
}

function tsRestType(...args) {
  return (0, _builder.default)("TSRestType", ...args);
}

function tsUnionType(...args) {
  return (0, _builder.default)("TSUnionType", ...args);
}

function tsIntersectionType(...args) {
  return (0, _builder.default)("TSIntersectionType", ...args);
}

function tsConditionalType(...args) {
  return (0, _builder.default)("TSConditionalType", ...args);
}

function tsInferType(...args) {
  return (0, _builder.default)("TSInferType", ...args);
}

function tsParenthesizedType(...args) {
  return (0, _builder.default)("TSParenthesizedType", ...args);
}

function tsTypeOperator(...args) {
  return (0, _builder.default)("TSTypeOperator", ...args);
}

function tsIndexedAccessType(...args) {
  return (0, _builder.default)("TSIndexedAccessType", ...args);
}

function tsMappedType(...args) {
  return (0, _builder.default)("TSMappedType", ...args);
}

function tsLiteralType(...args) {
  return (0, _builder.default)("TSLiteralType", ...args);
}

function tsExpressionWithTypeArguments(...args) {
  return (0, _builder.default)("TSExpressionWithTypeArguments", ...args);
}

function tsInterfaceDeclaration(...args) {
  return (0, _builder.default)("TSInterfaceDeclaration", ...args);
}

function tsInterfaceBody(...args) {
  return (0, _builder.default)("TSInterfaceBody", ...args);
}

function tsTypeAliasDeclaration(...args) {
  return (0, _builder.default)("TSTypeAliasDeclaration", ...args);
}

function tsAsExpression(...args) {
  return (0, _builder.default)("TSAsExpression", ...args);
}

function tsTypeAssertion(...args) {
  return (0, _builder.default)("TSTypeAssertion", ...args);
}

function tsEnumDeclaration(...args) {
  return (0, _builder.default)("TSEnumDeclaration", ...args);
}

function tsEnumMember(...args) {
  return (0, _builder.default)("TSEnumMember", ...args);
}

function tsModuleDeclaration(...args) {
  return (0, _builder.default)("TSModuleDeclaration", ...args);
}

function tsModuleBlock(...args) {
  return (0, _builder.default)("TSModuleBlock", ...args);
}

function tsImportType(...args) {
  return (0, _builder.default)("TSImportType", ...args);
}

function tsImportEqualsDeclaration(...args) {
  return (0, _builder.default)("TSImportEqualsDeclaration", ...args);
}

function tsExternalModuleReference(...args) {
  return (0, _builder.default)("TSExternalModuleReference", ...args);
}

function tsNonNullExpression(...args) {
  return (0, _builder.default)("TSNonNullExpression", ...args);
}

function tsExportAssignment(...args) {
  return (0, _builder.default)("TSExportAssignment", ...args);
}

function tsNamespaceExportDeclaration(...args) {
  return (0, _builder.default)("TSNamespaceExportDeclaration", ...args);
}

function tsTypeAnnotation(...args) {
  return (0, _builder.default)("TSTypeAnnotation", ...args);
}

function tsTypeParameterInstantiation(...args) {
  return (0, _builder.default)("TSTypeParameterInstantiation", ...args);
}

function tsTypeParameterDeclaration(...args) {
  return (0, _builder.default)("TSTypeParameterDeclaration", ...args);
}

function tsTypeParameter(...args) {
  return (0, _builder.default)("TSTypeParameter", ...args);
}

function NumberLiteral(...args) {
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
  return (0, _builder.default)("NumberLiteral", ...args);
}

function RegexLiteral(...args) {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  return (0, _builder.default)("RegexLiteral", ...args);
}

function RestProperty(...args) {
  console.trace("The node type RestProperty has been renamed to RestElement");
  return (0, _builder.default)("RestProperty", ...args);
}

function SpreadProperty(...args) {
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
  return (0, _builder.default)("SpreadProperty", ...args);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/builders/react/buildChildren.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/builders/react/buildChildren.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildChildren;

var _generated = __webpack_require__(/*! ../../validators/generated */ "./node_modules/@babel/types/lib/validators/generated/index.js");

var _cleanJSXElementLiteralChild = _interopRequireDefault(__webpack_require__(/*! ../../utils/react/cleanJSXElementLiteralChild */ "./node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function buildChildren(node) {
  const elements = [];

  for (let i = 0; i < node.children.length; i++) {
    let child = node.children[i];

    if ((0, _generated.isJSXText)(child)) {
      (0, _cleanJSXElementLiteralChild.default)(child, elements);
      continue;
    }

    if ((0, _generated.isJSXExpressionContainer)(child)) child = child.expression;
    if ((0, _generated.isJSXEmptyExpression)(child)) continue;
    elements.push(child);
  }

  return elements;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createTSUnionType;

var _generated = __webpack_require__(/*! ../generated */ "./node_modules/@babel/types/lib/builders/generated/index.js");

var _removeTypeDuplicates = _interopRequireDefault(__webpack_require__(/*! ../../modifications/typescript/removeTypeDuplicates */ "./node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createTSUnionType(typeAnnotations) {
  const types = typeAnnotations.map(type => type.typeAnnotations);
  const flattened = (0, _removeTypeDuplicates.default)(types);

  if (flattened.length === 1) {
    return flattened[0];
  } else {
    return (0, _generated.tsUnionType)(flattened);
  }
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/clone/clone.js":
/*!******************************************************!*\
  !*** ./node_modules/@babel/types/lib/clone/clone.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = clone;

var _cloneNode = _interopRequireDefault(__webpack_require__(/*! ./cloneNode */ "./node_modules/@babel/types/lib/clone/cloneNode.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function clone(node) {
  return (0, _cloneNode.default)(node, false);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/clone/cloneDeep.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/types/lib/clone/cloneDeep.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneDeep;

var _cloneNode = _interopRequireDefault(__webpack_require__(/*! ./cloneNode */ "./node_modules/@babel/types/lib/clone/cloneNode.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function cloneDeep(node) {
  return (0, _cloneNode.default)(node);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneDeepWithoutLoc;

var _cloneNode = _interopRequireDefault(__webpack_require__(/*! ./cloneNode */ "./node_modules/@babel/types/lib/clone/cloneNode.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function cloneDeepWithoutLoc(node) {
  return (0, _cloneNode.default)(node, true, true);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/clone/cloneNode.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/types/lib/clone/cloneNode.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneNode;

var _definitions = __webpack_require__(/*! ../definitions */ "./node_modules/@babel/types/lib/definitions/index.js");

const has = Function.call.bind(Object.prototype.hasOwnProperty);

function cloneIfNode(obj, deep, withoutLoc) {
  if (obj && typeof obj.type === "string") {
    return cloneNode(obj, deep, withoutLoc);
  }

  return obj;
}

function cloneIfNodeOrArray(obj, deep, withoutLoc) {
  if (Array.isArray(obj)) {
    return obj.map(node => cloneIfNode(node, deep, withoutLoc));
  }

  return cloneIfNode(obj, deep, withoutLoc);
}

function cloneNode(node, deep = true, withoutLoc = false) {
  if (!node) return node;
  const {
    type
  } = node;
  const newNode = {
    type
  };

  if (type === "Identifier") {
    newNode.name = node.name;

    if (has(node, "optional") && typeof node.optional === "boolean") {
      newNode.optional = node.optional;
    }

    if (has(node, "typeAnnotation")) {
      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation;
    }
  } else if (!has(_definitions.NODE_FIELDS, type)) {
    throw new Error(`Unknown node type: "${type}"`);
  } else {
    for (const field of Object.keys(_definitions.NODE_FIELDS[type])) {
      if (has(node, field)) {
        if (deep) {
          newNode[field] = type === "File" && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc);
        } else {
          newNode[field] = node[field];
        }
      }
    }
  }

  if (has(node, "loc")) {
    if (withoutLoc) {
      newNode.loc = null;
    } else {
      newNode.loc = node.loc;
    }
  }

  if (has(node, "leadingComments")) {
    newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc);
  }

  if (has(node, "innerComments")) {
    newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc);
  }

  if (has(node, "trailingComments")) {
    newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc);
  }

  if (has(node, "extra")) {
    newNode.extra = Object.assign({}, node.extra);
  }

  return newNode;
}

function cloneCommentsWithoutLoc(comments) {
  return comments.map(({
    type,
    value
  }) => ({
    type,
    value,
    loc: null
  }));
}

function maybeCloneComments(comments, deep, withoutLoc) {
  return deep && withoutLoc ? cloneCommentsWithoutLoc(comments) : comments;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/clone/cloneWithoutLoc.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/types/lib/clone/cloneWithoutLoc.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneWithoutLoc;

var _cloneNode = _interopRequireDefault(__webpack_require__(/*! ./cloneNode */ "./node_modules/@babel/types/lib/clone/cloneNode.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function cloneWithoutLoc(node) {
  return (0, _cloneNode.default)(node, false, true);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/comments/addComment.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/types/lib/comments/addComment.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = addComment;

var _addComments = _interopRequireDefault(__webpack_require__(/*! ./addComments */ "./node_modules/@babel/types/lib/comments/addComments.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function addComment(node, type, content, line) {
  return (0, _addComments.default)(node, type, [{
    type: line ? "CommentLine" : "CommentBlock",
    value: content
  }]);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/comments/addComments.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/types/lib/comments/addComments.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = addComments;

function addComments(node, type, comments) {
  if (!comments || !node) return node;
  const key = `${type}Comments`;

  if (node[key]) {
    if (type === "leading") {
      node[key] = comments.concat(node[key]);
    } else {
      node[key] = node[key].concat(comments);
    }
  } else {
    node[key] = comments;
  }

  return node;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/comments/inheritInnerComments.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/comments/inheritInnerComments.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inheritInnerComments;

var _inherit = _interopRequireDefault(__webpack_require__(/*! ../utils/inherit */ "./node_modules/@babel/types/lib/utils/inherit.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inheritInnerComments(child, parent) {
  (0, _inherit.default)("innerComments", child, parent);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/comments/inheritLeadingComments.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/comments/inheritLeadingComments.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inheritLeadingComments;

var _inherit = _interopRequireDefault(__webpack_require__(/*! ../utils/inherit */ "./node_modules/@babel/types/lib/utils/inherit.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inheritLeadingComments(child, parent) {
  (0, _inherit.default)("leadingComments", child, parent);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/comments/inheritTrailingComments.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/comments/inheritTrailingComments.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inheritTrailingComments;

var _inherit = _interopRequireDefault(__webpack_require__(/*! ../utils/inherit */ "./node_modules/@babel/types/lib/utils/inherit.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inheritTrailingComments(child, parent) {
  (0, _inherit.default)("trailingComments", child, parent);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/comments/inheritsComments.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/comments/inheritsComments.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inheritsComments;

var _inheritTrailingComments = _interopRequireDefault(__webpack_require__(/*! ./inheritTrailingComments */ "./node_modules/@babel/types/lib/comments/inheritTrailingComments.js"));

var _inheritLeadingComments = _interopRequireDefault(__webpack_require__(/*! ./inheritLeadingComments */ "./node_modules/@babel/types/lib/comments/inheritLeadingComments.js"));

var _inheritInnerComments = _interopRequireDefault(__webpack_require__(/*! ./inheritInnerComments */ "./node_modules/@babel/types/lib/comments/inheritInnerComments.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inheritsComments(child, parent) {
  (0, _inheritTrailingComments.default)(child, parent);
  (0, _inheritLeadingComments.default)(child, parent);
  (0, _inheritInnerComments.default)(child, parent);
  return child;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/comments/removeComments.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/comments/removeComments.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeComments;

var _constants = __webpack_require__(/*! ../constants */ "./node_modules/@babel/types/lib/constants/index.js");

function removeComments(node) {
  _constants.COMMENT_KEYS.forEach(key => {
    node[key] = null;
  });

  return node;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/constants/generated/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/constants/generated/index.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TSBASETYPE_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.PRIVATE_TYPES = exports.JSX_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.FLOWTYPE_TYPES = exports.FLOW_TYPES = exports.MODULESPECIFIER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = exports.CLASS_TYPES = exports.PATTERN_TYPES = exports.UNARYLIKE_TYPES = exports.PROPERTY_TYPES = exports.OBJECTMEMBER_TYPES = exports.METHOD_TYPES = exports.USERWHITESPACABLE_TYPES = exports.IMMUTABLE_TYPES = exports.LITERAL_TYPES = exports.TSENTITYNAME_TYPES = exports.LVAL_TYPES = exports.PATTERNLIKE_TYPES = exports.DECLARATION_TYPES = exports.PUREISH_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FUNCTION_TYPES = exports.FORXSTATEMENT_TYPES = exports.FOR_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.WHILE_TYPES = exports.LOOP_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.SCOPABLE_TYPES = exports.BINARY_TYPES = exports.EXPRESSION_TYPES = void 0;

var _definitions = __webpack_require__(/*! ../../definitions */ "./node_modules/@babel/types/lib/definitions/index.js");

const EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Expression"];
exports.EXPRESSION_TYPES = EXPRESSION_TYPES;
const BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Binary"];
exports.BINARY_TYPES = BINARY_TYPES;
const SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Scopable"];
exports.SCOPABLE_TYPES = SCOPABLE_TYPES;
const BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["BlockParent"];
exports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
const BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Block"];
exports.BLOCK_TYPES = BLOCK_TYPES;
const STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Statement"];
exports.STATEMENT_TYPES = STATEMENT_TYPES;
const TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Terminatorless"];
exports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
const COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["CompletionStatement"];
exports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
const CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Conditional"];
exports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
const LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Loop"];
exports.LOOP_TYPES = LOOP_TYPES;
const WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["While"];
exports.WHILE_TYPES = WHILE_TYPES;
const EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
exports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
const FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["For"];
exports.FOR_TYPES = FOR_TYPES;
const FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ForXStatement"];
exports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
const FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Function"];
exports.FUNCTION_TYPES = FUNCTION_TYPES;
const FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FunctionParent"];
exports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
const PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pureish"];
exports.PUREISH_TYPES = PUREISH_TYPES;
const DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Declaration"];
exports.DECLARATION_TYPES = DECLARATION_TYPES;
const PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["PatternLike"];
exports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
const LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["LVal"];
exports.LVAL_TYPES = LVAL_TYPES;
const TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSEntityName"];
exports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
const LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Literal"];
exports.LITERAL_TYPES = LITERAL_TYPES;
const IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Immutable"];
exports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
const USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
exports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
const METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Method"];
exports.METHOD_TYPES = METHOD_TYPES;
const OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ObjectMember"];
exports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
const PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Property"];
exports.PROPERTY_TYPES = PROPERTY_TYPES;
const UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UnaryLike"];
exports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
const PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pattern"];
exports.PATTERN_TYPES = PATTERN_TYPES;
const CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Class"];
exports.CLASS_TYPES = CLASS_TYPES;
const MODULEDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
exports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
const EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
exports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
const MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
exports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
const FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Flow"];
exports.FLOW_TYPES = FLOW_TYPES;
const FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowType"];
exports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
const FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
exports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
const FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
exports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
const FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowPredicate"];
exports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
const ENUMBODY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumBody"];
exports.ENUMBODY_TYPES = ENUMBODY_TYPES;
const ENUMMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumMember"];
exports.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
const JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS["JSX"];
exports.JSX_TYPES = JSX_TYPES;
const PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Private"];
exports.PRIVATE_TYPES = PRIVATE_TYPES;
const TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSTypeElement"];
exports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
const TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSType"];
exports.TSTYPE_TYPES = TSTYPE_TYPES;
const TSBASETYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSBaseType"];
exports.TSBASETYPE_TYPES = TSBASETYPE_TYPES;

/***/ }),

/***/ "./node_modules/@babel/types/lib/constants/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/types/lib/constants/index.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = void 0;
const STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
exports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
const FLATTENABLE_KEYS = ["body", "expressions"];
exports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
const FOR_INIT_KEYS = ["left", "init"];
exports.FOR_INIT_KEYS = FOR_INIT_KEYS;
const COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
exports.COMMENT_KEYS = COMMENT_KEYS;
const LOGICAL_OPERATORS = ["||", "&&", "??"];
exports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
const UPDATE_OPERATORS = ["++", "--"];
exports.UPDATE_OPERATORS = UPDATE_OPERATORS;
const BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
const EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
const COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
const BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
const NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
const BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS];
exports.BINARY_OPERATORS = BINARY_OPERATORS;
const ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map(op => op + "="), ...LOGICAL_OPERATORS.map(op => op + "=")];
exports.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
const BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
const NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
const STRING_UNARY_OPERATORS = ["typeof"];
exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
const UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
exports.UNARY_OPERATORS = UNARY_OPERATORS;
const INHERIT_KEYS = {
  optional: ["typeAnnotation", "typeParameters", "returnType"],
  force: ["start", "loc", "end"]
};
exports.INHERIT_KEYS = INHERIT_KEYS;
const BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
exports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
const NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
exports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;

/***/ }),

/***/ "./node_modules/@babel/types/lib/converters/ensureBlock.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/ensureBlock.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ensureBlock;

var _toBlock = _interopRequireDefault(__webpack_require__(/*! ./toBlock */ "./node_modules/@babel/types/lib/converters/toBlock.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ensureBlock(node, key = "body") {
  return node[key] = (0, _toBlock.default)(node[key], node);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js ***!
  \*******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = gatherSequenceExpressions;

var _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(/*! ../retrievers/getBindingIdentifiers */ "./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"));

var _generated = __webpack_require__(/*! ../validators/generated */ "./node_modules/@babel/types/lib/validators/generated/index.js");

var _generated2 = __webpack_require__(/*! ../builders/generated */ "./node_modules/@babel/types/lib/builders/generated/index.js");

var _cloneNode = _interopRequireDefault(__webpack_require__(/*! ../clone/cloneNode */ "./node_modules/@babel/types/lib/clone/cloneNode.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function gatherSequenceExpressions(nodes, scope, declars) {
  const exprs = [];
  let ensureLastUndefined = true;

  for (const node of nodes) {
    if (!(0, _generated.isEmptyStatement)(node)) {
      ensureLastUndefined = false;
    }

    if ((0, _generated.isExpression)(node)) {
      exprs.push(node);
    } else if ((0, _generated.isExpressionStatement)(node)) {
      exprs.push(node.expression);
    } else if ((0, _generated.isVariableDeclaration)(node)) {
      if (node.kind !== "var") return;

      for (const declar of node.declarations) {
        const bindings = (0, _getBindingIdentifiers.default)(declar);

        for (const key of Object.keys(bindings)) {
          declars.push({
            kind: node.kind,
            id: (0, _cloneNode.default)(bindings[key])
          });
        }

        if (declar.init) {
          exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));
        }
      }

      ensureLastUndefined = true;
    } else if ((0, _generated.isIfStatement)(node)) {
      const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
      const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
      if (!consequent || !alternate) return;
      exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));
    } else if ((0, _generated.isBlockStatement)(node)) {
      const body = gatherSequenceExpressions(node.body, scope, declars);
      if (!body) return;
      exprs.push(body);
    } else if ((0, _generated.isEmptyStatement)(node)) {
      if (nodes.indexOf(node) === 0) {
        ensureLastUndefined = true;
      }
    } else {
      return;
    }
  }

  if (ensureLastUndefined) {
    exprs.push(scope.buildUndefinedNode());
  }

  if (exprs.length === 1) {
    return exprs[0];
  } else {
    return (0, _generated2.sequenceExpression)(exprs);
  }
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/converters/toBindingIdentifierName.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/toBindingIdentifierName.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toBindingIdentifierName;

var _toIdentifier = _interopRequireDefault(__webpack_require__(/*! ./toIdentifier */ "./node_modules/@babel/types/lib/converters/toIdentifier.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toBindingIdentifierName(name) {
  name = (0, _toIdentifier.default)(name);
  if (name === "eval" || name === "arguments") name = "_" + name;
  return name;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/converters/toBlock.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/toBlock.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toBlock;

var _generated = __webpack_require__(/*! ../validators/generated */ "./node_modules/@babel/types/lib/validators/generated/index.js");

var _generated2 = __webpack_require__(/*! ../builders/generated */ "./node_modules/@babel/types/lib/builders/generated/index.js");

function toBlock(node, parent) {
  if ((0, _generated.isBlockStatement)(node)) {
    return node;
  }

  let blockNodes = [];

  if ((0, _generated.isEmptyStatement)(node)) {
    blockNodes = [];
  } else {
    if (!(0, _generated.isStatement)(node)) {
      if ((0, _generated.isFunction)(parent)) {
        node = (0, _generated2.returnStatement)(node);
      } else {
        node = (0, _generated2.expressionStatement)(node);
      }
    }

    blockNodes = [node];
  }

  return (0, _generated2.blockStatement)(blockNodes);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/converters/toComputedKey.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/toComputedKey.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toComputedKey;

var _generated = __webpack_require__(/*! ../validators/generated */ "./node_modules/@babel/types/lib/validators/generated/index.js");

var _generated2 = __webpack_require__(/*! ../builders/generated */ "./node_modules/@babel/types/lib/builders/generated/index.js");

function toComputedKey(node, key = node.key || node.property) {
  if (!node.computed && (0, _generated.isIdentifier)(key)) key = (0, _generated2.stringLiteral)(key.name);
  return key;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/converters/toExpression.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/toExpression.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toExpression;

var _generated = __webpack_require__(/*! ../validators/generated */ "./node_modules/@babel/types/lib/validators/generated/index.js");

function toExpression(node) {
  if ((0, _generated.isExpressionStatement)(node)) {
    node = node.expression;
  }

  if ((0, _generated.isExpression)(node)) {
    return node;
  }

  if ((0, _generated.isClass)(node)) {
    node.type = "ClassExpression";
  } else if ((0, _generated.isFunction)(node)) {
    node.type = "FunctionExpression";
  }

  if (!(0, _generated.isExpression)(node)) {
    throw new Error(`cannot turn ${node.type} to an expression`);
  }

  return node;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/converters/toIdentifier.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/toIdentifier.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toIdentifier;

var _isValidIdentifier = _interopRequireDefault(__webpack_require__(/*! ../validators/isValidIdentifier */ "./node_modules/@babel/types/lib/validators/isValidIdentifier.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toIdentifier(name) {
  name = name + "";
  name = name.replace(/[^a-zA-Z0-9$_]/g, "-");
  name = name.replace(/^[-0-9]+/, "");
  name = name.replace(/[-\s]+(.)?/g, function (match, c) {
    return c ? c.toUpperCase() : "";
  });

  if (!(0, _isValidIdentifier.default)(name)) {
    name = `_${name}`;
  }

  return name || "_";
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/converters/toKeyAlias.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/toKeyAlias.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toKeyAlias;

var _generated = __webpack_require__(/*! ../validators/generated */ "./node_modules/@babel/types/lib/validators/generated/index.js");

var _cloneNode = _interopRequireDefault(__webpack_require__(/*! ../clone/cloneNode */ "./node_modules/@babel/types/lib/clone/cloneNode.js"));

var _removePropertiesDeep = _interopRequireDefault(__webpack_require__(/*! ../modifications/removePropertiesDeep */ "./node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toKeyAlias(node, key = node.key) {
  let alias;

  if (node.kind === "method") {
    return toKeyAlias.increment() + "";
  } else if ((0, _generated.isIdentifier)(key)) {
    alias = key.name;
  } else if ((0, _generated.isStringLiteral)(key)) {
    alias = JSON.stringify(key.value);
  } else {
    alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
  }

  if (node.computed) {
    alias = `[${alias}]`;
  }

  if (node.static) {
    alias = `static:${alias}`;
  }

  return alias;
}

toKeyAlias.uid = 0;

toKeyAlias.increment = function () {
  if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
    return toKeyAlias.uid = 0;
  } else {
    return toKeyAlias.uid++;
  }
};

/***/ }),

/***/ "./node_modules/@babel/types/lib/converters/toSequenceExpression.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/toSequenceExpression.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toSequenceExpression;

var _gatherSequenceExpressions = _interopRequireDefault(__webpack_require__(/*! ./gatherSequenceExpressions */ "./node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toSequenceExpression(nodes, scope) {
  if (!(nodes == null ? void 0 : nodes.length)) return;
  const declars = [];
  const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
  if (!result) return;

  for (const declar of declars) {
    scope.push(declar);
  }

  return result;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/converters/toStatement.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/toStatement.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toStatement;

var _generated = __webpack_require__(/*! ../validators/generated */ "./node_modules/@babel/types/lib/validators/generated/index.js");

var _generated2 = __webpack_require__(/*! ../builders/generated */ "./node_modules/@babel/types/lib/builders/generated/index.js");

function toStatement(node, ignore) {
  if ((0, _generated.isStatement)(node)) {
    return node;
  }

  let mustHaveId = false;
  let newType;

  if ((0, _generated.isClass)(node)) {
    mustHaveId = true;
    newType = "ClassDeclaration";
  } else if ((0, _generated.isFunction)(node)) {
    mustHaveId = true;
    newType = "FunctionDeclaration";
  } else if ((0, _generated.isAssignmentExpression)(node)) {
    return (0, _generated2.expressionStatement)(node);
  }

  if (mustHaveId && !node.id) {
    newType = false;
  }

  if (!newType) {
    if (ignore) {
      return false;
    } else {
      throw new Error(`cannot turn ${node.type} to a statement`);
    }
  }

  node.type = newType;
  return node;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/converters/valueToNode.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/types/lib/converters/valueToNode.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = valueToNode;

var _isPlainObject = _interopRequireDefault(__webpack_require__(/*! lodash/isPlainObject */ "./node_modules/lodash/isPlainObject.js"));

var _isRegExp = _interopRequireDefault(__webpack_require__(/*! lodash/isRegExp */ "./node_modules/lodash/isRegExp.js"));

var _isValidIdentifier = _interopRequireDefault(__webpack_require__(/*! ../validators/isValidIdentifier */ "./node_modules/@babel/types/lib/validators/isValidIdentifier.js"));

var _generated = __webpack_require__(/*! ../builders/generated */ "./node_modules/@babel/types/lib/builders/generated/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function valueToNode(value) {
  if (value === undefined) {
    return (0, _generated.identifier)("undefined");
  }

  if (value === true || value === false) {
    return (0, _generated.booleanLiteral)(value);
  }

  if (value === null) {
    return (0, _generated.nullLiteral)();
  }

  if (typeof value === "string") {
    return (0, _generated.stringLiteral)(value);
  }

  if (typeof value === "number") {
    let result;

    if (Number.isFinite(value)) {
      result = (0, _generated.numericLiteral)(Math.abs(value));
    } else {
      let numerator;

      if (Number.isNaN(value)) {
        numerator = (0, _generated.numericLiteral)(0);
      } else {
        numerator = (0, _generated.numericLiteral)(1);
      }

      result = (0, _generated.binaryExpression)("/", numerator, (0, _generated.numericLiteral)(0));
    }

    if (value < 0 || Object.is(value, -0)) {
      result = (0, _generated.unaryExpression)("-", result);
    }

    return result;
  }

  if ((0, _isRegExp.default)(value)) {
    const pattern = value.source;
    const flags = value.toString().match(/\/([a-z]+|)$/)[1];
    return (0, _generated.regExpLiteral)(pattern, flags);
  }

  if (Array.isArray(value)) {
    return (0, _generated.arrayExpression)(value.map(valueToNode));
  }

  if ((0, _isPlainObject.default)(value)) {
    const props = [];

    for (const key of Object.keys(value)) {
      let nodeKey;

      if ((0, _isValidIdentifier.default)(key)) {
        nodeKey = (0, _generated.identifier)(key);
      } else {
        nodeKey = (0, _generated.stringLiteral)(key);
      }

      props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));
    }

    return (0, _generated.objectExpression)(props);
  }

  throw new Error("don't know how to turn this value into a node");
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/definitions/core.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/types/lib/definitions/core.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;

var _is = _interopRequireDefault(__webpack_require__(/*! ../validators/is */ "./node_modules/@babel/types/lib/validators/is.js"));

var _isValidIdentifier = _interopRequireDefault(__webpack_require__(/*! ../validators/isValidIdentifier */ "./node_modules/@babel/types/lib/validators/isValidIdentifier.js"));

var _helperValidatorIdentifier = __webpack_require__(/*! @babel/helper-validator-identifier */ "./node_modules/@babel/helper-validator-identifier/lib/index.js");

var _constants = __webpack_require__(/*! ../constants */ "./node_modules/@babel/types/lib/constants/index.js");

var _utils = _interopRequireWildcard(__webpack_require__(/*! ./utils */ "./node_modules/@babel/types/lib/definitions/utils.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _utils.default)("ArrayExpression", {
  fields: {
    elements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined
    }
  },
  visitor: ["elements"],
  aliases: ["Expression"]
});
(0, _utils.default)("AssignmentExpression", {
  fields: {
    operator: {
      validate: function () {
        if (!process.env.BABEL_TYPES_8_BREAKING) {
          return (0, _utils.assertValueType)("string");
        }

        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);
        const pattern = (0, _utils.assertOneOf)("=");
        return function (node, key, val) {
          const validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier;
          validator(node, key, val);
        };
      }()
    },
    left: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Expression"]
});
(0, _utils.default)("BinaryExpression", {
  builder: ["operator", "left", "right"],
  fields: {
    operator: {
      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)
    },
    left: {
      validate: function () {
        const expression = (0, _utils.assertNodeType)("Expression");
        const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");

        const validator = function (node, key, val) {
          const validator = node.operator === "in" ? inOp : expression;
          validator(node, key, val);
        };

        validator.oneOfNodeTypes = ["Expression", "PrivateName"];
        return validator;
      }()
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"]
});
(0, _utils.default)("InterpreterDirective", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
(0, _utils.default)("Directive", {
  visitor: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertNodeType)("DirectiveLiteral")
    }
  }
});
(0, _utils.default)("DirectiveLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
(0, _utils.default)("BlockStatement", {
  builder: ["body", "directives"],
  visitor: ["directives", "body"],
  fields: {
    directives: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
      default: []
    },
    body: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
    }
  },
  aliases: ["Scopable", "BlockParent", "Block", "Statement"]
});
(0, _utils.default)("BreakStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});
(0, _utils.default)("CallExpression", {
  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
  builder: ["callee", "arguments"],
  aliases: ["Expression"],
  fields: Object.assign({
    callee: {
      validate: (0, _utils.assertNodeType)("Expression", "V8IntrinsicIdentifier")
    },
    arguments: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
    }
  }, !process.env.BABEL_TYPES_8_BREAKING ? {
    optional: {
      validate: (0, _utils.assertOneOf)(true, false),
      optional: true
    }
  } : {}, {
    typeArguments: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
      optional: true
    }
  })
});
(0, _utils.default)("CatchClause", {
  visitor: ["param", "body"],
  fields: {
    param: {
      validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  },
  aliases: ["Scopable", "BlockParent"]
});
(0, _utils.default)("ConditionalExpression", {
  visitor: ["test", "consequent", "alternate"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    consequent: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    alternate: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  aliases: ["Expression", "Conditional"]
});
(0, _utils.default)("ContinueStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});
(0, _utils.default)("DebuggerStatement", {
  aliases: ["Statement"]
});
(0, _utils.default)("DoWhileStatement", {
  visitor: ["test", "body"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  },
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
});
(0, _utils.default)("EmptyStatement", {
  aliases: ["Statement"]
});
(0, _utils.default)("ExpressionStatement", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  aliases: ["Statement", "ExpressionWrapper"]
});
(0, _utils.default)("File", {
  builder: ["program", "comments", "tokens"],
  visitor: ["program"],
  fields: {
    program: {
      validate: (0, _utils.assertNodeType)("Program")
    },
    comments: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {
        each: {
          oneOfNodeTypes: ["CommentBlock", "CommentLine"]
        }
      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
      optional: true
    },
    tokens: {
      validate: (0, _utils.assertEach)(Object.assign(() => {}, {
        type: "any"
      })),
      optional: true
    }
  }
});
(0, _utils.default)("ForInStatement", {
  visitor: ["left", "right", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
(0, _utils.default)("ForStatement", {
  visitor: ["init", "test", "update", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
  fields: {
    init: {
      validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
      optional: true
    },
    test: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    update: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
const functionCommon = {
  params: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
  },
  generator: {
    default: false
  },
  async: {
    default: false
  }
};
exports.functionCommon = functionCommon;
const functionTypeAnnotationCommon = {
  returnType: {
    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    optional: true
  },
  typeParameters: {
    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
    optional: true
  }
};
exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
const functionDeclarationCommon = Object.assign({}, functionCommon, {
  declare: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  id: {
    validate: (0, _utils.assertNodeType)("Identifier"),
    optional: true
  }
});
exports.functionDeclarationCommon = functionDeclarationCommon;
(0, _utils.default)("FunctionDeclaration", {
  builder: ["id", "params", "body", "generator", "async"],
  visitor: ["id", "params", "body", "returnType", "typeParameters"],
  fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }),
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
  validate: function () {
    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};
    const identifier = (0, _utils.assertNodeType)("Identifier");
    return function (parent, key, node) {
      if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
        identifier(node, "id", node.id);
      }
    };
  }()
});
(0, _utils.default)("FunctionExpression", {
  inherits: "FunctionDeclaration",
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  })
});
const patternLikeCommon = {
  typeAnnotation: {
    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    optional: true
  },
  decorators: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
  }
};
exports.patternLikeCommon = patternLikeCommon;
(0, _utils.default)("Identifier", {
  builder: ["name"],
  visitor: ["typeAnnotation", "decorators"],
  aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
  fields: Object.assign({}, patternLikeCommon, {
    name: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (!(0, _isValidIdentifier.default)(val, false)) {
          throw new TypeError(`"${val}" is not a valid identifier name`);
        }
      }, {
        type: "string"
      }))
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  }),

  validate(parent, key, node) {
    if (!process.env.BABEL_TYPES_8_BREAKING) return;
    const match = /\.(\w+)$/.exec(key);
    if (!match) return;
    const [, parentKey] = match;
    const nonComp = {
      computed: false
    };

    if (parentKey === "property") {
      if ((0, _is.default)("MemberExpression", parent, nonComp)) return;
      if ((0, _is.default)("OptionalMemberExpression", parent, nonComp)) return;
    } else if (parentKey === "key") {
      if ((0, _is.default)("Property", parent, nonComp)) return;
      if ((0, _is.default)("Method", parent, nonComp)) return;
    } else if (parentKey === "exported") {
      if ((0, _is.default)("ExportSpecifier", parent)) return;
    } else if (parentKey === "imported") {
      if ((0, _is.default)("ImportSpecifier", parent, {
        imported: node
      })) return;
    } else if (parentKey === "meta") {
      if ((0, _is.default)("MetaProperty", parent, {
        meta: node
      })) return;
    }

    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name)) && node.name !== "this") {
      throw new TypeError(`"${node.name}" is not a valid identifier`);
    }
  }

});
(0, _utils.default)("IfStatement", {
  visitor: ["test", "consequent", "alternate"],
  aliases: ["Statement", "Conditional"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    consequent: {
      validate: (0, _utils.assertNodeType)("Statement")
    },
    alternate: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
(0, _utils.default)("LabeledStatement", {
  visitor: ["label", "body"],
  aliases: ["Statement"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
(0, _utils.default)("StringLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("NumericLiteral", {
  builder: ["value"],
  deprecatedAlias: "NumberLiteral",
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("number")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("NullLiteral", {
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("BooleanLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("boolean")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("RegExpLiteral", {
  builder: ["pattern", "flags"],
  deprecatedAlias: "RegexLiteral",
  aliases: ["Expression", "Pureish", "Literal"],
  fields: {
    pattern: {
      validate: (0, _utils.assertValueType)("string")
    },
    flags: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        const invalid = /[^gimsuy]/.exec(val);

        if (invalid) {
          throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
        }
      }, {
        type: "string"
      })),
      default: ""
    }
  }
});
(0, _utils.default)("LogicalExpression", {
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"],
  fields: {
    operator: {
      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)
    },
    left: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("MemberExpression", {
  builder: ["object", "property", "computed", "optional"],
  visitor: ["object", "property"],
  aliases: ["Expression", "LVal"],
  fields: Object.assign({
    object: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    property: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
        const computed = (0, _utils.assertNodeType)("Expression");

        const validator = function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };

        validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
        return validator;
      }()
    },
    computed: {
      default: false
    }
  }, !process.env.BABEL_TYPES_8_BREAKING ? {
    optional: {
      validate: (0, _utils.assertOneOf)(true, false),
      optional: true
    }
  } : {})
});
(0, _utils.default)("NewExpression", {
  inherits: "CallExpression"
});
(0, _utils.default)("Program", {
  visitor: ["directives", "body"],
  builder: ["body", "directives", "sourceType", "interpreter"],
  fields: {
    sourceFile: {
      validate: (0, _utils.assertValueType)("string")
    },
    sourceType: {
      validate: (0, _utils.assertOneOf)("script", "module"),
      default: "script"
    },
    interpreter: {
      validate: (0, _utils.assertNodeType)("InterpreterDirective"),
      default: null,
      optional: true
    },
    directives: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
      default: []
    },
    body: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
    }
  },
  aliases: ["Scopable", "BlockParent", "Block"]
});
(0, _utils.default)("ObjectExpression", {
  visitor: ["properties"],
  aliases: ["Expression"],
  fields: {
    properties: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
    }
  }
});
(0, _utils.default)("ObjectMethod", {
  builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
    kind: Object.assign({
      validate: (0, _utils.assertOneOf)("method", "get", "set")
    }, !process.env.BABEL_TYPES_8_BREAKING ? {
      default: "method"
    } : {}),
    computed: {
      default: false
    },
    key: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
        const computed = (0, _utils.assertNodeType)("Expression");

        const validator = function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };

        validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"];
        return validator;
      }()
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }),
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
});
(0, _utils.default)("ObjectProperty", {
  builder: ["key", "value", "computed", "shorthand", ...(!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : [])],
  fields: {
    computed: {
      default: false
    },
    key: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
        const computed = (0, _utils.assertNodeType)("Expression");

        const validator = function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };

        validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"];
        return validator;
      }()
    },
    value: {
      validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
    },
    shorthand: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (val && node.computed) {
          throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }
      }, {
        type: "boolean"
      }), function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (val && !(0, _is.default)("Identifier", node.key)) {
          throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }
      }),
      default: false
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  },
  visitor: ["key", "value", "decorators"],
  aliases: ["UserWhitespacable", "Property", "ObjectMember"],
  validate: function () {
    const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern");
    const expression = (0, _utils.assertNodeType)("Expression");
    return function (parent, key, node) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
      validator(node, "value", node.value);
    };
  }()
});
(0, _utils.default)("RestElement", {
  visitor: ["argument", "typeAnnotation"],
  builder: ["argument"],
  aliases: ["LVal", "PatternLike"],
  deprecatedAlias: "RestProperty",
  fields: Object.assign({}, patternLikeCommon, {
    argument: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "Pattern", "MemberExpression")
    }
  }),

  validate(parent, key) {
    if (!process.env.BABEL_TYPES_8_BREAKING) return;
    const match = /(\w+)\[(\d+)\]/.exec(key);
    if (!match) throw new Error("Internal Babel error: malformed key.");
    const [, listKey, index] = match;

    if (parent[listKey].length > index + 1) {
      throw new TypeError(`RestElement must be last element of ${listKey}`);
    }
  }

});
(0, _utils.default)("ReturnStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    }
  }
});
(0, _utils.default)("SequenceExpression", {
  visitor: ["expressions"],
  fields: {
    expressions: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
    }
  },
  aliases: ["Expression"]
});
(0, _utils.default)("ParenthesizedExpression", {
  visitor: ["expression"],
  aliases: ["Expression", "ExpressionWrapper"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("SwitchCase", {
  visitor: ["test", "consequent"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    consequent: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
    }
  }
});
(0, _utils.default)("SwitchStatement", {
  visitor: ["discriminant", "cases"],
  aliases: ["Statement", "BlockParent", "Scopable"],
  fields: {
    discriminant: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    cases: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
    }
  }
});
(0, _utils.default)("ThisExpression", {
  aliases: ["Expression"]
});
(0, _utils.default)("ThrowStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("TryStatement", {
  visitor: ["block", "handler", "finalizer"],
  aliases: ["Statement"],
  fields: {
    block: {
      validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function (node) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (!node.handler && !node.finalizer) {
          throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }
      }, {
        oneOfNodeTypes: ["BlockStatement"]
      }))
    },
    handler: {
      optional: true,
      validate: (0, _utils.assertNodeType)("CatchClause")
    },
    finalizer: {
      optional: true,
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }
});
(0, _utils.default)("UnaryExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: true
    },
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    operator: {
      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)
    }
  },
  visitor: ["argument"],
  aliases: ["UnaryLike", "Expression"]
});
(0, _utils.default)("UpdateExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: false
    },
    argument: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
    },
    operator: {
      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)
    }
  },
  visitor: ["argument"],
  aliases: ["Expression"]
});
(0, _utils.default)("VariableDeclaration", {
  builder: ["kind", "declarations"],
  visitor: ["declarations"],
  aliases: ["Statement", "Declaration"],
  fields: {
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    kind: {
      validate: (0, _utils.assertOneOf)("var", "let", "const")
    },
    declarations: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
    }
  },

  validate(parent, key, node) {
    if (!process.env.BABEL_TYPES_8_BREAKING) return;
    if (!(0, _is.default)("ForXStatement", parent, {
      left: node
    })) return;

    if (node.declarations.length !== 1) {
      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
    }
  }

});
(0, _utils.default)("VariableDeclarator", {
  visitor: ["id", "init"],
  fields: {
    id: {
      validate: function () {
        if (!process.env.BABEL_TYPES_8_BREAKING) {
          return (0, _utils.assertNodeType)("LVal");
        }

        const normal = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern");
        const without = (0, _utils.assertNodeType)("Identifier");
        return function (node, key, val) {
          const validator = node.init ? normal : without;
          validator(node, key, val);
        };
      }()
    },
    definite: {
      optional: true,
      validate: (0, _utils.assertValueType)("boolean")
    },
    init: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("WhileStatement", {
  visitor: ["test", "body"],
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
(0, _utils.default)("WithStatement", {
  visitor: ["object", "body"],
  aliases: ["Statement"],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@babel/types/lib/definitions/es2015.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/types/lib/definitions/es2015.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.classMethodOrDeclareMethodCommon = exports.classMethodOrPropertyCommon = void 0;

var _utils = _interopRequireWildcard(__webpack_require__(/*! ./utils */ "./node_modules/@babel/types/lib/definitions/utils.js"));

var _core = __webpack_require__(/*! ./core */ "./node_modules/@babel/types/lib/definitions/core.js");

var _is = _interopRequireDefault(__webpack_require__(/*! ../validators/is */ "./node_modules/@babel/types/lib/validators/is.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

(0, _utils.default)("AssignmentPattern", {
  visitor: ["left", "right", "decorators"],
  builder: ["left", "right"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, _core.patternLikeCommon, {
    left: {
      validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  })
});
(0, _utils.default)("ArrayPattern", {
  visitor: ["elements", "typeAnnotation"],
  builder: ["elements"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, _core.patternLikeCommon, {
    elements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike")))
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  })
});
(0, _utils.default)("ArrowFunctionExpression", {
  builder: ["params", "body", "async"],
  visitor: ["params", "body", "returnType", "typeParameters"],
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: Object.assign({}, _core.functionCommon, _core.functionTypeAnnotationCommon, {
    expression: {
      validate: (0, _utils.assertValueType)("boolean")
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
    }
  })
});
(0, _utils.default)("ClassBody", {
  visitor: ["body"],
  fields: {
    body: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))
    }
  }
});
(0, _utils.default)("ClassExpression", {
  builder: ["id", "superClass", "body", "decorators"],
  visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
  aliases: ["Scopable", "Class", "Expression"],
  fields: {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("ClassBody")
    },
    superClass: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
    },
    superTypeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    },
    implements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    },
    mixins: {
      validate: (0, _utils.assertNodeType)("InterfaceExtends"),
      optional: true
    }
  }
});
(0, _utils.default)("ClassDeclaration", {
  inherits: "ClassExpression",
  aliases: ["Scopable", "Class", "Statement", "Declaration"],
  fields: {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("ClassBody")
    },
    superClass: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
    },
    superTypeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    },
    implements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    },
    mixins: {
      validate: (0, _utils.assertNodeType)("InterfaceExtends"),
      optional: true
    },
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    abstract: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  },
  validate: function () {
    const identifier = (0, _utils.assertNodeType)("Identifier");
    return function (parent, key, node) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;

      if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
        identifier(node, "id", node.id);
      }
    };
  }()
});
(0, _utils.default)("ExportAllDeclaration", {
  visitor: ["source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    source: {
      validate: (0, _utils.assertNodeType)("StringLiteral")
    }
  }
});
(0, _utils.default)("ExportDefaultDeclaration", {
  visitor: ["declaration"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    declaration: {
      validate: (0, _utils.assertNodeType)("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
    }
  }
});
(0, _utils.default)("ExportNamedDeclaration", {
  visitor: ["declaration", "specifiers", "source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    declaration: {
      optional: true,
      validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (val && node.specifiers.length) {
          throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }
      }, {
        oneOfNodeTypes: ["Declaration"]
      }), function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (val && node.source) {
          throw new TypeError("Cannot export a declaration from a source");
        }
      })
    },
    specifiers: {
      default: [],
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function () {
        const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
        const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;
        return function (node, key, val) {
          const validator = node.source ? sourced : sourceless;
          validator(node, key, val);
        };
      }()))
    },
    source: {
      validate: (0, _utils.assertNodeType)("StringLiteral"),
      optional: true
    },
    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
  }
});
(0, _utils.default)("ExportSpecifier", {
  visitor: ["local", "exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    exported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("ForOfStatement", {
  visitor: ["left", "right", "body"],
  builder: ["left", "right", "body", "await"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: function () {
        if (!process.env.BABEL_TYPES_8_BREAKING) {
          return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
        }

        const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
        const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern");
        return function (node, key, val) {
          if ((0, _is.default)("VariableDeclaration", val)) {
            declaration(node, key, val);
          } else {
            lval(node, key, val);
          }
        };
      }()
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    },
    await: {
      default: false
    }
  }
});
(0, _utils.default)("ImportDeclaration", {
  visitor: ["specifiers", "source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration"],
  fields: {
    specifiers: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
    },
    source: {
      validate: (0, _utils.assertNodeType)("StringLiteral")
    },
    importKind: {
      validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
      optional: true
    }
  }
});
(0, _utils.default)("ImportDefaultSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("ImportNamespaceSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("ImportSpecifier", {
  visitor: ["local", "imported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    imported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    importKind: {
      validate: (0, _utils.assertOneOf)("type", "typeof"),
      optional: true
    }
  }
});
(0, _utils.default)("MetaProperty", {
  visitor: ["meta", "property"],
  aliases: ["Expression"],
  fields: {
    meta: {
      validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        let property;

        switch (val.name) {
          case "function":
            property = "sent";
            break;

          case "new":
            property = "target";
            break;

          case "import":
            property = "meta";
            break;
        }

        if (!(0, _is.default)("Identifier", node.property, {
          name: property
        })) {
          throw new TypeError("Unrecognised MetaProperty");
        }
      }, {
        oneOfNodeTypes: ["Identifier"]
      }))
    },
    property: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
const classMethodOrPropertyCommon = {
  abstract: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  accessibility: {
    validate: (0, _utils.assertOneOf)("public", "private", "protected"),
    optional: true
  },
  static: {
    default: false
  },
  computed: {
    default: false
  },
  optional: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  key: {
    validate: (0, _utils.chain)(function () {
      const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
      const computed = (0, _utils.assertNodeType)("Expression");
      return function (node, key, val) {
        const validator = node.computed ? computed : normal;
        validator(node, key, val);
      };
    }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
  }
};
exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
const classMethodOrDeclareMethodCommon = Object.assign({}, _core.functionCommon, classMethodOrPropertyCommon, {
  kind: {
    validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
    default: "method"
  },
  access: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
    optional: true
  },
  decorators: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
    optional: true
  }
});
exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
(0, _utils.default)("ClassMethod", {
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
  builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  fields: Object.assign({}, classMethodOrDeclareMethodCommon, _core.functionTypeAnnotationCommon, {
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  })
});
(0, _utils.default)("ObjectPattern", {
  visitor: ["properties", "typeAnnotation", "decorators"],
  builder: ["properties"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, _core.patternLikeCommon, {
    properties: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
    }
  })
});
(0, _utils.default)("SpreadElement", {
  visitor: ["argument"],
  aliases: ["UnaryLike"],
  deprecatedAlias: "SpreadProperty",
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("Super", {
  aliases: ["Expression"]
});
(0, _utils.default)("TaggedTemplateExpression", {
  visitor: ["tag", "quasi"],
  aliases: ["Expression"],
  fields: {
    tag: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    quasi: {
      validate: (0, _utils.assertNodeType)("TemplateLiteral")
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    }
  }
});
(0, _utils.default)("TemplateElement", {
  builder: ["value", "tail"],
  fields: {
    value: {
      validate: (0, _utils.assertShape)({
        raw: {
          validate: (0, _utils.assertValueType)("string")
        },
        cooked: {
          validate: (0, _utils.assertValueType)("string"),
          optional: true
        }
      })
    },
    tail: {
      default: false
    }
  }
});
(0, _utils.default)("TemplateLiteral", {
  visitor: ["quasis", "expressions"],
  aliases: ["Expression", "Literal"],
  fields: {
    quasis: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
    },
    expressions: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")), function (node, key, val) {
        if (node.quasis.length !== val.length + 1) {
          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);
        }
      })
    }
  }
});
(0, _utils.default)("YieldExpression", {
  builder: ["argument", "delegate"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    delegate: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (val && !node.argument) {
          throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }
      }, {
        type: "boolean"
      })),
      default: false
    },
    argument: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@babel/types/lib/definitions/experimental.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/definitions/experimental.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _utils = _interopRequireWildcard(__webpack_require__(/*! ./utils */ "./node_modules/@babel/types/lib/definitions/utils.js"));

var _es = __webpack_require__(/*! ./es2015 */ "./node_modules/@babel/types/lib/definitions/es2015.js");

var _core = __webpack_require__(/*! ./core */ "./node_modules/@babel/types/lib/definitions/core.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

(0, _utils.default)("ArgumentPlaceholder", {});
(0, _utils.default)("AwaitExpression", {
  builder: ["argument"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("BindExpression", {
  visitor: ["object", "callee"],
  aliases: ["Expression"],
  fields: !process.env.BABEL_TYPES_8_BREAKING ? {
    object: {
      validate: Object.assign(() => {}, {
        oneOfNodeTypes: ["Expression"]
      })
    },
    callee: {
      validate: Object.assign(() => {}, {
        oneOfNodeTypes: ["Expression"]
      })
    }
  } : {
    object: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    callee: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("ClassProperty", {
  visitor: ["key", "value", "typeAnnotation", "decorators"],
  builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
  aliases: ["Property"],
  fields: Object.assign({}, _es.classMethodOrPropertyCommon, {
    value: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    definite: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    },
    readonly: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  })
});
(0, _utils.default)("OptionalMemberExpression", {
  builder: ["object", "property", "computed", "optional"],
  visitor: ["object", "property"],
  aliases: ["Expression"],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    property: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier");
        const computed = (0, _utils.assertNodeType)("Expression");

        const validator = function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };

        validator.oneOfNodeTypes = ["Expression", "Identifier"];
        return validator;
      }()
    },
    computed: {
      default: false
    },
    optional: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
    }
  }
});
(0, _utils.default)("PipelineTopicExpression", {
  builder: ["expression"],
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("PipelineBareFunction", {
  builder: ["callee"],
  visitor: ["callee"],
  fields: {
    callee: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("PipelinePrimaryTopicReference", {
  aliases: ["Expression"]
});
(0, _utils.default)("OptionalCallExpression", {
  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
  builder: ["callee", "arguments", "optional"],
  aliases: ["Expression"],
  fields: {
    callee: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    arguments: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName")))
    },
    optional: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
    },
    typeArguments: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
      optional: true
    }
  }
});
(0, _utils.default)("ClassPrivateProperty", {
  visitor: ["key", "value", "decorators"],
  builder: ["key", "value", "decorators"],
  aliases: ["Property", "Private"],
  fields: {
    key: {
      validate: (0, _utils.assertNodeType)("PrivateName")
    },
    value: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  }
});
(0, _utils.default)("ClassPrivateMethod", {
  builder: ["kind", "key", "params", "body", "static"],
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
  fields: Object.assign({}, _es.classMethodOrDeclareMethodCommon, _core.functionTypeAnnotationCommon, {
    key: {
      validate: (0, _utils.assertNodeType)("PrivateName")
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  })
});
(0, _utils.default)("Import", {
  aliases: ["Expression"]
});
(0, _utils.default)("ImportAttribute", {
  visitor: ["key", "value"],
  fields: {
    key: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    value: {
      validate: (0, _utils.assertNodeType)("StringLiteral")
    }
  }
});
(0, _utils.default)("Decorator", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("DoExpression", {
  visitor: ["body"],
  aliases: ["Expression"],
  fields: {
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }
});
(0, _utils.default)("ExportDefaultSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("ExportNamespaceSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("PrivateName", {
  visitor: ["id"],
  aliases: ["Private"],
  fields: {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("BigIntLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("RecordExpression", {
  visitor: ["properties"],
  aliases: ["Expression"],
  fields: {
    properties: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty", "SpreadElement")))
    }
  }
});
(0, _utils.default)("TupleExpression", {
  fields: {
    elements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))),
      default: []
    }
  },
  visitor: ["elements"],
  aliases: ["Expression"]
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@babel/types/lib/definitions/flow.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/types/lib/definitions/flow.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _utils = _interopRequireWildcard(__webpack_require__(/*! ./utils */ "./node_modules/@babel/types/lib/definitions/utils.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const defineInterfaceishType = (name, typeParameterType = "TypeParameterDeclaration") => {
  (0, _utils.default)(name, {
    builder: ["id", "typeParameters", "extends", "body"],
    visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)(typeParameterType),
      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
      mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
      implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements")),
      body: (0, _utils.validateType)("ObjectTypeAnnotation")
    }
  });
};

(0, _utils.default)("AnyTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("ArrayTypeAnnotation", {
  visitor: ["elementType"],
  aliases: ["Flow", "FlowType"],
  fields: {
    elementType: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("BooleanTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("BooleanLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["Flow", "FlowType"],
  fields: {
    value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("NullLiteralTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("ClassImplements", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
  }
});
defineInterfaceishType("DeclareClass");
(0, _utils.default)("DeclareFunction", {
  visitor: ["id"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
  }
});
defineInterfaceishType("DeclareInterface");
(0, _utils.default)("DeclareModule", {
  builder: ["id", "body", "kind"],
  visitor: ["id", "body"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    body: (0, _utils.validateType)("BlockStatement"),
    kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
  }
});
(0, _utils.default)("DeclareModuleExports", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
  }
});
(0, _utils.default)("DeclareTypeAlias", {
  visitor: ["id", "typeParameters", "right"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    right: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("DeclareOpaqueType", {
  visitor: ["id", "typeParameters", "supertype"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    supertype: (0, _utils.validateOptionalType)("FlowType")
  }
});
(0, _utils.default)("DeclareVariable", {
  visitor: ["id"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier")
  }
});
(0, _utils.default)("DeclareExportDeclaration", {
  visitor: ["declaration", "specifiers", "source"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    declaration: (0, _utils.validateOptionalType)("Flow"),
    specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
    source: (0, _utils.validateOptionalType)("StringLiteral"),
    default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("DeclareExportAllDeclaration", {
  visitor: ["source"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    source: (0, _utils.validateType)("StringLiteral"),
    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
  }
});
(0, _utils.default)("DeclaredPredicate", {
  visitor: ["value"],
  aliases: ["Flow", "FlowPredicate"],
  fields: {
    value: (0, _utils.validateType)("Flow")
  }
});
(0, _utils.default)("ExistsTypeAnnotation", {
  aliases: ["Flow", "FlowType"]
});
(0, _utils.default)("FunctionTypeAnnotation", {
  visitor: ["typeParameters", "params", "rest", "returnType"],
  aliases: ["Flow", "FlowType"],
  fields: {
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
    rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
    returnType: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("FunctionTypeParam", {
  visitor: ["name", "typeAnnotation"],
  aliases: ["Flow"],
  fields: {
    name: (0, _utils.validateOptionalType)("Identifier"),
    typeAnnotation: (0, _utils.validateType)("FlowType"),
    optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("GenericTypeAnnotation", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow", "FlowType"],
  fields: {
    id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
  }
});
(0, _utils.default)("InferredPredicate", {
  aliases: ["Flow", "FlowPredicate"]
});
(0, _utils.default)("InterfaceExtends", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {
    id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
  }
});
defineInterfaceishType("InterfaceDeclaration");
(0, _utils.default)("InterfaceTypeAnnotation", {
  visitor: ["extends", "body"],
  aliases: ["Flow", "FlowType"],
  fields: {
    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
    body: (0, _utils.validateType)("ObjectTypeAnnotation")
  }
});
(0, _utils.default)("IntersectionTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow", "FlowType"],
  fields: {
    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
  }
});
(0, _utils.default)("MixedTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("EmptyTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("NullableTypeAnnotation", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow", "FlowType"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("NumberLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["Flow", "FlowType"],
  fields: {
    value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
  }
});
(0, _utils.default)("NumberTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("ObjectTypeAnnotation", {
  visitor: ["properties", "indexers", "callProperties", "internalSlots"],
  aliases: ["Flow", "FlowType"],
  builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
  fields: {
    properties: (0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
    indexers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeIndexer")),
    callProperties: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeCallProperty")),
    internalSlots: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeInternalSlot")),
    exact: {
      validate: (0, _utils.assertValueType)("boolean"),
      default: false
    },
    inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("ObjectTypeInternalSlot", {
  visitor: ["id", "value", "optional", "static", "method"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    value: (0, _utils.validateType)("FlowType"),
    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("ObjectTypeCallProperty", {
  visitor: ["value"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    value: (0, _utils.validateType)("FlowType"),
    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("ObjectTypeIndexer", {
  visitor: ["id", "key", "value", "variance"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    id: (0, _utils.validateOptionalType)("Identifier"),
    key: (0, _utils.validateType)("FlowType"),
    value: (0, _utils.validateType)("FlowType"),
    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    variance: (0, _utils.validateOptionalType)("Variance")
  }
});
(0, _utils.default)("ObjectTypeProperty", {
  visitor: ["key", "value", "variance"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    key: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    value: (0, _utils.validateType)("FlowType"),
    kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    variance: (0, _utils.validateOptionalType)("Variance")
  }
});
(0, _utils.default)("ObjectTypeSpreadProperty", {
  visitor: ["argument"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    argument: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("OpaqueType", {
  visitor: ["id", "typeParameters", "supertype", "impltype"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    supertype: (0, _utils.validateOptionalType)("FlowType"),
    impltype: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("QualifiedTypeIdentifier", {
  visitor: ["id", "qualification"],
  aliases: ["Flow"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    qualification: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"])
  }
});
(0, _utils.default)("StringLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["Flow", "FlowType"],
  fields: {
    value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
  }
});
(0, _utils.default)("StringTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("SymbolTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("ThisTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("TupleTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow", "FlowType"],
  fields: {
    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
  }
});
(0, _utils.default)("TypeofTypeAnnotation", {
  visitor: ["argument"],
  aliases: ["Flow", "FlowType"],
  fields: {
    argument: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("TypeAlias", {
  visitor: ["id", "typeParameters", "right"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    right: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("TypeAnnotation", {
  aliases: ["Flow"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("TypeCastExpression", {
  visitor: ["expression", "typeAnnotation"],
  aliases: ["Flow", "ExpressionWrapper", "Expression"],
  fields: {
    expression: (0, _utils.validateType)("Expression"),
    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
  }
});
(0, _utils.default)("TypeParameter", {
  aliases: ["Flow"],
  visitor: ["bound", "default", "variance"],
  fields: {
    name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
    bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
    default: (0, _utils.validateOptionalType)("FlowType"),
    variance: (0, _utils.validateOptionalType)("Variance")
  }
});
(0, _utils.default)("TypeParameterDeclaration", {
  aliases: ["Flow"],
  visitor: ["params"],
  fields: {
    params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
  }
});
(0, _utils.default)("TypeParameterInstantiation", {
  aliases: ["Flow"],
  visitor: ["params"],
  fields: {
    params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
  }
});
(0, _utils.default)("UnionTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow", "FlowType"],
  fields: {
    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
  }
});
(0, _utils.default)("Variance", {
  aliases: ["Flow"],
  builder: ["kind"],
  fields: {
    kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
  }
});
(0, _utils.default)("VoidTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("EnumDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "body"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    body: (0, _utils.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
  }
});
(0, _utils.default)("EnumBooleanBody", {
  aliases: ["EnumBody"],
  visitor: ["members"],
  fields: {
    explicit: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    members: (0, _utils.validateArrayOfType)("EnumBooleanMember")
  }
});
(0, _utils.default)("EnumNumberBody", {
  aliases: ["EnumBody"],
  visitor: ["members"],
  fields: {
    explicit: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    members: (0, _utils.validateArrayOfType)("EnumNumberMember")
  }
});
(0, _utils.default)("EnumStringBody", {
  aliases: ["EnumBody"],
  visitor: ["members"],
  fields: {
    explicit: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    members: (0, _utils.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"])
  }
});
(0, _utils.default)("EnumSymbolBody", {
  aliases: ["EnumBody"],
  visitor: ["members"],
  fields: {
    members: (0, _utils.validateArrayOfType)("EnumDefaultedMember")
  }
});
(0, _utils.default)("EnumBooleanMember", {
  aliases: ["EnumMember"],
  visitor: ["id"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    init: (0, _utils.validateType)("BooleanLiteral")
  }
});
(0, _utils.default)("EnumNumberMember", {
  aliases: ["EnumMember"],
  visitor: ["id", "init"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    init: (0, _utils.validateType)("NumericLiteral")
  }
});
(0, _utils.default)("EnumStringMember", {
  aliases: ["EnumMember"],
  visitor: ["id", "init"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    init: (0, _utils.validateType)("StringLiteral")
  }
});
(0, _utils.default)("EnumDefaultedMember", {
  aliases: ["EnumMember"],
  visitor: ["id"],
  fields: {
    id: (0, _utils.validateType)("Identifier")
  }
});

/***/ }),

/***/ "./node_modules/@babel/types/lib/definitions/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/types/lib/definitions/index.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "VISITOR_KEYS", {
  enumerable: true,
  get: function () {
    return _utils.VISITOR_KEYS;
  }
});
Object.defineProperty(exports, "ALIAS_KEYS", {
  enumerable: true,
  get: function () {
    return _utils.ALIAS_KEYS;
  }
});
Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
  enumerable: true,
  get: function () {
    return _utils.FLIPPED_ALIAS_KEYS;
  }
});
Object.defineProperty(exports, "NODE_FIELDS", {
  enumerable: true,
  get: function () {
    return _utils.NODE_FIELDS;
  }
});
Object.defineProperty(exports, "BUILDER_KEYS", {
  enumerable: true,
  get: function () {
    return _utils.BUILDER_KEYS;
  }
});
Object.defineProperty(exports, "DEPRECATED_KEYS", {
  enumerable: true,
  get: function () {
    return _utils.DEPRECATED_KEYS;
  }
});
Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
  enumerable: true,
  get: function () {
    return _utils.NODE_PARENT_VALIDATIONS;
  }
});
Object.defineProperty(exports, "PLACEHOLDERS", {
  enumerable: true,
  get: function () {
    return _placeholders.PLACEHOLDERS;
  }
});
Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
  enumerable: true,
  get: function () {
    return _placeholders.PLACEHOLDERS_ALIAS;
  }
});
Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
  enumerable: true,
  get: function () {
    return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
  }
});
exports.TYPES = void 0;

var _toFastProperties = _interopRequireDefault(__webpack_require__(/*! to-fast-properties */ "./node_modules/@babel/types/node_modules/to-fast-properties/index.js"));

__webpack_require__(/*! ./core */ "./node_modules/@babel/types/lib/definitions/core.js");

__webpack_require__(/*! ./es2015 */ "./node_modules/@babel/types/lib/definitions/es2015.js");

__webpack_require__(/*! ./flow */ "./node_modules/@babel/types/lib/definitions/flow.js");

__webpack_require__(/*! ./jsx */ "./node_modules/@babel/types/lib/definitions/jsx.js");

__webpack_require__(/*! ./misc */ "./node_modules/@babel/types/lib/definitions/misc.js");

__webpack_require__(/*! ./experimental */ "./node_modules/@babel/types/lib/definitions/experimental.js");

__webpack_require__(/*! ./typescript */ "./node_modules/@babel/types/lib/definitions/typescript.js");

var _utils = __webpack_require__(/*! ./utils */ "./node_modules/@babel/types/lib/definitions/utils.js");

var _placeholders = __webpack_require__(/*! ./placeholders */ "./node_modules/@babel/types/lib/definitions/placeholders.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _toFastProperties.default)(_utils.VISITOR_KEYS);
(0, _toFastProperties.default)(_utils.ALIAS_KEYS);
(0, _toFastProperties.default)(_utils.FLIPPED_ALIAS_KEYS);
(0, _toFastProperties.default)(_utils.NODE_FIELDS);
(0, _toFastProperties.default)(_utils.BUILDER_KEYS);
(0, _toFastProperties.default)(_utils.DEPRECATED_KEYS);
(0, _toFastProperties.default)(_placeholders.PLACEHOLDERS_ALIAS);
(0, _toFastProperties.default)(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
const TYPES = Object.keys(_utils.VISITOR_KEYS).concat(Object.keys(_utils.FLIPPED_ALIAS_KEYS)).concat(Object.keys(_utils.DEPRECATED_KEYS));
exports.TYPES = TYPES;

/***/ }),

/***/ "./node_modules/@babel/types/lib/definitions/jsx.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/types/lib/definitions/jsx.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _utils = _interopRequireWildcard(__webpack_require__(/*! ./utils */ "./node_modules/@babel/types/lib/definitions/utils.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

(0, _utils.default)("JSXAttribute", {
  visitor: ["name", "value"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
    },
    value: {
      optional: true,
      validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
    }
  }
});
(0, _utils.default)("JSXClosingElement", {
  visitor: ["name"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
    }
  }
});
(0, _utils.default)("JSXElement", {
  builder: ["openingElement", "closingElement", "children", "selfClosing"],
  visitor: ["openingElement", "children", "closingElement"],
  aliases: ["JSX", "Immutable", "Expression"],
  fields: {
    openingElement: {
      validate: (0, _utils.assertNodeType)("JSXOpeningElement")
    },
    closingElement: {
      optional: true,
      validate: (0, _utils.assertNodeType)("JSXClosingElement")
    },
    children: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
    },
    selfClosing: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  }
});
(0, _utils.default)("JSXEmptyExpression", {
  aliases: ["JSX"]
});
(0, _utils.default)("JSXExpressionContainer", {
  visitor: ["expression"],
  aliases: ["JSX", "Immutable"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
    }
  }
});
(0, _utils.default)("JSXSpreadChild", {
  visitor: ["expression"],
  aliases: ["JSX", "Immutable"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("JSXIdentifier", {
  builder: ["name"],
  aliases: ["JSX"],
  fields: {
    name: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
(0, _utils.default)("JSXMemberExpression", {
  visitor: ["object", "property"],
  aliases: ["JSX"],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
    },
    property: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier")
    }
  }
});
(0, _utils.default)("JSXNamespacedName", {
  visitor: ["namespace", "name"],
  aliases: ["JSX"],
  fields: {
    namespace: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier")
    },
    name: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier")
    }
  }
});
(0, _utils.default)("JSXOpeningElement", {
  builder: ["name", "attributes", "selfClosing"],
  visitor: ["name", "attributes"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
    },
    selfClosing: {
      default: false
    },
    attributes: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    }
  }
});
(0, _utils.default)("JSXSpreadAttribute", {
  visitor: ["argument"],
  aliases: ["JSX"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("JSXText", {
  aliases: ["JSX", "Immutable"],
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
(0, _utils.default)("JSXFragment", {
  builder: ["openingFragment", "closingFragment", "children"],
  visitor: ["openingFragment", "children", "closingFragment"],
  aliases: ["JSX", "Immutable", "Expression"],
  fields: {
    openingFragment: {
      validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
    },
    closingFragment: {
      validate: (0, _utils.assertNodeType)("JSXClosingFragment")
    },
    children: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
    }
  }
});
(0, _utils.default)("JSXOpeningFragment", {
  aliases: ["JSX", "Immutable"]
});
(0, _utils.default)("JSXClosingFragment", {
  aliases: ["JSX", "Immutable"]
});

/***/ }),

/***/ "./node_modules/@babel/types/lib/definitions/misc.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/types/lib/definitions/misc.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _utils = _interopRequireWildcard(__webpack_require__(/*! ./utils */ "./node_modules/@babel/types/lib/definitions/utils.js"));

var _placeholders = __webpack_require__(/*! ./placeholders */ "./node_modules/@babel/types/lib/definitions/placeholders.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

(0, _utils.default)("Noop", {
  visitor: []
});
(0, _utils.default)("Placeholder", {
  visitor: [],
  builder: ["expectedNode", "name"],
  fields: {
    name: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    expectedNode: {
      validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
    }
  }
});
(0, _utils.default)("V8IntrinsicIdentifier", {
  builder: ["name"],
  fields: {
    name: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});

/***/ }),

/***/ "./node_modules/@babel/types/lib/definitions/placeholders.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/definitions/placeholders.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;

var _utils = __webpack_require__(/*! ./utils */ "./node_modules/@babel/types/lib/definitions/utils.js");

const PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
exports.PLACEHOLDERS = PLACEHOLDERS;
const PLACEHOLDERS_ALIAS = {
  Declaration: ["Statement"],
  Pattern: ["PatternLike", "LVal"]
};
exports.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;

for (const type of PLACEHOLDERS) {
  const alias = _utils.ALIAS_KEYS[type];
  if (alias == null ? void 0 : alias.length) PLACEHOLDERS_ALIAS[type] = alias;
}

const PLACEHOLDERS_FLIPPED_ALIAS = {};
exports.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;
Object.keys(PLACEHOLDERS_ALIAS).forEach(type => {
  PLACEHOLDERS_ALIAS[type].forEach(alias => {
    if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
      PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
    }

    PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
  });
});

/***/ }),

/***/ "./node_modules/@babel/types/lib/definitions/typescript.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/types/lib/definitions/typescript.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _utils = _interopRequireWildcard(__webpack_require__(/*! ./utils */ "./node_modules/@babel/types/lib/definitions/utils.js"));

var _core = __webpack_require__(/*! ./core */ "./node_modules/@babel/types/lib/definitions/core.js");

var _es = __webpack_require__(/*! ./es2015 */ "./node_modules/@babel/types/lib/definitions/es2015.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const bool = (0, _utils.assertValueType)("boolean");
const tSFunctionTypeAnnotationCommon = {
  returnType: {
    validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
    optional: true
  },
  typeParameters: {
    validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
    optional: true
  }
};
(0, _utils.default)("TSParameterProperty", {
  aliases: ["LVal"],
  visitor: ["parameter"],
  fields: {
    accessibility: {
      validate: (0, _utils.assertOneOf)("public", "private", "protected"),
      optional: true
    },
    readonly: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    parameter: {
      validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
    }
  }
});
(0, _utils.default)("TSDeclareFunction", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "params", "returnType"],
  fields: Object.assign({}, _core.functionDeclarationCommon, tSFunctionTypeAnnotationCommon)
});
(0, _utils.default)("TSDeclareMethod", {
  visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
  fields: Object.assign({}, _es.classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon)
});
(0, _utils.default)("TSQualifiedName", {
  aliases: ["TSEntityName"],
  visitor: ["left", "right"],
  fields: {
    left: (0, _utils.validateType)("TSEntityName"),
    right: (0, _utils.validateType)("Identifier")
  }
});
const signatureDeclarationCommon = {
  typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
  parameters: (0, _utils.validateArrayOfType)(["Identifier", "RestElement"]),
  typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
};
const callConstructSignatureDeclaration = {
  aliases: ["TSTypeElement"],
  visitor: ["typeParameters", "parameters", "typeAnnotation"],
  fields: signatureDeclarationCommon
};
(0, _utils.default)("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
(0, _utils.default)("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
const namedTypeElementCommon = {
  key: (0, _utils.validateType)("Expression"),
  computed: (0, _utils.validate)(bool),
  optional: (0, _utils.validateOptional)(bool)
};
(0, _utils.default)("TSPropertySignature", {
  aliases: ["TSTypeElement"],
  visitor: ["key", "typeAnnotation", "initializer"],
  fields: Object.assign({}, namedTypeElementCommon, {
    readonly: (0, _utils.validateOptional)(bool),
    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
    initializer: (0, _utils.validateOptionalType)("Expression")
  })
});
(0, _utils.default)("TSMethodSignature", {
  aliases: ["TSTypeElement"],
  visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
  fields: Object.assign({}, signatureDeclarationCommon, namedTypeElementCommon)
});
(0, _utils.default)("TSIndexSignature", {
  aliases: ["TSTypeElement"],
  visitor: ["parameters", "typeAnnotation"],
  fields: {
    readonly: (0, _utils.validateOptional)(bool),
    parameters: (0, _utils.validateArrayOfType)("Identifier"),
    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
  }
});
const tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];

for (const type of tsKeywordTypes) {
  (0, _utils.default)(type, {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
}

(0, _utils.default)("TSThisType", {
  aliases: ["TSType", "TSBaseType"],
  visitor: [],
  fields: {}
});
const fnOrCtr = {
  aliases: ["TSType"],
  visitor: ["typeParameters", "parameters", "typeAnnotation"],
  fields: signatureDeclarationCommon
};
(0, _utils.default)("TSFunctionType", fnOrCtr);
(0, _utils.default)("TSConstructorType", fnOrCtr);
(0, _utils.default)("TSTypeReference", {
  aliases: ["TSType"],
  visitor: ["typeName", "typeParameters"],
  fields: {
    typeName: (0, _utils.validateType)("TSEntityName"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
  }
});
(0, _utils.default)("TSTypePredicate", {
  aliases: ["TSType"],
  visitor: ["parameterName", "typeAnnotation"],
  builder: ["parameterName", "typeAnnotation", "asserts"],
  fields: {
    parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),
    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
    asserts: (0, _utils.validateOptional)(bool)
  }
});
(0, _utils.default)("TSTypeQuery", {
  aliases: ["TSType"],
  visitor: ["exprName"],
  fields: {
    exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"])
  }
});
(0, _utils.default)("TSTypeLiteral", {
  aliases: ["TSType"],
  visitor: ["members"],
  fields: {
    members: (0, _utils.validateArrayOfType)("TSTypeElement")
  }
});
(0, _utils.default)("TSArrayType", {
  aliases: ["TSType"],
  visitor: ["elementType"],
  fields: {
    elementType: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSTupleType", {
  aliases: ["TSType"],
  visitor: ["elementTypes"],
  fields: {
    elementTypes: (0, _utils.validateArrayOfType)("TSType")
  }
});
(0, _utils.default)("TSOptionalType", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSRestType", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
const unionOrIntersection = {
  aliases: ["TSType"],
  visitor: ["types"],
  fields: {
    types: (0, _utils.validateArrayOfType)("TSType")
  }
};
(0, _utils.default)("TSUnionType", unionOrIntersection);
(0, _utils.default)("TSIntersectionType", unionOrIntersection);
(0, _utils.default)("TSConditionalType", {
  aliases: ["TSType"],
  visitor: ["checkType", "extendsType", "trueType", "falseType"],
  fields: {
    checkType: (0, _utils.validateType)("TSType"),
    extendsType: (0, _utils.validateType)("TSType"),
    trueType: (0, _utils.validateType)("TSType"),
    falseType: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSInferType", {
  aliases: ["TSType"],
  visitor: ["typeParameter"],
  fields: {
    typeParameter: (0, _utils.validateType)("TSTypeParameter")
  }
});
(0, _utils.default)("TSParenthesizedType", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSTypeOperator", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSIndexedAccessType", {
  aliases: ["TSType"],
  visitor: ["objectType", "indexType"],
  fields: {
    objectType: (0, _utils.validateType)("TSType"),
    indexType: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSMappedType", {
  aliases: ["TSType"],
  visitor: ["typeParameter", "typeAnnotation"],
  fields: {
    readonly: (0, _utils.validateOptional)(bool),
    typeParameter: (0, _utils.validateType)("TSTypeParameter"),
    optional: (0, _utils.validateOptional)(bool),
    typeAnnotation: (0, _utils.validateOptionalType)("TSType")
  }
});
(0, _utils.default)("TSLiteralType", {
  aliases: ["TSType", "TSBaseType"],
  visitor: ["literal"],
  fields: {
    literal: (0, _utils.validateType)(["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral"])
  }
});
(0, _utils.default)("TSExpressionWithTypeArguments", {
  aliases: ["TSType"],
  visitor: ["expression", "typeParameters"],
  fields: {
    expression: (0, _utils.validateType)("TSEntityName"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
  }
});
(0, _utils.default)("TSInterfaceDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "extends", "body"],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
    body: (0, _utils.validateType)("TSInterfaceBody")
  }
});
(0, _utils.default)("TSInterfaceBody", {
  visitor: ["body"],
  fields: {
    body: (0, _utils.validateArrayOfType)("TSTypeElement")
  }
});
(0, _utils.default)("TSTypeAliasDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "typeAnnotation"],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSAsExpression", {
  aliases: ["Expression"],
  visitor: ["expression", "typeAnnotation"],
  fields: {
    expression: (0, _utils.validateType)("Expression"),
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSTypeAssertion", {
  aliases: ["Expression"],
  visitor: ["typeAnnotation", "expression"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TSType"),
    expression: (0, _utils.validateType)("Expression")
  }
});
(0, _utils.default)("TSEnumDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "members"],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    const: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)("Identifier"),
    members: (0, _utils.validateArrayOfType)("TSEnumMember"),
    initializer: (0, _utils.validateOptionalType)("Expression")
  }
});
(0, _utils.default)("TSEnumMember", {
  visitor: ["id", "initializer"],
  fields: {
    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    initializer: (0, _utils.validateOptionalType)("Expression")
  }
});
(0, _utils.default)("TSModuleDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "body"],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    global: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
  }
});
(0, _utils.default)("TSModuleBlock", {
  aliases: ["Scopable", "Block", "BlockParent"],
  visitor: ["body"],
  fields: {
    body: (0, _utils.validateArrayOfType)("Statement")
  }
});
(0, _utils.default)("TSImportType", {
  aliases: ["TSType"],
  visitor: ["argument", "qualifier", "typeParameters"],
  fields: {
    argument: (0, _utils.validateType)("StringLiteral"),
    qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
  }
});
(0, _utils.default)("TSImportEqualsDeclaration", {
  aliases: ["Statement"],
  visitor: ["id", "moduleReference"],
  fields: {
    isExport: (0, _utils.validate)(bool),
    id: (0, _utils.validateType)("Identifier"),
    moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"])
  }
});
(0, _utils.default)("TSExternalModuleReference", {
  visitor: ["expression"],
  fields: {
    expression: (0, _utils.validateType)("StringLiteral")
  }
});
(0, _utils.default)("TSNonNullExpression", {
  aliases: ["Expression"],
  visitor: ["expression"],
  fields: {
    expression: (0, _utils.validateType)("Expression")
  }
});
(0, _utils.default)("TSExportAssignment", {
  aliases: ["Statement"],
  visitor: ["expression"],
  fields: {
    expression: (0, _utils.validateType)("Expression")
  }
});
(0, _utils.default)("TSNamespaceExportDeclaration", {
  aliases: ["Statement"],
  visitor: ["id"],
  fields: {
    id: (0, _utils.validateType)("Identifier")
  }
});
(0, _utils.default)("TSTypeAnnotation", {
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TSType")
    }
  }
});
(0, _utils.default)("TSTypeParameterInstantiation", {
  visitor: ["params"],
  fields: {
    params: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
    }
  }
});
(0, _utils.default)("TSTypeParameterDeclaration", {
  visitor: ["params"],
  fields: {
    params: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
    }
  }
});
(0, _utils.default)("TSTypeParameter", {
  builder: ["constraint", "default", "name"],
  visitor: ["constraint", "default"],
  fields: {
    name: {
      validate: (0, _utils.assertValueType)("string")
    },
    constraint: {
      validate: (0, _utils.assertNodeType)("TSType"),
      optional: true
    },
    default: {
      validate: (0, _utils.assertNodeType)("TSType"),
      optional: true
    }
  }
});

/***/ }),

/***/ "./node_modules/@babel/types/lib/definitions/utils.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/types/lib/definitions/utils.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validate = validate;
exports.typeIs = typeIs;
exports.validateType = validateType;
exports.validateOptional = validateOptional;
exports.validateOptionalType = validateOptionalType;
exports.arrayOf = arrayOf;
exports.arrayOfType = arrayOfType;
exports.validateArrayOfType = validateArrayOfType;
exports.assertEach = assertEach;
exports.assertOneOf = assertOneOf;
exports.assertNodeType = assertNodeType;
exports.assertNodeOrValueType = assertNodeOrValueType;
exports.assertValueType = assertValueType;
exports.assertShape = assertShape;
exports.assertOptionalChainStart = assertOptionalChainStart;
exports.chain = chain;
exports.default = defineType;
exports.NODE_PARENT_VALIDATIONS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = void 0;

var _is = _interopRequireDefault(__webpack_require__(/*! ../validators/is */ "./node_modules/@babel/types/lib/validators/is.js"));

var _validate = __webpack_require__(/*! ../validators/validate */ "./node_modules/@babel/types/lib/validators/validate.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const VISITOR_KEYS = {};
exports.VISITOR_KEYS = VISITOR_KEYS;
const ALIAS_KEYS = {};
exports.ALIAS_KEYS = ALIAS_KEYS;
const FLIPPED_ALIAS_KEYS = {};
exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
const NODE_FIELDS = {};
exports.NODE_FIELDS = NODE_FIELDS;
const BUILDER_KEYS = {};
exports.BUILDER_KEYS = BUILDER_KEYS;
const DEPRECATED_KEYS = {};
exports.DEPRECATED_KEYS = DEPRECATED_KEYS;
const NODE_PARENT_VALIDATIONS = {};
exports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;

function getType(val) {
  if (Array.isArray(val)) {
    return "array";
  } else if (val === null) {
    return "null";
  } else {
    return typeof val;
  }
}

function validate(validate) {
  return {
    validate
  };
}

function typeIs(typeName) {
  return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
}

function validateType(typeName) {
  return validate(typeIs(typeName));
}

function validateOptional(validate) {
  return {
    validate,
    optional: true
  };
}

function validateOptionalType(typeName) {
  return {
    validate: typeIs(typeName),
    optional: true
  };
}

function arrayOf(elementType) {
  return chain(assertValueType("array"), assertEach(elementType));
}

function arrayOfType(typeName) {
  return arrayOf(typeIs(typeName));
}

function validateArrayOfType(typeName) {
  return validate(arrayOfType(typeName));
}

function assertEach(callback) {
  function validator(node, key, val) {
    if (!Array.isArray(val)) return;

    for (let i = 0; i < val.length; i++) {
      const subkey = `${key}[${i}]`;
      const v = val[i];
      callback(node, subkey, v);
      if (process.env.BABEL_TYPES_8_BREAKING) (0, _validate.validateChild)(node, subkey, v);
    }
  }

  validator.each = callback;
  return validator;
}

function assertOneOf(...values) {
  function validate(node, key, val) {
    if (values.indexOf(val) < 0) {
      throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
    }
  }

  validate.oneOf = values;
  return validate;
}

function assertNodeType(...types) {
  function validate(node, key, val) {
    for (const type of types) {
      if ((0, _is.default)(type, val)) {
        (0, _validate.validateChild)(node, key, val);
        return;
      }
    }

    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
  }

  validate.oneOfNodeTypes = types;
  return validate;
}

function assertNodeOrValueType(...types) {
  function validate(node, key, val) {
    for (const type of types) {
      if (getType(val) === type || (0, _is.default)(type, val)) {
        (0, _validate.validateChild)(node, key, val);
        return;
      }
    }

    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
  }

  validate.oneOfNodeOrValueTypes = types;
  return validate;
}

function assertValueType(type) {
  function validate(node, key, val) {
    const valid = getType(val) === type;

    if (!valid) {
      throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
    }
  }

  validate.type = type;
  return validate;
}

function assertShape(shape) {
  function validate(node, key, val) {
    const errors = [];

    for (const property of Object.keys(shape)) {
      try {
        (0, _validate.validateField)(node, property, val[property], shape[property]);
      } catch (error) {
        if (error instanceof TypeError) {
          errors.push(error.message);
          continue;
        }

        throw error;
      }
    }

    if (errors.length) {
      throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\n${errors.join("\n")}`);
    }
  }

  validate.shapeOf = shape;
  return validate;
}

function assertOptionalChainStart() {
  function validate(node) {
    var _current;

    let current = node;

    while (node) {
      const {
        type
      } = current;

      if (type === "OptionalCallExpression") {
        if (current.optional) return;
        current = current.callee;
        continue;
      }

      if (type === "OptionalMemberExpression") {
        if (current.optional) return;
        current = current.object;
        continue;
      }

      break;
    }

    throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
  }

  return validate;
}

function chain(...fns) {
  function validate(...args) {
    for (const fn of fns) {
      fn(...args);
    }
  }

  validate.chainOf = fns;
  return validate;
}

const validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];
const validFieldKeys = ["default", "optional", "validate"];

function defineType(type, opts = {}) {
  const inherits = opts.inherits && store[opts.inherits] || {};
  let fields = opts.fields;

  if (!fields) {
    fields = {};

    if (inherits.fields) {
      const keys = Object.getOwnPropertyNames(inherits.fields);

      for (const key of keys) {
        const field = inherits.fields[key];
        fields[key] = {
          default: field.default,
          optional: field.optional,
          validate: field.validate
        };
      }
    }
  }

  const visitor = opts.visitor || inherits.visitor || [];
  const aliases = opts.aliases || inherits.aliases || [];
  const builder = opts.builder || inherits.builder || opts.visitor || [];

  for (const k of Object.keys(opts)) {
    if (validTypeOpts.indexOf(k) === -1) {
      throw new Error(`Unknown type option "${k}" on ${type}`);
    }
  }

  if (opts.deprecatedAlias) {
    DEPRECATED_KEYS[opts.deprecatedAlias] = type;
  }

  for (const key of visitor.concat(builder)) {
    fields[key] = fields[key] || {};
  }

  for (const key of Object.keys(fields)) {
    const field = fields[key];

    if (field.default !== undefined && builder.indexOf(key) === -1) {
      field.optional = true;
    }

    if (field.default === undefined) {
      field.default = null;
    } else if (!field.validate && field.default != null) {
      field.validate = assertValueType(getType(field.default));
    }

    for (const k of Object.keys(field)) {
      if (validFieldKeys.indexOf(k) === -1) {
        throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
      }
    }
  }

  VISITOR_KEYS[type] = opts.visitor = visitor;
  BUILDER_KEYS[type] = opts.builder = builder;
  NODE_FIELDS[type] = opts.fields = fields;
  ALIAS_KEYS[type] = opts.aliases = aliases;
  aliases.forEach(alias => {
    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
    FLIPPED_ALIAS_KEYS[alias].push(type);
  });

  if (opts.validate) {
    NODE_PARENT_VALIDATIONS[type] = opts.validate;
  }

  store[type] = opts;
}

const store = {};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@babel/types/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@babel/types/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  react: true,
  assertNode: true,
  createTypeAnnotationBasedOnTypeof: true,
  createUnionTypeAnnotation: true,
  createFlowUnionType: true,
  createTSUnionType: true,
  cloneNode: true,
  clone: true,
  cloneDeep: true,
  cloneDeepWithoutLoc: true,
  cloneWithoutLoc: true,
  addComment: true,
  addComments: true,
  inheritInnerComments: true,
  inheritLeadingComments: true,
  inheritsComments: true,
  inheritTrailingComments: true,
  removeComments: true,
  ensureBlock: true,
  toBindingIdentifierName: true,
  toBlock: true,
  toComputedKey: true,
  toExpression: true,
  toIdentifier: true,
  toKeyAlias: true,
  toSequenceExpression: true,
  toStatement: true,
  valueToNode: true,
  appendToMemberExpression: true,
  inherits: true,
  prependToMemberExpression: true,
  removeProperties: true,
  removePropertiesDeep: true,
  removeTypeDuplicates: true,
  getBindingIdentifiers: true,
  getOuterBindingIdentifiers: true,
  traverse: true,
  traverseFast: true,
  shallowEqual: true,
  is: true,
  isBinding: true,
  isBlockScoped: true,
  isImmutable: true,
  isLet: true,
  isNode: true,
  isNodesEquivalent: true,
  isPlaceholderType: true,
  isReferenced: true,
  isScope: true,
  isSpecifierDefault: true,
  isType: true,
  isValidES3Identifier: true,
  isValidIdentifier: true,
  isVar: true,
  matchesPattern: true,
  validate: true,
  buildMatchMemberExpression: true
};
Object.defineProperty(exports, "assertNode", {
  enumerable: true,
  get: function () {
    return _assertNode.default;
  }
});
Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
  enumerable: true,
  get: function () {
    return _createTypeAnnotationBasedOnTypeof.default;
  }
});
Object.defineProperty(exports, "createUnionTypeAnnotation", {
  enumerable: true,
  get: function () {
    return _createFlowUnionType.default;
  }
});
Object.defineProperty(exports, "createFlowUnionType", {
  enumerable: true,
  get: function () {
    return _createFlowUnionType.default;
  }
});
Object.defineProperty(exports, "createTSUnionType", {
  enumerable: true,
  get: function () {
    return _createTSUnionType.default;
  }
});
Object.defineProperty(exports, "cloneNode", {
  enumerable: true,
  get: function () {
    return _cloneNode.default;
  }
});
Object.defineProperty(exports, "clone", {
  enumerable: true,
  get: function () {
    return _clone.default;
  }
});
Object.defineProperty(exports, "cloneDeep", {
  enumerable: true,
  get: function () {
    return _cloneDeep.default;
  }
});
Object.defineProperty(exports, "cloneDeepWithoutLoc", {
  enumerable: true,
  get: function () {
    return _cloneDeepWithoutLoc.default;
  }
});
Object.defineProperty(exports, "cloneWithoutLoc", {
  enumerable: true,
  get: function () {
    return _cloneWithoutLoc.default;
  }
});
Object.defineProperty(exports, "addComment", {
  enumerable: true,
  get: function () {
    return _addComment.default;
  }
});
Object.defineProperty(exports, "addComments", {
  enumerable: true,
  get: function () {
    return _addComments.default;
  }
});
Object.defineProperty(exports, "inheritInnerComments", {
  enumerable: true,
  get: function () {
    return _inheritInnerComments.default;
  }
});
Object.defineProperty(exports, "inheritLeadingComments", {
  enumerable: true,
  get: function () {
    return _inheritLeadingComments.default;
  }
});
Object.defineProperty(exports, "inheritsComments", {
  enumerable: true,
  get: function () {
    return _inheritsComments.default;
  }
});
Object.defineProperty(exports, "inheritTrailingComments", {
  enumerable: true,
  get: function () {
    return _inheritTrailingComments.default;
  }
});
Object.defineProperty(exports, "removeComments", {
  enumerable: true,
  get: function () {
    return _removeComments.default;
  }
});
Object.defineProperty(exports, "ensureBlock", {
  enumerable: true,
  get: function () {
    return _ensureBlock.default;
  }
});
Object.defineProperty(exports, "toBindingIdentifierName", {
  enumerable: true,
  get: function () {
    return _toBindingIdentifierName.default;
  }
});
Object.defineProperty(exports, "toBlock", {
  enumerable: true,
  get: function () {
    return _toBlock.default;
  }
});
Object.defineProperty(exports, "toComputedKey", {
  enumerable: true,
  get: function () {
    return _toComputedKey.default;
  }
});
Object.defineProperty(exports, "toExpression", {
  enumerable: true,
  get: function () {
    return _toExpression.default;
  }
});
Object.defineProperty(exports, "toIdentifier", {
  enumerable: true,
  get: function () {
    return _toIdentifier.default;
  }
});
Object.defineProperty(exports, "toKeyAlias", {
  enumerable: true,
  get: function () {
    return _toKeyAlias.default;
  }
});
Object.defineProperty(exports, "toSequenceExpression", {
  enumerable: true,
  get: function () {
    return _toSequenceExpression.default;
  }
});
Object.defineProperty(exports, "toStatement", {
  enumerable: true,
  get: function () {
    return _toStatement.default;
  }
});
Object.defineProperty(exports, "valueToNode", {
  enumerable: true,
  get: function () {
    return _valueToNode.default;
  }
});
Object.defineProperty(exports, "appendToMemberExpression", {
  enumerable: true,
  get: function () {
    return _appendToMemberExpression.default;
  }
});
Object.defineProperty(exports, "inherits", {
  enumerable: true,
  get: function () {
    return _inherits.default;
  }
});
Object.defineProperty(exports, "prependToMemberExpression", {
  enumerable: true,
  get: function () {
    return _prependToMemberExpression.default;
  }
});
Object.defineProperty(exports, "removeProperties", {
  enumerable: true,
  get: function () {
    return _removeProperties.default;
  }
});
Object.defineProperty(exports, "removePropertiesDeep", {
  enumerable: true,
  get: function () {
    return _removePropertiesDeep.default;
  }
});
Object.defineProperty(exports, "removeTypeDuplicates", {
  enumerable: true,
  get: function () {
    return _removeTypeDuplicates.default;
  }
});
Object.defineProperty(exports, "getBindingIdentifiers", {
  enumerable: true,
  get: function () {
    return _getBindingIdentifiers.default;
  }
});
Object.defineProperty(exports, "getOuterBindingIdentifiers", {
  enumerable: true,
  get: function () {
    return _getOuterBindingIdentifiers.default;
  }
});
Object.defineProperty(exports, "traverse", {
  enumerable: true,
  get: function () {
    return _traverse.default;
  }
});
Object.defineProperty(exports, "traverseFast", {
  enumerable: true,
  get: function () {
    return _traverseFast.default;
  }
});
Object.defineProperty(exports, "shallowEqual", {
  enumerable: true,
  get: function () {
    return _shallowEqual.default;
  }
});
Object.defineProperty(exports, "is", {
  enumerable: true,
  get: function () {
    return _is.default;
  }
});
Object.defineProperty(exports, "isBinding", {
  enumerable: true,
  get: function () {
    return _isBinding.default;
  }
});
Object.defineProperty(exports, "isBlockScoped", {
  enumerable: true,
  get: function () {
    return _isBlockScoped.default;
  }
});
Object.defineProperty(exports, "isImmutable", {
  enumerable: true,
  get: function () {
    return _isImmutable.default;
  }
});
Object.defineProperty(exports, "isLet", {
  enumerable: true,
  get: function () {
    return _isLet.default;
  }
});
Object.defineProperty(exports, "isNode", {
  enumerable: true,
  get: function () {
    return _isNode.default;
  }
});
Object.defineProperty(exports, "isNodesEquivalent", {
  enumerable: true,
  get: function () {
    return _isNodesEquivalent.default;
  }
});
Object.defineProperty(exports, "isPlaceholderType", {
  enumerable: true,
  get: function () {
    return _isPlaceholderType.default;
  }
});
Object.defineProperty(exports, "isReferenced", {
  enumerable: true,
  get: function () {
    return _isReferenced.default;
  }
});
Object.defineProperty(exports, "isScope", {
  enumerable: true,
  get: function () {
    return _isScope.default;
  }
});
Object.defineProperty(exports, "isSpecifierDefault", {
  enumerable: true,
  get: function () {
    return _isSpecifierDefault.default;
  }
});
Object.defineProperty(exports, "isType", {
  enumerable: true,
  get: function () {
    return _isType.default;
  }
});
Object.defineProperty(exports, "isValidES3Identifier", {
  enumerable: true,
  get: function () {
    return _isValidES3Identifier.default;
  }
});
Object.defineProperty(exports, "isValidIdentifier", {
  enumerable: true,
  get: function () {
    return _isValidIdentifier.default;
  }
});
Object.defineProperty(exports, "isVar", {
  enumerable: true,
  get: function () {
    return _isVar.default;
  }
});
Object.defineProperty(exports, "matchesPattern", {
  enumerable: true,
  get: function () {
    return _matchesPattern.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return _validate.default;
  }
});
Object.defineProperty(exports, "buildMatchMemberExpression", {
  enumerable: true,
  get: function () {
    return _buildMatchMemberExpression.default;
  }
});
exports.react = void 0;

var _isReactComponent = _interopRequireDefault(__webpack_require__(/*! ./validators/react/isReactComponent */ "./node_modules/@babel/types/lib/validators/react/isReactComponent.js"));

var _isCompatTag = _interopRequireDefault(__webpack_require__(/*! ./validators/react/isCompatTag */ "./node_modules/@babel/types/lib/validators/react/isCompatTag.js"));

var _buildChildren = _interopRequireDefault(__webpack_require__(/*! ./builders/react/buildChildren */ "./node_modules/@babel/types/lib/builders/react/buildChildren.js"));

var _assertNode = _interopRequireDefault(__webpack_require__(/*! ./asserts/assertNode */ "./node_modules/@babel/types/lib/asserts/assertNode.js"));

var _generated = __webpack_require__(/*! ./asserts/generated */ "./node_modules/@babel/types/lib/asserts/generated/index.js");

Object.keys(_generated).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _generated[key];
    }
  });
});

var _createTypeAnnotationBasedOnTypeof = _interopRequireDefault(__webpack_require__(/*! ./builders/flow/createTypeAnnotationBasedOnTypeof */ "./node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"));

var _createFlowUnionType = _interopRequireDefault(__webpack_require__(/*! ./builders/flow/createFlowUnionType */ "./node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"));

var _createTSUnionType = _interopRequireDefault(__webpack_require__(/*! ./builders/typescript/createTSUnionType */ "./node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"));

var _generated2 = __webpack_require__(/*! ./builders/generated */ "./node_modules/@babel/types/lib/builders/generated/index.js");

Object.keys(_generated2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _generated2[key];
    }
  });
});

var _cloneNode = _interopRequireDefault(__webpack_require__(/*! ./clone/cloneNode */ "./node_modules/@babel/types/lib/clone/cloneNode.js"));

var _clone = _interopRequireDefault(__webpack_require__(/*! ./clone/clone */ "./node_modules/@babel/types/lib/clone/clone.js"));

var _cloneDeep = _interopRequireDefault(__webpack_require__(/*! ./clone/cloneDeep */ "./node_modules/@babel/types/lib/clone/cloneDeep.js"));

var _cloneDeepWithoutLoc = _interopRequireDefault(__webpack_require__(/*! ./clone/cloneDeepWithoutLoc */ "./node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"));

var _cloneWithoutLoc = _interopRequireDefault(__webpack_require__(/*! ./clone/cloneWithoutLoc */ "./node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"));

var _addComment = _interopRequireDefault(__webpack_require__(/*! ./comments/addComment */ "./node_modules/@babel/types/lib/comments/addComment.js"));

var _addComments = _interopRequireDefault(__webpack_require__(/*! ./comments/addComments */ "./node_modules/@babel/types/lib/comments/addComments.js"));

var _inheritInnerComments = _interopRequireDefault(__webpack_require__(/*! ./comments/inheritInnerComments */ "./node_modules/@babel/types/lib/comments/inheritInnerComments.js"));

var _inheritLeadingComments = _interopRequireDefault(__webpack_require__(/*! ./comments/inheritLeadingComments */ "./node_modules/@babel/types/lib/comments/inheritLeadingComments.js"));

var _inheritsComments = _interopRequireDefault(__webpack_require__(/*! ./comments/inheritsComments */ "./node_modules/@babel/types/lib/comments/inheritsComments.js"));

var _inheritTrailingComments = _interopRequireDefault(__webpack_require__(/*! ./comments/inheritTrailingComments */ "./node_modules/@babel/types/lib/comments/inheritTrailingComments.js"));

var _removeComments = _interopRequireDefault(__webpack_require__(/*! ./comments/removeComments */ "./node_modules/@babel/types/lib/comments/removeComments.js"));

var _generated3 = __webpack_require__(/*! ./constants/generated */ "./node_modules/@babel/types/lib/constants/generated/index.js");

Object.keys(_generated3).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _generated3[key];
    }
  });
});

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/@babel/types/lib/constants/index.js");

Object.keys(_constants).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _constants[key];
    }
  });
});

var _ensureBlock = _interopRequireDefault(__webpack_require__(/*! ./converters/ensureBlock */ "./node_modules/@babel/types/lib/converters/ensureBlock.js"));

var _toBindingIdentifierName = _interopRequireDefault(__webpack_require__(/*! ./converters/toBindingIdentifierName */ "./node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"));

var _toBlock = _interopRequireDefault(__webpack_require__(/*! ./converters/toBlock */ "./node_modules/@babel/types/lib/converters/toBlock.js"));

var _toComputedKey = _interopRequireDefault(__webpack_require__(/*! ./converters/toComputedKey */ "./node_modules/@babel/types/lib/converters/toComputedKey.js"));

var _toExpression = _interopRequireDefault(__webpack_require__(/*! ./converters/toExpression */ "./node_modules/@babel/types/lib/converters/toExpression.js"));

var _toIdentifier = _interopRequireDefault(__webpack_require__(/*! ./converters/toIdentifier */ "./node_modules/@babel/types/lib/converters/toIdentifier.js"));

var _toKeyAlias = _interopRequireDefault(__webpack_require__(/*! ./converters/toKeyAlias */ "./node_modules/@babel/types/lib/converters/toKeyAlias.js"));

var _toSequenceExpression = _interopRequireDefault(__webpack_require__(/*! ./converters/toSequenceExpression */ "./node_modules/@babel/types/lib/converters/toSequenceExpression.js"));

var _toStatement = _interopRequireDefault(__webpack_require__(/*! ./converters/toStatement */ "./node_modules/@babel/types/lib/converters/toStatement.js"));

var _valueToNode = _interopRequireDefault(__webpack_require__(/*! ./converters/valueToNode */ "./node_modules/@babel/types/lib/converters/valueToNode.js"));

var _definitions = __webpack_require__(/*! ./definitions */ "./node_modules/@babel/types/lib/definitions/index.js");

Object.keys(_definitions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _definitions[key];
    }
  });
});

var _appendToMemberExpression = _interopRequireDefault(__webpack_require__(/*! ./modifications/appendToMemberExpression */ "./node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"));

var _inherits = _interopRequireDefault(__webpack_require__(/*! ./modifications/inherits */ "./node_modules/@babel/types/lib/modifications/inherits.js"));

var _prependToMemberExpression = _interopRequireDefault(__webpack_require__(/*! ./modifications/prependToMemberExpression */ "./node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"));

var _removeProperties = _interopRequireDefault(__webpack_require__(/*! ./modifications/removeProperties */ "./node_modules/@babel/types/lib/modifications/removeProperties.js"));

var _removePropertiesDeep = _interopRequireDefault(__webpack_require__(/*! ./modifications/removePropertiesDeep */ "./node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"));

var _removeTypeDuplicates = _interopRequireDefault(__webpack_require__(/*! ./modifications/flow/removeTypeDuplicates */ "./node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"));

var _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(/*! ./retrievers/getBindingIdentifiers */ "./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"));

var _getOuterBindingIdentifiers = _interopRequireDefault(__webpack_require__(/*! ./retrievers/getOuterBindingIdentifiers */ "./node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"));

var _traverse = _interopRequireDefault(__webpack_require__(/*! ./traverse/traverse */ "./node_modules/@babel/types/lib/traverse/traverse.js"));

var _traverseFast = _interopRequireDefault(__webpack_require__(/*! ./traverse/traverseFast */ "./node_modules/@babel/types/lib/traverse/traverseFast.js"));

var _shallowEqual = _interopRequireDefault(__webpack_require__(/*! ./utils/shallowEqual */ "./node_modules/@babel/types/lib/utils/shallowEqual.js"));

var _is = _interopRequireDefault(__webpack_require__(/*! ./validators/is */ "./node_modules/@babel/types/lib/validators/is.js"));

var _isBinding = _interopRequireDefault(__webpack_require__(/*! ./validators/isBinding */ "./node_modules/@babel/types/lib/validators/isBinding.js"));

var _isBlockScoped = _interopRequireDefault(__webpack_require__(/*! ./validators/isBlockScoped */ "./node_modules/@babel/types/lib/validators/isBlockScoped.js"));

var _isImmutable = _interopRequireDefault(__webpack_require__(/*! ./validators/isImmutable */ "./node_modules/@babel/types/lib/validators/isImmutable.js"));

var _isLet = _interopRequireDefault(__webpack_require__(/*! ./validators/isLet */ "./node_modules/@babel/types/lib/validators/isLet.js"));

var _isNode = _interopRequireDefault(__webpack_require__(/*! ./validators/isNode */ "./node_modules/@babel/types/lib/validators/isNode.js"));

var _isNodesEquivalent = _interopRequireDefault(__webpack_require__(/*! ./validators/isNodesEquivalent */ "./node_modules/@babel/types/lib/validators/isNodesEquivalent.js"));

var _isPlaceholderType = _interopRequireDefault(__webpack_require__(/*! ./validators/isPlaceholderType */ "./node_modules/@babel/types/lib/validators/isPlaceholderType.js"));

var _isReferenced = _interopRequireDefault(__webpack_require__(/*! ./validators/isReferenced */ "./node_modules/@babel/types/lib/validators/isReferenced.js"));

var _isScope = _interopRequireDefault(__webpack_require__(/*! ./validators/isScope */ "./node_modules/@babel/types/lib/validators/isScope.js"));

var _isSpecifierDefault = _interopRequireDefault(__webpack_require__(/*! ./validators/isSpecifierDefault */ "./node_modules/@babel/types/lib/validators/isSpecifierDefault.js"));

var _isType = _interopRequireDefault(__webpack_require__(/*! ./validators/isType */ "./node_modules/@babel/types/lib/validators/isType.js"));

var _isValidES3Identifier = _interopRequireDefault(__webpack_require__(/*! ./validators/isValidES3Identifier */ "./node_modules/@babel/types/lib/validators/isValidES3Identifier.js"));

var _isValidIdentifier = _interopRequireDefault(__webpack_require__(/*! ./validators/isValidIdentifier */ "./node_modules/@babel/types/lib/validators/isValidIdentifier.js"));

var _isVar = _interopRequireDefault(__webpack_require__(/*! ./validators/isVar */ "./node_modules/@babel/types/lib/validators/isVar.js"));

var _matchesPattern = _interopRequireDefault(__webpack_require__(/*! ./validators/matchesPattern */ "./node_modules/@babel/types/lib/validators/matchesPattern.js"));

var _validate = _interopRequireDefault(__webpack_require__(/*! ./validators/validate */ "./node_modules/@babel/types/lib/validators/validate.js"));

var _buildMatchMemberExpression = _interopRequireDefault(__webpack_require__(/*! ./validators/buildMatchMemberExpression */ "./node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"));

var _generated4 = __webpack_require__(/*! ./validators/generated */ "./node_modules/@babel/types/lib/validators/generated/index.js");

Object.keys(_generated4).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _generated4[key];
    }
  });
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const react = {
  isReactComponent: _isReactComponent.default,
  isCompatTag: _isCompatTag.default,
  buildChildren: _buildChildren.default
};
exports.react = react;

/***/ }),

/***/ "./node_modules/@babel/types/lib/modifications/appendToMemberExpression.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/modifications/appendToMemberExpression.js ***!
  \*********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = appendToMemberExpression;

var _generated = __webpack_require__(/*! ../builders/generated */ "./node_modules/@babel/types/lib/builders/generated/index.js");

function appendToMemberExpression(member, append, computed = false) {
  member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed);
  member.property = append;
  member.computed = !!computed;
  return member;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeTypeDuplicates;

var _generated = __webpack_require__(/*! ../../validators/generated */ "./node_modules/@babel/types/lib/validators/generated/index.js");

function removeTypeDuplicates(nodes) {
  const generics = {};
  const bases = {};
  const typeGroups = [];
  const types = [];

  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (!node) continue;

    if (types.indexOf(node) >= 0) {
      continue;
    }

    if ((0, _generated.isAnyTypeAnnotation)(node)) {
      return [node];
    }

    if ((0, _generated.isFlowBaseAnnotation)(node)) {
      bases[node.type] = node;
      continue;
    }

    if ((0, _generated.isUnionTypeAnnotation)(node)) {
      if (typeGroups.indexOf(node.types) < 0) {
        nodes = nodes.concat(node.types);
        typeGroups.push(node.types);
      }

      continue;
    }

    if ((0, _generated.isGenericTypeAnnotation)(node)) {
      const name = node.id.name;

      if (generics[name]) {
        let existing = generics[name];

        if (existing.typeParameters) {
          if (node.typeParameters) {
            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
          }
        } else {
          existing = node.typeParameters;
        }
      } else {
        generics[name] = node;
      }

      continue;
    }

    types.push(node);
  }

  for (const type of Object.keys(bases)) {
    types.push(bases[type]);
  }

  for (const name of Object.keys(generics)) {
    types.push(generics[name]);
  }

  return types;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/modifications/inherits.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/types/lib/modifications/inherits.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inherits;

var _constants = __webpack_require__(/*! ../constants */ "./node_modules/@babel/types/lib/constants/index.js");

var _inheritsComments = _interopRequireDefault(__webpack_require__(/*! ../comments/inheritsComments */ "./node_modules/@babel/types/lib/comments/inheritsComments.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inherits(child, parent) {
  if (!child || !parent) return child;

  for (const key of _constants.INHERIT_KEYS.optional) {
    if (child[key] == null) {
      child[key] = parent[key];
    }
  }

  for (const key of Object.keys(parent)) {
    if (key[0] === "_" && key !== "__clone") child[key] = parent[key];
  }

  for (const key of _constants.INHERIT_KEYS.force) {
    child[key] = parent[key];
  }

  (0, _inheritsComments.default)(child, parent);
  return child;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/modifications/prependToMemberExpression.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/modifications/prependToMemberExpression.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = prependToMemberExpression;

var _generated = __webpack_require__(/*! ../builders/generated */ "./node_modules/@babel/types/lib/builders/generated/index.js");

function prependToMemberExpression(member, prepend) {
  member.object = (0, _generated.memberExpression)(prepend, member.object);
  return member;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/modifications/removeProperties.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/modifications/removeProperties.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeProperties;

var _constants = __webpack_require__(/*! ../constants */ "./node_modules/@babel/types/lib/constants/index.js");

const CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];

const CLEAR_KEYS_PLUS_COMMENTS = _constants.COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);

function removeProperties(node, opts = {}) {
  const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;

  for (const key of map) {
    if (node[key] != null) node[key] = undefined;
  }

  for (const key of Object.keys(node)) {
    if (key[0] === "_" && node[key] != null) node[key] = undefined;
  }

  const symbols = Object.getOwnPropertySymbols(node);

  for (const sym of symbols) {
    node[sym] = null;
  }
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/modifications/removePropertiesDeep.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/modifications/removePropertiesDeep.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removePropertiesDeep;

var _traverseFast = _interopRequireDefault(__webpack_require__(/*! ../traverse/traverseFast */ "./node_modules/@babel/types/lib/traverse/traverseFast.js"));

var _removeProperties = _interopRequireDefault(__webpack_require__(/*! ./removeProperties */ "./node_modules/@babel/types/lib/modifications/removeProperties.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function removePropertiesDeep(tree, opts) {
  (0, _traverseFast.default)(tree, _removeProperties.default, opts);
  return tree;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeTypeDuplicates;

var _generated = __webpack_require__(/*! ../../validators/generated */ "./node_modules/@babel/types/lib/validators/generated/index.js");

function removeTypeDuplicates(nodes) {
  const generics = {};
  const bases = {};
  const typeGroups = [];
  const types = [];

  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (!node) continue;

    if (types.indexOf(node) >= 0) {
      continue;
    }

    if ((0, _generated.isTSAnyKeyword)(node.type)) {
      return [node];
    }

    if ((0, _generated.isTSBaseType)(node)) {
      bases[node.type] = node;
      continue;
    }

    if ((0, _generated.isTSUnionType)(node)) {
      if (typeGroups.indexOf(node.types) < 0) {
        nodes = nodes.concat(node.types);
        typeGroups.push(node.types);
      }

      continue;
    }

    types.push(node);
  }

  for (const type of Object.keys(bases)) {
    types.push(bases[type]);
  }

  for (const name of Object.keys(generics)) {
    types.push(generics[name]);
  }

  return types;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getBindingIdentifiers;

var _generated = __webpack_require__(/*! ../validators/generated */ "./node_modules/@babel/types/lib/validators/generated/index.js");

function getBindingIdentifiers(node, duplicates, outerOnly) {
  let search = [].concat(node);
  const ids = Object.create(null);

  while (search.length) {
    const id = search.shift();
    if (!id) continue;
    const keys = getBindingIdentifiers.keys[id.type];

    if ((0, _generated.isIdentifier)(id)) {
      if (duplicates) {
        const _ids = ids[id.name] = ids[id.name] || [];

        _ids.push(id);
      } else {
        ids[id.name] = id;
      }

      continue;
    }

    if ((0, _generated.isExportDeclaration)(id)) {
      if ((0, _generated.isDeclaration)(id.declaration)) {
        search.push(id.declaration);
      }

      continue;
    }

    if (outerOnly) {
      if ((0, _generated.isFunctionDeclaration)(id)) {
        search.push(id.id);
        continue;
      }

      if ((0, _generated.isFunctionExpression)(id)) {
        continue;
      }
    }

    if (keys) {
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];

        if (id[key]) {
          search = search.concat(id[key]);
        }
      }
    }
  }

  return ids;
}

getBindingIdentifiers.keys = {
  DeclareClass: ["id"],
  DeclareFunction: ["id"],
  DeclareModule: ["id"],
  DeclareVariable: ["id"],
  DeclareInterface: ["id"],
  DeclareTypeAlias: ["id"],
  DeclareOpaqueType: ["id"],
  InterfaceDeclaration: ["id"],
  TypeAlias: ["id"],
  OpaqueType: ["id"],
  CatchClause: ["param"],
  LabeledStatement: ["label"],
  UnaryExpression: ["argument"],
  AssignmentExpression: ["left"],
  ImportSpecifier: ["local"],
  ImportNamespaceSpecifier: ["local"],
  ImportDefaultSpecifier: ["local"],
  ImportDeclaration: ["specifiers"],
  ExportSpecifier: ["exported"],
  ExportNamespaceSpecifier: ["exported"],
  ExportDefaultSpecifier: ["exported"],
  FunctionDeclaration: ["id", "params"],
  FunctionExpression: ["id", "params"],
  ArrowFunctionExpression: ["params"],
  ObjectMethod: ["params"],
  ClassMethod: ["params"],
  ForInStatement: ["left"],
  ForOfStatement: ["left"],
  ClassDeclaration: ["id"],
  ClassExpression: ["id"],
  RestElement: ["argument"],
  UpdateExpression: ["argument"],
  ObjectProperty: ["value"],
  AssignmentPattern: ["left"],
  ArrayPattern: ["elements"],
  ObjectPattern: ["properties"],
  VariableDeclaration: ["declarations"],
  VariableDeclarator: ["id"]
};

/***/ }),

/***/ "./node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getOuterBindingIdentifiers;

var _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(/*! ./getBindingIdentifiers */ "./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getOuterBindingIdentifiers(node, duplicates) {
  return (0, _getBindingIdentifiers.default)(node, duplicates, true);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/traverse/traverse.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/types/lib/traverse/traverse.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = traverse;

var _definitions = __webpack_require__(/*! ../definitions */ "./node_modules/@babel/types/lib/definitions/index.js");

function traverse(node, handlers, state) {
  if (typeof handlers === "function") {
    handlers = {
      enter: handlers
    };
  }

  const {
    enter,
    exit
  } = handlers;
  traverseSimpleImpl(node, enter, exit, state, []);
}

function traverseSimpleImpl(node, enter, exit, state, ancestors) {
  const keys = _definitions.VISITOR_KEYS[node.type];
  if (!keys) return;
  if (enter) enter(node, ancestors, state);

  for (const key of keys) {
    const subNode = node[key];

    if (Array.isArray(subNode)) {
      for (let i = 0; i < subNode.length; i++) {
        const child = subNode[i];
        if (!child) continue;
        ancestors.push({
          node,
          key,
          index: i
        });
        traverseSimpleImpl(child, enter, exit, state, ancestors);
        ancestors.pop();
      }
    } else if (subNode) {
      ancestors.push({
        node,
        key
      });
      traverseSimpleImpl(subNode, enter, exit, state, ancestors);
      ancestors.pop();
    }
  }

  if (exit) exit(node, ancestors, state);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/traverse/traverseFast.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/types/lib/traverse/traverseFast.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = traverseFast;

var _definitions = __webpack_require__(/*! ../definitions */ "./node_modules/@babel/types/lib/definitions/index.js");

function traverseFast(node, enter, opts) {
  if (!node) return;
  const keys = _definitions.VISITOR_KEYS[node.type];
  if (!keys) return;
  opts = opts || {};
  enter(node, opts);

  for (const key of keys) {
    const subNode = node[key];

    if (Array.isArray(subNode)) {
      for (const node of subNode) {
        traverseFast(node, enter, opts);
      }
    } else {
      traverseFast(subNode, enter, opts);
    }
  }
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/utils/inherit.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/types/lib/utils/inherit.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inherit;

function inherit(key, child, parent) {
  if (child && parent) {
    child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
  }
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cleanJSXElementLiteralChild;

var _generated = __webpack_require__(/*! ../../builders/generated */ "./node_modules/@babel/types/lib/builders/generated/index.js");

function cleanJSXElementLiteralChild(child, args) {
  const lines = child.value.split(/\r\n|\n|\r/);
  let lastNonEmptyLine = 0;

  for (let i = 0; i < lines.length; i++) {
    if (lines[i].match(/[^ \t]/)) {
      lastNonEmptyLine = i;
    }
  }

  let str = "";

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const isFirstLine = i === 0;
    const isLastLine = i === lines.length - 1;
    const isLastNonEmptyLine = i === lastNonEmptyLine;
    let trimmedLine = line.replace(/\t/g, " ");

    if (!isFirstLine) {
      trimmedLine = trimmedLine.replace(/^[ ]+/, "");
    }

    if (!isLastLine) {
      trimmedLine = trimmedLine.replace(/[ ]+$/, "");
    }

    if (trimmedLine) {
      if (!isLastNonEmptyLine) {
        trimmedLine += " ";
      }

      str += trimmedLine;
    }
  }

  if (str) args.push((0, _generated.stringLiteral)(str));
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/utils/shallowEqual.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/types/lib/utils/shallowEqual.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = shallowEqual;

function shallowEqual(actual, expected) {
  const keys = Object.keys(expected);

  for (const key of keys) {
    if (actual[key] !== expected[key]) {
      return false;
    }
  }

  return true;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildMatchMemberExpression;

var _matchesPattern = _interopRequireDefault(__webpack_require__(/*! ./matchesPattern */ "./node_modules/@babel/types/lib/validators/matchesPattern.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function buildMatchMemberExpression(match, allowPartial) {
  const parts = match.split(".");
  return member => (0, _matchesPattern.default)(member, parts, allowPartial);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/generated/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/generated/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isArrayExpression = isArrayExpression;
exports.isAssignmentExpression = isAssignmentExpression;
exports.isBinaryExpression = isBinaryExpression;
exports.isInterpreterDirective = isInterpreterDirective;
exports.isDirective = isDirective;
exports.isDirectiveLiteral = isDirectiveLiteral;
exports.isBlockStatement = isBlockStatement;
exports.isBreakStatement = isBreakStatement;
exports.isCallExpression = isCallExpression;
exports.isCatchClause = isCatchClause;
exports.isConditionalExpression = isConditionalExpression;
exports.isContinueStatement = isContinueStatement;
exports.isDebuggerStatement = isDebuggerStatement;
exports.isDoWhileStatement = isDoWhileStatement;
exports.isEmptyStatement = isEmptyStatement;
exports.isExpressionStatement = isExpressionStatement;
exports.isFile = isFile;
exports.isForInStatement = isForInStatement;
exports.isForStatement = isForStatement;
exports.isFunctionDeclaration = isFunctionDeclaration;
exports.isFunctionExpression = isFunctionExpression;
exports.isIdentifier = isIdentifier;
exports.isIfStatement = isIfStatement;
exports.isLabeledStatement = isLabeledStatement;
exports.isStringLiteral = isStringLiteral;
exports.isNumericLiteral = isNumericLiteral;
exports.isNullLiteral = isNullLiteral;
exports.isBooleanLiteral = isBooleanLiteral;
exports.isRegExpLiteral = isRegExpLiteral;
exports.isLogicalExpression = isLogicalExpression;
exports.isMemberExpression = isMemberExpression;
exports.isNewExpression = isNewExpression;
exports.isProgram = isProgram;
exports.isObjectExpression = isObjectExpression;
exports.isObjectMethod = isObjectMethod;
exports.isObjectProperty = isObjectProperty;
exports.isRestElement = isRestElement;
exports.isReturnStatement = isReturnStatement;
exports.isSequenceExpression = isSequenceExpression;
exports.isParenthesizedExpression = isParenthesizedExpression;
exports.isSwitchCase = isSwitchCase;
exports.isSwitchStatement = isSwitchStatement;
exports.isThisExpression = isThisExpression;
exports.isThrowStatement = isThrowStatement;
exports.isTryStatement = isTryStatement;
exports.isUnaryExpression = isUnaryExpression;
exports.isUpdateExpression = isUpdateExpression;
exports.isVariableDeclaration = isVariableDeclaration;
exports.isVariableDeclarator = isVariableDeclarator;
exports.isWhileStatement = isWhileStatement;
exports.isWithStatement = isWithStatement;
exports.isAssignmentPattern = isAssignmentPattern;
exports.isArrayPattern = isArrayPattern;
exports.isArrowFunctionExpression = isArrowFunctionExpression;
exports.isClassBody = isClassBody;
exports.isClassExpression = isClassExpression;
exports.isClassDeclaration = isClassDeclaration;
exports.isExportAllDeclaration = isExportAllDeclaration;
exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
exports.isExportNamedDeclaration = isExportNamedDeclaration;
exports.isExportSpecifier = isExportSpecifier;
exports.isForOfStatement = isForOfStatement;
exports.isImportDeclaration = isImportDeclaration;
exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
exports.isImportSpecifier = isImportSpecifier;
exports.isMetaProperty = isMetaProperty;
exports.isClassMethod = isClassMethod;
exports.isObjectPattern = isObjectPattern;
exports.isSpreadElement = isSpreadElement;
exports.isSuper = isSuper;
exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
exports.isTemplateElement = isTemplateElement;
exports.isTemplateLiteral = isTemplateLiteral;
exports.isYieldExpression = isYieldExpression;
exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
exports.isClassImplements = isClassImplements;
exports.isDeclareClass = isDeclareClass;
exports.isDeclareFunction = isDeclareFunction;
exports.isDeclareInterface = isDeclareInterface;
exports.isDeclareModule = isDeclareModule;
exports.isDeclareModuleExports = isDeclareModuleExports;
exports.isDeclareTypeAlias = isDeclareTypeAlias;
exports.isDeclareOpaqueType = isDeclareOpaqueType;
exports.isDeclareVariable = isDeclareVariable;
exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
exports.isDeclaredPredicate = isDeclaredPredicate;
exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
exports.isFunctionTypeParam = isFunctionTypeParam;
exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
exports.isInferredPredicate = isInferredPredicate;
exports.isInterfaceExtends = isInterfaceExtends;
exports.isInterfaceDeclaration = isInterfaceDeclaration;
exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
exports.isObjectTypeIndexer = isObjectTypeIndexer;
exports.isObjectTypeProperty = isObjectTypeProperty;
exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
exports.isOpaqueType = isOpaqueType;
exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
exports.isStringTypeAnnotation = isStringTypeAnnotation;
exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
exports.isThisTypeAnnotation = isThisTypeAnnotation;
exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
exports.isTypeAlias = isTypeAlias;
exports.isTypeAnnotation = isTypeAnnotation;
exports.isTypeCastExpression = isTypeCastExpression;
exports.isTypeParameter = isTypeParameter;
exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
exports.isVariance = isVariance;
exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
exports.isEnumDeclaration = isEnumDeclaration;
exports.isEnumBooleanBody = isEnumBooleanBody;
exports.isEnumNumberBody = isEnumNumberBody;
exports.isEnumStringBody = isEnumStringBody;
exports.isEnumSymbolBody = isEnumSymbolBody;
exports.isEnumBooleanMember = isEnumBooleanMember;
exports.isEnumNumberMember = isEnumNumberMember;
exports.isEnumStringMember = isEnumStringMember;
exports.isEnumDefaultedMember = isEnumDefaultedMember;
exports.isJSXAttribute = isJSXAttribute;
exports.isJSXClosingElement = isJSXClosingElement;
exports.isJSXElement = isJSXElement;
exports.isJSXEmptyExpression = isJSXEmptyExpression;
exports.isJSXExpressionContainer = isJSXExpressionContainer;
exports.isJSXSpreadChild = isJSXSpreadChild;
exports.isJSXIdentifier = isJSXIdentifier;
exports.isJSXMemberExpression = isJSXMemberExpression;
exports.isJSXNamespacedName = isJSXNamespacedName;
exports.isJSXOpeningElement = isJSXOpeningElement;
exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
exports.isJSXText = isJSXText;
exports.isJSXFragment = isJSXFragment;
exports.isJSXOpeningFragment = isJSXOpeningFragment;
exports.isJSXClosingFragment = isJSXClosingFragment;
exports.isNoop = isNoop;
exports.isPlaceholder = isPlaceholder;
exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
exports.isArgumentPlaceholder = isArgumentPlaceholder;
exports.isAwaitExpression = isAwaitExpression;
exports.isBindExpression = isBindExpression;
exports.isClassProperty = isClassProperty;
exports.isOptionalMemberExpression = isOptionalMemberExpression;
exports.isPipelineTopicExpression = isPipelineTopicExpression;
exports.isPipelineBareFunction = isPipelineBareFunction;
exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
exports.isOptionalCallExpression = isOptionalCallExpression;
exports.isClassPrivateProperty = isClassPrivateProperty;
exports.isClassPrivateMethod = isClassPrivateMethod;
exports.isImport = isImport;
exports.isImportAttribute = isImportAttribute;
exports.isDecorator = isDecorator;
exports.isDoExpression = isDoExpression;
exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
exports.isPrivateName = isPrivateName;
exports.isBigIntLiteral = isBigIntLiteral;
exports.isRecordExpression = isRecordExpression;
exports.isTupleExpression = isTupleExpression;
exports.isTSParameterProperty = isTSParameterProperty;
exports.isTSDeclareFunction = isTSDeclareFunction;
exports.isTSDeclareMethod = isTSDeclareMethod;
exports.isTSQualifiedName = isTSQualifiedName;
exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
exports.isTSPropertySignature = isTSPropertySignature;
exports.isTSMethodSignature = isTSMethodSignature;
exports.isTSIndexSignature = isTSIndexSignature;
exports.isTSAnyKeyword = isTSAnyKeyword;
exports.isTSBooleanKeyword = isTSBooleanKeyword;
exports.isTSBigIntKeyword = isTSBigIntKeyword;
exports.isTSNeverKeyword = isTSNeverKeyword;
exports.isTSNullKeyword = isTSNullKeyword;
exports.isTSNumberKeyword = isTSNumberKeyword;
exports.isTSObjectKeyword = isTSObjectKeyword;
exports.isTSStringKeyword = isTSStringKeyword;
exports.isTSSymbolKeyword = isTSSymbolKeyword;
exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
exports.isTSUnknownKeyword = isTSUnknownKeyword;
exports.isTSVoidKeyword = isTSVoidKeyword;
exports.isTSThisType = isTSThisType;
exports.isTSFunctionType = isTSFunctionType;
exports.isTSConstructorType = isTSConstructorType;
exports.isTSTypeReference = isTSTypeReference;
exports.isTSTypePredicate = isTSTypePredicate;
exports.isTSTypeQuery = isTSTypeQuery;
exports.isTSTypeLiteral = isTSTypeLiteral;
exports.isTSArrayType = isTSArrayType;
exports.isTSTupleType = isTSTupleType;
exports.isTSOptionalType = isTSOptionalType;
exports.isTSRestType = isTSRestType;
exports.isTSUnionType = isTSUnionType;
exports.isTSIntersectionType = isTSIntersectionType;
exports.isTSConditionalType = isTSConditionalType;
exports.isTSInferType = isTSInferType;
exports.isTSParenthesizedType = isTSParenthesizedType;
exports.isTSTypeOperator = isTSTypeOperator;
exports.isTSIndexedAccessType = isTSIndexedAccessType;
exports.isTSMappedType = isTSMappedType;
exports.isTSLiteralType = isTSLiteralType;
exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
exports.isTSInterfaceBody = isTSInterfaceBody;
exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
exports.isTSAsExpression = isTSAsExpression;
exports.isTSTypeAssertion = isTSTypeAssertion;
exports.isTSEnumDeclaration = isTSEnumDeclaration;
exports.isTSEnumMember = isTSEnumMember;
exports.isTSModuleDeclaration = isTSModuleDeclaration;
exports.isTSModuleBlock = isTSModuleBlock;
exports.isTSImportType = isTSImportType;
exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
exports.isTSExternalModuleReference = isTSExternalModuleReference;
exports.isTSNonNullExpression = isTSNonNullExpression;
exports.isTSExportAssignment = isTSExportAssignment;
exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
exports.isTSTypeAnnotation = isTSTypeAnnotation;
exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
exports.isTSTypeParameter = isTSTypeParameter;
exports.isExpression = isExpression;
exports.isBinary = isBinary;
exports.isScopable = isScopable;
exports.isBlockParent = isBlockParent;
exports.isBlock = isBlock;
exports.isStatement = isStatement;
exports.isTerminatorless = isTerminatorless;
exports.isCompletionStatement = isCompletionStatement;
exports.isConditional = isConditional;
exports.isLoop = isLoop;
exports.isWhile = isWhile;
exports.isExpressionWrapper = isExpressionWrapper;
exports.isFor = isFor;
exports.isForXStatement = isForXStatement;
exports.isFunction = isFunction;
exports.isFunctionParent = isFunctionParent;
exports.isPureish = isPureish;
exports.isDeclaration = isDeclaration;
exports.isPatternLike = isPatternLike;
exports.isLVal = isLVal;
exports.isTSEntityName = isTSEntityName;
exports.isLiteral = isLiteral;
exports.isImmutable = isImmutable;
exports.isUserWhitespacable = isUserWhitespacable;
exports.isMethod = isMethod;
exports.isObjectMember = isObjectMember;
exports.isProperty = isProperty;
exports.isUnaryLike = isUnaryLike;
exports.isPattern = isPattern;
exports.isClass = isClass;
exports.isModuleDeclaration = isModuleDeclaration;
exports.isExportDeclaration = isExportDeclaration;
exports.isModuleSpecifier = isModuleSpecifier;
exports.isFlow = isFlow;
exports.isFlowType = isFlowType;
exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
exports.isFlowDeclaration = isFlowDeclaration;
exports.isFlowPredicate = isFlowPredicate;
exports.isEnumBody = isEnumBody;
exports.isEnumMember = isEnumMember;
exports.isJSX = isJSX;
exports.isPrivate = isPrivate;
exports.isTSTypeElement = isTSTypeElement;
exports.isTSType = isTSType;
exports.isTSBaseType = isTSBaseType;
exports.isNumberLiteral = isNumberLiteral;
exports.isRegexLiteral = isRegexLiteral;
exports.isRestProperty = isRestProperty;
exports.isSpreadProperty = isSpreadProperty;

var _shallowEqual = _interopRequireDefault(__webpack_require__(/*! ../../utils/shallowEqual */ "./node_modules/@babel/types/lib/utils/shallowEqual.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isArrayExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ArrayExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isAssignmentExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "AssignmentExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBinaryExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BinaryExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInterpreterDirective(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "InterpreterDirective") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDirective(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Directive") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDirectiveLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DirectiveLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBlockStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BlockStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBreakStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BreakStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isCallExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "CallExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isCatchClause(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "CatchClause") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isConditionalExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ConditionalExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isContinueStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ContinueStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDebuggerStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DebuggerStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDoWhileStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DoWhileStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEmptyStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EmptyStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExpressionStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExpressionStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFile(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "File") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isForInStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ForInStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isForStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ForStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FunctionDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FunctionExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Identifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isIfStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "IfStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLabeledStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "LabeledStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isStringLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "StringLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNumericLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NumericLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNullLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NullLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBooleanLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BooleanLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRegExpLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "RegExpLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLogicalExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "LogicalExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isMemberExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "MemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNewExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NewExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isProgram(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Program") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRestElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "RestElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isReturnStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ReturnStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSequenceExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SequenceExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isParenthesizedExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ParenthesizedExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSwitchCase(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SwitchCase") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSwitchStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SwitchStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isThisExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ThisExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isThrowStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ThrowStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTryStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TryStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUnaryExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "UnaryExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUpdateExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "UpdateExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isVariableDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "VariableDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isVariableDeclarator(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "VariableDeclarator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isWhileStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "WhileStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isWithStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "WithStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isAssignmentPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "AssignmentPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isArrayPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ArrayPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isArrowFunctionExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ArrowFunctionExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportAllDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportAllDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportDefaultDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportDefaultDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportNamedDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportNamedDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isForOfStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ForOfStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ImportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportDefaultSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ImportDefaultSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportNamespaceSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ImportNamespaceSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ImportSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isMetaProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "MetaProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSpreadElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SpreadElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSuper(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Super") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTaggedTemplateExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TaggedTemplateExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTemplateElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TemplateElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTemplateLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TemplateLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isYieldExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "YieldExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isAnyTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "AnyTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isArrayTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ArrayTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBooleanTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BooleanTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBooleanLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BooleanLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNullLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NullLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassImplements(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassImplements") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareClass(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareClass") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareInterface(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareInterface") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareModule(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareModule") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareModuleExports(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareModuleExports") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareTypeAlias(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareTypeAlias") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareOpaqueType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareOpaqueType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareVariable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareVariable") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareExportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareExportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareExportAllDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareExportAllDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclaredPredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclaredPredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExistsTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExistsTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FunctionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionTypeParam(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FunctionTypeParam") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isGenericTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "GenericTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInferredPredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "InferredPredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInterfaceExtends(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "InterfaceExtends") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInterfaceDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "InterfaceDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInterfaceTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "InterfaceTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isIntersectionTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "IntersectionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isMixedTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "MixedTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEmptyTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EmptyTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNullableTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NullableTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNumberLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NumberLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNumberTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NumberTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeInternalSlot(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeInternalSlot") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeCallProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeCallProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeIndexer(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeIndexer") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeSpreadProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeSpreadProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isOpaqueType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "OpaqueType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isQualifiedTypeIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "QualifiedTypeIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isStringLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "StringLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isStringTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "StringTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSymbolTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SymbolTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isThisTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ThisTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTupleTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TupleTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeofTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeofTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeAlias(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeAlias") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeCastExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeCastExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeParameter(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeParameter") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeParameterDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeParameterDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeParameterInstantiation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeParameterInstantiation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUnionTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "UnionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isVariance(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Variance") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isVoidTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "VoidTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumBooleanBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumBooleanBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumNumberBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumNumberBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumStringBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumStringBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumSymbolBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumSymbolBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumBooleanMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumBooleanMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumNumberMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumNumberMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumStringMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumStringMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumDefaultedMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumDefaultedMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXAttribute(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXClosingElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXClosingElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXEmptyExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXEmptyExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXExpressionContainer(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXExpressionContainer") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXSpreadChild(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXSpreadChild") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXMemberExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXMemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXNamespacedName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXNamespacedName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXOpeningElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXOpeningElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXSpreadAttribute(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXSpreadAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXText(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXText") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXFragment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXOpeningFragment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXOpeningFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXClosingFragment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXClosingFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNoop(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Noop") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPlaceholder(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Placeholder") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isV8IntrinsicIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "V8IntrinsicIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isArgumentPlaceholder(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ArgumentPlaceholder") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isAwaitExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "AwaitExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBindExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BindExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isOptionalMemberExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "OptionalMemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPipelineTopicExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "PipelineTopicExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPipelineBareFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "PipelineBareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPipelinePrimaryTopicReference(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "PipelinePrimaryTopicReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isOptionalCallExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "OptionalCallExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassPrivateProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassPrivateProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassPrivateMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassPrivateMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImport(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Import") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportAttribute(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ImportAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDecorator(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Decorator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDoExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DoExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportDefaultSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportDefaultSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportNamespaceSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportNamespaceSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPrivateName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "PrivateName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBigIntLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BigIntLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRecordExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "RecordExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTupleExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TupleExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSParameterProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSParameterProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSDeclareFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSDeclareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSDeclareMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSDeclareMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSQualifiedName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSQualifiedName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSCallSignatureDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSCallSignatureDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSConstructSignatureDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSConstructSignatureDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSPropertySignature(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSPropertySignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSMethodSignature(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSMethodSignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSIndexSignature(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSIndexSignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSAnyKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSAnyKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSBooleanKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSBooleanKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSBigIntKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSBigIntKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNeverKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNeverKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNullKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNullKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNumberKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNumberKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSObjectKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSObjectKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSStringKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSStringKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSSymbolKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSSymbolKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSUndefinedKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSUndefinedKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSUnknownKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSUnknownKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSVoidKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSVoidKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSThisType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSThisType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSFunctionType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSFunctionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSConstructorType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSConstructorType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeReference(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypePredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypePredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeQuery(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeQuery") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSArrayType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSArrayType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTupleType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTupleType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSOptionalType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSOptionalType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSRestType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSRestType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSUnionType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSUnionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSIntersectionType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSIntersectionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSConditionalType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSConditionalType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSInferType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSInferType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSParenthesizedType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSParenthesizedType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeOperator(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeOperator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSIndexedAccessType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSIndexedAccessType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSMappedType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSMappedType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSLiteralType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSLiteralType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSExpressionWithTypeArguments(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSExpressionWithTypeArguments") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSInterfaceDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSInterfaceDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSInterfaceBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSInterfaceBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeAliasDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeAliasDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSAsExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSAsExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeAssertion(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeAssertion") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSEnumDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSEnumDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSEnumMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSEnumMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSModuleDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSModuleDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSModuleBlock(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSModuleBlock") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSImportType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSImportType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSImportEqualsDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSImportEqualsDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSExternalModuleReference(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSExternalModuleReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNonNullExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNonNullExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSExportAssignment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSExportAssignment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNamespaceExportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNamespaceExportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeParameterInstantiation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeParameterInstantiation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeParameterDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeParameterDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeParameter(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeParameter") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Expression" || "ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "AwaitExpression" === nodeType || "BindExpression" === nodeType || "OptionalMemberExpression" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "OptionalCallExpression" === nodeType || "Import" === nodeType || "DoExpression" === nodeType || "BigIntLiteral" === nodeType || "RecordExpression" === nodeType || "TupleExpression" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Expression" === node.expectedNode || "Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode)) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBinary(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Binary" || "BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isScopable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Scopable" || "BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBlockParent(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BlockParent" || "BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBlock(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Block" || "BlockStatement" === nodeType || "Program" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Statement" || "BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || nodeType === "Placeholder" && ("Statement" === node.expectedNode || "Declaration" === node.expectedNode || "BlockStatement" === node.expectedNode)) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTerminatorless(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Terminatorless" || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isCompletionStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "CompletionStatement" || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isConditional(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Conditional" || "ConditionalExpression" === nodeType || "IfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLoop(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Loop" || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isWhile(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "While" || "DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExpressionWrapper(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExpressionWrapper" || "ExpressionStatement" === nodeType || "ParenthesizedExpression" === nodeType || "TypeCastExpression" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFor(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "For" || "ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isForXStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ForXStatement" || "ForInStatement" === nodeType || "ForOfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Function" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionParent(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FunctionParent" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPureish(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Pureish" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "BigIntLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Declaration" || "FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || nodeType === "Placeholder" && "Declaration" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPatternLike(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "PatternLike" || "Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLVal(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "LVal" || "Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSEntityName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSEntityName" || "Identifier" === nodeType || "TSQualifiedName" === nodeType || nodeType === "Placeholder" && "Identifier" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Literal" || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImmutable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Immutable" || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXOpeningElement" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType || "BigIntLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUserWhitespacable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "UserWhitespacable" || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Method" || "ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectMember" || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Property" || "ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUnaryLike(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "UnaryLike" || "UnaryExpression" === nodeType || "SpreadElement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Pattern" || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && "Pattern" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClass(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Class" || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isModuleDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ModuleDeclaration" || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportDeclaration" || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isModuleSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ModuleSpecifier" || "ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlow(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Flow" || "AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlowType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FlowType" || "AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlowBaseAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FlowBaseAnnotation" || "AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlowDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FlowDeclaration" || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlowPredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FlowPredicate" || "DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumBody" || "EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumMember" || "EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSX(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSX" || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPrivate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Private" || "ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeElement" || "TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSType" || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSBaseType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSBaseType" || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSLiteralType" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNumberLiteral(node, opts) {
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NumberLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRegexLiteral(node, opts) {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "RegexLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRestProperty(node, opts) {
  console.trace("The node type RestProperty has been renamed to RestElement");
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "RestProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSpreadProperty(node, opts) {
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SpreadProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/is.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/is.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = is;

var _shallowEqual = _interopRequireDefault(__webpack_require__(/*! ../utils/shallowEqual */ "./node_modules/@babel/types/lib/utils/shallowEqual.js"));

var _isType = _interopRequireDefault(__webpack_require__(/*! ./isType */ "./node_modules/@babel/types/lib/validators/isType.js"));

var _isPlaceholderType = _interopRequireDefault(__webpack_require__(/*! ./isPlaceholderType */ "./node_modules/@babel/types/lib/validators/isPlaceholderType.js"));

var _definitions = __webpack_require__(/*! ../definitions */ "./node_modules/@babel/types/lib/definitions/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function is(type, node, opts) {
  if (!node) return false;
  const matches = (0, _isType.default)(node.type, type);

  if (!matches) {
    if (!opts && node.type === "Placeholder" && type in _definitions.FLIPPED_ALIAS_KEYS) {
      return (0, _isPlaceholderType.default)(node.expectedNode, type);
    }

    return false;
  }

  if (typeof opts === "undefined") {
    return true;
  } else {
    return (0, _shallowEqual.default)(node, opts);
  }
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/isBinding.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isBinding.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBinding;

var _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(/*! ../retrievers/getBindingIdentifiers */ "./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBinding(node, parent, grandparent) {
  if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
    return false;
  }

  const keys = _getBindingIdentifiers.default.keys[parent.type];

  if (keys) {
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const val = parent[key];

      if (Array.isArray(val)) {
        if (val.indexOf(node) >= 0) return true;
      } else {
        if (val === node) return true;
      }
    }
  }

  return false;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/isBlockScoped.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isBlockScoped.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBlockScoped;

var _generated = __webpack_require__(/*! ./generated */ "./node_modules/@babel/types/lib/validators/generated/index.js");

var _isLet = _interopRequireDefault(__webpack_require__(/*! ./isLet */ "./node_modules/@babel/types/lib/validators/isLet.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBlockScoped(node) {
  return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/isImmutable.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isImmutable.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isImmutable;

var _isType = _interopRequireDefault(__webpack_require__(/*! ./isType */ "./node_modules/@babel/types/lib/validators/isType.js"));

var _generated = __webpack_require__(/*! ./generated */ "./node_modules/@babel/types/lib/validators/generated/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isImmutable(node) {
  if ((0, _isType.default)(node.type, "Immutable")) return true;

  if ((0, _generated.isIdentifier)(node)) {
    if (node.name === "undefined") {
      return true;
    } else {
      return false;
    }
  }

  return false;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/isLet.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isLet.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isLet;

var _generated = __webpack_require__(/*! ./generated */ "./node_modules/@babel/types/lib/validators/generated/index.js");

var _constants = __webpack_require__(/*! ../constants */ "./node_modules/@babel/types/lib/constants/index.js");

function isLet(node) {
  return (0, _generated.isVariableDeclaration)(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/isNode.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isNode.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isNode;

var _definitions = __webpack_require__(/*! ../definitions */ "./node_modules/@babel/types/lib/definitions/index.js");

function isNode(node) {
  return !!(node && _definitions.VISITOR_KEYS[node.type]);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/isNodesEquivalent.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isNodesEquivalent.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isNodesEquivalent;

var _definitions = __webpack_require__(/*! ../definitions */ "./node_modules/@babel/types/lib/definitions/index.js");

function isNodesEquivalent(a, b) {
  if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
    return a === b;
  }

  if (a.type !== b.type) {
    return false;
  }

  const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);
  const visitorKeys = _definitions.VISITOR_KEYS[a.type];

  for (const field of fields) {
    if (typeof a[field] !== typeof b[field]) {
      return false;
    }

    if (a[field] == null && b[field] == null) {
      continue;
    } else if (a[field] == null || b[field] == null) {
      return false;
    }

    if (Array.isArray(a[field])) {
      if (!Array.isArray(b[field])) {
        return false;
      }

      if (a[field].length !== b[field].length) {
        return false;
      }

      for (let i = 0; i < a[field].length; i++) {
        if (!isNodesEquivalent(a[field][i], b[field][i])) {
          return false;
        }
      }

      continue;
    }

    if (typeof a[field] === "object" && !(visitorKeys == null ? void 0 : visitorKeys.includes(field))) {
      for (const key of Object.keys(a[field])) {
        if (a[field][key] !== b[field][key]) {
          return false;
        }
      }

      continue;
    }

    if (!isNodesEquivalent(a[field], b[field])) {
      return false;
    }
  }

  return true;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/isPlaceholderType.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isPlaceholderType.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isPlaceholderType;

var _definitions = __webpack_require__(/*! ../definitions */ "./node_modules/@babel/types/lib/definitions/index.js");

function isPlaceholderType(placeholderType, targetType) {
  if (placeholderType === targetType) return true;
  const aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];

  if (aliases) {
    for (const alias of aliases) {
      if (targetType === alias) return true;
    }
  }

  return false;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/isReferenced.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isReferenced.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isReferenced;

function isReferenced(node, parent, grandparent) {
  switch (parent.type) {
    case "MemberExpression":
    case "JSXMemberExpression":
    case "OptionalMemberExpression":
      if (parent.property === node) {
        return !!parent.computed;
      }

      return parent.object === node;

    case "VariableDeclarator":
      return parent.init === node;

    case "ArrowFunctionExpression":
      return parent.body === node;

    case "ExportSpecifier":
      if (parent.source) {
        return false;
      }

      return parent.local === node;

    case "PrivateName":
      return false;

    case "ClassMethod":
    case "ClassPrivateMethod":
    case "ObjectMethod":
      if (parent.params.includes(node)) {
        return false;
      }

    case "ObjectProperty":
    case "ClassProperty":
    case "ClassPrivateProperty":
      if (parent.key === node) {
        return !!parent.computed;
      }

      if (parent.value === node) {
        return !grandparent || grandparent.type !== "ObjectPattern";
      }

      return true;

    case "ClassDeclaration":
    case "ClassExpression":
      return parent.superClass === node;

    case "AssignmentExpression":
      return parent.right === node;

    case "AssignmentPattern":
      return parent.right === node;

    case "LabeledStatement":
      return false;

    case "CatchClause":
      return false;

    case "RestElement":
      return false;

    case "BreakStatement":
    case "ContinueStatement":
      return false;

    case "FunctionDeclaration":
    case "FunctionExpression":
      return false;

    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return false;

    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
      return false;

    case "JSXAttribute":
      return false;

    case "ObjectPattern":
    case "ArrayPattern":
      return false;

    case "MetaProperty":
      return false;

    case "ObjectTypeProperty":
      return parent.key !== node;

    case "TSEnumMember":
      return parent.id !== node;

    case "TSPropertySignature":
      if (parent.key === node) {
        return !!parent.computed;
      }

      return true;
  }

  return true;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/isScope.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isScope.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isScope;

var _generated = __webpack_require__(/*! ./generated */ "./node_modules/@babel/types/lib/validators/generated/index.js");

function isScope(node, parent) {
  if ((0, _generated.isBlockStatement)(node) && (0, _generated.isFunction)(parent, {
    body: node
  })) {
    return false;
  }

  if ((0, _generated.isBlockStatement)(node) && (0, _generated.isCatchClause)(parent, {
    body: node
  })) {
    return false;
  }

  if ((0, _generated.isPattern)(node) && (0, _generated.isFunction)(parent)) {
    return true;
  }

  return (0, _generated.isScopable)(node);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/isSpecifierDefault.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isSpecifierDefault.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isSpecifierDefault;

var _generated = __webpack_require__(/*! ./generated */ "./node_modules/@babel/types/lib/validators/generated/index.js");

function isSpecifierDefault(specifier) {
  return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {
    name: "default"
  });
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/isType.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isType.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isType;

var _definitions = __webpack_require__(/*! ../definitions */ "./node_modules/@babel/types/lib/definitions/index.js");

function isType(nodeType, targetType) {
  if (nodeType === targetType) return true;
  if (_definitions.ALIAS_KEYS[targetType]) return false;
  const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];

  if (aliases) {
    if (aliases[0] === nodeType) return true;

    for (const alias of aliases) {
      if (nodeType === alias) return true;
    }
  }

  return false;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/isValidES3Identifier.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isValidES3Identifier.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isValidES3Identifier;

var _isValidIdentifier = _interopRequireDefault(__webpack_require__(/*! ./isValidIdentifier */ "./node_modules/@babel/types/lib/validators/isValidIdentifier.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);

function isValidES3Identifier(name) {
  return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/isValidIdentifier.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isValidIdentifier.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isValidIdentifier;

var _helperValidatorIdentifier = __webpack_require__(/*! @babel/helper-validator-identifier */ "./node_modules/@babel/helper-validator-identifier/lib/index.js");

function isValidIdentifier(name, reserved = true) {
  if (typeof name !== "string") return false;

  if (reserved) {
    if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name)) {
      return false;
    } else if (name === "await") {
      return false;
    }
  }

  return (0, _helperValidatorIdentifier.isIdentifierName)(name);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/isVar.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/isVar.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isVar;

var _generated = __webpack_require__(/*! ./generated */ "./node_modules/@babel/types/lib/validators/generated/index.js");

var _constants = __webpack_require__(/*! ../constants */ "./node_modules/@babel/types/lib/constants/index.js");

function isVar(node) {
  return (0, _generated.isVariableDeclaration)(node, {
    kind: "var"
  }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/matchesPattern.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/matchesPattern.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = matchesPattern;

var _generated = __webpack_require__(/*! ./generated */ "./node_modules/@babel/types/lib/validators/generated/index.js");

function matchesPattern(member, match, allowPartial) {
  if (!(0, _generated.isMemberExpression)(member)) return false;
  const parts = Array.isArray(match) ? match : match.split(".");
  const nodes = [];
  let node;

  for (node = member; (0, _generated.isMemberExpression)(node); node = node.object) {
    nodes.push(node.property);
  }

  nodes.push(node);
  if (nodes.length < parts.length) return false;
  if (!allowPartial && nodes.length > parts.length) return false;

  for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
    const node = nodes[j];
    let value;

    if ((0, _generated.isIdentifier)(node)) {
      value = node.name;
    } else if ((0, _generated.isStringLiteral)(node)) {
      value = node.value;
    } else {
      return false;
    }

    if (parts[i] !== value) return false;
  }

  return true;
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/react/isCompatTag.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/react/isCompatTag.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isCompatTag;

function isCompatTag(tagName) {
  return !!tagName && /^[a-z]/.test(tagName);
}

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/react/isReactComponent.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/react/isReactComponent.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _buildMatchMemberExpression = _interopRequireDefault(__webpack_require__(/*! ../buildMatchMemberExpression */ "./node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
var _default = isReactComponent;
exports.default = _default;

/***/ }),

/***/ "./node_modules/@babel/types/lib/validators/validate.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/types/lib/validators/validate.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validate;
exports.validateField = validateField;
exports.validateChild = validateChild;

var _definitions = __webpack_require__(/*! ../definitions */ "./node_modules/@babel/types/lib/definitions/index.js");

function validate(node, key, val) {
  if (!node) return;
  const fields = _definitions.NODE_FIELDS[node.type];
  if (!fields) return;
  const field = fields[key];
  validateField(node, key, val, field);
  validateChild(node, key, val);
}

function validateField(node, key, val, field) {
  if (!(field == null ? void 0 : field.validate)) return;
  if (field.optional && val == null) return;
  field.validate(node, key, val);
}

function validateChild(node, key, val) {
  if (val == null) return;
  const validate = _definitions.NODE_PARENT_VALIDATIONS[val.type];
  if (!validate) return;
  validate(node, key, val);
}

/***/ }),

/***/ "./node_modules/@babel/types/node_modules/to-fast-properties/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/types/node_modules/to-fast-properties/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


let fastProto = null;

// Creates an object with permanently fast properties in V8. See Toon Verwaest's
// post https://medium.com/@tverwaes/setting-up-prototypes-in-v8-ec9c9491dfe2#5f62
// for more details. Use %HasFastProperties(object) and the Node.js flag
// --allow-natives-syntax to check whether an object has fast properties.
function FastObject(o) {
	// A prototype object will have "fast properties" enabled once it is checked
	// against the inline property cache of a function, e.g. fastProto.property:
	// https://github.com/v8/v8/blob/6.0.122/test/mjsunit/fast-prototype.js#L48-L63
	if (fastProto !== null && typeof fastProto.property) {
		const result = fastProto;
		fastProto = FastObject.prototype = null;
		return result;
	}
	fastProto = FastObject.prototype = o == null ? Object.create(null) : o;
	return new FastObject;
}

// Initialize the inline property cache of FastObject
FastObject();

module.exports = function toFastproperties(o) {
	return FastObject(o);
};


/***/ }),

/***/ "./node_modules/babel-walk/lib/explode.js":
/*!************************************************!*\
  !*** ./node_modules/babel-walk/lib/explode.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const t = __importStar(__webpack_require__(/*! @babel/types */ "./node_modules/@babel/types/lib/index.js"));
if (!(Array.isArray(t.TYPES) &&
    t.TYPES.every((t) => typeof t === 'string'))) {
    throw new Error('@babel/types TYPES does not match the expected type.');
}
const FLIPPED_ALIAS_KEYS = t
    .FLIPPED_ALIAS_KEYS;
const TYPES = new Set(t.TYPES);
if (!(FLIPPED_ALIAS_KEYS &&
    // tslint:disable-next-line: strict-type-predicates
    typeof FLIPPED_ALIAS_KEYS === 'object' &&
    Object.keys(FLIPPED_ALIAS_KEYS).every((key) => Array.isArray(FLIPPED_ALIAS_KEYS[key]) &&
        // tslint:disable-next-line: strict-type-predicates
        FLIPPED_ALIAS_KEYS[key].every((v) => typeof v === 'string')))) {
    throw new Error('@babel/types FLIPPED_ALIAS_KEYS does not match the expected type.');
}
/**
 * This serves thre functions:
 *
 * 1. Take any "aliases" and explode them to refecence the concrete types
 * 2. Normalize all handlers to have an `{enter, exit}` pair, rather than raw functions
 * 3. make the enter and exit handlers arrays, so that multiple handlers can be merged
 */
function explode(input) {
    const results = {};
    for (const key in input) {
        const aliases = FLIPPED_ALIAS_KEYS[key];
        if (aliases) {
            for (const concreteKey of aliases) {
                if (concreteKey in results) {
                    if (typeof input[key] === 'function') {
                        results[concreteKey].enter.push(input[key]);
                    }
                    else {
                        if (input[key].enter)
                            results[concreteKey].enter.push(input[key].enter);
                        if (input[key].exit)
                            results[concreteKey].exit.push(input[key].exit);
                    }
                }
                else {
                    if (typeof input[key] === 'function') {
                        results[concreteKey] = {
                            enter: [input[key]],
                            exit: [],
                        };
                    }
                    else {
                        results[concreteKey] = {
                            enter: input[key].enter ? [input[key].enter] : [],
                            exit: input[key].exit ? [input[key].exit] : [],
                        };
                    }
                }
            }
        }
        else if (TYPES.has(key)) {
            if (key in results) {
                if (typeof input[key] === 'function') {
                    results[key].enter.push(input[key]);
                }
                else {
                    if (input[key].enter)
                        results[key].enter.push(input[key].enter);
                    if (input[key].exit)
                        results[key].exit.push(input[key].exit);
                }
            }
            else {
                if (typeof input[key] === 'function') {
                    results[key] = {
                        enter: [input[key]],
                        exit: [],
                    };
                }
                else {
                    results[key] = {
                        enter: input[key].enter ? [input[key].enter] : [],
                        exit: input[key].exit ? [input[key].exit] : [],
                    };
                }
            }
        }
    }
    return results;
}
exports.default = explode;
//# sourceMappingURL=explode.js.map

/***/ }),

/***/ "./node_modules/babel-walk/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/babel-walk/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/*! exports used: simple */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.recursive = exports.ancestor = exports.simple = void 0;
const t = __importStar(__webpack_require__(/*! @babel/types */ "./node_modules/@babel/types/lib/index.js"));
const explode_1 = __importDefault(__webpack_require__(/*! ./explode */ "./node_modules/babel-walk/lib/explode.js"));
const VISITOR_KEYS = t.VISITOR_KEYS;
if (!(VISITOR_KEYS &&
    // tslint:disable-next-line: strict-type-predicates
    typeof VISITOR_KEYS === 'object' &&
    Object.keys(VISITOR_KEYS).every((key) => Array.isArray(VISITOR_KEYS[key]) &&
        // tslint:disable-next-line: strict-type-predicates
        VISITOR_KEYS[key].every((v) => typeof v === 'string')))) {
    throw new Error('@babel/types VISITOR_KEYS does not match the expected type.');
}
function simple(visitors) {
    const vis = explode_1.default(visitors);
    return (node, state) => {
        (function recurse(node) {
            if (!node)
                return;
            const visitor = vis[node.type];
            if (visitor === null || visitor === void 0 ? void 0 : visitor.enter) {
                for (const v of visitor.enter) {
                    v(node, state);
                }
            }
            for (const key of VISITOR_KEYS[node.type] || []) {
                const subNode = node[key];
                if (Array.isArray(subNode)) {
                    for (const subSubNode of subNode) {
                        recurse(subSubNode);
                    }
                }
                else {
                    recurse(subNode);
                }
            }
            if (visitor === null || visitor === void 0 ? void 0 : visitor.exit) {
                for (const v of visitor.exit) {
                    v(node, state);
                }
            }
        })(node);
    };
}
exports.simple = simple;
function ancestor(visitors) {
    const vis = explode_1.default(visitors);
    return (node, state) => {
        const ancestors = [];
        (function recurse(node) {
            if (!node)
                return;
            const visitor = vis[node.type];
            const isNew = node !== ancestors[ancestors.length - 1];
            if (isNew)
                ancestors.push(node);
            if (visitor === null || visitor === void 0 ? void 0 : visitor.enter) {
                for (const v of visitor.enter) {
                    v(node, state, ancestors);
                }
            }
            for (const key of VISITOR_KEYS[node.type] || []) {
                const subNode = node[key];
                if (Array.isArray(subNode)) {
                    for (const subSubNode of subNode) {
                        recurse(subSubNode);
                    }
                }
                else {
                    recurse(subNode);
                }
            }
            if (visitor === null || visitor === void 0 ? void 0 : visitor.exit) {
                for (const v of visitor.exit) {
                    v(node, state, ancestors);
                }
            }
            if (isNew)
                ancestors.pop();
        })(node);
    };
}
exports.ancestor = ancestor;
function recursive(visitors) {
    const vis = explode_1.default(visitors);
    return (node, state) => {
        (function recurse(node) {
            if (!node)
                return;
            const visitor = vis[node.type];
            if (visitor === null || visitor === void 0 ? void 0 : visitor.enter) {
                for (const v of visitor.enter) {
                    v(node, state, recurse);
                }
            }
            else {
                for (const key of VISITOR_KEYS[node.type] || []) {
                    const subNode = node[key];
                    if (Array.isArray(subNode)) {
                        for (const subSubNode of subNode) {
                            recurse(subSubNode);
                        }
                    }
                    else {
                        recurse(subNode);
                    }
                }
            }
        })(node);
    };
}
exports.recursive = recursive;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/lodash/_DataView.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_DataView.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ "./node_modules/lodash/_Hash.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_Hash.js ***!
  \**************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(/*! ./_hashClear */ "./node_modules/lodash/_hashClear.js"),
    hashDelete = __webpack_require__(/*! ./_hashDelete */ "./node_modules/lodash/_hashDelete.js"),
    hashGet = __webpack_require__(/*! ./_hashGet */ "./node_modules/lodash/_hashGet.js"),
    hashHas = __webpack_require__(/*! ./_hashHas */ "./node_modules/lodash/_hashHas.js"),
    hashSet = __webpack_require__(/*! ./_hashSet */ "./node_modules/lodash/_hashSet.js");

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ "./node_modules/lodash/_ListCache.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_ListCache.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ "./node_modules/lodash/_listCacheClear.js"),
    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ "./node_modules/lodash/_listCacheDelete.js"),
    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ "./node_modules/lodash/_listCacheGet.js"),
    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ "./node_modules/lodash/_listCacheHas.js"),
    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ "./node_modules/lodash/_listCacheSet.js");

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ "./node_modules/lodash/_Map.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Map.js ***!
  \*************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ "./node_modules/lodash/_MapCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_MapCache.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ "./node_modules/lodash/_mapCacheClear.js"),
    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ "./node_modules/lodash/_mapCacheDelete.js"),
    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ "./node_modules/lodash/_mapCacheGet.js"),
    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ "./node_modules/lodash/_mapCacheHas.js"),
    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ "./node_modules/lodash/_mapCacheSet.js");

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ "./node_modules/lodash/_Promise.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_Promise.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ "./node_modules/lodash/_Set.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Set.js ***!
  \*************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ "./node_modules/lodash/_Stack.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_Stack.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    stackClear = __webpack_require__(/*! ./_stackClear */ "./node_modules/lodash/_stackClear.js"),
    stackDelete = __webpack_require__(/*! ./_stackDelete */ "./node_modules/lodash/_stackDelete.js"),
    stackGet = __webpack_require__(/*! ./_stackGet */ "./node_modules/lodash/_stackGet.js"),
    stackHas = __webpack_require__(/*! ./_stackHas */ "./node_modules/lodash/_stackHas.js"),
    stackSet = __webpack_require__(/*! ./_stackSet */ "./node_modules/lodash/_stackSet.js");

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "./node_modules/lodash/_Uint8Array.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_Uint8Array.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ "./node_modules/lodash/_WeakMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_WeakMap.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ "./node_modules/lodash/_arrayEach.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayEach.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),

/***/ "./node_modules/lodash/_arrayFilter.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayFilter.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ "./node_modules/lodash/_arrayLikeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ "./node_modules/lodash/_arrayPush.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayPush.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ "./node_modules/lodash/_assignValue.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_assignValue.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),

/***/ "./node_modules/lodash/_assocIndexOf.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_assocIndexOf.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_baseAssign.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseAssign.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseAssignIn.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignValue.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseAssignValue.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js");

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),

/***/ "./node_modules/lodash/_baseClone.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseClone.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssign = __webpack_require__(/*! ./_baseAssign */ "./node_modules/lodash/_baseAssign.js"),
    baseAssignIn = __webpack_require__(/*! ./_baseAssignIn */ "./node_modules/lodash/_baseAssignIn.js"),
    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ "./node_modules/lodash/_cloneBuffer.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "./node_modules/lodash/_copyArray.js"),
    copySymbols = __webpack_require__(/*! ./_copySymbols */ "./node_modules/lodash/_copySymbols.js"),
    copySymbolsIn = __webpack_require__(/*! ./_copySymbolsIn */ "./node_modules/lodash/_copySymbolsIn.js"),
    getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js"),
    getAllKeysIn = __webpack_require__(/*! ./_getAllKeysIn */ "./node_modules/lodash/_getAllKeysIn.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    initCloneArray = __webpack_require__(/*! ./_initCloneArray */ "./node_modules/lodash/_initCloneArray.js"),
    initCloneByTag = __webpack_require__(/*! ./_initCloneByTag */ "./node_modules/lodash/_initCloneByTag.js"),
    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ "./node_modules/lodash/_initCloneObject.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isMap = __webpack_require__(/*! ./isMap */ "./node_modules/lodash/isMap.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSet = __webpack_require__(/*! ./isSet */ "./node_modules/lodash/isSet.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),

/***/ "./node_modules/lodash/_baseCreate.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseCreate.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),

/***/ "./node_modules/lodash/_baseGetAllKeys.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_baseGetAllKeys.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "./node_modules/lodash/_baseIsArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ "./node_modules/lodash/_baseIsMap.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsMap.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),

/***/ "./node_modules/lodash/_baseIsNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIsNative.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "./node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ "./node_modules/lodash/_baseIsRegExp.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIsRegExp.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var regexpTag = '[object RegExp]';

/**
 * The base implementation of `_.isRegExp` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 */
function baseIsRegExp(value) {
  return isObjectLike(value) && baseGetTag(value) == regexpTag;
}

module.exports = baseIsRegExp;


/***/ }),

/***/ "./node_modules/lodash/_baseIsSet.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsSet.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_baseKeys.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseKeysIn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseKeysIn.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeysIn = __webpack_require__(/*! ./_nativeKeysIn */ "./node_modules/lodash/_nativeKeysIn.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_baseTimes.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ "./node_modules/lodash/_cloneArrayBuffer.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_cloneArrayBuffer.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js");

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),

/***/ "./node_modules/lodash/_cloneBuffer.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneBuffer.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/_cloneDataView.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_cloneDataView.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),

/***/ "./node_modules/lodash/_cloneRegExp.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneRegExp.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),

/***/ "./node_modules/lodash/_cloneSymbol.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneSymbol.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),

/***/ "./node_modules/lodash/_cloneTypedArray.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_cloneTypedArray.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_copyArray.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_copyArray.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),

/***/ "./node_modules/lodash/_copyObject.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_copyObject.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js");

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),

/***/ "./node_modules/lodash/_copySymbols.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_copySymbols.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js");

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),

/***/ "./node_modules/lodash/_copySymbolsIn.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_copySymbolsIn.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js");

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),

/***/ "./node_modules/lodash/_coreJsData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_coreJsData.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ "./node_modules/lodash/_defineProperty.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_defineProperty.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lodash/_getAllKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getAllKeys.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_getAllKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getAllKeysIn.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_getMapData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getMapData.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(/*! ./_isKeyable */ "./node_modules/lodash/_isKeyable.js");

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ "./node_modules/lodash/_getNative.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "./node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "./node_modules/lodash/_getValue.js");

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ "./node_modules/lodash/_getPrototype.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getPrototype.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "./node_modules/lodash/_getSymbols.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getSymbols.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ "./node_modules/lodash/_getSymbolsIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getSymbolsIn.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),

/***/ "./node_modules/lodash/_getTag.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_getTag.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(/*! ./_DataView */ "./node_modules/lodash/_DataView.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    Promise = __webpack_require__(/*! ./_Promise */ "./node_modules/lodash/_Promise.js"),
    Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    WeakMap = __webpack_require__(/*! ./_WeakMap */ "./node_modules/lodash/_WeakMap.js"),
    baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ "./node_modules/lodash/_getValue.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_getValue.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ "./node_modules/lodash/_hashClear.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_hashClear.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ "./node_modules/lodash/_hashDelete.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hashDelete.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ "./node_modules/lodash/_hashGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashGet.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ "./node_modules/lodash/_hashHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashHas.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ "./node_modules/lodash/_hashSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashSet.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ "./node_modules/lodash/_initCloneArray.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneArray.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),

/***/ "./node_modules/lodash/_initCloneByTag.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneByTag.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js"),
    cloneDataView = __webpack_require__(/*! ./_cloneDataView */ "./node_modules/lodash/_cloneDataView.js"),
    cloneRegExp = __webpack_require__(/*! ./_cloneRegExp */ "./node_modules/lodash/_cloneRegExp.js"),
    cloneSymbol = __webpack_require__(/*! ./_cloneSymbol */ "./node_modules/lodash/_cloneSymbol.js"),
    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ "./node_modules/lodash/_cloneTypedArray.js");

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),

/***/ "./node_modules/lodash/_initCloneObject.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_initCloneObject.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(/*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js");

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),

/***/ "./node_modules/lodash/_isIndex.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ "./node_modules/lodash/_isKeyable.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_isKeyable.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ "./node_modules/lodash/_isMasked.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_isMasked.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(/*! ./_coreJsData */ "./node_modules/lodash/_coreJsData.js");

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ "./node_modules/lodash/_listCacheClear.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_listCacheClear.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_listCacheDelete.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_listCacheDelete.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_listCacheGet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheGet.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_listCacheHas.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheHas.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_listCacheSet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheSet.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheClear.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_mapCacheClear.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(/*! ./_Hash */ "./node_modules/lodash/_Hash.js"),
    ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js");

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheDelete.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_mapCacheDelete.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheGet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheGet.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheHas.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheSet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheSet.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_nativeCreate.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeCreate.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_nativeKeys.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeKeysIn.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "./node_modules/lodash/_stackClear.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stackClear.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js");

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ "./node_modules/lodash/_stackDelete.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_stackDelete.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ "./node_modules/lodash/_stackGet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackGet.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ "./node_modules/lodash/_stackHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackHas.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ "./node_modules/lodash/_stackSet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackSet.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ "./node_modules/lodash/_toSource.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_toSource.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ "./node_modules/lodash/clone.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/clone.js ***!
  \**************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var baseClone = __webpack_require__(/*! ./_baseClone */ "./node_modules/lodash/_baseClone.js");

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;


/***/ }),

/***/ "./node_modules/lodash/eq.js":
/*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "./node_modules/lodash/stubFalse.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ "./node_modules/lodash/isMap.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isMap.js ***!
  \**************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMap = __webpack_require__(/*! ./_baseIsMap */ "./node_modules/lodash/_baseIsMap.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "./node_modules/lodash/isPlainObject.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/isPlainObject.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),

/***/ "./node_modules/lodash/isRegExp.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isRegExp.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var baseIsRegExp = __webpack_require__(/*! ./_baseIsRegExp */ "./node_modules/lodash/_baseIsRegExp.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;

/**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */
var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

module.exports = isRegExp;


/***/ }),

/***/ "./node_modules/lodash/isSet.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isSet.js ***!
  \**************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var baseIsSet = __webpack_require__(/*! ./_baseIsSet */ "./node_modules/lodash/_baseIsSet.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ "./node_modules/lodash/keys.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ "./node_modules/lodash/keysIn.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/keysIn.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeysIn = __webpack_require__(/*! ./_baseKeysIn */ "./node_modules/lodash/_baseKeysIn.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),

/***/ "./node_modules/lodash/stubArray.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubArray.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ "./node_modules/lodash/stubFalse.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL2hlbHBlci12YWxpZGF0b3ItaWRlbnRpZmllci9saWIvaWRlbnRpZmllci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL2hlbHBlci12YWxpZGF0b3ItaWRlbnRpZmllci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9oZWxwZXItdmFsaWRhdG9yLWlkZW50aWZpZXIvbGliL2tleXdvcmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9wYXJzZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2Fzc2VydHMvYXNzZXJ0Tm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9hc3NlcnRzL2dlbmVyYXRlZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9idWlsZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2J1aWxkZXJzL2Zsb3cvY3JlYXRlRmxvd1VuaW9uVHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9mbG93L2NyZWF0ZVR5cGVBbm5vdGF0aW9uQmFzZWRPblR5cGVvZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9nZW5lcmF0ZWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvYnVpbGRlcnMvcmVhY3QvYnVpbGRDaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy90eXBlc2NyaXB0L2NyZWF0ZVRTVW5pb25UeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2Nsb25lL2Nsb25lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2Nsb25lL2Nsb25lRGVlcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jbG9uZS9jbG9uZURlZXBXaXRob3V0TG9jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2Nsb25lL2Nsb25lTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jbG9uZS9jbG9uZVdpdGhvdXRMb2MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29tbWVudHMvYWRkQ29tbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb21tZW50cy9hZGRDb21tZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb21tZW50cy9pbmhlcml0SW5uZXJDb21tZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb21tZW50cy9pbmhlcml0TGVhZGluZ0NvbW1lbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbW1lbnRzL2luaGVyaXRUcmFpbGluZ0NvbW1lbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbW1lbnRzL2luaGVyaXRzQ29tbWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29tbWVudHMvcmVtb3ZlQ29tbWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29uc3RhbnRzL2dlbmVyYXRlZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb25zdGFudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29udmVydGVycy9lbnN1cmVCbG9jay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL2dhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29udmVydGVycy90b0JpbmRpbmdJZGVudGlmaWVyTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvQmxvY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29udmVydGVycy90b0NvbXB1dGVkS2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvdG9FeHByZXNzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvdG9JZGVudGlmaWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvdG9LZXlBbGlhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvU2VxdWVuY2VFeHByZXNzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvdG9TdGF0ZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29udmVydGVycy92YWx1ZVRvTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2RlZmluaXRpb25zL2VzMjAxNS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9leHBlcmltZW50YWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvZGVmaW5pdGlvbnMvZmxvdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9qc3guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvZGVmaW5pdGlvbnMvbWlzYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9wbGFjZWhvbGRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvZGVmaW5pdGlvbnMvdHlwZXNjcmlwdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9tb2RpZmljYXRpb25zL2FwcGVuZFRvTWVtYmVyRXhwcmVzc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9tb2RpZmljYXRpb25zL2Zsb3cvcmVtb3ZlVHlwZUR1cGxpY2F0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvbW9kaWZpY2F0aW9ucy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9tb2RpZmljYXRpb25zL3ByZXBlbmRUb01lbWJlckV4cHJlc3Npb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvbW9kaWZpY2F0aW9ucy9yZW1vdmVQcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL21vZGlmaWNhdGlvbnMvcmVtb3ZlUHJvcGVydGllc0RlZXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvbW9kaWZpY2F0aW9ucy90eXBlc2NyaXB0L3JlbW92ZVR5cGVEdXBsaWNhdGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3JldHJpZXZlcnMvZ2V0QmluZGluZ0lkZW50aWZpZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3JldHJpZXZlcnMvZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdHJhdmVyc2UvdHJhdmVyc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdHJhdmVyc2UvdHJhdmVyc2VGYXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3V0aWxzL2luaGVyaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdXRpbHMvcmVhY3QvY2xlYW5KU1hFbGVtZW50TGl0ZXJhbENoaWxkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3V0aWxzL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2J1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc0JpbmRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc0Jsb2NrU2NvcGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNJbW11dGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc0xldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzTm9kZXNFcXVpdmFsZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNQbGFjZWhvbGRlclR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc1JlZmVyZW5jZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc1Njb3BlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNTcGVjaWZpZXJEZWZhdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNUeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNWYWxpZEVTM0lkZW50aWZpZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc1ZhbGlkSWRlbnRpZmllci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzVmFyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvbWF0Y2hlc1BhdHRlcm4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9yZWFjdC9pc0NvbXBhdFRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL3JlYWN0L2lzUmVhY3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy92YWxpZGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL25vZGVfbW9kdWxlcy90by1mYXN0LXByb3BlcnRpZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXdhbGsvbGliL2V4cGxvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXdhbGsvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGlzdENhY2hlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19Qcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19XZWFrTWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzUmVnRXhwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1NldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUFycmF5QnVmZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lRGF0YVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVSZWdFeHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5T2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5c0luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9scy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZUFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZUJ5VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbm9kZVV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tEZWxldGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2VxLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNSZWdFeHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1NldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrREFBa0QseUJBQXlCO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQzs7Ozs7Ozs7Ozs7OztBQzVFYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsa0JBQWtCLG1CQUFPLENBQUMseUZBQWM7O0FBRXhDLGVBQWUsbUJBQU8sQ0FBQyxtRkFBVyxFOzs7Ozs7Ozs7Ozs7O0FDeERyQjs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7OztBQ3JDYTs7QUFFYiw4Q0FBOEMsY0FBYzs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsMEJBQTBCO0FBQzFCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHdCQUF3QjtBQUN4QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix1Q0FBdUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsdUNBQXVDO0FBQzFEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx3REFBd0QsUUFBUTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCLHVDQUF1QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsbUJBQW1CLHVDQUF1QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0xBQWtMO0FBQ2xMLGdHQUFnRyxNQUFNO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGLG1GQUFtRjtBQUNuRixxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxTQUFTLFFBQVEsRUFBRTtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsMkVBQTJFLHlEQUF5RCx1RUFBdUU7QUFDdlE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlGQUFpRixTQUFTLEdBQUcsV0FBVztBQUN4RztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsb0NBQW9DO0FBQ3BDLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLGdDQUFnQztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsdUJBQXVCLCtCQUErQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYLCtFQUErRSxvQ0FBb0M7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGdGQUFnRixxQ0FBcUM7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLEVBQUU7QUFDcEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFJQUFxSSxFQUFFO0FBQ3ZJOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnSkFBZ0osRUFBRTtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQsMEJBQTBCO0FBQ3hGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFELE9BQU87QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFELG9CQUFvQjtBQUN6RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxvRUFBb0UsS0FBSztBQUNoRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx3RkFBd0YsaUJBQWlCO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFlBQVk7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyRUFBMkUsWUFBWTtBQUN2Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsVUFBVTs7QUFFcEM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDZEQUE2RCwrQkFBK0I7QUFDNUY7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlEQUF5RCw2QkFBNkI7QUFDdEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDBEQUEwRCw2QkFBNkI7QUFDdkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qix1QkFBdUI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlGQUFpRixjQUFjO0FBQy9GOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2RUFBNkUseUJBQXlCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsOEJBQThCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZELGlDQUFpQztBQUM5Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLDZCQUE2QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkRBQTZELCtCQUErQjtBQUM1RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsa0ZBQWtGLG9DQUFvQztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyREFBMkQsK0JBQStCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1REFBdUQsNkJBQTZCO0FBQ3BGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUZBQW1GLHlCQUF5QjtBQUM1Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtDQUErQywwQkFBMEI7QUFDekU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQSx3RUFBd0U7QUFDeEUsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMvb1phOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEscUNBQXFDLG1CQUFPLENBQUMsa0ZBQXNCOztBQUVuRSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFELEtBQUs7QUFDMUQ7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDbEJhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsbUJBQU8sQ0FBQyw2RUFBcUI7O0FBRTlELHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0Esc0NBQXNDLEtBQUssZ0JBQWdCLHFCQUFxQiwwQkFBMEIsVUFBVTtBQUNwSDtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBLDJEQUEyRDtBQUMzRDtBQUNBOztBQUVBLHdEQUF3RDtBQUN4RDtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBLDBEQUEwRDtBQUMxRDtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHlEQUF5RDtBQUN6RDtBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBLDBEQUEwRDtBQUMxRDtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLDBEQUEwRDtBQUMxRDtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBLHlEQUF5RDtBQUN6RDtBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBLDREQUE0RDtBQUM1RDtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLHlEQUF5RDtBQUN6RDtBQUNBOztBQUVBLDhEQUE4RDtBQUM5RDtBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBLDREQUE0RDtBQUM1RDtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBLHdEQUF3RDtBQUN4RDtBQUNBOztBQUVBLHdEQUF3RDtBQUN4RDtBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBLDJEQUEyRDtBQUMzRDtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBLDJEQUEyRDtBQUMzRDtBQUNBOztBQUVBLHlEQUF5RDtBQUN6RDtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUM3NkNhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsb0NBQW9DLG1CQUFPLENBQUMsb0RBQWM7O0FBRTFELG1CQUFtQixtQkFBTyxDQUFDLDRFQUFnQjs7QUFFM0MsdUNBQXVDLG1CQUFPLENBQUMsc0ZBQXdCOztBQUV2RSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLEtBQUssd0NBQXdDLFVBQVUsZ0NBQWdDLFlBQVk7QUFDMUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQzs7Ozs7Ozs7Ozs7OztBQ3pDYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLGlGQUFjOztBQUV2QyxtREFBbUQsbUJBQU8sQ0FBQyxpSUFBK0M7O0FBRTFHLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUNyQmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBYzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDM0JhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsbUJBQU8sQ0FBQyx1RUFBWTs7QUFFMUQsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDdHNDYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLGlHQUE0Qjs7QUFFckQsMERBQTBELG1CQUFPLENBQUMsaUlBQStDOztBQUVqSCxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTs7QUFFQSxpQkFBaUIsMEJBQTBCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQzs7Ozs7Ozs7Ozs7OztBQzlCYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLGlGQUFjOztBQUV2QyxtREFBbUQsbUJBQU8sQ0FBQyw2SUFBcUQ7O0FBRWhILHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7OztBQ3RCYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLHdDQUF3QyxtQkFBTyxDQUFDLHVFQUFhOztBQUU3RCxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUNiYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLHdDQUF3QyxtQkFBTyxDQUFDLHVFQUFhOztBQUU3RCxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUNiYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLHdDQUF3QyxtQkFBTyxDQUFDLHVFQUFhOztBQUU3RCxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUNiYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFnQjs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsMkNBQTJDLEtBQUs7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7OztBQ3BHYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLHdDQUF3QyxtQkFBTyxDQUFDLHVFQUFhOztBQUU3RCxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUNiYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLDBDQUEwQyxtQkFBTyxDQUFDLDhFQUFlOztBQUVqRSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQzs7Ozs7Ozs7Ozs7OztBQ2hCYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSzs7QUFFdEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUN0QmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxzQ0FBc0MsbUJBQU8sQ0FBQywwRUFBa0I7O0FBRWhFLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7OztBQ2JhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsc0NBQXNDLG1CQUFPLENBQUMsMEVBQWtCOztBQUVoRSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUNiYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLHNDQUFzQyxtQkFBTyxDQUFDLDBFQUFrQjs7QUFFaEUsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDYmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxzREFBc0QsbUJBQU8sQ0FBQyxzR0FBMkI7O0FBRXpGLHFEQUFxRCxtQkFBTyxDQUFDLG9HQUEwQjs7QUFFdkYsbURBQW1ELG1CQUFPLENBQUMsZ0dBQXdCOztBQUVuRixzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUNwQmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBYzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUNmYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLG1CQUFtQixtQkFBTyxDQUFDLCtFQUFtQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDOzs7Ozs7Ozs7Ozs7O0FDbEdhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Qzs7Ozs7Ozs7Ozs7OztBQ2hEYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLHNDQUFzQyxtQkFBTyxDQUFDLHdFQUFXOztBQUV6RCxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUNiYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLG9EQUFvRCxtQkFBTyxDQUFDLGdIQUFxQzs7QUFFakcsaUJBQWlCLG1CQUFPLENBQUMsOEZBQXlCOztBQUVsRCxrQkFBa0IsbUJBQU8sQ0FBQywwRkFBdUI7O0FBRWpELHdDQUF3QyxtQkFBTyxDQUFDLDhFQUFvQjs7QUFFcEUsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUM1RWE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSwyQ0FBMkMsbUJBQU8sQ0FBQyxrRkFBZ0I7O0FBRW5FLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUNmYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLDhGQUF5Qjs7QUFFbEQsa0JBQWtCLG1CQUFPLENBQUMsMEZBQXVCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUNqQ2E7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyw4RkFBeUI7O0FBRWxELGtCQUFrQixtQkFBTyxDQUFDLDBGQUF1Qjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7OztBQ2RhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsOEZBQXlCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0M7O0FBRUE7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDN0JhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsZ0RBQWdELG1CQUFPLENBQUMsd0dBQWlDOztBQUV6RixzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGVBQWUsS0FBSztBQUNwQjs7QUFFQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUN4QmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyw4RkFBeUI7O0FBRWxELHdDQUF3QyxtQkFBTyxDQUFDLDhFQUFvQjs7QUFFcEUsbURBQW1ELG1CQUFPLENBQUMsb0hBQXVDOztBQUVsRyxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0Qjs7QUFFQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFOzs7Ozs7Ozs7Ozs7O0FDL0NhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsd0RBQXdELG1CQUFPLENBQUMsNEdBQTZCOztBQUU3RixzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDdEJhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsOEZBQXlCOztBQUVsRCxrQkFBa0IsbUJBQU8sQ0FBQywwRkFBdUI7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFDQUFxQyxVQUFVO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUMzQ2E7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSw0Q0FBNEMsbUJBQU8sQ0FBQyxvRUFBc0I7O0FBRTFFLHVDQUF1QyxtQkFBTyxDQUFDLDBEQUFpQjs7QUFFaEUsZ0RBQWdELG1CQUFPLENBQUMsd0dBQWlDOztBQUV6RixpQkFBaUIsbUJBQU8sQ0FBQywwRkFBdUI7O0FBRWhELHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDdkZBLCtDQUFhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsaUNBQWlDLG1CQUFPLENBQUMsMEVBQWtCOztBQUUzRCxnREFBZ0QsbUJBQU8sQ0FBQyx3R0FBaUM7O0FBRXpGLGlDQUFpQyxtQkFBTyxDQUFDLDBHQUFvQzs7QUFFN0UsaUJBQWlCLG1CQUFPLENBQUMsd0VBQWM7O0FBRXZDLHFDQUFxQyxtQkFBTyxDQUFDLHFFQUFTOztBQUV0RCxxQ0FBcUMsZ0RBQWdELDJCQUEyQix5Q0FBeUMsY0FBYyxHQUFHLGNBQWM7O0FBRXhMLHVDQUF1Qyw2QkFBNkIsWUFBWSxFQUFFLDRFQUE0RSxTQUFTLGdCQUFnQixFQUFFLHdDQUF3QywrQkFBK0IsdUJBQXVCLEVBQUUsaUJBQWlCLHNGQUFzRix1QkFBdUIsc0RBQXNELHFGQUFxRixzQ0FBc0MsMENBQTBDLEVBQUUsT0FBTyx3QkFBd0IsRUFBRSxFQUFFLEVBQUUsc0JBQXNCLGFBQWEsd0JBQXdCLEVBQUUsZUFBZTs7QUFFcnVCLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEtBQUs7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxXQUFXO0FBQzdDO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsS0FBSztBQUNSLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUssS0FBSztBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUUsUUFBUTtBQUN6RTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHdHQUF3RyxZQUFZO0FBQ3BIO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7Ozs7Ozs7OztBQ3Q0QkQsK0NBQWE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxxQ0FBcUMsbUJBQU8sQ0FBQyxxRUFBUzs7QUFFdEQsWUFBWSxtQkFBTyxDQUFDLG1FQUFROztBQUU1QixpQ0FBaUMsbUJBQU8sQ0FBQywwRUFBa0I7O0FBRTNELHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RixxQ0FBcUMsZ0RBQWdELDJCQUEyQix5Q0FBeUMsY0FBYyxHQUFHLGNBQWM7O0FBRXhMLHVDQUF1Qyw2QkFBNkIsWUFBWSxFQUFFLDRFQUE0RSxTQUFTLGdCQUFnQixFQUFFLHdDQUF3QywrQkFBK0IsdUJBQXVCLEVBQUUsaUJBQWlCLHNGQUFzRix1QkFBdUIsc0RBQXNELHFGQUFxRixzQ0FBc0MsMENBQTBDLEVBQUUsT0FBTyx3QkFBd0IsRUFBRSxFQUFFLEVBQUUsc0JBQXNCLGFBQWEsd0JBQXdCLEVBQUUsZUFBZTs7QUFFcnVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxVQUFVLCtFQUErRSxlQUFlLGtCQUFrQixtQkFBbUI7QUFDeEw7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7Ozs7Ozs7OztBQzFmRCwrQ0FBYTs7QUFFYixxQ0FBcUMsbUJBQU8sQ0FBQyxxRUFBUzs7QUFFdEQsVUFBVSxtQkFBTyxDQUFDLHVFQUFVOztBQUU1QixZQUFZLG1CQUFPLENBQUMsbUVBQVE7O0FBRTVCLHFDQUFxQyxnREFBZ0QsMkJBQTJCLHlDQUF5QyxjQUFjLEdBQUcsY0FBYzs7QUFFeEwsdUNBQXVDLDZCQUE2QixZQUFZLEVBQUUsNEVBQTRFLFNBQVMsZ0JBQWdCLEVBQUUsd0NBQXdDLCtCQUErQix1QkFBdUIsRUFBRSxpQkFBaUIsc0ZBQXNGLHVCQUF1QixzREFBc0QscUZBQXFGLHNDQUFzQywwQ0FBMEMsRUFBRSxPQUFPLHdCQUF3QixFQUFFLEVBQUUsRUFBRSxzQkFBc0IsYUFBYSx3QkFBd0IsRUFBRSxlQUFlOztBQUVydUIsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLHNDQUFzQztBQUN0QztBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUMsRTs7Ozs7Ozs7Ozs7Ozs7QUM1UVk7O0FBRWIscUNBQXFDLG1CQUFPLENBQUMscUVBQVM7O0FBRXRELHFDQUFxQyxnREFBZ0QsMkJBQTJCLHlDQUF5QyxjQUFjLEdBQUcsY0FBYzs7QUFFeEwsdUNBQXVDLDZCQUE2QixZQUFZLEVBQUUsNEVBQTRFLFNBQVMsZ0JBQWdCLEVBQUUsd0NBQXdDLCtCQUErQix1QkFBdUIsRUFBRSxpQkFBaUIsc0ZBQXNGLHVCQUF1QixzREFBc0QscUZBQXFGLHNDQUFzQywwQ0FBMEMsRUFBRSxPQUFPLHdCQUF3QixFQUFFLEVBQUUsRUFBRSxzQkFBc0IsYUFBYSx3QkFBd0IsRUFBRSxlQUFlOztBQUVydUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7Ozs7Ozs7Ozs7QUM1Y1k7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLCtDQUErQyxtQkFBTyxDQUFDLGdHQUFvQjs7QUFFM0UsbUJBQU8sQ0FBQyxtRUFBUTs7QUFFaEIsbUJBQU8sQ0FBQyx1RUFBVTs7QUFFbEIsbUJBQU8sQ0FBQyxtRUFBUTs7QUFFaEIsbUJBQU8sQ0FBQyxpRUFBTzs7QUFFZixtQkFBTyxDQUFDLG1FQUFROztBQUVoQixtQkFBTyxDQUFDLG1GQUFnQjs7QUFFeEIsbUJBQU8sQ0FBQywrRUFBYzs7QUFFdEIsYUFBYSxtQkFBTyxDQUFDLHFFQUFTOztBQUU5QixvQkFBb0IsbUJBQU8sQ0FBQyxtRkFBZ0I7O0FBRTVDLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQjs7Ozs7Ozs7Ozs7OztBQ2xHYTs7QUFFYixxQ0FBcUMsbUJBQU8sQ0FBQyxxRUFBUzs7QUFFdEQscUNBQXFDLGdEQUFnRCwyQkFBMkIseUNBQXlDLGNBQWMsR0FBRyxjQUFjOztBQUV4TCx1Q0FBdUMsNkJBQTZCLFlBQVksRUFBRSw0RUFBNEUsU0FBUyxnQkFBZ0IsRUFBRSx3Q0FBd0MsK0JBQStCLHVCQUF1QixFQUFFLGlCQUFpQixzRkFBc0YsdUJBQXVCLHNEQUFzRCxxRkFBcUYsc0NBQXNDLDBDQUEwQyxFQUFFLE9BQU8sd0JBQXdCLEVBQUUsRUFBRSxFQUFFLHNCQUFzQixhQUFhLHdCQUF3QixFQUFFLGVBQWU7O0FBRXJ1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUMsRTs7Ozs7Ozs7Ozs7OztBQ3BLWTs7QUFFYixxQ0FBcUMsbUJBQU8sQ0FBQyxxRUFBUzs7QUFFdEQsb0JBQW9CLG1CQUFPLENBQUMsbUZBQWdCOztBQUU1QyxxQ0FBcUMsZ0RBQWdELDJCQUEyQix5Q0FBeUMsY0FBYyxHQUFHLGNBQWM7O0FBRXhMLHVDQUF1Qyw2QkFBNkIsWUFBWSxFQUFFLDRFQUE0RSxTQUFTLGdCQUFnQixFQUFFLHdDQUF3QywrQkFBK0IsdUJBQXVCLEVBQUUsaUJBQWlCLHNGQUFzRix1QkFBdUIsc0RBQXNELHFGQUFxRixzQ0FBc0MsMENBQTBDLEVBQUUsT0FBTyx3QkFBd0IsRUFBRSxFQUFFLEVBQUUsc0JBQXNCLGFBQWEsd0JBQXdCLEVBQUUsZUFBZTs7QUFFcnVCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7Ozs7Ozs7O0FDaENZOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHFFQUFTOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCxDQUFDLEU7Ozs7Ozs7Ozs7Ozs7QUNoQ1k7O0FBRWIscUNBQXFDLG1CQUFPLENBQUMscUVBQVM7O0FBRXRELFlBQVksbUJBQU8sQ0FBQyxtRUFBUTs7QUFFNUIsVUFBVSxtQkFBTyxDQUFDLHVFQUFVOztBQUU1QixxQ0FBcUMsZ0RBQWdELDJCQUEyQix5Q0FBeUMsY0FBYyxHQUFHLGNBQWM7O0FBRXhMLHVDQUF1Qyw2QkFBNkIsWUFBWSxFQUFFLDRFQUE0RSxTQUFTLGdCQUFnQixFQUFFLHdDQUF3QywrQkFBK0IsdUJBQXVCLEVBQUUsaUJBQWlCLHNGQUFzRix1QkFBdUIsc0RBQXNELHFGQUFxRixzQ0FBc0MsMENBQTBDLEVBQUUsT0FBTyx3QkFBd0IsRUFBRSxFQUFFLEVBQUUsc0JBQXNCLGFBQWEsd0JBQXdCLEVBQUUsZUFBZTs7QUFFcnVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsQ0FBQztBQUNEO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRTs7Ozs7Ozs7Ozs7OztBQ2hhRCwrQ0FBYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsbUJBQU8sQ0FBQywwRUFBa0I7O0FBRTNELGdCQUFnQixtQkFBTyxDQUFDLHNGQUF3Qjs7QUFFaEQsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGdCQUFnQjtBQUNuQyx3QkFBd0IsSUFBSSxHQUFHLEVBQUU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLElBQUksK0JBQStCLHVCQUF1QixXQUFXLG9CQUFvQjtBQUMvSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxJQUFJLE1BQU0sVUFBVSxpQ0FBaUMsc0JBQXNCLG1CQUFtQixnREFBZ0Q7QUFDbEw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLElBQUksTUFBTSxVQUFVLGlDQUFpQyxzQkFBc0IsbUJBQW1CLGdEQUFnRDtBQUNsTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLElBQUksb0JBQW9CLEtBQUssV0FBVyxhQUFhO0FBQzNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLElBQUksTUFBTSxVQUFVLG9DQUFvQyxrQkFBa0I7QUFDaEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLFVBQVUsb0dBQW9HLHNEQUFzRDtBQUM1TTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsRUFBRSxPQUFPLEtBQUs7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLEVBQUUsT0FBTyxLQUFLLEdBQUcsSUFBSTtBQUNuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCOzs7Ozs7Ozs7Ozs7OztBQzFUYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsK0NBQStDLG1CQUFPLENBQUMsaUhBQXFDOztBQUU1RiwwQ0FBMEMsbUJBQU8sQ0FBQyx1R0FBZ0M7O0FBRWxGLDRDQUE0QyxtQkFBTyxDQUFDLHVHQUFnQzs7QUFFcEYseUNBQXlDLG1CQUFPLENBQUMsbUZBQXNCOztBQUV2RSxpQkFBaUIsbUJBQU8sQ0FBQyx1RkFBcUI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCxnRUFBZ0UsbUJBQU8sQ0FBQyw2SUFBbUQ7O0FBRTNILGtEQUFrRCxtQkFBTyxDQUFDLGlIQUFxQzs7QUFFL0YsZ0RBQWdELG1CQUFPLENBQUMseUhBQXlDOztBQUVqRyxrQkFBa0IsbUJBQU8sQ0FBQyx5RkFBc0I7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCx3Q0FBd0MsbUJBQU8sQ0FBQyw2RUFBbUI7O0FBRW5FLG9DQUFvQyxtQkFBTyxDQUFDLHFFQUFlOztBQUUzRCx3Q0FBd0MsbUJBQU8sQ0FBQyw2RUFBbUI7O0FBRW5FLGtEQUFrRCxtQkFBTyxDQUFDLGlHQUE2Qjs7QUFFdkYsOENBQThDLG1CQUFPLENBQUMseUZBQXlCOztBQUUvRSx5Q0FBeUMsbUJBQU8sQ0FBQyxxRkFBdUI7O0FBRXhFLDBDQUEwQyxtQkFBTyxDQUFDLHVGQUF3Qjs7QUFFMUUsbURBQW1ELG1CQUFPLENBQUMseUdBQWlDOztBQUU1RixxREFBcUQsbUJBQU8sQ0FBQyw2R0FBbUM7O0FBRWhHLCtDQUErQyxtQkFBTyxDQUFDLGlHQUE2Qjs7QUFFcEYsc0RBQXNELG1CQUFPLENBQUMsK0dBQW9DOztBQUVsRyw2Q0FBNkMsbUJBQU8sQ0FBQyw2RkFBMkI7O0FBRWhGLGtCQUFrQixtQkFBTyxDQUFDLDJGQUF1Qjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVELGlCQUFpQixtQkFBTyxDQUFDLHVFQUFhOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQsMENBQTBDLG1CQUFPLENBQUMsMkZBQTBCOztBQUU1RSxzREFBc0QsbUJBQU8sQ0FBQyxtSEFBc0M7O0FBRXBHLHNDQUFzQyxtQkFBTyxDQUFDLG1GQUFzQjs7QUFFcEUsNENBQTRDLG1CQUFPLENBQUMsK0ZBQTRCOztBQUVoRiwyQ0FBMkMsbUJBQU8sQ0FBQyw2RkFBMkI7O0FBRTlFLDJDQUEyQyxtQkFBTyxDQUFDLDZGQUEyQjs7QUFFOUUseUNBQXlDLG1CQUFPLENBQUMseUZBQXlCOztBQUUxRSxtREFBbUQsbUJBQU8sQ0FBQyw2R0FBbUM7O0FBRTlGLDBDQUEwQyxtQkFBTyxDQUFDLDJGQUEwQjs7QUFFNUUsMENBQTBDLG1CQUFPLENBQUMsMkZBQTBCOztBQUU1RSxtQkFBbUIsbUJBQU8sQ0FBQywyRUFBZTs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVELHVEQUF1RCxtQkFBTyxDQUFDLDJIQUEwQzs7QUFFekcsdUNBQXVDLG1CQUFPLENBQUMsMkZBQTBCOztBQUV6RSx3REFBd0QsbUJBQU8sQ0FBQyw2SEFBMkM7O0FBRTNHLCtDQUErQyxtQkFBTyxDQUFDLDJHQUFrQzs7QUFFekYsbURBQW1ELG1CQUFPLENBQUMsbUhBQXNDOztBQUVqRyxtREFBbUQsbUJBQU8sQ0FBQyw2SEFBMkM7O0FBRXRHLG9EQUFvRCxtQkFBTyxDQUFDLCtHQUFvQzs7QUFFaEcseURBQXlELG1CQUFPLENBQUMseUhBQXlDOztBQUUxRyx1Q0FBdUMsbUJBQU8sQ0FBQyxpRkFBcUI7O0FBRXBFLDJDQUEyQyxtQkFBTyxDQUFDLHlGQUF5Qjs7QUFFNUUsMkNBQTJDLG1CQUFPLENBQUMsbUZBQXNCOztBQUV6RSxpQ0FBaUMsbUJBQU8sQ0FBQyx5RUFBaUI7O0FBRTFELHdDQUF3QyxtQkFBTyxDQUFDLHVGQUF3Qjs7QUFFeEUsNENBQTRDLG1CQUFPLENBQUMsK0ZBQTRCOztBQUVoRiwwQ0FBMEMsbUJBQU8sQ0FBQywyRkFBMEI7O0FBRTVFLG9DQUFvQyxtQkFBTyxDQUFDLCtFQUFvQjs7QUFFaEUscUNBQXFDLG1CQUFPLENBQUMsaUZBQXFCOztBQUVsRSxnREFBZ0QsbUJBQU8sQ0FBQyx1R0FBZ0M7O0FBRXhGLGdEQUFnRCxtQkFBTyxDQUFDLHVHQUFnQzs7QUFFeEYsMkNBQTJDLG1CQUFPLENBQUMsNkZBQTJCOztBQUU5RSxzQ0FBc0MsbUJBQU8sQ0FBQyxtRkFBc0I7O0FBRXBFLGlEQUFpRCxtQkFBTyxDQUFDLHlHQUFpQzs7QUFFMUYscUNBQXFDLG1CQUFPLENBQUMsaUZBQXFCOztBQUVsRSxtREFBbUQsbUJBQU8sQ0FBQyw2R0FBbUM7O0FBRTlGLGdEQUFnRCxtQkFBTyxDQUFDLHVHQUFnQzs7QUFFeEYsb0NBQW9DLG1CQUFPLENBQUMsK0VBQW9COztBQUVoRSw2Q0FBNkMsbUJBQU8sQ0FBQyxpR0FBNkI7O0FBRWxGLHVDQUF1QyxtQkFBTyxDQUFDLHFGQUF1Qjs7QUFFdEUseURBQXlELG1CQUFPLENBQUMseUhBQXlDOztBQUUxRyxrQkFBa0IsbUJBQU8sQ0FBQyw2RkFBd0I7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCOzs7Ozs7Ozs7Ozs7O0FDM2xCYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLDBGQUF1Qjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUNkYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLGlHQUE0Qjs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUN6RWE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBYzs7QUFFdkMsK0NBQStDLG1CQUFPLENBQUMsa0dBQThCOztBQUVyRixzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUNoQ2E7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQywwRkFBdUI7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUNaYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLHdFQUFjOztBQUV2Qzs7QUFFQTs7QUFFQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDN0JhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsMkNBQTJDLG1CQUFPLENBQUMsMEZBQTBCOztBQUU3RSwrQ0FBK0MsbUJBQU8sQ0FBQyw2RkFBb0I7O0FBRTNFLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDaEJhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsaUdBQTRCOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDckRhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsOEZBQXlCOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7Ozs7Ozs7QUN0R2E7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxvREFBb0QsbUJBQU8sQ0FBQyxvR0FBeUI7O0FBRXJGLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7OztBQ2JhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsNEVBQWdCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDdERhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsNEVBQWdCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDM0JhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDWGE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyw2RkFBMEI7O0FBRW5EO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUM5Q2E7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDakJhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsNkNBQTZDLG1CQUFPLENBQUMsc0ZBQWtCOztBQUV2RSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7OztBQ2RhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsbUJBQU8sQ0FBQyx1RkFBMEI7O0FBRTdFLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDNS9JYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLDJDQUEyQyxtQkFBTyxDQUFDLG9GQUF1Qjs7QUFFMUUscUNBQXFDLG1CQUFPLENBQUMsc0VBQVU7O0FBRXZELGdEQUFnRCxtQkFBTyxDQUFDLDRGQUFxQjs7QUFFN0UsbUJBQW1CLG1CQUFPLENBQUMsNEVBQWdCOztBQUUzQyxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7OztBQ2xDYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLG9EQUFvRCxtQkFBTyxDQUFDLGdIQUFxQzs7QUFFakcsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDaENhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsa0ZBQWE7O0FBRXRDLG9DQUFvQyxtQkFBTyxDQUFDLG9FQUFTOztBQUVyRCxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUNmYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLHFDQUFxQyxtQkFBTyxDQUFDLHNFQUFVOztBQUV2RCxpQkFBaUIsbUJBQU8sQ0FBQyxrRkFBYTs7QUFFdEMsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUN6QmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyxrRkFBYTs7QUFFdEMsaUJBQWlCLG1CQUFPLENBQUMsd0VBQWM7O0FBRXZDO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDYmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBZ0I7O0FBRTNDO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDWGE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBZ0I7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQzs7Ozs7Ozs7Ozs7OztBQ2xFYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFnQjs7QUFFM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDcEJhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDbkhhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsa0ZBQWE7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDM0JhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsa0ZBQWE7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDOzs7Ozs7Ozs7Ozs7O0FDYmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBZ0I7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDdkJhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsZ0RBQWdELG1CQUFPLENBQUMsNEZBQXFCOztBQUU3RSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7O0FBRUE7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7QUNmYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLGlDQUFpQyxtQkFBTyxDQUFDLDBHQUFvQzs7QUFFN0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQzs7Ozs7Ozs7Ozs7OztBQ3JCYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLGtGQUFhOztBQUV0QyxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBYzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEM7Ozs7Ozs7Ozs7Ozs7QUNmYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLGtGQUFhOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQiwwQ0FBMEM7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLGtCQUFrQjtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQzs7Ozs7Ozs7Ozs7OztBQ3ZDYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDVGE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSx5REFBeUQsbUJBQU8sQ0FBQywrR0FBK0I7O0FBRWhHLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0EsMkI7Ozs7Ozs7Ozs7Ozs7QUNiYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBZ0I7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7OztBQy9CYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMxQmE7QUFDYjtBQUNBO0FBQ0Esa0NBQWtDLG9DQUFvQyxhQUFhLEVBQUUsRUFBRTtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHlDQUF5Qyw2QkFBNkI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQsdUJBQXVCLG1CQUFPLENBQUMsOERBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQzs7Ozs7Ozs7Ozs7OztBQzVHYTtBQUNiO0FBQ0E7QUFDQSxrQ0FBa0Msb0NBQW9DLGFBQWEsRUFBRSxFQUFFO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EseUNBQXlDLDZCQUE2QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsOERBQWM7QUFDN0Msa0NBQWtDLG1CQUFPLENBQUMsMkRBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7Ozs7Ozs7OztBQ3ZJQSxnQkFBZ0IsbUJBQU8sQ0FBQyx5REFBYztBQUN0QyxXQUFXLG1CQUFPLENBQUMsK0NBQVM7O0FBRTVCO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNOQSxnQkFBZ0IsbUJBQU8sQ0FBQyx5REFBYztBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQywyREFBZTtBQUN4QyxjQUFjLG1CQUFPLENBQUMscURBQVk7QUFDbEMsY0FBYyxtQkFBTyxDQUFDLHFEQUFZO0FBQ2xDLGNBQWMsbUJBQU8sQ0FBQyxxREFBWTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDL0JBLHFCQUFxQixtQkFBTyxDQUFDLG1FQUFtQjtBQUNoRCxzQkFBc0IsbUJBQU8sQ0FBQyxxRUFBb0I7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsK0RBQWlCO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLCtEQUFpQjtBQUM1QyxtQkFBbUIsbUJBQU8sQ0FBQywrREFBaUI7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQy9CQSxnQkFBZ0IsbUJBQU8sQ0FBQyx5REFBYztBQUN0QyxXQUFXLG1CQUFPLENBQUMsK0NBQVM7O0FBRTVCO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNOQSxvQkFBb0IsbUJBQU8sQ0FBQyxpRUFBa0I7QUFDOUMscUJBQXFCLG1CQUFPLENBQUMsbUVBQW1CO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLDZEQUFnQjtBQUMxQyxrQkFBa0IsbUJBQU8sQ0FBQyw2REFBZ0I7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMsNkRBQWdCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUMvQkEsZ0JBQWdCLG1CQUFPLENBQUMseURBQWM7QUFDdEMsV0FBVyxtQkFBTyxDQUFDLCtDQUFTOztBQUU1QjtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDTkEsZ0JBQWdCLG1CQUFPLENBQUMseURBQWM7QUFDdEMsV0FBVyxtQkFBTyxDQUFDLCtDQUFTOztBQUU1QjtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDTkEsZ0JBQWdCLG1CQUFPLENBQUMseURBQWM7QUFDdEMsaUJBQWlCLG1CQUFPLENBQUMsMkRBQWU7QUFDeEMsa0JBQWtCLG1CQUFPLENBQUMsNkRBQWdCO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQyx1REFBYTtBQUNwQyxlQUFlLG1CQUFPLENBQUMsdURBQWE7QUFDcEMsZUFBZSxtQkFBTyxDQUFDLHVEQUFhOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDMUJBLFdBQVcsbUJBQU8sQ0FBQywrQ0FBUzs7QUFFNUI7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ0xBLFdBQVcsbUJBQU8sQ0FBQywrQ0FBUzs7QUFFNUI7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ0xBLGdCQUFnQixtQkFBTyxDQUFDLHlEQUFjO0FBQ3RDLFdBQVcsbUJBQU8sQ0FBQywrQ0FBUzs7QUFFNUI7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUN4QkEsZ0JBQWdCLG1CQUFPLENBQUMseURBQWM7QUFDdEMsa0JBQWtCLG1CQUFPLENBQUMsMkRBQWU7QUFDekMsY0FBYyxtQkFBTyxDQUFDLG1EQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxxREFBWTtBQUNuQyxjQUFjLG1CQUFPLENBQUMscURBQVk7QUFDbEMsbUJBQW1CLG1CQUFPLENBQUMsNkRBQWdCOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDbkJBLHNCQUFzQixtQkFBTyxDQUFDLHFFQUFvQjtBQUNsRCxTQUFTLG1CQUFPLENBQUMseUNBQU07O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUMzQkEsU0FBUyxtQkFBTyxDQUFDLHlDQUFNOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNwQkEsaUJBQWlCLG1CQUFPLENBQUMsMkRBQWU7QUFDeEMsV0FBVyxtQkFBTyxDQUFDLDZDQUFROztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNoQkEsaUJBQWlCLG1CQUFPLENBQUMsMkRBQWU7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLGlEQUFVOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNoQkEscUJBQXFCLG1CQUFPLENBQUMsbUVBQW1COztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUN4QkEsWUFBWSxtQkFBTyxDQUFDLGlEQUFVO0FBQzlCLGdCQUFnQixtQkFBTyxDQUFDLHlEQUFjO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLDZEQUFnQjtBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQywyREFBZTtBQUN4QyxtQkFBbUIsbUJBQU8sQ0FBQywrREFBaUI7QUFDNUMsa0JBQWtCLG1CQUFPLENBQUMsNkRBQWdCO0FBQzFDLGdCQUFnQixtQkFBTyxDQUFDLHlEQUFjO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLDZEQUFnQjtBQUMxQyxvQkFBb0IsbUJBQU8sQ0FBQyxpRUFBa0I7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMsMkRBQWU7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMsK0RBQWlCO0FBQzVDLGFBQWEsbUJBQU8sQ0FBQyxtREFBVztBQUNoQyxxQkFBcUIsbUJBQU8sQ0FBQyxtRUFBbUI7QUFDaEQscUJBQXFCLG1CQUFPLENBQUMsbUVBQW1CO0FBQ2hELHNCQUFzQixtQkFBTyxDQUFDLHFFQUFvQjtBQUNsRCxjQUFjLG1CQUFPLENBQUMsbURBQVc7QUFDakMsZUFBZSxtQkFBTyxDQUFDLHFEQUFZO0FBQ25DLFlBQVksbUJBQU8sQ0FBQywrQ0FBUztBQUM3QixlQUFlLG1CQUFPLENBQUMscURBQVk7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLCtDQUFTO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyw2Q0FBUTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNwS0EsZUFBZSxtQkFBTyxDQUFDLHFEQUFZOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7QUM3QkEsZ0JBQWdCLG1CQUFPLENBQUMseURBQWM7QUFDdEMsY0FBYyxtQkFBTyxDQUFDLG1EQUFXOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ25CQSxhQUFhLG1CQUFPLENBQUMsbURBQVc7QUFDaEMsZ0JBQWdCLG1CQUFPLENBQUMseURBQWM7QUFDdEMscUJBQXFCLG1CQUFPLENBQUMsbUVBQW1COztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUMzQkEsaUJBQWlCLG1CQUFPLENBQUMsMkRBQWU7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMsNkRBQWdCOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDakJBLGFBQWEsbUJBQU8sQ0FBQyxtREFBVztBQUNoQyxtQkFBbUIsbUJBQU8sQ0FBQyw2REFBZ0I7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNqQkEsaUJBQWlCLG1CQUFPLENBQUMseURBQWM7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLHVEQUFhO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQyxxREFBWTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsdURBQWE7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUM5Q0EsaUJBQWlCLG1CQUFPLENBQUMsMkRBQWU7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMsNkRBQWdCOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDakJBLGFBQWEsbUJBQU8sQ0FBQyxtREFBVztBQUNoQyxtQkFBbUIsbUJBQU8sQ0FBQyw2REFBZ0I7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNqQkEsaUJBQWlCLG1CQUFPLENBQUMsMkRBQWU7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLHFEQUFZO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLDZEQUFnQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDM0RBLGtCQUFrQixtQkFBTyxDQUFDLDZEQUFnQjtBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQywyREFBZTs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQzdCQSxlQUFlLG1CQUFPLENBQUMscURBQVk7QUFDbkMsa0JBQWtCLG1CQUFPLENBQUMsNkRBQWdCO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLCtEQUFpQjs7QUFFNUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDYkEsaUJBQWlCLG1CQUFPLENBQUMsMkRBQWU7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNmQSx5REFBVyxtQkFBTyxDQUFDLCtDQUFTOztBQUU1QjtBQUNBLGtCQUFrQixLQUEwQjs7QUFFNUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUNsQ0EsdUJBQXVCLG1CQUFPLENBQUMsdUVBQXFCOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNoQkEsYUFBYSxtQkFBTyxDQUFDLG1EQUFXOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDakJBLHVCQUF1QixtQkFBTyxDQUFDLHVFQUFxQjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNuQkEsa0JBQWtCLG1CQUFPLENBQUMsNkRBQWdCO0FBQzFDLHNCQUFzQixtQkFBTyxDQUFDLHFFQUFvQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTyxXQUFXO0FBQzdCLFdBQVcsU0FBUztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ3ZDQSxpQkFBaUIsbUJBQU8sQ0FBQywyREFBZTtBQUN4QyxpQkFBaUIsbUJBQU8sQ0FBQywyREFBZTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPLFdBQVc7QUFDN0IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDZkEsaUJBQWlCLG1CQUFPLENBQUMsMkRBQWU7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMsK0RBQWlCOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU8sV0FBVztBQUM3QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNmQSxXQUFXLG1CQUFPLENBQUMsK0NBQVM7O0FBRTVCO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNMQSxnQkFBZ0IsbUJBQU8sQ0FBQyx5REFBYzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7QUNWQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7OztBQ0hBLHFCQUFxQixtQkFBTyxDQUFDLG1FQUFtQjtBQUNoRCxpQkFBaUIsbUJBQU8sQ0FBQywyREFBZTtBQUN4QyxXQUFXLG1CQUFPLENBQUMsNkNBQVE7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2ZBLHFCQUFxQixtQkFBTyxDQUFDLG1FQUFtQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQywrREFBaUI7QUFDNUMsYUFBYSxtQkFBTyxDQUFDLGlEQUFVOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2hCQSxnQkFBZ0IsbUJBQU8sQ0FBQyx5REFBYzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDakJBLG1CQUFtQixtQkFBTyxDQUFDLCtEQUFpQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsdURBQWE7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDaEJBLGNBQWMsbUJBQU8sQ0FBQyxxREFBWTs7QUFFbEM7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ0xBLGFBQWEsbUJBQU8sQ0FBQyxtREFBVzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQzdDQSxrQkFBa0IsbUJBQU8sQ0FBQyw2REFBZ0I7QUFDMUMsZ0JBQWdCLG1CQUFPLENBQUMsdURBQWE7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDN0JBLGdCQUFnQixtQkFBTyxDQUFDLHlEQUFjO0FBQ3RDLG1CQUFtQixtQkFBTyxDQUFDLCtEQUFpQjtBQUM1QyxpQkFBaUIsbUJBQU8sQ0FBQywyREFBZTtBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQyx1REFBYTs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDeEJBLGVBQWUsbUJBQU8sQ0FBQyx1REFBYTtBQUNwQyxVQUFVLG1CQUFPLENBQUMsNkNBQVE7QUFDMUIsY0FBYyxtQkFBTyxDQUFDLHFEQUFZO0FBQ2xDLFVBQVUsbUJBQU8sQ0FBQyw2Q0FBUTtBQUMxQixjQUFjLG1CQUFPLENBQUMscURBQVk7QUFDbEMsaUJBQWlCLG1CQUFPLENBQUMsMkRBQWU7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLHVEQUFhOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ1pBLG1CQUFtQixtQkFBTyxDQUFDLCtEQUFpQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2hCQSxtQkFBbUIsbUJBQU8sQ0FBQywrREFBaUI7O0FBRTVDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUM3QkEsbUJBQW1CLG1CQUFPLENBQUMsK0RBQWlCOztBQUU1QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDdEJBLG1CQUFtQixtQkFBTyxDQUFDLCtEQUFpQjs7QUFFNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUN6QkEsdUJBQXVCLG1CQUFPLENBQUMsdUVBQXFCO0FBQ3BELG9CQUFvQixtQkFBTyxDQUFDLGlFQUFrQjtBQUM5QyxrQkFBa0IsbUJBQU8sQ0FBQyw2REFBZ0I7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMsNkRBQWdCO0FBQzFDLHNCQUFzQixtQkFBTyxDQUFDLHFFQUFvQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQzVFQSxpQkFBaUIsbUJBQU8sQ0FBQywyREFBZTtBQUN4QyxtQkFBbUIsbUJBQU8sQ0FBQywrREFBaUI7QUFDNUMsa0JBQWtCLG1CQUFPLENBQUMsNkRBQWdCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDakJBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2RBLGlCQUFpQixtQkFBTyxDQUFDLDJEQUFlOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDWkEsbUJBQW1CLG1CQUFPLENBQUMsK0RBQWlCOztBQUU1QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2xDQSxtQkFBbUIsbUJBQU8sQ0FBQywrREFBaUI7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDbEJBLG1CQUFtQixtQkFBTyxDQUFDLCtEQUFpQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2ZBLG1CQUFtQixtQkFBTyxDQUFDLCtEQUFpQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsRUFBRTtBQUNiLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUN6QkEsV0FBVyxtQkFBTyxDQUFDLCtDQUFTO0FBQzVCLGdCQUFnQixtQkFBTyxDQUFDLHlEQUFjO0FBQ3RDLFVBQVUsbUJBQU8sQ0FBQyw2Q0FBUTs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDcEJBLGlCQUFpQixtQkFBTyxDQUFDLDJEQUFlOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2pCQSxpQkFBaUIsbUJBQU8sQ0FBQywyREFBZTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDZkEsaUJBQWlCLG1CQUFPLENBQUMsMkRBQWU7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNmQSxpQkFBaUIsbUJBQU8sQ0FBQywyREFBZTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsRUFBRTtBQUNiLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ3JCQSxnQkFBZ0IsbUJBQU8sQ0FBQyx5REFBYzs7QUFFdEM7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ0xBLGNBQWMsbUJBQU8sQ0FBQyxxREFBWTs7QUFFbEM7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNuQkEsK0RBQWlCLG1CQUFPLENBQUMsMkRBQWU7O0FBRXhDO0FBQ0Esa0JBQWtCLEtBQTBCOztBQUU1QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDZEEsaUJBQWlCLG1CQUFPLENBQUMsMkRBQWU7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ1JBLGdCQUFnQixtQkFBTyxDQUFDLHlEQUFjOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2JBLGdCQUFnQixtQkFBTyxDQUFDLHlEQUFjO0FBQ3RDLFVBQVUsbUJBQU8sQ0FBQyw2Q0FBUTtBQUMxQixlQUFlLG1CQUFPLENBQUMsdURBQWE7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsRUFBRTtBQUNiLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2pDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUN6QkEsZ0JBQWdCLG1CQUFPLENBQUMseURBQWM7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVMsR0FBRyxTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDcENBLHNCQUFzQixtQkFBTyxDQUFDLHFFQUFvQjtBQUNsRCxtQkFBbUIsbUJBQU8sQ0FBQyw2REFBZ0I7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0IsRUFBRTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtCQUFrQixFQUFFO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUN6QkEsaUJBQWlCLG1CQUFPLENBQUMseURBQWM7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLHFEQUFZOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2hDQSx5REFBVyxtQkFBTyxDQUFDLCtDQUFTO0FBQzVCLGdCQUFnQixtQkFBTyxDQUFDLHVEQUFhOztBQUVyQztBQUNBLGtCQUFrQixLQUEwQjs7QUFFNUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FDckNBLGlCQUFpQixtQkFBTyxDQUFDLDJEQUFlO0FBQ3hDLGVBQWUsbUJBQU8sQ0FBQyxxREFBWTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDbENBLGdCQUFnQixtQkFBTyxDQUFDLHlEQUFjO0FBQ3RDLGdCQUFnQixtQkFBTyxDQUFDLHlEQUFjO0FBQ3RDLGVBQWUsbUJBQU8sQ0FBQyx1REFBYTs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDNUJBLGlCQUFpQixtQkFBTyxDQUFDLDJEQUFlO0FBQ3hDLG1CQUFtQixtQkFBTyxDQUFDLCtEQUFpQjtBQUM1QyxtQkFBbUIsbUJBQU8sQ0FBQyw2REFBZ0I7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDN0RBLG1CQUFtQixtQkFBTyxDQUFDLCtEQUFpQjtBQUM1QyxnQkFBZ0IsbUJBQU8sQ0FBQyx5REFBYztBQUN0QyxlQUFlLG1CQUFPLENBQUMsdURBQWE7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDMUJBLGdCQUFnQixtQkFBTyxDQUFDLHlEQUFjO0FBQ3RDLGdCQUFnQixtQkFBTyxDQUFDLHlEQUFjO0FBQ3RDLGVBQWUsbUJBQU8sQ0FBQyx1REFBYTs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUMxQkEsdUJBQXVCLG1CQUFPLENBQUMsdUVBQXFCO0FBQ3BELGdCQUFnQixtQkFBTyxDQUFDLHlEQUFjO0FBQ3RDLGVBQWUsbUJBQU8sQ0FBQyx1REFBYTs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUMxQkEsb0JBQW9CLG1CQUFPLENBQUMsaUVBQWtCO0FBQzlDLGVBQWUsbUJBQU8sQ0FBQyx1REFBYTtBQUNwQyxrQkFBa0IsbUJBQU8sQ0FBQywyREFBZTs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDcENBLG9CQUFvQixtQkFBTyxDQUFDLGlFQUFrQjtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQywyREFBZTtBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQywyREFBZTs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJ2ZW5kb3JzfmJhYmVsLXByZWNvbXBpbGUuY2h1bmsuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNJZGVudGlmaWVyU3RhcnQgPSBpc0lkZW50aWZpZXJTdGFydDtcbmV4cG9ydHMuaXNJZGVudGlmaWVyQ2hhciA9IGlzSWRlbnRpZmllckNoYXI7XG5leHBvcnRzLmlzSWRlbnRpZmllck5hbWUgPSBpc0lkZW50aWZpZXJOYW1lO1xubGV0IG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzN2ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyZlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYwLVxcdTA1ODhcXHUwNWQwLVxcdTA1ZWFcXHUwNWVmLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDg2MC1cXHUwODZhXFx1MDhhMC1cXHUwOGI0XFx1MDhiNi1cXHUwOGM3XFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwOWZjXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGFmOVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzM5XFx1MGMzZFxcdTBjNTgtXFx1MGM1YVxcdTBjNjBcXHUwYzYxXFx1MGM4MFxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDQtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4Ni1cXHUwZThhXFx1MGU4Yy1cXHUwZWEzXFx1MGVhNVxcdTBlYTctXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y1XFx1MTNmOC1cXHUxM2ZkXFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmY4XFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFlXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTliMC1cXHUxOWM5XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWM4MC1cXHUxYzg4XFx1MWM5MC1cXHUxY2JhXFx1MWNiZC1cXHUxY2JmXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YzXFx1MWNmNVxcdTFjZjZcXHUxY2ZhXFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJmXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJmXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGJmXFx1NGUwMC1cXHU5ZmZjXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3YmZcXHVhN2MyLVxcdWE3Y2FcXHVhN2Y1LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE4ZmVcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YTllMC1cXHVhOWU0XFx1YTllNi1cXHVhOWVmXFx1YTlmYS1cXHVhOWZlXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2UtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWIzMC1cXHVhYjVhXFx1YWI1Yy1cXHVhYjY5XFx1YWI3MC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG5sZXQgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxcdTIwMGNcXHUyMDBkXFx4YjdcXHUwMzAwLVxcdTAzNmZcXHUwMzg3XFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDY0Yi1cXHUwNjY5XFx1MDY3MFxcdTA2ZDYtXFx1MDZkY1xcdTA2ZGYtXFx1MDZlNFxcdTA2ZTdcXHUwNmU4XFx1MDZlYS1cXHUwNmVkXFx1MDZmMC1cXHUwNmY5XFx1MDcxMVxcdTA3MzAtXFx1MDc0YVxcdTA3YTYtXFx1MDdiMFxcdTA3YzAtXFx1MDdjOVxcdTA3ZWItXFx1MDdmM1xcdTA3ZmRcXHUwODE2LVxcdTA4MTlcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwODU5LVxcdTA4NWJcXHUwOGQzLVxcdTA4ZTFcXHUwOGUzLVxcdTA5MDNcXHUwOTNhLVxcdTA5M2NcXHUwOTNlLVxcdTA5NGZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5NjYtXFx1MDk2ZlxcdTA5ODEtXFx1MDk4M1xcdTA5YmNcXHUwOWJlLVxcdTA5YzRcXHUwOWM3XFx1MDljOFxcdTA5Y2ItXFx1MDljZFxcdTA5ZDdcXHUwOWUyXFx1MDllM1xcdTA5ZTYtXFx1MDllZlxcdTA5ZmVcXHUwYTAxLVxcdTBhMDNcXHUwYTNjXFx1MGEzZS1cXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE2Ni1cXHUwYTcxXFx1MGE3NVxcdTBhODEtXFx1MGE4M1xcdTBhYmNcXHUwYWJlLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzlcXHUwYWNiLVxcdTBhY2RcXHUwYWUyXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBhZmEtXFx1MGFmZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTUtXFx1MGI1N1xcdTBiNjJcXHUwYjYzXFx1MGI2Ni1cXHUwYjZmXFx1MGI4MlxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDdcXHUwYmU2LVxcdTBiZWZcXHUwYzAwLVxcdTBjMDRcXHUwYzNlLVxcdTBjNDRcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjJcXHUwYzYzXFx1MGM2Ni1cXHUwYzZmXFx1MGM4MS1cXHUwYzgzXFx1MGNiY1xcdTBjYmUtXFx1MGNjNFxcdTBjYzYtXFx1MGNjOFxcdTBjY2EtXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMlxcdTBjZTNcXHUwY2U2LVxcdTBjZWZcXHUwZDAwLVxcdTBkMDNcXHUwZDNiXFx1MGQzY1xcdTBkM2UtXFx1MGQ0NFxcdTBkNDYtXFx1MGQ0OFxcdTBkNGEtXFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODEtXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRlNi1cXHUwZGVmXFx1MGRmMlxcdTBkZjNcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGViMVxcdTBlYjQtXFx1MGViY1xcdTBlYzgtXFx1MGVjZFxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxMzY5LVxcdTEzNzFcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWQwLVxcdTE5ZGFcXHUxYTE3LVxcdTFhMWJcXHUxYTU1LVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWIwLVxcdTFhYmRcXHUxYWJmXFx1MWFjMFxcdTFiMDAtXFx1MWIwNFxcdTFiMzQtXFx1MWI0NFxcdTFiNTAtXFx1MWI1OVxcdTFiNmItXFx1MWI3M1xcdTFiODAtXFx1MWI4MlxcdTFiYTEtXFx1MWJhZFxcdTFiYjAtXFx1MWJiOVxcdTFiZTYtXFx1MWJmM1xcdTFjMjQtXFx1MWMzN1xcdTFjNDAtXFx1MWM0OVxcdTFjNTAtXFx1MWM1OVxcdTFjZDAtXFx1MWNkMlxcdTFjZDQtXFx1MWNlOFxcdTFjZWRcXHUxY2Y0XFx1MWNmNy1cXHUxY2Y5XFx1MWRjMC1cXHUxZGY5XFx1MWRmYi1cXHUxZGZmXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkN2ZcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdWE2MjAtXFx1YTYyOVxcdWE2NmZcXHVhNjc0LVxcdWE2N2RcXHVhNjllXFx1YTY5ZlxcdWE2ZjBcXHVhNmYxXFx1YTgwMlxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTgyY1xcdWE4ODBcXHVhODgxXFx1YThiNC1cXHVhOGM1XFx1YThkMC1cXHVhOGQ5XFx1YThlMC1cXHVhOGYxXFx1YThmZi1cXHVhOTA5XFx1YTkyNi1cXHVhOTJkXFx1YTk0Ny1cXHVhOTUzXFx1YTk4MC1cXHVhOTgzXFx1YTliMy1cXHVhOWMwXFx1YTlkMC1cXHVhOWQ5XFx1YTllNVxcdWE5ZjAtXFx1YTlmOVxcdWFhMjktXFx1YWEzNlxcdWFhNDNcXHVhYTRjXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2ItXFx1YWE3ZFxcdWFhYjBcXHVhYWIyLVxcdWFhYjRcXHVhYWI3XFx1YWFiOFxcdWFhYmVcXHVhYWJmXFx1YWFjMVxcdWFhZWItXFx1YWFlZlxcdWFhZjVcXHVhYWY2XFx1YWJlMy1cXHVhYmVhXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVmYjFlXFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTJmXFx1ZmUzM1xcdWZlMzRcXHVmZTRkLVxcdWZlNGZcXHVmZjEwLVxcdWZmMTlcXHVmZjNmXCI7XG5jb25zdCBub25BU0NJSWlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgXCJdXCIpO1xuY29uc3Qgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcbm5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IG51bGw7XG5jb25zdCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcyA9IFswLCAxMSwgMiwgMjUsIDIsIDE4LCAyLCAxLCAyLCAxNCwgMywgMTMsIDM1LCAxMjIsIDcwLCA1MiwgMjY4LCAyOCwgNCwgNDgsIDQ4LCAzMSwgMTQsIDI5LCA2LCAzNywgMTEsIDI5LCAzLCAzNSwgNSwgNywgMiwgNCwgNDMsIDE1NywgMTksIDM1LCA1LCAzNSwgNSwgMzksIDksIDUxLCAxNTcsIDMxMCwgMTAsIDIxLCAxMSwgNywgMTUzLCA1LCAzLCAwLCAyLCA0MywgMiwgMSwgNCwgMCwgMywgMjIsIDExLCAyMiwgMTAsIDMwLCA2NiwgMTgsIDIsIDEsIDExLCAyMSwgMTEsIDI1LCA3MSwgNTUsIDcsIDEsIDY1LCAwLCAxNiwgMywgMiwgMiwgMiwgMjgsIDQzLCAyOCwgNCwgMjgsIDM2LCA3LCAyLCAyNywgMjgsIDUzLCAxMSwgMjEsIDExLCAxOCwgMTQsIDE3LCAxMTEsIDcyLCA1NiwgNTAsIDE0LCA1MCwgMTQsIDM1LCAzNDksIDQxLCA3LCAxLCA3OSwgMjgsIDExLCAwLCA5LCAyMSwgMTA3LCAyMCwgMjgsIDIyLCAxMywgNTIsIDc2LCA0NCwgMzMsIDI0LCAyNywgMzUsIDMwLCAwLCAzLCAwLCA5LCAzNCwgNCwgMCwgMTMsIDQ3LCAxNSwgMywgMjIsIDAsIDIsIDAsIDM2LCAxNywgMiwgMjQsIDg1LCA2LCAyLCAwLCAyLCAzLCAyLCAxNCwgMiwgOSwgOCwgNDYsIDM5LCA3LCAzLCAxLCAzLCAyMSwgMiwgNiwgMiwgMSwgMiwgNCwgNCwgMCwgMTksIDAsIDEzLCA0LCAxNTksIDUyLCAxOSwgMywgMjEsIDIsIDMxLCA0NywgMjEsIDEsIDIsIDAsIDE4NSwgNDYsIDQyLCAzLCAzNywgNDcsIDIxLCAwLCA2MCwgNDIsIDE0LCAwLCA3MiwgMjYsIDIzMCwgNDMsIDExNywgNjMsIDMyLCA3LCAzLCAwLCAzLCA3LCAyLCAxLCAyLCAyMywgMTYsIDAsIDIsIDAsIDk1LCA3LCAzLCAzOCwgMTcsIDAsIDIsIDAsIDI5LCAwLCAxMSwgMzksIDgsIDAsIDIyLCAwLCAxMiwgNDUsIDIwLCAwLCAzNSwgNTYsIDI2NCwgOCwgMiwgMzYsIDE4LCAwLCA1MCwgMjksIDExMywgNiwgMiwgMSwgMiwgMzcsIDIyLCAwLCAyNiwgNSwgMiwgMSwgMiwgMzEsIDE1LCAwLCAzMjgsIDE4LCAxOTAsIDAsIDgwLCA5MjEsIDEwMywgMTEwLCAxOCwgMTk1LCAyNzQ5LCAxMDcwLCA0MDUwLCA1ODIsIDg2MzQsIDU2OCwgOCwgMzAsIDExNCwgMjksIDE5LCA0NywgMTcsIDMsIDMyLCAyMCwgNiwgMTgsIDY4OSwgNjMsIDEyOSwgNzQsIDYsIDAsIDY3LCAxMiwgNjUsIDEsIDIsIDAsIDI5LCA2MTM1LCA5LCAxMjM3LCA0MywgOCwgODk1MiwgMjg2LCA1MCwgMiwgMTgsIDMsIDksIDM5NSwgMjMwOSwgMTA2LCA2LCAxMiwgNCwgOCwgOCwgOSwgNTk5MSwgODQsIDIsIDcwLCAyLCAxLCAzLCAwLCAzLCAxLCAzLCAzLCAyLCAxMSwgMiwgMCwgMiwgNiwgMiwgNjQsIDIsIDMsIDMsIDcsIDIsIDYsIDIsIDI3LCAyLCAzLCAyLCA0LCAyLCAwLCA0LCA2LCAyLCAzMzksIDMsIDI0LCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCA3LCAyMzU3LCA0NCwgMTEsIDYsIDE3LCAwLCAzNzAsIDQzLCAxMzAxLCAxOTYsIDYwLCA2NywgOCwgMCwgMTIwNSwgMywgMiwgMjYsIDIsIDEsIDIsIDAsIDMsIDAsIDIsIDksIDIsIDMsIDIsIDAsIDIsIDAsIDcsIDAsIDUsIDAsIDIsIDAsIDIsIDAsIDIsIDIsIDIsIDEsIDIsIDAsIDMsIDAsIDIsIDAsIDIsIDAsIDIsIDAsIDIsIDAsIDIsIDEsIDIsIDAsIDMsIDMsIDIsIDYsIDIsIDMsIDIsIDMsIDIsIDAsIDIsIDksIDIsIDE2LCA2LCAyLCAyLCA0LCAyLCAxNiwgNDQyMSwgNDI3MTcsIDM1LCA0MTQ4LCAxMiwgMjIxLCAzLCA1NzYxLCAxNSwgNzQ3MiwgMzEwNCwgNTQxLCAxNTA3LCA0OTM4XTtcbmNvbnN0IGFzdHJhbElkZW50aWZpZXJDb2RlcyA9IFs1MDksIDAsIDIyNywgMCwgMTUwLCA0LCAyOTQsIDksIDEzNjgsIDIsIDIsIDEsIDYsIDMsIDQxLCAyLCA1LCAwLCAxNjYsIDEsIDU3NCwgMywgOSwgOSwgMzcwLCAxLCAxNTQsIDEwLCAxNzYsIDIsIDU0LCAxNCwgMzIsIDksIDE2LCAzLCA0NiwgMTAsIDU0LCA5LCA3LCAyLCAzNywgMTMsIDIsIDksIDYsIDEsIDQ1LCAwLCAxMywgMiwgNDksIDEzLCA5LCAzLCAyLCAxMSwgODMsIDExLCA3LCAwLCAxNjEsIDExLCA2LCA5LCA3LCAzLCA1NiwgMSwgMiwgNiwgMywgMSwgMywgMiwgMTAsIDAsIDExLCAxLCAzLCA2LCA0LCA0LCAxOTMsIDE3LCAxMCwgOSwgNSwgMCwgODIsIDE5LCAxMywgOSwgMjE0LCA2LCAzLCA4LCAyOCwgMSwgODMsIDE2LCAxNiwgOSwgODIsIDEyLCA5LCA5LCA4NCwgMTQsIDUsIDksIDI0MywgMTQsIDE2NiwgOSwgNzEsIDUsIDIsIDEsIDMsIDMsIDIsIDAsIDIsIDEsIDEzLCA5LCAxMjAsIDYsIDMsIDYsIDQsIDAsIDI5LCA5LCA0MSwgNiwgMiwgMywgOSwgMCwgMTAsIDEwLCA0NywgMTUsIDQwNiwgNywgMiwgNywgMTcsIDksIDU3LCAyMSwgMiwgMTMsIDEyMywgNSwgNCwgMCwgMiwgMSwgMiwgNiwgMiwgMCwgOSwgOSwgNDksIDQsIDIsIDEsIDIsIDQsIDksIDksIDMzMCwgMywgMTkzMDYsIDksIDEzNSwgNCwgNjAsIDYsIDI2LCA5LCAxMDE0LCAwLCAyLCA1NCwgOCwgMywgODIsIDAsIDEyLCAxLCAxOTYyOCwgMSwgNTMxOSwgNCwgNCwgNSwgOSwgNywgMywgNiwgMzEsIDMsIDE0OSwgMiwgMTQxOCwgNDksIDUxMywgNTQsIDUsIDQ5LCA5LCAwLCAxNSwgMCwgMjMsIDQsIDIsIDE0LCAxMzYxLCA2LCAyLCAxNiwgMywgNiwgMiwgMSwgMiwgNCwgMjYyLCA2LCAxMCwgOSwgNDE5LCAxMywgMTQ5NSwgNiwgMTEwLCA2LCA2LCA5LCA0NzU5LCA5LCA3ODc3MTksIDIzOV07XG5cbmZ1bmN0aW9uIGlzSW5Bc3RyYWxTZXQoY29kZSwgc2V0KSB7XG4gIGxldCBwb3MgPSAweDEwMDAwO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBzZXQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcbiAgICBwb3MgKz0gc2V0W2ldO1xuICAgIGlmIChwb3MgPiBjb2RlKSByZXR1cm4gZmFsc2U7XG4gICAgcG9zICs9IHNldFtpICsgMV07XG4gICAgaWYgKHBvcyA+PSBjb2RlKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSkge1xuICBpZiAoY29kZSA8IDY1KSByZXR1cm4gY29kZSA9PT0gMzY7XG4gIGlmIChjb2RlIDw9IDkwKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICBpZiAoY29kZSA8PSAxMjIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChjb2RlIDw9IDB4ZmZmZikge1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgfVxuXG4gIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKTtcbn1cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyQ2hhcihjb2RlKSB7XG4gIGlmIChjb2RlIDwgNDgpIHJldHVybiBjb2RlID09PSAzNjtcbiAgaWYgKGNvZGUgPCA1OCkgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDwgNjUpIHJldHVybiBmYWxzZTtcbiAgaWYgKGNvZGUgPD0gOTApIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gIGlmIChjb2RlIDw9IDEyMikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGNvZGUgPD0gMHhmZmZmKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgfVxuXG4gIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKSB8fCBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJDb2Rlcyk7XG59XG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllck5hbWUobmFtZSkge1xuICBsZXQgaXNGaXJzdCA9IHRydWU7XG5cbiAgZm9yIChsZXQgX2kgPSAwLCBfQXJyYXkkZnJvbSA9IEFycmF5LmZyb20obmFtZSk7IF9pIDwgX0FycmF5JGZyb20ubGVuZ3RoOyBfaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IF9BcnJheSRmcm9tW19pXTtcbiAgICBjb25zdCBjcCA9IGNoYXIuY29kZVBvaW50QXQoMCk7XG5cbiAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgaWYgKCFpc0lkZW50aWZpZXJTdGFydChjcCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpc0ZpcnN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaXNJZGVudGlmaWVyQ2hhcihjcCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gIWlzRmlyc3Q7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0lkZW50aWZpZXJOYW1lXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pZGVudGlmaWVyLmlzSWRlbnRpZmllck5hbWU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNJZGVudGlmaWVyQ2hhclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaWRlbnRpZmllci5pc0lkZW50aWZpZXJDaGFyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzSWRlbnRpZmllclN0YXJ0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pZGVudGlmaWVyLmlzSWRlbnRpZmllclN0YXJ0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzUmVzZXJ2ZWRXb3JkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9rZXl3b3JkLmlzUmVzZXJ2ZWRXb3JkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzU3RyaWN0QmluZE9ubHlSZXNlcnZlZFdvcmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2tleXdvcmQuaXNTdHJpY3RCaW5kT25seVJlc2VydmVkV29yZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1N0cmljdEJpbmRSZXNlcnZlZFdvcmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2tleXdvcmQuaXNTdHJpY3RCaW5kUmVzZXJ2ZWRXb3JkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzU3RyaWN0UmVzZXJ2ZWRXb3JkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9rZXl3b3JkLmlzU3RyaWN0UmVzZXJ2ZWRXb3JkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzS2V5d29yZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfa2V5d29yZC5pc0tleXdvcmQ7XG4gIH1cbn0pO1xuXG52YXIgX2lkZW50aWZpZXIgPSByZXF1aXJlKFwiLi9pZGVudGlmaWVyXCIpO1xuXG52YXIgX2tleXdvcmQgPSByZXF1aXJlKFwiLi9rZXl3b3JkXCIpOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pc1Jlc2VydmVkV29yZCA9IGlzUmVzZXJ2ZWRXb3JkO1xuZXhwb3J0cy5pc1N0cmljdFJlc2VydmVkV29yZCA9IGlzU3RyaWN0UmVzZXJ2ZWRXb3JkO1xuZXhwb3J0cy5pc1N0cmljdEJpbmRPbmx5UmVzZXJ2ZWRXb3JkID0gaXNTdHJpY3RCaW5kT25seVJlc2VydmVkV29yZDtcbmV4cG9ydHMuaXNTdHJpY3RCaW5kUmVzZXJ2ZWRXb3JkID0gaXNTdHJpY3RCaW5kUmVzZXJ2ZWRXb3JkO1xuZXhwb3J0cy5pc0tleXdvcmQgPSBpc0tleXdvcmQ7XG5jb25zdCByZXNlcnZlZFdvcmRzID0ge1xuICBrZXl3b3JkOiBbXCJicmVha1wiLCBcImNhc2VcIiwgXCJjYXRjaFwiLCBcImNvbnRpbnVlXCIsIFwiZGVidWdnZXJcIiwgXCJkZWZhdWx0XCIsIFwiZG9cIiwgXCJlbHNlXCIsIFwiZmluYWxseVwiLCBcImZvclwiLCBcImZ1bmN0aW9uXCIsIFwiaWZcIiwgXCJyZXR1cm5cIiwgXCJzd2l0Y2hcIiwgXCJ0aHJvd1wiLCBcInRyeVwiLCBcInZhclwiLCBcImNvbnN0XCIsIFwid2hpbGVcIiwgXCJ3aXRoXCIsIFwibmV3XCIsIFwidGhpc1wiLCBcInN1cGVyXCIsIFwiY2xhc3NcIiwgXCJleHRlbmRzXCIsIFwiZXhwb3J0XCIsIFwiaW1wb3J0XCIsIFwibnVsbFwiLCBcInRydWVcIiwgXCJmYWxzZVwiLCBcImluXCIsIFwiaW5zdGFuY2VvZlwiLCBcInR5cGVvZlwiLCBcInZvaWRcIiwgXCJkZWxldGVcIl0sXG4gIHN0cmljdDogW1wiaW1wbGVtZW50c1wiLCBcImludGVyZmFjZVwiLCBcImxldFwiLCBcInBhY2thZ2VcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIsIFwicHVibGljXCIsIFwic3RhdGljXCIsIFwieWllbGRcIl0sXG4gIHN0cmljdEJpbmQ6IFtcImV2YWxcIiwgXCJhcmd1bWVudHNcIl1cbn07XG5jb25zdCBrZXl3b3JkcyA9IG5ldyBTZXQocmVzZXJ2ZWRXb3Jkcy5rZXl3b3JkKTtcbmNvbnN0IHJlc2VydmVkV29yZHNTdHJpY3RTZXQgPSBuZXcgU2V0KHJlc2VydmVkV29yZHMuc3RyaWN0KTtcbmNvbnN0IHJlc2VydmVkV29yZHNTdHJpY3RCaW5kU2V0ID0gbmV3IFNldChyZXNlcnZlZFdvcmRzLnN0cmljdEJpbmQpO1xuXG5mdW5jdGlvbiBpc1Jlc2VydmVkV29yZCh3b3JkLCBpbk1vZHVsZSkge1xuICByZXR1cm4gaW5Nb2R1bGUgJiYgd29yZCA9PT0gXCJhd2FpdFwiIHx8IHdvcmQgPT09IFwiZW51bVwiO1xufVxuXG5mdW5jdGlvbiBpc1N0cmljdFJlc2VydmVkV29yZCh3b3JkLCBpbk1vZHVsZSkge1xuICByZXR1cm4gaXNSZXNlcnZlZFdvcmQod29yZCwgaW5Nb2R1bGUpIHx8IHJlc2VydmVkV29yZHNTdHJpY3RTZXQuaGFzKHdvcmQpO1xufVxuXG5mdW5jdGlvbiBpc1N0cmljdEJpbmRPbmx5UmVzZXJ2ZWRXb3JkKHdvcmQpIHtcbiAgcmV0dXJuIHJlc2VydmVkV29yZHNTdHJpY3RCaW5kU2V0Lmhhcyh3b3JkKTtcbn1cblxuZnVuY3Rpb24gaXNTdHJpY3RCaW5kUmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB7XG4gIHJldHVybiBpc1N0cmljdFJlc2VydmVkV29yZCh3b3JkLCBpbk1vZHVsZSkgfHwgaXNTdHJpY3RCaW5kT25seVJlc2VydmVkV29yZCh3b3JkKTtcbn1cblxuZnVuY3Rpb24gaXNLZXl3b3JkKHdvcmQpIHtcbiAgcmV0dXJuIGtleXdvcmRzLmhhcyh3b3JkKTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNvbnN0IGJlZm9yZUV4cHIgPSB0cnVlO1xuY29uc3Qgc3RhcnRzRXhwciA9IHRydWU7XG5jb25zdCBpc0xvb3AgPSB0cnVlO1xuY29uc3QgaXNBc3NpZ24gPSB0cnVlO1xuY29uc3QgcHJlZml4ID0gdHJ1ZTtcbmNvbnN0IHBvc3RmaXggPSB0cnVlO1xuY2xhc3MgVG9rZW5UeXBlIHtcbiAgY29uc3RydWN0b3IobGFiZWwsIGNvbmYgPSB7fSkge1xuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICB0aGlzLmtleXdvcmQgPSBjb25mLmtleXdvcmQ7XG4gICAgdGhpcy5iZWZvcmVFeHByID0gISFjb25mLmJlZm9yZUV4cHI7XG4gICAgdGhpcy5zdGFydHNFeHByID0gISFjb25mLnN0YXJ0c0V4cHI7XG4gICAgdGhpcy5yaWdodEFzc29jaWF0aXZlID0gISFjb25mLnJpZ2h0QXNzb2NpYXRpdmU7XG4gICAgdGhpcy5pc0xvb3AgPSAhIWNvbmYuaXNMb29wO1xuICAgIHRoaXMuaXNBc3NpZ24gPSAhIWNvbmYuaXNBc3NpZ247XG4gICAgdGhpcy5wcmVmaXggPSAhIWNvbmYucHJlZml4O1xuICAgIHRoaXMucG9zdGZpeCA9ICEhY29uZi5wb3N0Zml4O1xuICAgIHRoaXMuYmlub3AgPSBjb25mLmJpbm9wICE9IG51bGwgPyBjb25mLmJpbm9wIDogbnVsbDtcbiAgICB0aGlzLnVwZGF0ZUNvbnRleHQgPSBudWxsO1xuICB9XG5cbn1cbmNvbnN0IGtleXdvcmRzID0gbmV3IE1hcCgpO1xuXG5mdW5jdGlvbiBjcmVhdGVLZXl3b3JkKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICBvcHRpb25zLmtleXdvcmQgPSBuYW1lO1xuICBjb25zdCB0b2tlbiA9IG5ldyBUb2tlblR5cGUobmFtZSwgb3B0aW9ucyk7XG4gIGtleXdvcmRzLnNldChuYW1lLCB0b2tlbik7XG4gIHJldHVybiB0b2tlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQmlub3AobmFtZSwgYmlub3ApIHtcbiAgcmV0dXJuIG5ldyBUb2tlblR5cGUobmFtZSwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgYmlub3BcbiAgfSk7XG59XG5cbmNvbnN0IHR5cGVzID0ge1xuICBudW06IG5ldyBUb2tlblR5cGUoXCJudW1cIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIGJpZ2ludDogbmV3IFRva2VuVHlwZShcImJpZ2ludFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgcmVnZXhwOiBuZXcgVG9rZW5UeXBlKFwicmVnZXhwXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBzdHJpbmc6IG5ldyBUb2tlblR5cGUoXCJzdHJpbmdcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIG5hbWU6IG5ldyBUb2tlblR5cGUoXCJuYW1lXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBlb2Y6IG5ldyBUb2tlblR5cGUoXCJlb2ZcIiksXG4gIGJyYWNrZXRMOiBuZXcgVG9rZW5UeXBlKFwiW1wiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBicmFja2V0SGFzaEw6IG5ldyBUb2tlblR5cGUoXCIjW1wiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBicmFja2V0QmFyTDogbmV3IFRva2VuVHlwZShcIlt8XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIGJyYWNrZXRSOiBuZXcgVG9rZW5UeXBlKFwiXVwiKSxcbiAgYnJhY2tldEJhclI6IG5ldyBUb2tlblR5cGUoXCJ8XVwiKSxcbiAgYnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwie1wiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBicmFjZUJhckw6IG5ldyBUb2tlblR5cGUoXCJ7fFwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBicmFjZUhhc2hMOiBuZXcgVG9rZW5UeXBlKFwiI3tcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYnJhY2VSOiBuZXcgVG9rZW5UeXBlKFwifVwiKSxcbiAgYnJhY2VCYXJSOiBuZXcgVG9rZW5UeXBlKFwifH1cIiksXG4gIHBhcmVuTDogbmV3IFRva2VuVHlwZShcIihcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgcGFyZW5SOiBuZXcgVG9rZW5UeXBlKFwiKVwiKSxcbiAgY29tbWE6IG5ldyBUb2tlblR5cGUoXCIsXCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBzZW1pOiBuZXcgVG9rZW5UeXBlKFwiO1wiLCB7XG4gICAgYmVmb3JlRXhwclxuICB9KSxcbiAgY29sb246IG5ldyBUb2tlblR5cGUoXCI6XCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBkb3VibGVDb2xvbjogbmV3IFRva2VuVHlwZShcIjo6XCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBkb3Q6IG5ldyBUb2tlblR5cGUoXCIuXCIpLFxuICBxdWVzdGlvbjogbmV3IFRva2VuVHlwZShcIj9cIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIHF1ZXN0aW9uRG90OiBuZXcgVG9rZW5UeXBlKFwiPy5cIiksXG4gIGFycm93OiBuZXcgVG9rZW5UeXBlKFwiPT5cIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIHRlbXBsYXRlOiBuZXcgVG9rZW5UeXBlKFwidGVtcGxhdGVcIiksXG4gIGVsbGlwc2lzOiBuZXcgVG9rZW5UeXBlKFwiLi4uXCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBiYWNrUXVvdGU6IG5ldyBUb2tlblR5cGUoXCJgXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBkb2xsYXJCcmFjZUw6IG5ldyBUb2tlblR5cGUoXCIke1wiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBhdDogbmV3IFRva2VuVHlwZShcIkBcIiksXG4gIGhhc2g6IG5ldyBUb2tlblR5cGUoXCIjXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBpbnRlcnByZXRlckRpcmVjdGl2ZTogbmV3IFRva2VuVHlwZShcIiMhLi4uXCIpLFxuICBlcTogbmV3IFRva2VuVHlwZShcIj1cIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgaXNBc3NpZ25cbiAgfSksXG4gIGFzc2lnbjogbmV3IFRva2VuVHlwZShcIl89XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGlzQXNzaWduXG4gIH0pLFxuICBpbmNEZWM6IG5ldyBUb2tlblR5cGUoXCIrKy8tLVwiLCB7XG4gICAgcHJlZml4LFxuICAgIHBvc3RmaXgsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYmFuZzogbmV3IFRva2VuVHlwZShcIiFcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgcHJlZml4LFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIHRpbGRlOiBuZXcgVG9rZW5UeXBlKFwiflwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBwcmVmaXgsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgcGlwZWxpbmU6IGNyZWF0ZUJpbm9wKFwifD5cIiwgMCksXG4gIG51bGxpc2hDb2FsZXNjaW5nOiBjcmVhdGVCaW5vcChcIj8/XCIsIDEpLFxuICBsb2dpY2FsT1I6IGNyZWF0ZUJpbm9wKFwifHxcIiwgMSksXG4gIGxvZ2ljYWxBTkQ6IGNyZWF0ZUJpbm9wKFwiJiZcIiwgMiksXG4gIGJpdHdpc2VPUjogY3JlYXRlQmlub3AoXCJ8XCIsIDMpLFxuICBiaXR3aXNlWE9SOiBjcmVhdGVCaW5vcChcIl5cIiwgNCksXG4gIGJpdHdpc2VBTkQ6IGNyZWF0ZUJpbm9wKFwiJlwiLCA1KSxcbiAgZXF1YWxpdHk6IGNyZWF0ZUJpbm9wKFwiPT0vIT0vPT09LyE9PVwiLCA2KSxcbiAgcmVsYXRpb25hbDogY3JlYXRlQmlub3AoXCI8Lz4vPD0vPj1cIiwgNyksXG4gIGJpdFNoaWZ0OiBjcmVhdGVCaW5vcChcIjw8Lz4+Lz4+PlwiLCA4KSxcbiAgcGx1c01pbjogbmV3IFRva2VuVHlwZShcIisvLVwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBiaW5vcDogOSxcbiAgICBwcmVmaXgsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgbW9kdWxvOiBuZXcgVG9rZW5UeXBlKFwiJVwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBiaW5vcDogMTAsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgc3RhcjogY3JlYXRlQmlub3AoXCIqXCIsIDEwKSxcbiAgc2xhc2g6IGNyZWF0ZUJpbm9wKFwiL1wiLCAxMCksXG4gIGV4cG9uZW50OiBuZXcgVG9rZW5UeXBlKFwiKipcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgYmlub3A6IDExLFxuICAgIHJpZ2h0QXNzb2NpYXRpdmU6IHRydWVcbiAgfSksXG4gIF9icmVhazogY3JlYXRlS2V5d29yZChcImJyZWFrXCIpLFxuICBfY2FzZTogY3JlYXRlS2V5d29yZChcImNhc2VcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9jYXRjaDogY3JlYXRlS2V5d29yZChcImNhdGNoXCIpLFxuICBfY29udGludWU6IGNyZWF0ZUtleXdvcmQoXCJjb250aW51ZVwiKSxcbiAgX2RlYnVnZ2VyOiBjcmVhdGVLZXl3b3JkKFwiZGVidWdnZXJcIiksXG4gIF9kZWZhdWx0OiBjcmVhdGVLZXl3b3JkKFwiZGVmYXVsdFwiLCB7XG4gICAgYmVmb3JlRXhwclxuICB9KSxcbiAgX2RvOiBjcmVhdGVLZXl3b3JkKFwiZG9cIiwge1xuICAgIGlzTG9vcCxcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBfZWxzZTogY3JlYXRlS2V5d29yZChcImVsc2VcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9maW5hbGx5OiBjcmVhdGVLZXl3b3JkKFwiZmluYWxseVwiKSxcbiAgX2ZvcjogY3JlYXRlS2V5d29yZChcImZvclwiLCB7XG4gICAgaXNMb29wXG4gIH0pLFxuICBfZnVuY3Rpb246IGNyZWF0ZUtleXdvcmQoXCJmdW5jdGlvblwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2lmOiBjcmVhdGVLZXl3b3JkKFwiaWZcIiksXG4gIF9yZXR1cm46IGNyZWF0ZUtleXdvcmQoXCJyZXR1cm5cIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9zd2l0Y2g6IGNyZWF0ZUtleXdvcmQoXCJzd2l0Y2hcIiksXG4gIF90aHJvdzogY3JlYXRlS2V5d29yZChcInRocm93XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfdHJ5OiBjcmVhdGVLZXl3b3JkKFwidHJ5XCIpLFxuICBfdmFyOiBjcmVhdGVLZXl3b3JkKFwidmFyXCIpLFxuICBfY29uc3Q6IGNyZWF0ZUtleXdvcmQoXCJjb25zdFwiKSxcbiAgX3doaWxlOiBjcmVhdGVLZXl3b3JkKFwid2hpbGVcIiwge1xuICAgIGlzTG9vcFxuICB9KSxcbiAgX3dpdGg6IGNyZWF0ZUtleXdvcmQoXCJ3aXRoXCIpLFxuICBfbmV3OiBjcmVhdGVLZXl3b3JkKFwibmV3XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF90aGlzOiBjcmVhdGVLZXl3b3JkKFwidGhpc1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3N1cGVyOiBjcmVhdGVLZXl3b3JkKFwic3VwZXJcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9jbGFzczogY3JlYXRlS2V5d29yZChcImNsYXNzXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZXh0ZW5kczogY3JlYXRlS2V5d29yZChcImV4dGVuZHNcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9leHBvcnQ6IGNyZWF0ZUtleXdvcmQoXCJleHBvcnRcIiksXG4gIF9pbXBvcnQ6IGNyZWF0ZUtleXdvcmQoXCJpbXBvcnRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9udWxsOiBjcmVhdGVLZXl3b3JkKFwibnVsbFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3RydWU6IGNyZWF0ZUtleXdvcmQoXCJ0cnVlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZmFsc2U6IGNyZWF0ZUtleXdvcmQoXCJmYWxzZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2luOiBjcmVhdGVLZXl3b3JkKFwiaW5cIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgYmlub3A6IDdcbiAgfSksXG4gIF9pbnN0YW5jZW9mOiBjcmVhdGVLZXl3b3JkKFwiaW5zdGFuY2VvZlwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBiaW5vcDogN1xuICB9KSxcbiAgX3R5cGVvZjogY3JlYXRlS2V5d29yZChcInR5cGVvZlwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBwcmVmaXgsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3ZvaWQ6IGNyZWF0ZUtleXdvcmQoXCJ2b2lkXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZGVsZXRlOiBjcmVhdGVLZXl3b3JkKFwiZGVsZXRlXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pXG59O1xuXG5jb25zdCBTQ09QRV9PVEhFUiA9IDBiMDAwMDAwMDAsXG4gICAgICBTQ09QRV9QUk9HUkFNID0gMGIwMDAwMDAwMSxcbiAgICAgIFNDT1BFX0ZVTkNUSU9OID0gMGIwMDAwMDAxMCxcbiAgICAgIFNDT1BFX0FSUk9XID0gMGIwMDAwMDEwMCxcbiAgICAgIFNDT1BFX1NJTVBMRV9DQVRDSCA9IDBiMDAwMDEwMDAsXG4gICAgICBTQ09QRV9TVVBFUiA9IDBiMDAwMTAwMDAsXG4gICAgICBTQ09QRV9ESVJFQ1RfU1VQRVIgPSAwYjAwMTAwMDAwLFxuICAgICAgU0NPUEVfQ0xBU1MgPSAwYjAxMDAwMDAwLFxuICAgICAgU0NPUEVfVFNfTU9EVUxFID0gMGIxMDAwMDAwMCxcbiAgICAgIFNDT1BFX1ZBUiA9IFNDT1BFX1BST0dSQU0gfCBTQ09QRV9GVU5DVElPTiB8IFNDT1BFX1RTX01PRFVMRTtcbmNvbnN0IEJJTkRfS0lORF9WQUxVRSA9IDBiMDAwMDAwMDAwMDEsXG4gICAgICBCSU5EX0tJTkRfVFlQRSA9IDBiMDAwMDAwMDAwMTAsXG4gICAgICBCSU5EX1NDT1BFX1ZBUiA9IDBiMDAwMDAwMDAxMDAsXG4gICAgICBCSU5EX1NDT1BFX0xFWElDQUwgPSAwYjAwMDAwMDAxMDAwLFxuICAgICAgQklORF9TQ09QRV9GVU5DVElPTiA9IDBiMDAwMDAwMTAwMDAsXG4gICAgICBCSU5EX0ZMQUdTX05PTkUgPSAwYjAwMDAxMDAwMDAwLFxuICAgICAgQklORF9GTEFHU19DTEFTUyA9IDBiMDAwMTAwMDAwMDAsXG4gICAgICBCSU5EX0ZMQUdTX1RTX0VOVU0gPSAwYjAwMTAwMDAwMDAwLFxuICAgICAgQklORF9GTEFHU19UU19DT05TVF9FTlVNID0gMGIwMTAwMDAwMDAwMCxcbiAgICAgIEJJTkRfRkxBR1NfVFNfRVhQT1JUX09OTFkgPSAwYjEwMDAwMDAwMDAwO1xuY29uc3QgQklORF9DTEFTUyA9IEJJTkRfS0lORF9WQUxVRSB8IEJJTkRfS0lORF9UWVBFIHwgQklORF9TQ09QRV9MRVhJQ0FMIHwgQklORF9GTEFHU19DTEFTUyxcbiAgICAgIEJJTkRfTEVYSUNBTCA9IEJJTkRfS0lORF9WQUxVRSB8IDAgfCBCSU5EX1NDT1BFX0xFWElDQUwgfCAwLFxuICAgICAgQklORF9WQVIgPSBCSU5EX0tJTkRfVkFMVUUgfCAwIHwgQklORF9TQ09QRV9WQVIgfCAwLFxuICAgICAgQklORF9GVU5DVElPTiA9IEJJTkRfS0lORF9WQUxVRSB8IDAgfCBCSU5EX1NDT1BFX0ZVTkNUSU9OIHwgMCxcbiAgICAgIEJJTkRfVFNfSU5URVJGQUNFID0gMCB8IEJJTkRfS0lORF9UWVBFIHwgMCB8IEJJTkRfRkxBR1NfQ0xBU1MsXG4gICAgICBCSU5EX1RTX1RZUEUgPSAwIHwgQklORF9LSU5EX1RZUEUgfCAwIHwgMCxcbiAgICAgIEJJTkRfVFNfRU5VTSA9IEJJTkRfS0lORF9WQUxVRSB8IEJJTkRfS0lORF9UWVBFIHwgQklORF9TQ09QRV9MRVhJQ0FMIHwgQklORF9GTEFHU19UU19FTlVNLFxuICAgICAgQklORF9UU19BTUJJRU5UID0gMCB8IDAgfCAwIHwgQklORF9GTEFHU19UU19FWFBPUlRfT05MWSxcbiAgICAgIEJJTkRfTk9ORSA9IDAgfCAwIHwgMCB8IEJJTkRfRkxBR1NfTk9ORSxcbiAgICAgIEJJTkRfT1VUU0lERSA9IEJJTkRfS0lORF9WQUxVRSB8IDAgfCAwIHwgQklORF9GTEFHU19OT05FLFxuICAgICAgQklORF9UU19DT05TVF9FTlVNID0gQklORF9UU19FTlVNIHwgQklORF9GTEFHU19UU19DT05TVF9FTlVNLFxuICAgICAgQklORF9UU19OQU1FU1BBQ0UgPSAwIHwgMCB8IDAgfCBCSU5EX0ZMQUdTX1RTX0VYUE9SVF9PTkxZO1xuY29uc3QgQ0xBU1NfRUxFTUVOVF9GTEFHX1NUQVRJQyA9IDBiMTAwLFxuICAgICAgQ0xBU1NfRUxFTUVOVF9LSU5EX0dFVFRFUiA9IDBiMDEwLFxuICAgICAgQ0xBU1NfRUxFTUVOVF9LSU5EX1NFVFRFUiA9IDBiMDAxLFxuICAgICAgQ0xBU1NfRUxFTUVOVF9LSU5EX0FDQ0VTU09SID0gQ0xBU1NfRUxFTUVOVF9LSU5EX0dFVFRFUiB8IENMQVNTX0VMRU1FTlRfS0lORF9TRVRURVI7XG5jb25zdCBDTEFTU19FTEVNRU5UX1NUQVRJQ19HRVRURVIgPSBDTEFTU19FTEVNRU5UX0tJTkRfR0VUVEVSIHwgQ0xBU1NfRUxFTUVOVF9GTEFHX1NUQVRJQyxcbiAgICAgIENMQVNTX0VMRU1FTlRfU1RBVElDX1NFVFRFUiA9IENMQVNTX0VMRU1FTlRfS0lORF9TRVRURVIgfCBDTEFTU19FTEVNRU5UX0ZMQUdfU1RBVElDLFxuICAgICAgQ0xBU1NfRUxFTUVOVF9JTlNUQU5DRV9HRVRURVIgPSBDTEFTU19FTEVNRU5UX0tJTkRfR0VUVEVSLFxuICAgICAgQ0xBU1NfRUxFTUVOVF9JTlNUQU5DRV9TRVRURVIgPSBDTEFTU19FTEVNRU5UX0tJTkRfU0VUVEVSLFxuICAgICAgQ0xBU1NfRUxFTUVOVF9PVEhFUiA9IDA7XG5cbmNvbnN0IGxpbmVCcmVhayA9IC9cXHJcXG4/fFtcXG5cXHUyMDI4XFx1MjAyOV0vO1xuY29uc3QgbGluZUJyZWFrRyA9IG5ldyBSZWdFeHAobGluZUJyZWFrLnNvdXJjZSwgXCJnXCIpO1xuZnVuY3Rpb24gaXNOZXdMaW5lKGNvZGUpIHtcbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAxMDpcbiAgICBjYXNlIDEzOlxuICAgIGNhc2UgODIzMjpcbiAgICBjYXNlIDgyMzM6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNvbnN0IHNraXBXaGl0ZVNwYWNlID0gLyg/Olxcc3xcXC9cXC8uKnxcXC9cXCpbXl0qP1xcKlxcLykqL2c7XG5mdW5jdGlvbiBpc1doaXRlc3BhY2UoY29kZSkge1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4MDAwOTpcbiAgICBjYXNlIDB4MDAwYjpcbiAgICBjYXNlIDB4MDAwYzpcbiAgICBjYXNlIDMyOlxuICAgIGNhc2UgMTYwOlxuICAgIGNhc2UgNTc2MDpcbiAgICBjYXNlIDB4MjAwMDpcbiAgICBjYXNlIDB4MjAwMTpcbiAgICBjYXNlIDB4MjAwMjpcbiAgICBjYXNlIDB4MjAwMzpcbiAgICBjYXNlIDB4MjAwNDpcbiAgICBjYXNlIDB4MjAwNTpcbiAgICBjYXNlIDB4MjAwNjpcbiAgICBjYXNlIDB4MjAwNzpcbiAgICBjYXNlIDB4MjAwODpcbiAgICBjYXNlIDB4MjAwOTpcbiAgICBjYXNlIDB4MjAwYTpcbiAgICBjYXNlIDB4MjAyZjpcbiAgICBjYXNlIDB4MjA1ZjpcbiAgICBjYXNlIDB4MzAwMDpcbiAgICBjYXNlIDB4ZmVmZjpcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5jbGFzcyBQb3NpdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGxpbmUsIGNvbCkge1xuICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2w7XG4gIH1cblxufVxuY2xhc3MgU291cmNlTG9jYXRpb24ge1xuICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICB9XG5cbn1cbmZ1bmN0aW9uIGdldExpbmVJbmZvKGlucHV0LCBvZmZzZXQpIHtcbiAgbGV0IGxpbmUgPSAxO1xuICBsZXQgbGluZVN0YXJ0ID0gMDtcbiAgbGV0IG1hdGNoO1xuICBsaW5lQnJlYWtHLmxhc3RJbmRleCA9IDA7XG5cbiAgd2hpbGUgKChtYXRjaCA9IGxpbmVCcmVha0cuZXhlYyhpbnB1dCkpICYmIG1hdGNoLmluZGV4IDwgb2Zmc2V0KSB7XG4gICAgbGluZSsrO1xuICAgIGxpbmVTdGFydCA9IGxpbmVCcmVha0cubGFzdEluZGV4O1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQb3NpdGlvbihsaW5lLCBvZmZzZXQgLSBsaW5lU3RhcnQpO1xufVxuXG5jbGFzcyBCYXNlUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zYXdVbmFtYmlndW91c0VTTSA9IGZhbHNlO1xuICAgIHRoaXMuYW1iaWd1b3VzU2NyaXB0RGlmZmVyZW50QXN0ID0gZmFsc2U7XG4gIH1cblxuICBoYXNQbHVnaW4obmFtZSkge1xuICAgIHJldHVybiB0aGlzLnBsdWdpbnMuaGFzKG5hbWUpO1xuICB9XG5cbiAgZ2V0UGx1Z2luT3B0aW9uKHBsdWdpbiwgbmFtZSkge1xuICAgIGlmICh0aGlzLmhhc1BsdWdpbihwbHVnaW4pKSByZXR1cm4gdGhpcy5wbHVnaW5zLmdldChwbHVnaW4pW25hbWVdO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gbGFzdChzdGFjaykge1xuICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG59XG5cbmNsYXNzIENvbW1lbnRzUGFyc2VyIGV4dGVuZHMgQmFzZVBhcnNlciB7XG4gIGFkZENvbW1lbnQoY29tbWVudCkge1xuICAgIGlmICh0aGlzLmZpbGVuYW1lKSBjb21tZW50LmxvYy5maWxlbmFtZSA9IHRoaXMuZmlsZW5hbWU7XG4gICAgdGhpcy5zdGF0ZS50cmFpbGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgdGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMucHVzaChjb21tZW50KTtcbiAgfVxuXG4gIGFkanVzdENvbW1lbnRzQWZ0ZXJUcmFpbGluZ0NvbW1hKG5vZGUsIGVsZW1lbnRzLCB0YWtlQWxsQ29tbWVudHMpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGxhc3RFbGVtZW50ID0gbnVsbDtcbiAgICBsZXQgaSA9IGVsZW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsYXN0RWxlbWVudCA9PT0gbnVsbCAmJiBpID4gMCkge1xuICAgICAgbGFzdEVsZW1lbnQgPSBlbGVtZW50c1stLWldO1xuICAgIH1cblxuICAgIGlmIChsYXN0RWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50c1tqXS5lbmQgPCB0aGlzLnN0YXRlLmNvbW1lbnRQcmV2aW91c05vZGUuZW5kKSB7XG4gICAgICAgIHRoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzLnNwbGljZShqLCAxKTtcbiAgICAgICAgai0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG5ld1RyYWlsaW5nQ29tbWVudHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxlYWRpbmdDb21tZW50ID0gdGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHNbaV07XG5cbiAgICAgIGlmIChsZWFkaW5nQ29tbWVudC5lbmQgPCBub2RlLmVuZCkge1xuICAgICAgICBuZXdUcmFpbGluZ0NvbW1lbnRzLnB1c2gobGVhZGluZ0NvbW1lbnQpO1xuXG4gICAgICAgIGlmICghdGFrZUFsbENvbW1lbnRzKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5vZGUudHJhaWxpbmdDb21tZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLnRyYWlsaW5nQ29tbWVudHMucHVzaChsZWFkaW5nQ29tbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRha2VBbGxDb21tZW50cykgdGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMgPSBbXTtcblxuICAgIGlmIChuZXdUcmFpbGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGxhc3RFbGVtZW50LnRyYWlsaW5nQ29tbWVudHMgPSBuZXdUcmFpbGluZ0NvbW1lbnRzO1xuICAgIH0gZWxzZSBpZiAobGFzdEVsZW1lbnQudHJhaWxpbmdDb21tZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsYXN0RWxlbWVudC50cmFpbGluZ0NvbW1lbnRzID0gW107XG4gICAgfVxuICB9XG5cbiAgcHJvY2Vzc0NvbW1lbnQobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiUHJvZ3JhbVwiICYmIG5vZGUuYm9keS5sZW5ndGggPiAwKSByZXR1cm47XG4gICAgY29uc3Qgc3RhY2sgPSB0aGlzLnN0YXRlLmNvbW1lbnRTdGFjaztcbiAgICBsZXQgZmlyc3RDaGlsZCwgbGFzdENoaWxkLCB0cmFpbGluZ0NvbW1lbnRzLCBpLCBqO1xuXG4gICAgaWYgKHRoaXMuc3RhdGUudHJhaWxpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS50cmFpbGluZ0NvbW1lbnRzWzBdLnN0YXJ0ID49IG5vZGUuZW5kKSB7XG4gICAgICAgIHRyYWlsaW5nQ29tbWVudHMgPSB0aGlzLnN0YXRlLnRyYWlsaW5nQ29tbWVudHM7XG4gICAgICAgIHRoaXMuc3RhdGUudHJhaWxpbmdDb21tZW50cyA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZS50cmFpbGluZ0NvbW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBsYXN0SW5TdGFjayA9IGxhc3Qoc3RhY2spO1xuXG4gICAgICBpZiAobGFzdEluU3RhY2sudHJhaWxpbmdDb21tZW50cyAmJiBsYXN0SW5TdGFjay50cmFpbGluZ0NvbW1lbnRzWzBdLnN0YXJ0ID49IG5vZGUuZW5kKSB7XG4gICAgICAgIHRyYWlsaW5nQ29tbWVudHMgPSBsYXN0SW5TdGFjay50cmFpbGluZ0NvbW1lbnRzO1xuICAgICAgICBkZWxldGUgbGFzdEluU3RhY2sudHJhaWxpbmdDb21tZW50cztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhY2subGVuZ3RoID4gMCAmJiBsYXN0KHN0YWNrKS5zdGFydCA+PSBub2RlLnN0YXJ0KSB7XG4gICAgICBmaXJzdENoaWxkID0gc3RhY2sucG9wKCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDAgJiYgbGFzdChzdGFjaykuc3RhcnQgPj0gbm9kZS5zdGFydCkge1xuICAgICAgbGFzdENoaWxkID0gc3RhY2sucG9wKCk7XG4gICAgfVxuXG4gICAgaWYgKCFsYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZCkgbGFzdENoaWxkID0gZmlyc3RDaGlsZDtcblxuICAgIGlmIChmaXJzdENoaWxkKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgICAgIHRoaXMuYWRqdXN0Q29tbWVudHNBZnRlclRyYWlsaW5nQ29tbWEobm9kZSwgbm9kZS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgICAgIHRoaXMuYWRqdXN0Q29tbWVudHNBZnRlclRyYWlsaW5nQ29tbWEobm9kZSwgbm9kZS5wcm9wZXJ0aWVzLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICB0aGlzLmFkanVzdENvbW1lbnRzQWZ0ZXJUcmFpbGluZ0NvbW1hKG5vZGUsIG5vZGUuYXJndW1lbnRzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgICAgdGhpcy5hZGp1c3RDb21tZW50c0FmdGVyVHJhaWxpbmdDb21tYShub2RlLCBub2RlLmVsZW1lbnRzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICAgICAgdGhpcy5hZGp1c3RDb21tZW50c0FmdGVyVHJhaWxpbmdDb21tYShub2RlLCBub2RlLmVsZW1lbnRzLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuY29tbWVudFByZXZpb3VzTm9kZSAmJiAodGhpcy5zdGF0ZS5jb21tZW50UHJldmlvdXNOb2RlLnR5cGUgPT09IFwiSW1wb3J0U3BlY2lmaWVyXCIgJiYgbm9kZS50eXBlICE9PSBcIkltcG9ydFNwZWNpZmllclwiIHx8IHRoaXMuc3RhdGUuY29tbWVudFByZXZpb3VzTm9kZS50eXBlID09PSBcIkV4cG9ydFNwZWNpZmllclwiICYmIG5vZGUudHlwZSAhPT0gXCJFeHBvcnRTcGVjaWZpZXJcIikpIHtcbiAgICAgIHRoaXMuYWRqdXN0Q29tbWVudHNBZnRlclRyYWlsaW5nQ29tbWEobm9kZSwgW3RoaXMuc3RhdGUuY29tbWVudFByZXZpb3VzTm9kZV0pO1xuICAgIH1cblxuICAgIGlmIChsYXN0Q2hpbGQpIHtcbiAgICAgIGlmIChsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgIGlmIChsYXN0Q2hpbGQgIT09IG5vZGUgJiYgbGFzdENoaWxkLmxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwICYmIGxhc3QobGFzdENoaWxkLmxlYWRpbmdDb21tZW50cykuZW5kIDw9IG5vZGUuc3RhcnQpIHtcbiAgICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHM7XG4gICAgICAgICAgZGVsZXRlIGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChpID0gbGFzdENoaWxkLmxlYWRpbmdDb21tZW50cy5sZW5ndGggLSAyOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgaWYgKGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHNbaV0uZW5kIDw9IG5vZGUuc3RhcnQpIHtcbiAgICAgICAgICAgICAgbm9kZS5sZWFkaW5nQ29tbWVudHMgPSBsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzLnNwbGljZSgwLCBpICsgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGxhc3QodGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMpLmVuZCA8PSBub2RlLnN0YXJ0KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmNvbW1lbnRQcmV2aW91c05vZGUpIHtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50c1tqXS5lbmQgPCB0aGlzLnN0YXRlLmNvbW1lbnRQcmV2aW91c05vZGUuZW5kKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbm9kZS5sZWFkaW5nQ29tbWVudHMgPSB0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cztcbiAgICAgICAgICB0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHNbaV0uZW5kID4gbm9kZS5zdGFydCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGVhZGluZ0NvbW1lbnRzID0gdGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMuc2xpY2UoMCwgaSk7XG5cbiAgICAgICAgaWYgKGxlYWRpbmdDb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IGxlYWRpbmdDb21tZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYWlsaW5nQ29tbWVudHMgPSB0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cy5zbGljZShpKTtcblxuICAgICAgICBpZiAodHJhaWxpbmdDb21tZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuY29tbWVudFByZXZpb3VzTm9kZSA9IG5vZGU7XG5cbiAgICBpZiAodHJhaWxpbmdDb21tZW50cykge1xuICAgICAgaWYgKHRyYWlsaW5nQ29tbWVudHMubGVuZ3RoICYmIHRyYWlsaW5nQ29tbWVudHNbMF0uc3RhcnQgPj0gbm9kZS5zdGFydCAmJiBsYXN0KHRyYWlsaW5nQ29tbWVudHMpLmVuZCA8PSBub2RlLmVuZCkge1xuICAgICAgICBub2RlLmlubmVyQ29tbWVudHMgPSB0cmFpbGluZ0NvbW1lbnRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZmlyc3RUcmFpbGluZ0NvbW1lbnRJbmRleCA9IHRyYWlsaW5nQ29tbWVudHMuZmluZEluZGV4KGNvbW1lbnQgPT4gY29tbWVudC5lbmQgPj0gbm9kZS5lbmQpO1xuXG4gICAgICAgIGlmIChmaXJzdFRyYWlsaW5nQ29tbWVudEluZGV4ID4gMCkge1xuICAgICAgICAgIG5vZGUuaW5uZXJDb21tZW50cyA9IHRyYWlsaW5nQ29tbWVudHMuc2xpY2UoMCwgZmlyc3RUcmFpbGluZ0NvbW1lbnRJbmRleCk7XG4gICAgICAgICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzID0gdHJhaWxpbmdDb21tZW50cy5zbGljZShmaXJzdFRyYWlsaW5nQ29tbWVudEluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnRyYWlsaW5nQ29tbWVudHMgPSB0cmFpbGluZ0NvbW1lbnRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhY2sucHVzaChub2RlKTtcbiAgfVxuXG59XG5cbmNvbnN0IEVycm9yTWVzc2FnZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgQXJndW1lbnRzRGlzYWxsb3dlZEluSW5pdGlhbGl6ZXI6IFwiJ2FyZ3VtZW50cycgaXMgbm90IGFsbG93ZWQgaW4gY2xhc3MgZmllbGQgaW5pdGlhbGl6ZXJcIixcbiAgQXN5bmNGdW5jdGlvbkluU2luZ2xlU3RhdGVtZW50Q29udGV4dDogXCJBc3luYyBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdGhlIHRvcCBsZXZlbCBvciBpbnNpZGUgYSBibG9ja1wiLFxuICBBd2FpdEJpbmRpbmdJZGVudGlmaWVyOiBcIkNhbiBub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIixcbiAgQXdhaXRFeHByZXNzaW9uRm9ybWFsUGFyYW1ldGVyOiBcImF3YWl0IGlzIG5vdCBhbGxvd2VkIGluIGFzeW5jIGZ1bmN0aW9uIHBhcmFtZXRlcnNcIixcbiAgQXdhaXROb3RJbkFzeW5jRnVuY3Rpb246IFwiQ2FuIG5vdCB1c2Uga2V5d29yZCAnYXdhaXQnIG91dHNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIixcbiAgQmFkR2V0dGVyQXJpdHk6IFwiZ2V0dGVyIG11c3Qgbm90IGhhdmUgYW55IGZvcm1hbCBwYXJhbWV0ZXJzXCIsXG4gIEJhZFNldHRlckFyaXR5OiBcInNldHRlciBtdXN0IGhhdmUgZXhhY3RseSBvbmUgZm9ybWFsIHBhcmFtZXRlclwiLFxuICBCYWRTZXR0ZXJSZXN0UGFyYW1ldGVyOiBcInNldHRlciBmdW5jdGlvbiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIHJlc3QgcGFyYW1ldGVyXCIsXG4gIENvbnN0cnVjdG9yQ2xhc3NGaWVsZDogXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIGZpZWxkIG5hbWVkICdjb25zdHJ1Y3RvcidcIixcbiAgQ29uc3RydWN0b3JDbGFzc1ByaXZhdGVGaWVsZDogXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIHByaXZhdGUgZmllbGQgbmFtZWQgJyNjb25zdHJ1Y3RvcidcIixcbiAgQ29uc3RydWN0b3JJc0FjY2Vzc29yOiBcIkNsYXNzIGNvbnN0cnVjdG9yIG1heSBub3QgYmUgYW4gYWNjZXNzb3JcIixcbiAgQ29uc3RydWN0b3JJc0FzeW5jOiBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGFuIGFzeW5jIGZ1bmN0aW9uXCIsXG4gIENvbnN0cnVjdG9ySXNHZW5lcmF0b3I6IFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYSBnZW5lcmF0b3JcIixcbiAgRGVjbGFyYXRpb25NaXNzaW5nSW5pdGlhbGl6ZXI6IFwiJTAgcmVxdWlyZSBhbiBpbml0aWFsaXphdGlvbiB2YWx1ZVwiLFxuICBEZWNvcmF0b3JCZWZvcmVFeHBvcnQ6IFwiRGVjb3JhdG9ycyBtdXN0IGJlIHBsYWNlZCAqYmVmb3JlKiB0aGUgJ2V4cG9ydCcga2V5d29yZC4gWW91IGNhbiBzZXQgdGhlICdkZWNvcmF0b3JzQmVmb3JlRXhwb3J0JyBvcHRpb24gdG8gZmFsc2UgdG8gdXNlIHRoZSAnZXhwb3J0IEBkZWNvcmF0b3IgY2xhc3Mge30nIHN5bnRheFwiLFxuICBEZWNvcmF0b3JDb25zdHJ1Y3RvcjogXCJEZWNvcmF0b3JzIGNhbid0IGJlIHVzZWQgd2l0aCBhIGNvbnN0cnVjdG9yLiBEaWQgeW91IG1lYW4gJ0BkZWMgY2xhc3MgeyAuLi4gfSc/XCIsXG4gIERlY29yYXRvckV4cG9ydENsYXNzOiBcIlVzaW5nIHRoZSBleHBvcnQga2V5d29yZCBiZXR3ZWVuIGEgZGVjb3JhdG9yIGFuZCBhIGNsYXNzIGlzIG5vdCBhbGxvd2VkLiBQbGVhc2UgdXNlIGBleHBvcnQgQGRlYyBjbGFzc2AgaW5zdGVhZC5cIixcbiAgRGVjb3JhdG9yU2VtaWNvbG9uOiBcIkRlY29yYXRvcnMgbXVzdCBub3QgYmUgZm9sbG93ZWQgYnkgYSBzZW1pY29sb25cIixcbiAgRGVsZXRlUHJpdmF0ZUZpZWxkOiBcIkRlbGV0aW5nIGEgcHJpdmF0ZSBmaWVsZCBpcyBub3QgYWxsb3dlZFwiLFxuICBEZXN0cnVjdHVyZU5hbWVkSW1wb3J0OiBcIkVTMjAxNSBuYW1lZCBpbXBvcnRzIGRvIG5vdCBkZXN0cnVjdHVyZS4gVXNlIGFub3RoZXIgc3RhdGVtZW50IGZvciBkZXN0cnVjdHVyaW5nIGFmdGVyIHRoZSBpbXBvcnQuXCIsXG4gIER1cGxpY2F0ZUNvbnN0cnVjdG9yOiBcIkR1cGxpY2F0ZSBjb25zdHJ1Y3RvciBpbiB0aGUgc2FtZSBjbGFzc1wiLFxuICBEdXBsaWNhdGVEZWZhdWx0RXhwb3J0OiBcIk9ubHkgb25lIGRlZmF1bHQgZXhwb3J0IGFsbG93ZWQgcGVyIG1vZHVsZS5cIixcbiAgRHVwbGljYXRlRXhwb3J0OiBcImAlMGAgaGFzIGFscmVhZHkgYmVlbiBleHBvcnRlZC4gRXhwb3J0ZWQgaWRlbnRpZmllcnMgbXVzdCBiZSB1bmlxdWUuXCIsXG4gIER1cGxpY2F0ZVByb3RvOiBcIlJlZGVmaW5pdGlvbiBvZiBfX3Byb3RvX18gcHJvcGVydHlcIixcbiAgRHVwbGljYXRlUmVnRXhwRmxhZ3M6IFwiRHVwbGljYXRlIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnXCIsXG4gIEVsZW1lbnRBZnRlclJlc3Q6IFwiUmVzdCBlbGVtZW50IG11c3QgYmUgbGFzdCBlbGVtZW50XCIsXG4gIEVzY2FwZWRDaGFyTm90QW5JZGVudGlmaWVyOiBcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIixcbiAgRXhwb3J0RGVmYXVsdEZyb21Bc0lkZW50aWZpZXI6IFwiJ2Zyb20nIGlzIG5vdCBhbGxvd2VkIGFzIGFuIGlkZW50aWZpZXIgYWZ0ZXIgJ2V4cG9ydCBkZWZhdWx0J1wiLFxuICBGb3JJbk9mTG9vcEluaXRpYWxpemVyOiBcIiUwIGxvb3AgdmFyaWFibGUgZGVjbGFyYXRpb24gbWF5IG5vdCBoYXZlIGFuIGluaXRpYWxpemVyXCIsXG4gIEdlbmVyYXRvckluU2luZ2xlU3RhdGVtZW50Q29udGV4dDogXCJHZW5lcmF0b3JzIGNhbiBvbmx5IGJlIGRlY2xhcmVkIGF0IHRoZSB0b3AgbGV2ZWwgb3IgaW5zaWRlIGEgYmxvY2tcIixcbiAgSWxsZWdhbEJyZWFrQ29udGludWU6IFwiVW5zeW50YWN0aWMgJTBcIixcbiAgSWxsZWdhbExhbmd1YWdlTW9kZURpcmVjdGl2ZTogXCJJbGxlZ2FsICd1c2Ugc3RyaWN0JyBkaXJlY3RpdmUgaW4gZnVuY3Rpb24gd2l0aCBub24tc2ltcGxlIHBhcmFtZXRlciBsaXN0XCIsXG4gIElsbGVnYWxSZXR1cm46IFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvblwiLFxuICBJbXBvcnRDYWxsQXJndW1lbnRUcmFpbGluZ0NvbW1hOiBcIlRyYWlsaW5nIGNvbW1hIGlzIGRpc2FsbG93ZWQgaW5zaWRlIGltcG9ydCguLi4pIGFyZ3VtZW50c1wiLFxuICBJbXBvcnRDYWxsQXJpdHk6IFwiaW1wb3J0KCkgcmVxdWlyZXMgZXhhY3RseSAlMFwiLFxuICBJbXBvcnRDYWxsTm90TmV3RXhwcmVzc2lvbjogXCJDYW5ub3QgdXNlIG5ldyB3aXRoIGltcG9ydCguLi4pXCIsXG4gIEltcG9ydENhbGxTcHJlYWRBcmd1bWVudDogXCIuLi4gaXMgbm90IGFsbG93ZWQgaW4gaW1wb3J0KClcIixcbiAgSW1wb3J0TWV0YU91dHNpZGVNb2R1bGU6IGBpbXBvcnQubWV0YSBtYXkgYXBwZWFyIG9ubHkgd2l0aCAnc291cmNlVHlwZTogXCJtb2R1bGVcIidgLFxuICBJbXBvcnRPdXRzaWRlTW9kdWxlOiBgJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBhcHBlYXIgb25seSB3aXRoICdzb3VyY2VUeXBlOiBcIm1vZHVsZVwiJ2AsXG4gIEludmFsaWRCaWdJbnRMaXRlcmFsOiBcIkludmFsaWQgQmlnSW50TGl0ZXJhbFwiLFxuICBJbnZhbGlkQ29kZVBvaW50OiBcIkNvZGUgcG9pbnQgb3V0IG9mIGJvdW5kc1wiLFxuICBJbnZhbGlkRGlnaXQ6IFwiRXhwZWN0ZWQgbnVtYmVyIGluIHJhZGl4ICUwXCIsXG4gIEludmFsaWRFc2NhcGVTZXF1ZW5jZTogXCJCYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZVwiLFxuICBJbnZhbGlkRXNjYXBlU2VxdWVuY2VUZW1wbGF0ZTogXCJJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZSBpbiB0ZW1wbGF0ZVwiLFxuICBJbnZhbGlkRXNjYXBlZFJlc2VydmVkV29yZDogXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCAlMFwiLFxuICBJbnZhbGlkSWRlbnRpZmllcjogXCJJbnZhbGlkIGlkZW50aWZpZXIgJTBcIixcbiAgSW52YWxpZExoczogXCJJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluICUwXCIsXG4gIEludmFsaWRMaHNCaW5kaW5nOiBcIkJpbmRpbmcgaW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiAlMFwiLFxuICBJbnZhbGlkTnVtYmVyOiBcIkludmFsaWQgbnVtYmVyXCIsXG4gIEludmFsaWRPclVuZXhwZWN0ZWRUb2tlbjogXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnJTAnXCIsXG4gIEludmFsaWRQYXJlbnRoZXNpemVkQXNzaWdubWVudDogXCJJbnZhbGlkIHBhcmVudGhlc2l6ZWQgYXNzaWdubWVudCBwYXR0ZXJuXCIsXG4gIEludmFsaWRQcml2YXRlRmllbGRSZXNvbHV0aW9uOiBcIlByaXZhdGUgbmFtZSAjJTAgaXMgbm90IGRlZmluZWRcIixcbiAgSW52YWxpZFByb3BlcnR5QmluZGluZ1BhdHRlcm46IFwiQmluZGluZyBtZW1iZXIgZXhwcmVzc2lvblwiLFxuICBJbnZhbGlkUmVjb3JkUHJvcGVydHk6IFwiT25seSBwcm9wZXJ0aWVzIGFuZCBzcHJlYWQgZWxlbWVudHMgYXJlIGFsbG93ZWQgaW4gcmVjb3JkIGRlZmluaXRpb25zXCIsXG4gIEludmFsaWRSZXN0QXNzaWdubWVudFBhdHRlcm46IFwiSW52YWxpZCByZXN0IG9wZXJhdG9yJ3MgYXJndW1lbnRcIixcbiAgTGFiZWxSZWRlY2xhcmF0aW9uOiBcIkxhYmVsICclMCcgaXMgYWxyZWFkeSBkZWNsYXJlZFwiLFxuICBMZXRJbkxleGljYWxCaW5kaW5nOiBcIidsZXQnIGlzIG5vdCBhbGxvd2VkIHRvIGJlIHVzZWQgYXMgYSBuYW1lIGluICdsZXQnIG9yICdjb25zdCcgZGVjbGFyYXRpb25zLlwiLFxuICBNYWxmb3JtZWRSZWdFeHBGbGFnczogXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnXCIsXG4gIE1pc3NpbmdDbGFzc05hbWU6IFwiQSBjbGFzcyBuYW1lIGlzIHJlcXVpcmVkXCIsXG4gIE1pc3NpbmdFcUluQXNzaWdubWVudDogXCJPbmx5ICc9JyBvcGVyYXRvciBjYW4gYmUgdXNlZCBmb3Igc3BlY2lmeWluZyBkZWZhdWx0IHZhbHVlLlwiLFxuICBNaXNzaW5nVW5pY29kZUVzY2FwZTogXCJFeHBlY3RpbmcgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UgXFxcXHVYWFhYXCIsXG4gIE1peGluZ0NvYWxlc2NlV2l0aExvZ2ljYWw6IFwiTnVsbGlzaCBjb2FsZXNjaW5nIG9wZXJhdG9yKD8/KSByZXF1aXJlcyBwYXJlbnMgd2hlbiBtaXhpbmcgd2l0aCBsb2dpY2FsIG9wZXJhdG9yc1wiLFxuICBNb2R1bGVBdHRyaWJ1dGVEaWZmZXJlbnRGcm9tVHlwZTogXCJUaGUgb25seSBhY2NlcHRlZCBtb2R1bGUgYXR0cmlidXRlIGlzIGB0eXBlYFwiLFxuICBNb2R1bGVBdHRyaWJ1dGVJbnZhbGlkVmFsdWU6IFwiT25seSBzdHJpbmcgbGl0ZXJhbHMgYXJlIGFsbG93ZWQgYXMgbW9kdWxlIGF0dHJpYnV0ZSB2YWx1ZXNcIixcbiAgTW9kdWxlQXR0cmlidXRlc1dpdGhEdXBsaWNhdGVLZXlzOiAnRHVwbGljYXRlIGtleSBcIiUwXCIgaXMgbm90IGFsbG93ZWQgaW4gbW9kdWxlIGF0dHJpYnV0ZXMnLFxuICBNb2R1bGVFeHBvcnRVbmRlZmluZWQ6IFwiRXhwb3J0ICclMCcgaXMgbm90IGRlZmluZWRcIixcbiAgTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoOiBcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiLFxuICBOZXdsaW5lQWZ0ZXJUaHJvdzogXCJJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3dcIixcbiAgTm9DYXRjaE9yRmluYWxseTogXCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlXCIsXG4gIE51bWJlcklkZW50aWZpZXI6IFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIixcbiAgTnVtZXJpY1NlcGFyYXRvckluRXNjYXBlU2VxdWVuY2U6IFwiTnVtZXJpYyBzZXBhcmF0b3JzIGFyZSBub3QgYWxsb3dlZCBpbnNpZGUgdW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzIG9yIGhleCBlc2NhcGUgc2VxdWVuY2VzXCIsXG4gIE9ic29sZXRlQXdhaXRTdGFyOiBcImF3YWl0KiBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIGFzeW5jIGZ1bmN0aW9ucyBwcm9wb3NhbC4gVXNlIFByb21pc2UuYWxsKCkgaW5zdGVhZC5cIixcbiAgT3B0aW9uYWxDaGFpbmluZ05vTmV3OiBcImNvbnN0cnVjdG9ycyBpbi9hZnRlciBhbiBPcHRpb25hbCBDaGFpbiBhcmUgbm90IGFsbG93ZWRcIixcbiAgT3B0aW9uYWxDaGFpbmluZ05vVGVtcGxhdGU6IFwiVGFnZ2VkIFRlbXBsYXRlIExpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiBvcHRpb25hbENoYWluXCIsXG4gIFBhcmFtRHVwZTogXCJBcmd1bWVudCBuYW1lIGNsYXNoXCIsXG4gIFBhdHRlcm5IYXNBY2Nlc3NvcjogXCJPYmplY3QgcGF0dGVybiBjYW4ndCBjb250YWluIGdldHRlciBvciBzZXR0ZXJcIixcbiAgUGF0dGVybkhhc01ldGhvZDogXCJPYmplY3QgcGF0dGVybiBjYW4ndCBjb250YWluIG1ldGhvZHNcIixcbiAgUGlwZWxpbmVCb2R5Tm9BcnJvdzogJ1VuZXhwZWN0ZWQgYXJyb3cgXCI9PlwiIGFmdGVyIHBpcGVsaW5lIGJvZHk7IGFycm93IGZ1bmN0aW9uIGluIHBpcGVsaW5lIGJvZHkgbXVzdCBiZSBwYXJlbnRoZXNpemVkJyxcbiAgUGlwZWxpbmVCb2R5U2VxdWVuY2VFeHByZXNzaW9uOiBcIlBpcGVsaW5lIGJvZHkgbWF5IG5vdCBiZSBhIGNvbW1hLXNlcGFyYXRlZCBzZXF1ZW5jZSBleHByZXNzaW9uXCIsXG4gIFBpcGVsaW5lSGVhZFNlcXVlbmNlRXhwcmVzc2lvbjogXCJQaXBlbGluZSBoZWFkIHNob3VsZCBub3QgYmUgYSBjb21tYS1zZXBhcmF0ZWQgc2VxdWVuY2UgZXhwcmVzc2lvblwiLFxuICBQaXBlbGluZVRvcGljVW51c2VkOiBcIlBpcGVsaW5lIGlzIGluIHRvcGljIHN0eWxlIGJ1dCBkb2VzIG5vdCB1c2UgdG9waWMgcmVmZXJlbmNlXCIsXG4gIFByaW1hcnlUb3BpY05vdEFsbG93ZWQ6IFwiVG9waWMgcmVmZXJlbmNlIHdhcyB1c2VkIGluIGEgbGV4aWNhbCBjb250ZXh0IHdpdGhvdXQgdG9waWMgYmluZGluZ1wiLFxuICBQcmltYXJ5VG9waWNSZXF1aXJlc1NtYXJ0UGlwZWxpbmU6IFwiUHJpbWFyeSBUb3BpYyBSZWZlcmVuY2UgZm91bmQgYnV0IHBpcGVsaW5lT3BlcmF0b3Igbm90IHBhc3NlZCAnc21hcnQnIGZvciAncHJvcG9zYWwnIG9wdGlvbi5cIixcbiAgUHJpdmF0ZUluRXhwZWN0ZWRJbjogXCJQcml2YXRlIG5hbWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gcHJvcGVydHkgYWNjZXNzZXMgKGBvYmouIyUwYCkgb3IgaW4gYGluYCBleHByZXNzaW9ucyAoYCMlMCBpbiBvYmpgKVwiLFxuICBQcml2YXRlTmFtZVJlZGVjbGFyYXRpb246IFwiRHVwbGljYXRlIHByaXZhdGUgbmFtZSAjJTBcIixcbiAgUmVjb3JkRXhwcmVzc2lvbkJhckluY29ycmVjdEVuZFN5bnRheFR5cGU6IFwiUmVjb3JkIGV4cHJlc3Npb25zIGVuZGluZyB3aXRoICd8fScgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHRoZSAnc3ludGF4VHlwZScgb3B0aW9uIG9mIHRoZSAncmVjb3JkQW5kVHVwbGUnIHBsdWdpbiBpcyBzZXQgdG8gJ2JhcidcIixcbiAgUmVjb3JkRXhwcmVzc2lvbkJhckluY29ycmVjdFN0YXJ0U3ludGF4VHlwZTogXCJSZWNvcmQgZXhwcmVzc2lvbnMgc3RhcnRpbmcgd2l0aCAne3wnIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiB0aGUgJ3N5bnRheFR5cGUnIG9wdGlvbiBvZiB0aGUgJ3JlY29yZEFuZFR1cGxlJyBwbHVnaW4gaXMgc2V0IHRvICdiYXInXCIsXG4gIFJlY29yZEV4cHJlc3Npb25IYXNoSW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlOiBcIlJlY29yZCBleHByZXNzaW9ucyBzdGFydGluZyB3aXRoICcjeycgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHRoZSAnc3ludGF4VHlwZScgb3B0aW9uIG9mIHRoZSAncmVjb3JkQW5kVHVwbGUnIHBsdWdpbiBpcyBzZXQgdG8gJ2hhc2gnXCIsXG4gIFJlY29yZE5vUHJvdG86IFwiJ19fcHJvdG9fXycgaXMgbm90IGFsbG93ZWQgaW4gUmVjb3JkIGV4cHJlc3Npb25zXCIsXG4gIFJlc3RUcmFpbGluZ0NvbW1hOiBcIlVuZXhwZWN0ZWQgdHJhaWxpbmcgY29tbWEgYWZ0ZXIgcmVzdCBlbGVtZW50XCIsXG4gIFNsb3BweUZ1bmN0aW9uOiBcIkluIG5vbi1zdHJpY3QgbW9kZSBjb2RlLCBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdG9wIGxldmVsLCBpbnNpZGUgYSBibG9jaywgb3IgYXMgdGhlIGJvZHkgb2YgYW4gaWYgc3RhdGVtZW50XCIsXG4gIFN0YXRpY1Byb3RvdHlwZTogXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgcHJvdG90eXBlXCIsXG4gIFN0cmljdERlbGV0ZTogXCJEZWxldGluZyBsb2NhbCB2YXJpYWJsZSBpbiBzdHJpY3QgbW9kZVwiLFxuICBTdHJpY3RFdmFsQXJndW1lbnRzOiBcIkFzc2lnbmluZyB0byAnJTAnIGluIHN0cmljdCBtb2RlXCIsXG4gIFN0cmljdEV2YWxBcmd1bWVudHNCaW5kaW5nOiBcIkJpbmRpbmcgJyUwJyBpbiBzdHJpY3QgbW9kZVwiLFxuICBTdHJpY3RGdW5jdGlvbjogXCJJbiBzdHJpY3QgbW9kZSBjb2RlLCBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdG9wIGxldmVsIG9yIGluc2lkZSBhIGJsb2NrXCIsXG4gIFN0cmljdE9jdGFsTGl0ZXJhbDogXCJMZWdhY3kgb2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlXCIsXG4gIFN0cmljdFdpdGg6IFwiJ3dpdGgnIGluIHN0cmljdCBtb2RlXCIsXG4gIFN1cGVyTm90QWxsb3dlZDogXCJzdXBlcigpIGlzIG9ubHkgdmFsaWQgaW5zaWRlIGEgY2xhc3MgY29uc3RydWN0b3Igb2YgYSBzdWJjbGFzcy4gTWF5YmUgYSB0eXBvIGluIHRoZSBtZXRob2QgbmFtZSAoJ2NvbnN0cnVjdG9yJykgb3Igbm90IGV4dGVuZGluZyBhbm90aGVyIGNsYXNzP1wiLFxuICBTdXBlclByaXZhdGVGaWVsZDogXCJQcml2YXRlIGZpZWxkcyBjYW4ndCBiZSBhY2Nlc3NlZCBvbiBzdXBlclwiLFxuICBUcmFpbGluZ0RlY29yYXRvcjogXCJEZWNvcmF0b3JzIG11c3QgYmUgYXR0YWNoZWQgdG8gYSBjbGFzcyBlbGVtZW50XCIsXG4gIFR1cGxlRXhwcmVzc2lvbkJhckluY29ycmVjdEVuZFN5bnRheFR5cGU6IFwiVHVwbGUgZXhwcmVzc2lvbnMgZW5kaW5nIHdpdGggJ3xdJyBhcmUgb25seSBhbGxvd2VkIHdoZW4gdGhlICdzeW50YXhUeXBlJyBvcHRpb24gb2YgdGhlICdyZWNvcmRBbmRUdXBsZScgcGx1Z2luIGlzIHNldCB0byAnYmFyJ1wiLFxuICBUdXBsZUV4cHJlc3Npb25CYXJJbmNvcnJlY3RTdGFydFN5bnRheFR5cGU6IFwiVHVwbGUgZXhwcmVzc2lvbnMgc3RhcnRpbmcgd2l0aCAnW3wnIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiB0aGUgJ3N5bnRheFR5cGUnIG9wdGlvbiBvZiB0aGUgJ3JlY29yZEFuZFR1cGxlJyBwbHVnaW4gaXMgc2V0IHRvICdiYXInXCIsXG4gIFR1cGxlRXhwcmVzc2lvbkhhc2hJbmNvcnJlY3RTdGFydFN5bnRheFR5cGU6IFwiVHVwbGUgZXhwcmVzc2lvbnMgc3RhcnRpbmcgd2l0aCAnI1snIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiB0aGUgJ3N5bnRheFR5cGUnIG9wdGlvbiBvZiB0aGUgJ3JlY29yZEFuZFR1cGxlJyBwbHVnaW4gaXMgc2V0IHRvICdoYXNoJ1wiLFxuICBVbmV4cGVjdGVkQXJndW1lbnRQbGFjZWhvbGRlcjogXCJVbmV4cGVjdGVkIGFyZ3VtZW50IHBsYWNlaG9sZGVyXCIsXG4gIFVuZXhwZWN0ZWRBd2FpdEFmdGVyUGlwZWxpbmVCb2R5OiAnVW5leHBlY3RlZCBcImF3YWl0XCIgYWZ0ZXIgcGlwZWxpbmUgYm9keTsgYXdhaXQgbXVzdCBoYXZlIHBhcmVudGhlc2VzIGluIG1pbmltYWwgcHJvcG9zYWwnLFxuICBVbmV4cGVjdGVkRGlnaXRBZnRlckhhc2g6IFwiVW5leHBlY3RlZCBkaWdpdCBhZnRlciBoYXNoIHRva2VuXCIsXG4gIFVuZXhwZWN0ZWRJbXBvcnRFeHBvcnQ6IFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBvbmx5IGFwcGVhciBhdCB0aGUgdG9wIGxldmVsXCIsXG4gIFVuZXhwZWN0ZWRLZXl3b3JkOiBcIlVuZXhwZWN0ZWQga2V5d29yZCAnJTAnXCIsXG4gIFVuZXhwZWN0ZWRMZWFkaW5nRGVjb3JhdG9yOiBcIkxlYWRpbmcgZGVjb3JhdG9ycyBtdXN0IGJlIGF0dGFjaGVkIHRvIGEgY2xhc3MgZGVjbGFyYXRpb25cIixcbiAgVW5leHBlY3RlZExleGljYWxEZWNsYXJhdGlvbjogXCJMZXhpY2FsIGRlY2xhcmF0aW9uIGNhbm5vdCBhcHBlYXIgaW4gYSBzaW5nbGUtc3RhdGVtZW50IGNvbnRleHRcIixcbiAgVW5leHBlY3RlZE5ld1RhcmdldDogXCJuZXcudGFyZ2V0IGNhbiBvbmx5IGJlIHVzZWQgaW4gZnVuY3Rpb25zXCIsXG4gIFVuZXhwZWN0ZWROdW1lcmljU2VwYXJhdG9yOiBcIkEgbnVtZXJpYyBzZXBhcmF0b3IgaXMgb25seSBhbGxvd2VkIGJldHdlZW4gdHdvIGRpZ2l0c1wiLFxuICBVbmV4cGVjdGVkUHJpdmF0ZUZpZWxkOiBcIlByaXZhdGUgbmFtZXMgY2FuIG9ubHkgYmUgdXNlZCBhcyB0aGUgbmFtZSBvZiBhIGNsYXNzIGVsZW1lbnQgKGkuZS4gY2xhc3MgQyB7ICNwID0gNDI7ICNtKCkge30gfSApXFxuIG9yIGEgcHJvcGVydHkgb2YgbWVtYmVyIGV4cHJlc3Npb24gKGkuZS4gdGhpcy4jcCkuXCIsXG4gIFVuZXhwZWN0ZWRSZXNlcnZlZFdvcmQ6IFwiVW5leHBlY3RlZCByZXNlcnZlZCB3b3JkICclMCdcIixcbiAgVW5leHBlY3RlZFN1cGVyOiBcInN1cGVyIGlzIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbWV0aG9kcyBhbmQgY2xhc3Nlc1wiLFxuICBVbmV4cGVjdGVkVG9rZW46IFwiVW5leHBlY3RlZCB0b2tlbiAnJTAnXCIsXG4gIFVuZXhwZWN0ZWRUb2tlblVuYXJ5RXhwb25lbnRpYXRpb246IFwiSWxsZWdhbCBleHByZXNzaW9uLiBXcmFwIGxlZnQgaGFuZCBzaWRlIG9yIGVudGlyZSBleHBvbmVudGlhdGlvbiBpbiBwYXJlbnRoZXNlcy5cIixcbiAgVW5zdXBwb3J0ZWRCaW5kOiBcIkJpbmRpbmcgc2hvdWxkIGJlIHBlcmZvcm1lZCBvbiBvYmplY3QgcHJvcGVydHkuXCIsXG4gIFVuc3VwcG9ydGVkRGVjb3JhdG9yRXhwb3J0OiBcIkEgZGVjb3JhdGVkIGV4cG9ydCBtdXN0IGV4cG9ydCBhIGNsYXNzIGRlY2xhcmF0aW9uXCIsXG4gIFVuc3VwcG9ydGVkRGVmYXVsdEV4cG9ydDogXCJPbmx5IGV4cHJlc3Npb25zLCBmdW5jdGlvbnMgb3IgY2xhc3NlcyBhcmUgYWxsb3dlZCBhcyB0aGUgYGRlZmF1bHRgIGV4cG9ydC5cIixcbiAgVW5zdXBwb3J0ZWRJbXBvcnQ6IFwiaW1wb3J0IGNhbiBvbmx5IGJlIHVzZWQgaW4gaW1wb3J0KCkgb3IgaW1wb3J0Lm1ldGFcIixcbiAgVW5zdXBwb3J0ZWRNZXRhUHJvcGVydHk6IFwiVGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgJTAgaXMgJTAuJTFcIixcbiAgVW5zdXBwb3J0ZWRQYXJhbWV0ZXJEZWNvcmF0b3I6IFwiRGVjb3JhdG9ycyBjYW5ub3QgYmUgdXNlZCB0byBkZWNvcmF0ZSBwYXJhbWV0ZXJzXCIsXG4gIFVuc3VwcG9ydGVkUHJvcGVydHlEZWNvcmF0b3I6IFwiRGVjb3JhdG9ycyBjYW5ub3QgYmUgdXNlZCB0byBkZWNvcmF0ZSBvYmplY3QgbGl0ZXJhbCBwcm9wZXJ0aWVzXCIsXG4gIFVuc3VwcG9ydGVkU3VwZXI6IFwic3VwZXIgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIGZ1bmN0aW9uIGNhbGxzIChpLmUuIHN1cGVyKCkpIG9yIGluIHByb3BlcnR5IGFjY2Vzc2VzIChpLmUuIHN1cGVyLnByb3Agb3Igc3VwZXJbcHJvcF0pXCIsXG4gIFVudGVybWluYXRlZENvbW1lbnQ6IFwiVW50ZXJtaW5hdGVkIGNvbW1lbnRcIixcbiAgVW50ZXJtaW5hdGVkUmVnRXhwOiBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIixcbiAgVW50ZXJtaW5hdGVkU3RyaW5nOiBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIixcbiAgVW50ZXJtaW5hdGVkVGVtcGxhdGU6IFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIsXG4gIFZhclJlZGVjbGFyYXRpb246IFwiSWRlbnRpZmllciAnJTAnIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWRcIixcbiAgWWllbGRCaW5kaW5nSWRlbnRpZmllcjogXCJDYW4gbm90IHVzZSAneWllbGQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGEgZ2VuZXJhdG9yXCIsXG4gIFlpZWxkSW5QYXJhbWV0ZXI6IFwieWllbGQgaXMgbm90IGFsbG93ZWQgaW4gZ2VuZXJhdG9yIHBhcmFtZXRlcnNcIixcbiAgWmVyb0RpZ2l0TnVtZXJpY1NlcGFyYXRvcjogXCJOdW1lcmljIHNlcGFyYXRvciBjYW4gbm90IGJlIHVzZWQgYWZ0ZXIgbGVhZGluZyAwXCJcbn0pO1xuXG5jbGFzcyBQYXJzZXJFcnJvciBleHRlbmRzIENvbW1lbnRzUGFyc2VyIHtcbiAgZ2V0TG9jYXRpb25Gb3JQb3NpdGlvbihwb3MpIHtcbiAgICBsZXQgbG9jO1xuICAgIGlmIChwb3MgPT09IHRoaXMuc3RhdGUuc3RhcnQpIGxvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7ZWxzZSBpZiAocG9zID09PSB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydCkgbG9jID0gdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2M7ZWxzZSBpZiAocG9zID09PSB0aGlzLnN0YXRlLmVuZCkgbG9jID0gdGhpcy5zdGF0ZS5lbmRMb2M7ZWxzZSBpZiAocG9zID09PSB0aGlzLnN0YXRlLmxhc3RUb2tFbmQpIGxvYyA9IHRoaXMuc3RhdGUubGFzdFRva0VuZExvYztlbHNlIGxvYyA9IGdldExpbmVJbmZvKHRoaXMuaW5wdXQsIHBvcyk7XG4gICAgcmV0dXJuIGxvYztcbiAgfVxuXG4gIHJhaXNlKHBvcywgZXJyb3JUZW1wbGF0ZSwgLi4ucGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMucmFpc2VXaXRoRGF0YShwb3MsIHVuZGVmaW5lZCwgZXJyb3JUZW1wbGF0ZSwgLi4ucGFyYW1zKTtcbiAgfVxuXG4gIHJhaXNlV2l0aERhdGEocG9zLCBkYXRhLCBlcnJvclRlbXBsYXRlLCAuLi5wYXJhbXMpIHtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmdldExvY2F0aW9uRm9yUG9zaXRpb24ocG9zKTtcbiAgICBjb25zdCBtZXNzYWdlID0gZXJyb3JUZW1wbGF0ZS5yZXBsYWNlKC8lKFxcZCspL2csIChfLCBpKSA9PiBwYXJhbXNbaV0pICsgYCAoJHtsb2MubGluZX06JHtsb2MuY29sdW1ufSlgO1xuICAgIHJldHVybiB0aGlzLl9yYWlzZShPYmplY3QuYXNzaWduKHtcbiAgICAgIGxvYyxcbiAgICAgIHBvc1xuICAgIH0sIGRhdGEpLCBtZXNzYWdlKTtcbiAgfVxuXG4gIF9yYWlzZShlcnJvckNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSk7XG4gICAgT2JqZWN0LmFzc2lnbihlcnIsIGVycm9yQ29udGV4dCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmVycm9yUmVjb3ZlcnkpIHtcbiAgICAgIGlmICghdGhpcy5pc0xvb2thaGVhZCkgdGhpcy5zdGF0ZS5lcnJvcnMucHVzaChlcnIpO1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGlzU2ltcGxlUHJvcGVydHkobm9kZSkge1xuICByZXR1cm4gbm9kZSAhPSBudWxsICYmIG5vZGUudHlwZSA9PT0gXCJQcm9wZXJ0eVwiICYmIG5vZGUua2luZCA9PT0gXCJpbml0XCIgJiYgbm9kZS5tZXRob2QgPT09IGZhbHNlO1xufVxuXG52YXIgZXN0cmVlID0gKHN1cGVyQ2xhc3MgPT4gY2xhc3MgZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgZXN0cmVlUGFyc2VSZWdFeHBMaXRlcmFsKHtcbiAgICBwYXR0ZXJuLFxuICAgIGZsYWdzXG4gIH0pIHtcbiAgICBsZXQgcmVnZXggPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmVzdHJlZVBhcnNlTGl0ZXJhbChyZWdleCk7XG4gICAgbm9kZS5yZWdleCA9IHtcbiAgICAgIHBhdHRlcm4sXG4gICAgICBmbGFnc1xuICAgIH07XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBlc3RyZWVQYXJzZUJpZ0ludExpdGVyYWwodmFsdWUpIHtcbiAgICBjb25zdCBiaWdJbnQgPSB0eXBlb2YgQmlnSW50ICE9PSBcInVuZGVmaW5lZFwiID8gQmlnSW50KHZhbHVlKSA6IG51bGw7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKGJpZ0ludCk7XG4gICAgbm9kZS5iaWdpbnQgPSBTdHJpbmcobm9kZS52YWx1ZSB8fCB2YWx1ZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBlc3RyZWVQYXJzZUxpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUsIFwiTGl0ZXJhbFwiKTtcbiAgfVxuXG4gIGRpcmVjdGl2ZVRvU3RtdChkaXJlY3RpdmUpIHtcbiAgICBjb25zdCBkaXJlY3RpdmVMaXRlcmFsID0gZGlyZWN0aXZlLnZhbHVlO1xuICAgIGNvbnN0IHN0bXQgPSB0aGlzLnN0YXJ0Tm9kZUF0KGRpcmVjdGl2ZS5zdGFydCwgZGlyZWN0aXZlLmxvYy5zdGFydCk7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IHRoaXMuc3RhcnROb2RlQXQoZGlyZWN0aXZlTGl0ZXJhbC5zdGFydCwgZGlyZWN0aXZlTGl0ZXJhbC5sb2Muc3RhcnQpO1xuICAgIGV4cHJlc3Npb24udmFsdWUgPSBkaXJlY3RpdmVMaXRlcmFsLnZhbHVlO1xuICAgIGV4cHJlc3Npb24ucmF3ID0gZGlyZWN0aXZlTGl0ZXJhbC5leHRyYS5yYXc7XG4gICAgc3RtdC5leHByZXNzaW9uID0gdGhpcy5maW5pc2hOb2RlQXQoZXhwcmVzc2lvbiwgXCJMaXRlcmFsXCIsIGRpcmVjdGl2ZUxpdGVyYWwuZW5kLCBkaXJlY3RpdmVMaXRlcmFsLmxvYy5lbmQpO1xuICAgIHN0bXQuZGlyZWN0aXZlID0gZGlyZWN0aXZlTGl0ZXJhbC5leHRyYS5yYXcuc2xpY2UoMSwgLTEpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGVBdChzdG10LCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiwgZGlyZWN0aXZlLmVuZCwgZGlyZWN0aXZlLmxvYy5lbmQpO1xuICB9XG5cbiAgaW5pdEZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMpIHtcbiAgICBzdXBlci5pbml0RnVuY3Rpb24obm9kZSwgaXNBc3luYyk7XG4gICAgbm9kZS5leHByZXNzaW9uID0gZmFsc2U7XG4gIH1cblxuICBjaGVja0RlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBpZiAoaXNTaW1wbGVQcm9wZXJ0eShub2RlKSkge1xuICAgICAgdGhpcy5jaGVja0RlY2xhcmF0aW9uKG5vZGUudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5jaGVja0RlY2xhcmF0aW9uKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrR2V0dGVyU2V0dGVyUGFyYW1zKG1ldGhvZCkge1xuICAgIGNvbnN0IHByb3AgPSBtZXRob2Q7XG4gICAgY29uc3QgcGFyYW1Db3VudCA9IHByb3Aua2luZCA9PT0gXCJnZXRcIiA/IDAgOiAxO1xuICAgIGNvbnN0IHN0YXJ0ID0gcHJvcC5zdGFydDtcblxuICAgIGlmIChwcm9wLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJnZXRcIikge1xuICAgICAgICB0aGlzLnJhaXNlKHN0YXJ0LCBFcnJvck1lc3NhZ2VzLkJhZEdldHRlckFyaXR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmFpc2Uoc3RhcnQsIEVycm9yTWVzc2FnZXMuQmFkU2V0dGVyQXJpdHkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcC5raW5kID09PSBcInNldFwiICYmIHByb3AudmFsdWUucGFyYW1zWzBdLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIikge1xuICAgICAgdGhpcy5yYWlzZShzdGFydCwgRXJyb3JNZXNzYWdlcy5CYWRTZXR0ZXJSZXN0UGFyYW1ldGVyKTtcbiAgICB9XG4gIH1cblxuICBjaGVja0xWYWwoZXhwciwgYmluZGluZ1R5cGUgPSBCSU5EX05PTkUsIGNoZWNrQ2xhc2hlcywgY29udGV4dERlc2NyaXB0aW9uLCBkaXNhbGxvd0xldEJpbmRpbmcpIHtcbiAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgICAgZXhwci5wcm9wZXJ0aWVzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgdGhpcy5jaGVja0xWYWwocHJvcC50eXBlID09PSBcIlByb3BlcnR5XCIgPyBwcm9wLnZhbHVlIDogcHJvcCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcywgXCJvYmplY3QgZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuXCIsIGRpc2FsbG93TGV0QmluZGluZyk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3VwZXIuY2hlY2tMVmFsKGV4cHIsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMsIGNvbnRleHREZXNjcmlwdGlvbiwgZGlzYWxsb3dMZXRCaW5kaW5nKTtcbiAgICB9XG4gIH1cblxuICBjaGVja1Byb3RvKHByb3AsIGlzUmVjb3JkLCBwcm90b1JlZiwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGlmIChwcm9wLm1ldGhvZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN1cGVyLmNoZWNrUHJvdG8ocHJvcCwgaXNSZWNvcmQsIHByb3RvUmVmLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgfVxuXG4gIGlzVmFsaWREaXJlY3RpdmUoc3RtdCkge1xuICAgIHZhciBfc3RtdCRleHByZXNzaW9uJGV4dHI7XG5cbiAgICByZXR1cm4gc3RtdC50eXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiAmJiBzdG10LmV4cHJlc3Npb24udHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYgdHlwZW9mIHN0bXQuZXhwcmVzc2lvbi52YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhKChfc3RtdCRleHByZXNzaW9uJGV4dHIgPSBzdG10LmV4cHJlc3Npb24uZXh0cmEpID09IG51bGwgPyB2b2lkIDAgOiBfc3RtdCRleHByZXNzaW9uJGV4dHIucGFyZW50aGVzaXplZCk7XG4gIH1cblxuICBzdG10VG9EaXJlY3RpdmUoc3RtdCkge1xuICAgIGNvbnN0IGRpcmVjdGl2ZSA9IHN1cGVyLnN0bXRUb0RpcmVjdGl2ZShzdG10KTtcbiAgICBjb25zdCB2YWx1ZSA9IHN0bXQuZXhwcmVzc2lvbi52YWx1ZTtcbiAgICBkaXJlY3RpdmUudmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gZGlyZWN0aXZlO1xuICB9XG5cbiAgcGFyc2VCbG9ja0JvZHkobm9kZSwgYWxsb3dEaXJlY3RpdmVzLCB0b3BMZXZlbCwgZW5kKSB7XG4gICAgc3VwZXIucGFyc2VCbG9ja0JvZHkobm9kZSwgYWxsb3dEaXJlY3RpdmVzLCB0b3BMZXZlbCwgZW5kKTtcbiAgICBjb25zdCBkaXJlY3RpdmVTdGF0ZW1lbnRzID0gbm9kZS5kaXJlY3RpdmVzLm1hcChkID0+IHRoaXMuZGlyZWN0aXZlVG9TdG10KGQpKTtcbiAgICBub2RlLmJvZHkgPSBkaXJlY3RpdmVTdGF0ZW1lbnRzLmNvbmNhdChub2RlLmJvZHkpO1xuICAgIGRlbGV0ZSBub2RlLmRpcmVjdGl2ZXM7XG4gIH1cblxuICBwdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd3NEaXJlY3RTdXBlcikge1xuICAgIHRoaXMucGFyc2VNZXRob2QobWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dzRGlyZWN0U3VwZXIsIFwiQ2xhc3NNZXRob2RcIiwgdHJ1ZSk7XG5cbiAgICBpZiAobWV0aG9kLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICBtZXRob2QudmFsdWUudHlwZVBhcmFtZXRlcnMgPSBtZXRob2QudHlwZVBhcmFtZXRlcnM7XG4gICAgICBkZWxldGUgbWV0aG9kLnR5cGVQYXJhbWV0ZXJzO1xuICAgIH1cblxuICAgIGNsYXNzQm9keS5ib2R5LnB1c2gobWV0aG9kKTtcbiAgfVxuXG4gIHBhcnNlRXhwckF0b20ocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIHR5cGVzLm51bTpcbiAgICAgIGNhc2UgdHlwZXMuc3RyaW5nOlxuICAgICAgICByZXR1cm4gdGhpcy5lc3RyZWVQYXJzZUxpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG5cbiAgICAgIGNhc2UgdHlwZXMucmVnZXhwOlxuICAgICAgICByZXR1cm4gdGhpcy5lc3RyZWVQYXJzZVJlZ0V4cExpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG5cbiAgICAgIGNhc2UgdHlwZXMuYmlnaW50OlxuICAgICAgICByZXR1cm4gdGhpcy5lc3RyZWVQYXJzZUJpZ0ludExpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG5cbiAgICAgIGNhc2UgdHlwZXMuX251bGw6XG4gICAgICAgIHJldHVybiB0aGlzLmVzdHJlZVBhcnNlTGl0ZXJhbChudWxsKTtcblxuICAgICAgY2FzZSB0eXBlcy5fdHJ1ZTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKHRydWUpO1xuXG4gICAgICBjYXNlIHR5cGVzLl9mYWxzZTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKGZhbHNlKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlRXhwckF0b20ocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VMaXRlcmFsKHZhbHVlLCB0eXBlLCBzdGFydFBvcywgc3RhcnRMb2MpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VMaXRlcmFsKHZhbHVlLCB0eXBlLCBzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUucmF3ID0gbm9kZS5leHRyYS5yYXc7XG4gICAgZGVsZXRlIG5vZGUuZXh0cmE7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBwYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb24sIGlzTWV0aG9kID0gZmFsc2UpIHtcbiAgICBzdXBlci5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb24sIGlzTWV0aG9kKTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSBub2RlLmJvZHkudHlwZSAhPT0gXCJCbG9ja1N0YXRlbWVudFwiO1xuICB9XG5cbiAgcGFyc2VNZXRob2Qobm9kZSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93RGlyZWN0U3VwZXIsIHR5cGUsIGluQ2xhc3NTY29wZSA9IGZhbHNlKSB7XG4gICAgbGV0IGZ1bmNOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBmdW5jTm9kZS5raW5kID0gbm9kZS5raW5kO1xuICAgIGZ1bmNOb2RlID0gc3VwZXIucGFyc2VNZXRob2QoZnVuY05vZGUsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd0RpcmVjdFN1cGVyLCB0eXBlLCBpbkNsYXNzU2NvcGUpO1xuICAgIGZ1bmNOb2RlLnR5cGUgPSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiO1xuICAgIGRlbGV0ZSBmdW5jTm9kZS5raW5kO1xuICAgIG5vZGUudmFsdWUgPSBmdW5jTm9kZTtcbiAgICB0eXBlID0gdHlwZSA9PT0gXCJDbGFzc01ldGhvZFwiID8gXCJNZXRob2REZWZpbml0aW9uXCIgOiB0eXBlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG4gIH1cblxuICBwYXJzZU9iamVjdE1ldGhvZChwcm9wLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuLCBjb250YWluc0VzYykge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5wYXJzZU9iamVjdE1ldGhvZChwcm9wLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuLCBjb250YWluc0VzYyk7XG5cbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZS50eXBlID0gXCJQcm9wZXJ0eVwiO1xuICAgICAgaWYgKG5vZGUua2luZCA9PT0gXCJtZXRob2RcIikgbm9kZS5raW5kID0gXCJpbml0XCI7XG4gICAgICBub2RlLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcGFyc2VPYmplY3RQcm9wZXJ0eShwcm9wLCBzdGFydFBvcywgc3RhcnRMb2MsIGlzUGF0dGVybiwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5wYXJzZU9iamVjdFByb3BlcnR5KHByb3AsIHN0YXJ0UG9zLCBzdGFydExvYywgaXNQYXR0ZXJuLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcblxuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlLmtpbmQgPSBcImluaXRcIjtcbiAgICAgIG5vZGUudHlwZSA9IFwiUHJvcGVydHlcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHRvQXNzaWduYWJsZShub2RlKSB7XG4gICAgaWYgKGlzU2ltcGxlUHJvcGVydHkobm9kZSkpIHtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUudmFsdWUpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnRvQXNzaWduYWJsZShub2RlKTtcbiAgfVxuXG4gIHRvQXNzaWduYWJsZU9iamVjdEV4cHJlc3Npb25Qcm9wKHByb3AsIGlzTGFzdCkge1xuICAgIGlmIChwcm9wLmtpbmQgPT09IFwiZ2V0XCIgfHwgcHJvcC5raW5kID09PSBcInNldFwiKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKHByb3Aua2V5LnN0YXJ0LCBFcnJvck1lc3NhZ2VzLlBhdHRlcm5IYXNBY2Nlc3Nvcik7XG4gICAgfSBlbHNlIGlmIChwcm9wLm1ldGhvZCkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShwcm9wLmtleS5zdGFydCwgRXJyb3JNZXNzYWdlcy5QYXR0ZXJuSGFzTWV0aG9kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIudG9Bc3NpZ25hYmxlT2JqZWN0RXhwcmVzc2lvblByb3AocHJvcCwgaXNMYXN0KTtcbiAgICB9XG4gIH1cblxuICBmaW5pc2hDYWxsRXhwcmVzc2lvbihub2RlLCBvcHRpb25hbCkge1xuICAgIHN1cGVyLmZpbmlzaENhbGxFeHByZXNzaW9uKG5vZGUsIG9wdGlvbmFsKTtcblxuICAgIGlmIChub2RlLmNhbGxlZS50eXBlID09PSBcIkltcG9ydFwiKSB7XG4gICAgICBub2RlLnR5cGUgPSBcIkltcG9ydEV4cHJlc3Npb25cIjtcbiAgICAgIG5vZGUuc291cmNlID0gbm9kZS5hcmd1bWVudHNbMF07XG4gICAgICBkZWxldGUgbm9kZS5hcmd1bWVudHM7XG4gICAgICBkZWxldGUgbm9kZS5jYWxsZWU7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIikge1xuICAgICAgbm9kZS5vcHRpb25hbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdG9SZWZlcmVuY2VkTGlzdERlZXAoZXhwckxpc3QsIGlzUGFyZW50aGVzaXplZEV4cHIpIHtcbiAgICBpZiAoIWV4cHJMaXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3VwZXIudG9SZWZlcmVuY2VkTGlzdERlZXAoZXhwckxpc3QsIGlzUGFyZW50aGVzaXplZEV4cHIpO1xuICB9XG5cbiAgcGFyc2VFeHBvcnQobm9kZSkge1xuICAgIHN1cGVyLnBhcnNlRXhwb3J0KG5vZGUpO1xuXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiOlxuICAgICAgICBub2RlLmV4cG9ydGVkID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCI6XG4gICAgICAgIGlmIChub2RlLnNwZWNpZmllcnMubGVuZ3RoID09PSAxICYmIG5vZGUuc3BlY2lmaWVyc1swXS50eXBlID09PSBcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSB7XG4gICAgICAgICAgbm9kZS50eXBlID0gXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiO1xuICAgICAgICAgIG5vZGUuZXhwb3J0ZWQgPSBub2RlLnNwZWNpZmllcnNbMF0uZXhwb3J0ZWQ7XG4gICAgICAgICAgZGVsZXRlIG5vZGUuc3BlY2lmaWVycztcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcGFyc2VTdWJzY3JpcHQoLi4uYXJncykge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5wYXJzZVN1YnNjcmlwdCguLi5hcmdzKTtcblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICBub2RlLm9wdGlvbmFsID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxufSk7XG5cbmNsYXNzIFRva0NvbnRleHQge1xuICBjb25zdHJ1Y3Rvcih0b2tlbiwgaXNFeHByLCBwcmVzZXJ2ZVNwYWNlLCBvdmVycmlkZSkge1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB0aGlzLmlzRXhwciA9ICEhaXNFeHByO1xuICAgIHRoaXMucHJlc2VydmVTcGFjZSA9ICEhcHJlc2VydmVTcGFjZTtcbiAgICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gIH1cblxufVxuY29uc3QgdHlwZXMkMSA9IHtcbiAgYnJhY2VTdGF0ZW1lbnQ6IG5ldyBUb2tDb250ZXh0KFwie1wiLCBmYWxzZSksXG4gIGJyYWNlRXhwcmVzc2lvbjogbmV3IFRva0NvbnRleHQoXCJ7XCIsIHRydWUpLFxuICB0ZW1wbGF0ZVF1YXNpOiBuZXcgVG9rQ29udGV4dChcIiR7XCIsIGZhbHNlKSxcbiAgcGFyZW5TdGF0ZW1lbnQ6IG5ldyBUb2tDb250ZXh0KFwiKFwiLCBmYWxzZSksXG4gIHBhcmVuRXhwcmVzc2lvbjogbmV3IFRva0NvbnRleHQoXCIoXCIsIHRydWUpLFxuICB0ZW1wbGF0ZTogbmV3IFRva0NvbnRleHQoXCJgXCIsIHRydWUsIHRydWUsIHAgPT4gcC5yZWFkVG1wbFRva2VuKCkpLFxuICBmdW5jdGlvbkV4cHJlc3Npb246IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgdHJ1ZSksXG4gIGZ1bmN0aW9uU3RhdGVtZW50OiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlKVxufTtcblxudHlwZXMucGFyZW5SLnVwZGF0ZUNvbnRleHQgPSB0eXBlcy5icmFjZVIudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3RhdGUuY29udGV4dC5sZW5ndGggPT09IDEpIHtcbiAgICB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgb3V0ID0gdGhpcy5zdGF0ZS5jb250ZXh0LnBvcCgpO1xuXG4gIGlmIChvdXQgPT09IHR5cGVzJDEuYnJhY2VTdGF0ZW1lbnQgJiYgdGhpcy5jdXJDb250ZXh0KCkudG9rZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIG91dCA9IHRoaXMuc3RhdGUuY29udGV4dC5wb3AoKTtcbiAgfVxuXG4gIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSAhb3V0LmlzRXhwcjtcbn07XG5cbnR5cGVzLm5hbWUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uIChwcmV2VHlwZSkge1xuICBsZXQgYWxsb3dlZCA9IGZhbHNlO1xuXG4gIGlmIChwcmV2VHlwZSAhPT0gdHlwZXMuZG90KSB7XG4gICAgaWYgKHRoaXMuc3RhdGUudmFsdWUgPT09IFwib2ZcIiAmJiAhdGhpcy5zdGF0ZS5leHByQWxsb3dlZCAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuX2Z1bmN0aW9uICYmIHByZXZUeXBlICE9PSB0eXBlcy5fY2xhc3MgfHwgdGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCJ5aWVsZFwiICYmIHRoaXMucHJvZFBhcmFtLmhhc1lpZWxkKSB7XG4gICAgICBhbGxvd2VkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkID0gYWxsb3dlZDtcblxuICBpZiAodGhpcy5zdGF0ZS5pc0l0ZXJhdG9yKSB7XG4gICAgdGhpcy5zdGF0ZS5pc0l0ZXJhdG9yID0gZmFsc2U7XG4gIH1cbn07XG5cbnR5cGVzLmJyYWNlTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKHByZXZUeXBlKSB7XG4gIHRoaXMuc3RhdGUuY29udGV4dC5wdXNoKHRoaXMuYnJhY2VJc0Jsb2NrKHByZXZUeXBlKSA/IHR5cGVzJDEuYnJhY2VTdGF0ZW1lbnQgOiB0eXBlcyQxLmJyYWNlRXhwcmVzc2lvbik7XG4gIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMuZG9sbGFyQnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc3RhdGUuY29udGV4dC5wdXNoKHR5cGVzJDEudGVtcGxhdGVRdWFzaSk7XG4gIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMucGFyZW5MLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAocHJldlR5cGUpIHtcbiAgY29uc3Qgc3RhdGVtZW50UGFyZW5zID0gcHJldlR5cGUgPT09IHR5cGVzLl9pZiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX2ZvciB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX3dpdGggfHwgcHJldlR5cGUgPT09IHR5cGVzLl93aGlsZTtcbiAgdGhpcy5zdGF0ZS5jb250ZXh0LnB1c2goc3RhdGVtZW50UGFyZW5zID8gdHlwZXMkMS5wYXJlblN0YXRlbWVudCA6IHR5cGVzJDEucGFyZW5FeHByZXNzaW9uKTtcbiAgdGhpcy5zdGF0ZS5leHByQWxsb3dlZCA9IHRydWU7XG59O1xuXG50eXBlcy5pbmNEZWMudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHt9O1xuXG50eXBlcy5fZnVuY3Rpb24udXBkYXRlQ29udGV4dCA9IHR5cGVzLl9jbGFzcy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKHByZXZUeXBlKSB7XG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuZG90IHx8IHByZXZUeXBlID09PSB0eXBlcy5xdWVzdGlvbkRvdCkgOyBlbHNlIGlmIChwcmV2VHlwZS5iZWZvcmVFeHByICYmIHByZXZUeXBlICE9PSB0eXBlcy5zZW1pICYmIHByZXZUeXBlICE9PSB0eXBlcy5fZWxzZSAmJiAhKHByZXZUeXBlID09PSB0eXBlcy5fcmV0dXJuICYmIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGF0ZS5sYXN0VG9rRW5kLCB0aGlzLnN0YXRlLnN0YXJ0KSkpICYmICEoKHByZXZUeXBlID09PSB0eXBlcy5jb2xvbiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuYnJhY2VMKSAmJiB0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMkMS5iX3N0YXQpKSB7XG4gICAgdGhpcy5zdGF0ZS5jb250ZXh0LnB1c2godHlwZXMkMS5mdW5jdGlvbkV4cHJlc3Npb24pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc3RhdGUuY29udGV4dC5wdXNoKHR5cGVzJDEuZnVuY3Rpb25TdGF0ZW1lbnQpO1xuICB9XG5cbiAgdGhpcy5zdGF0ZS5leHByQWxsb3dlZCA9IGZhbHNlO1xufTtcblxudHlwZXMuYmFja1F1b3RlLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMkMS50ZW1wbGF0ZSkge1xuICAgIHRoaXMuc3RhdGUuY29udGV4dC5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YXRlLmNvbnRleHQucHVzaCh0eXBlcyQxLnRlbXBsYXRlKTtcbiAgfVxuXG4gIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSBmYWxzZTtcbn07XG5cbnR5cGVzLnN0YXIudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zdGF0ZS5leHByQWxsb3dlZCA9IGZhbHNlO1xufTtcblxubGV0IG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzN2ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyZlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYwLVxcdTA1ODhcXHUwNWQwLVxcdTA1ZWFcXHUwNWVmLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDg2MC1cXHUwODZhXFx1MDhhMC1cXHUwOGI0XFx1MDhiNi1cXHUwOGM3XFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwOWZjXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGFmOVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzM5XFx1MGMzZFxcdTBjNTgtXFx1MGM1YVxcdTBjNjBcXHUwYzYxXFx1MGM4MFxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDQtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4Ni1cXHUwZThhXFx1MGU4Yy1cXHUwZWEzXFx1MGVhNVxcdTBlYTctXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y1XFx1MTNmOC1cXHUxM2ZkXFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmY4XFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFlXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTliMC1cXHUxOWM5XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWM4MC1cXHUxYzg4XFx1MWM5MC1cXHUxY2JhXFx1MWNiZC1cXHUxY2JmXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YzXFx1MWNmNVxcdTFjZjZcXHUxY2ZhXFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJmXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJmXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGJmXFx1NGUwMC1cXHU5ZmZjXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3YmZcXHVhN2MyLVxcdWE3Y2FcXHVhN2Y1LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE4ZmVcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YTllMC1cXHVhOWU0XFx1YTllNi1cXHVhOWVmXFx1YTlmYS1cXHVhOWZlXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2UtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWIzMC1cXHVhYjVhXFx1YWI1Yy1cXHVhYjY5XFx1YWI3MC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG5sZXQgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxcdTIwMGNcXHUyMDBkXFx4YjdcXHUwMzAwLVxcdTAzNmZcXHUwMzg3XFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDY0Yi1cXHUwNjY5XFx1MDY3MFxcdTA2ZDYtXFx1MDZkY1xcdTA2ZGYtXFx1MDZlNFxcdTA2ZTdcXHUwNmU4XFx1MDZlYS1cXHUwNmVkXFx1MDZmMC1cXHUwNmY5XFx1MDcxMVxcdTA3MzAtXFx1MDc0YVxcdTA3YTYtXFx1MDdiMFxcdTA3YzAtXFx1MDdjOVxcdTA3ZWItXFx1MDdmM1xcdTA3ZmRcXHUwODE2LVxcdTA4MTlcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwODU5LVxcdTA4NWJcXHUwOGQzLVxcdTA4ZTFcXHUwOGUzLVxcdTA5MDNcXHUwOTNhLVxcdTA5M2NcXHUwOTNlLVxcdTA5NGZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5NjYtXFx1MDk2ZlxcdTA5ODEtXFx1MDk4M1xcdTA5YmNcXHUwOWJlLVxcdTA5YzRcXHUwOWM3XFx1MDljOFxcdTA5Y2ItXFx1MDljZFxcdTA5ZDdcXHUwOWUyXFx1MDllM1xcdTA5ZTYtXFx1MDllZlxcdTA5ZmVcXHUwYTAxLVxcdTBhMDNcXHUwYTNjXFx1MGEzZS1cXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE2Ni1cXHUwYTcxXFx1MGE3NVxcdTBhODEtXFx1MGE4M1xcdTBhYmNcXHUwYWJlLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzlcXHUwYWNiLVxcdTBhY2RcXHUwYWUyXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBhZmEtXFx1MGFmZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTUtXFx1MGI1N1xcdTBiNjJcXHUwYjYzXFx1MGI2Ni1cXHUwYjZmXFx1MGI4MlxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDdcXHUwYmU2LVxcdTBiZWZcXHUwYzAwLVxcdTBjMDRcXHUwYzNlLVxcdTBjNDRcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjJcXHUwYzYzXFx1MGM2Ni1cXHUwYzZmXFx1MGM4MS1cXHUwYzgzXFx1MGNiY1xcdTBjYmUtXFx1MGNjNFxcdTBjYzYtXFx1MGNjOFxcdTBjY2EtXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMlxcdTBjZTNcXHUwY2U2LVxcdTBjZWZcXHUwZDAwLVxcdTBkMDNcXHUwZDNiXFx1MGQzY1xcdTBkM2UtXFx1MGQ0NFxcdTBkNDYtXFx1MGQ0OFxcdTBkNGEtXFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODEtXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRlNi1cXHUwZGVmXFx1MGRmMlxcdTBkZjNcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGViMVxcdTBlYjQtXFx1MGViY1xcdTBlYzgtXFx1MGVjZFxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxMzY5LVxcdTEzNzFcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWQwLVxcdTE5ZGFcXHUxYTE3LVxcdTFhMWJcXHUxYTU1LVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWIwLVxcdTFhYmRcXHUxYWJmXFx1MWFjMFxcdTFiMDAtXFx1MWIwNFxcdTFiMzQtXFx1MWI0NFxcdTFiNTAtXFx1MWI1OVxcdTFiNmItXFx1MWI3M1xcdTFiODAtXFx1MWI4MlxcdTFiYTEtXFx1MWJhZFxcdTFiYjAtXFx1MWJiOVxcdTFiZTYtXFx1MWJmM1xcdTFjMjQtXFx1MWMzN1xcdTFjNDAtXFx1MWM0OVxcdTFjNTAtXFx1MWM1OVxcdTFjZDAtXFx1MWNkMlxcdTFjZDQtXFx1MWNlOFxcdTFjZWRcXHUxY2Y0XFx1MWNmNy1cXHUxY2Y5XFx1MWRjMC1cXHUxZGY5XFx1MWRmYi1cXHUxZGZmXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkN2ZcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdWE2MjAtXFx1YTYyOVxcdWE2NmZcXHVhNjc0LVxcdWE2N2RcXHVhNjllXFx1YTY5ZlxcdWE2ZjBcXHVhNmYxXFx1YTgwMlxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTgyY1xcdWE4ODBcXHVhODgxXFx1YThiNC1cXHVhOGM1XFx1YThkMC1cXHVhOGQ5XFx1YThlMC1cXHVhOGYxXFx1YThmZi1cXHVhOTA5XFx1YTkyNi1cXHVhOTJkXFx1YTk0Ny1cXHVhOTUzXFx1YTk4MC1cXHVhOTgzXFx1YTliMy1cXHVhOWMwXFx1YTlkMC1cXHVhOWQ5XFx1YTllNVxcdWE5ZjAtXFx1YTlmOVxcdWFhMjktXFx1YWEzNlxcdWFhNDNcXHVhYTRjXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2ItXFx1YWE3ZFxcdWFhYjBcXHVhYWIyLVxcdWFhYjRcXHVhYWI3XFx1YWFiOFxcdWFhYmVcXHVhYWJmXFx1YWFjMVxcdWFhZWItXFx1YWFlZlxcdWFhZjVcXHVhYWY2XFx1YWJlMy1cXHVhYmVhXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVmYjFlXFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTJmXFx1ZmUzM1xcdWZlMzRcXHVmZTRkLVxcdWZlNGZcXHVmZjEwLVxcdWZmMTlcXHVmZjNmXCI7XG5jb25zdCBub25BU0NJSWlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgXCJdXCIpO1xuY29uc3Qgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcbm5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IG51bGw7XG5jb25zdCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcyA9IFswLCAxMSwgMiwgMjUsIDIsIDE4LCAyLCAxLCAyLCAxNCwgMywgMTMsIDM1LCAxMjIsIDcwLCA1MiwgMjY4LCAyOCwgNCwgNDgsIDQ4LCAzMSwgMTQsIDI5LCA2LCAzNywgMTEsIDI5LCAzLCAzNSwgNSwgNywgMiwgNCwgNDMsIDE1NywgMTksIDM1LCA1LCAzNSwgNSwgMzksIDksIDUxLCAxNTcsIDMxMCwgMTAsIDIxLCAxMSwgNywgMTUzLCA1LCAzLCAwLCAyLCA0MywgMiwgMSwgNCwgMCwgMywgMjIsIDExLCAyMiwgMTAsIDMwLCA2NiwgMTgsIDIsIDEsIDExLCAyMSwgMTEsIDI1LCA3MSwgNTUsIDcsIDEsIDY1LCAwLCAxNiwgMywgMiwgMiwgMiwgMjgsIDQzLCAyOCwgNCwgMjgsIDM2LCA3LCAyLCAyNywgMjgsIDUzLCAxMSwgMjEsIDExLCAxOCwgMTQsIDE3LCAxMTEsIDcyLCA1NiwgNTAsIDE0LCA1MCwgMTQsIDM1LCAzNDksIDQxLCA3LCAxLCA3OSwgMjgsIDExLCAwLCA5LCAyMSwgMTA3LCAyMCwgMjgsIDIyLCAxMywgNTIsIDc2LCA0NCwgMzMsIDI0LCAyNywgMzUsIDMwLCAwLCAzLCAwLCA5LCAzNCwgNCwgMCwgMTMsIDQ3LCAxNSwgMywgMjIsIDAsIDIsIDAsIDM2LCAxNywgMiwgMjQsIDg1LCA2LCAyLCAwLCAyLCAzLCAyLCAxNCwgMiwgOSwgOCwgNDYsIDM5LCA3LCAzLCAxLCAzLCAyMSwgMiwgNiwgMiwgMSwgMiwgNCwgNCwgMCwgMTksIDAsIDEzLCA0LCAxNTksIDUyLCAxOSwgMywgMjEsIDIsIDMxLCA0NywgMjEsIDEsIDIsIDAsIDE4NSwgNDYsIDQyLCAzLCAzNywgNDcsIDIxLCAwLCA2MCwgNDIsIDE0LCAwLCA3MiwgMjYsIDIzMCwgNDMsIDExNywgNjMsIDMyLCA3LCAzLCAwLCAzLCA3LCAyLCAxLCAyLCAyMywgMTYsIDAsIDIsIDAsIDk1LCA3LCAzLCAzOCwgMTcsIDAsIDIsIDAsIDI5LCAwLCAxMSwgMzksIDgsIDAsIDIyLCAwLCAxMiwgNDUsIDIwLCAwLCAzNSwgNTYsIDI2NCwgOCwgMiwgMzYsIDE4LCAwLCA1MCwgMjksIDExMywgNiwgMiwgMSwgMiwgMzcsIDIyLCAwLCAyNiwgNSwgMiwgMSwgMiwgMzEsIDE1LCAwLCAzMjgsIDE4LCAxOTAsIDAsIDgwLCA5MjEsIDEwMywgMTEwLCAxOCwgMTk1LCAyNzQ5LCAxMDcwLCA0MDUwLCA1ODIsIDg2MzQsIDU2OCwgOCwgMzAsIDExNCwgMjksIDE5LCA0NywgMTcsIDMsIDMyLCAyMCwgNiwgMTgsIDY4OSwgNjMsIDEyOSwgNzQsIDYsIDAsIDY3LCAxMiwgNjUsIDEsIDIsIDAsIDI5LCA2MTM1LCA5LCAxMjM3LCA0MywgOCwgODk1MiwgMjg2LCA1MCwgMiwgMTgsIDMsIDksIDM5NSwgMjMwOSwgMTA2LCA2LCAxMiwgNCwgOCwgOCwgOSwgNTk5MSwgODQsIDIsIDcwLCAyLCAxLCAzLCAwLCAzLCAxLCAzLCAzLCAyLCAxMSwgMiwgMCwgMiwgNiwgMiwgNjQsIDIsIDMsIDMsIDcsIDIsIDYsIDIsIDI3LCAyLCAzLCAyLCA0LCAyLCAwLCA0LCA2LCAyLCAzMzksIDMsIDI0LCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCA3LCAyMzU3LCA0NCwgMTEsIDYsIDE3LCAwLCAzNzAsIDQzLCAxMzAxLCAxOTYsIDYwLCA2NywgOCwgMCwgMTIwNSwgMywgMiwgMjYsIDIsIDEsIDIsIDAsIDMsIDAsIDIsIDksIDIsIDMsIDIsIDAsIDIsIDAsIDcsIDAsIDUsIDAsIDIsIDAsIDIsIDAsIDIsIDIsIDIsIDEsIDIsIDAsIDMsIDAsIDIsIDAsIDIsIDAsIDIsIDAsIDIsIDAsIDIsIDEsIDIsIDAsIDMsIDMsIDIsIDYsIDIsIDMsIDIsIDMsIDIsIDAsIDIsIDksIDIsIDE2LCA2LCAyLCAyLCA0LCAyLCAxNiwgNDQyMSwgNDI3MTcsIDM1LCA0MTQ4LCAxMiwgMjIxLCAzLCA1NzYxLCAxNSwgNzQ3MiwgMzEwNCwgNTQxLCAxNTA3LCA0OTM4XTtcbmNvbnN0IGFzdHJhbElkZW50aWZpZXJDb2RlcyA9IFs1MDksIDAsIDIyNywgMCwgMTUwLCA0LCAyOTQsIDksIDEzNjgsIDIsIDIsIDEsIDYsIDMsIDQxLCAyLCA1LCAwLCAxNjYsIDEsIDU3NCwgMywgOSwgOSwgMzcwLCAxLCAxNTQsIDEwLCAxNzYsIDIsIDU0LCAxNCwgMzIsIDksIDE2LCAzLCA0NiwgMTAsIDU0LCA5LCA3LCAyLCAzNywgMTMsIDIsIDksIDYsIDEsIDQ1LCAwLCAxMywgMiwgNDksIDEzLCA5LCAzLCAyLCAxMSwgODMsIDExLCA3LCAwLCAxNjEsIDExLCA2LCA5LCA3LCAzLCA1NiwgMSwgMiwgNiwgMywgMSwgMywgMiwgMTAsIDAsIDExLCAxLCAzLCA2LCA0LCA0LCAxOTMsIDE3LCAxMCwgOSwgNSwgMCwgODIsIDE5LCAxMywgOSwgMjE0LCA2LCAzLCA4LCAyOCwgMSwgODMsIDE2LCAxNiwgOSwgODIsIDEyLCA5LCA5LCA4NCwgMTQsIDUsIDksIDI0MywgMTQsIDE2NiwgOSwgNzEsIDUsIDIsIDEsIDMsIDMsIDIsIDAsIDIsIDEsIDEzLCA5LCAxMjAsIDYsIDMsIDYsIDQsIDAsIDI5LCA5LCA0MSwgNiwgMiwgMywgOSwgMCwgMTAsIDEwLCA0NywgMTUsIDQwNiwgNywgMiwgNywgMTcsIDksIDU3LCAyMSwgMiwgMTMsIDEyMywgNSwgNCwgMCwgMiwgMSwgMiwgNiwgMiwgMCwgOSwgOSwgNDksIDQsIDIsIDEsIDIsIDQsIDksIDksIDMzMCwgMywgMTkzMDYsIDksIDEzNSwgNCwgNjAsIDYsIDI2LCA5LCAxMDE0LCAwLCAyLCA1NCwgOCwgMywgODIsIDAsIDEyLCAxLCAxOTYyOCwgMSwgNTMxOSwgNCwgNCwgNSwgOSwgNywgMywgNiwgMzEsIDMsIDE0OSwgMiwgMTQxOCwgNDksIDUxMywgNTQsIDUsIDQ5LCA5LCAwLCAxNSwgMCwgMjMsIDQsIDIsIDE0LCAxMzYxLCA2LCAyLCAxNiwgMywgNiwgMiwgMSwgMiwgNCwgMjYyLCA2LCAxMCwgOSwgNDE5LCAxMywgMTQ5NSwgNiwgMTEwLCA2LCA2LCA5LCA0NzU5LCA5LCA3ODc3MTksIDIzOV07XG5cbmZ1bmN0aW9uIGlzSW5Bc3RyYWxTZXQoY29kZSwgc2V0KSB7XG4gIGxldCBwb3MgPSAweDEwMDAwO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBzZXQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcbiAgICBwb3MgKz0gc2V0W2ldO1xuICAgIGlmIChwb3MgPiBjb2RlKSByZXR1cm4gZmFsc2U7XG4gICAgcG9zICs9IHNldFtpICsgMV07XG4gICAgaWYgKHBvcyA+PSBjb2RlKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSkge1xuICBpZiAoY29kZSA8IDY1KSByZXR1cm4gY29kZSA9PT0gMzY7XG4gIGlmIChjb2RlIDw9IDkwKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICBpZiAoY29kZSA8PSAxMjIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChjb2RlIDw9IDB4ZmZmZikge1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgfVxuXG4gIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKTtcbn1cbmZ1bmN0aW9uIGlzSWRlbnRpZmllckNoYXIoY29kZSkge1xuICBpZiAoY29kZSA8IDQ4KSByZXR1cm4gY29kZSA9PT0gMzY7XG4gIGlmIChjb2RlIDwgNTgpIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8IDY1KSByZXR1cm4gZmFsc2U7XG4gIGlmIChjb2RlIDw9IDkwKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICBpZiAoY29kZSA8PSAxMjIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChjb2RlIDw9IDB4ZmZmZikge1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gIH1cblxuICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcykgfHwgaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyQ29kZXMpO1xufVxuXG5jb25zdCByZXNlcnZlZFdvcmRzID0ge1xuICBrZXl3b3JkOiBbXCJicmVha1wiLCBcImNhc2VcIiwgXCJjYXRjaFwiLCBcImNvbnRpbnVlXCIsIFwiZGVidWdnZXJcIiwgXCJkZWZhdWx0XCIsIFwiZG9cIiwgXCJlbHNlXCIsIFwiZmluYWxseVwiLCBcImZvclwiLCBcImZ1bmN0aW9uXCIsIFwiaWZcIiwgXCJyZXR1cm5cIiwgXCJzd2l0Y2hcIiwgXCJ0aHJvd1wiLCBcInRyeVwiLCBcInZhclwiLCBcImNvbnN0XCIsIFwid2hpbGVcIiwgXCJ3aXRoXCIsIFwibmV3XCIsIFwidGhpc1wiLCBcInN1cGVyXCIsIFwiY2xhc3NcIiwgXCJleHRlbmRzXCIsIFwiZXhwb3J0XCIsIFwiaW1wb3J0XCIsIFwibnVsbFwiLCBcInRydWVcIiwgXCJmYWxzZVwiLCBcImluXCIsIFwiaW5zdGFuY2VvZlwiLCBcInR5cGVvZlwiLCBcInZvaWRcIiwgXCJkZWxldGVcIl0sXG4gIHN0cmljdDogW1wiaW1wbGVtZW50c1wiLCBcImludGVyZmFjZVwiLCBcImxldFwiLCBcInBhY2thZ2VcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIsIFwicHVibGljXCIsIFwic3RhdGljXCIsIFwieWllbGRcIl0sXG4gIHN0cmljdEJpbmQ6IFtcImV2YWxcIiwgXCJhcmd1bWVudHNcIl1cbn07XG5jb25zdCBrZXl3b3JkcyQxID0gbmV3IFNldChyZXNlcnZlZFdvcmRzLmtleXdvcmQpO1xuY29uc3QgcmVzZXJ2ZWRXb3Jkc1N0cmljdFNldCA9IG5ldyBTZXQocmVzZXJ2ZWRXb3Jkcy5zdHJpY3QpO1xuY29uc3QgcmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmRTZXQgPSBuZXcgU2V0KHJlc2VydmVkV29yZHMuc3RyaWN0QmluZCk7XG5mdW5jdGlvbiBpc1Jlc2VydmVkV29yZCh3b3JkLCBpbk1vZHVsZSkge1xuICByZXR1cm4gaW5Nb2R1bGUgJiYgd29yZCA9PT0gXCJhd2FpdFwiIHx8IHdvcmQgPT09IFwiZW51bVwiO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RSZXNlcnZlZFdvcmQod29yZCwgaW5Nb2R1bGUpIHtcbiAgcmV0dXJuIGlzUmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB8fCByZXNlcnZlZFdvcmRzU3RyaWN0U2V0Lmhhcyh3b3JkKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0QmluZE9ubHlSZXNlcnZlZFdvcmQod29yZCkge1xuICByZXR1cm4gcmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmRTZXQuaGFzKHdvcmQpO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RCaW5kUmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB7XG4gIHJldHVybiBpc1N0cmljdFJlc2VydmVkV29yZCh3b3JkLCBpbk1vZHVsZSkgfHwgaXNTdHJpY3RCaW5kT25seVJlc2VydmVkV29yZCh3b3JkKTtcbn1cbmZ1bmN0aW9uIGlzS2V5d29yZCh3b3JkKSB7XG4gIHJldHVybiBrZXl3b3JkcyQxLmhhcyh3b3JkKTtcbn1cblxuY29uc3Qga2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvciA9IC9eaW4oc3RhbmNlb2YpPyQvO1xuZnVuY3Rpb24gaXNJdGVyYXRvclN0YXJ0KGN1cnJlbnQsIG5leHQpIHtcbiAgcmV0dXJuIGN1cnJlbnQgPT09IDY0ICYmIG5leHQgPT09IDY0O1xufVxuXG5jb25zdCByZXNlcnZlZFR5cGVzID0gbmV3IFNldChbXCJfXCIsIFwiYW55XCIsIFwiYm9vbFwiLCBcImJvb2xlYW5cIiwgXCJlbXB0eVwiLCBcImV4dGVuZHNcIiwgXCJmYWxzZVwiLCBcImludGVyZmFjZVwiLCBcIm1peGVkXCIsIFwibnVsbFwiLCBcIm51bWJlclwiLCBcInN0YXRpY1wiLCBcInN0cmluZ1wiLCBcInRydWVcIiwgXCJ0eXBlb2ZcIiwgXCJ2b2lkXCJdKTtcbmNvbnN0IEZsb3dFcnJvcnMgPSBPYmplY3QuZnJlZXplKHtcbiAgQW1iaWd1b3VzQ29uZGl0aW9uYWxBcnJvdzogXCJBbWJpZ3VvdXMgZXhwcmVzc2lvbjogd3JhcCB0aGUgYXJyb3cgZnVuY3Rpb25zIGluIHBhcmVudGhlc2VzIHRvIGRpc2FtYmlndWF0ZS5cIixcbiAgQW1iaWd1b3VzRGVjbGFyZU1vZHVsZUtpbmQ6IFwiRm91bmQgYm90aCBgZGVjbGFyZSBtb2R1bGUuZXhwb3J0c2AgYW5kIGBkZWNsYXJlIGV4cG9ydGAgaW4gdGhlIHNhbWUgbW9kdWxlLiBNb2R1bGVzIGNhbiBvbmx5IGhhdmUgMSBzaW5jZSB0aGV5IGFyZSBlaXRoZXIgYW4gRVMgbW9kdWxlIG9yIHRoZXkgYXJlIGEgQ29tbW9uSlMgbW9kdWxlXCIsXG4gIEFzc2lnblJlc2VydmVkVHlwZTogXCJDYW5ub3Qgb3ZlcndyaXRlIHJlc2VydmVkIHR5cGUgJTBcIixcbiAgRGVjbGFyZUNsYXNzRWxlbWVudDogXCJUaGUgYGRlY2xhcmVgIG1vZGlmaWVyIGNhbiBvbmx5IGFwcGVhciBvbiBjbGFzcyBmaWVsZHMuXCIsXG4gIERlY2xhcmVDbGFzc0ZpZWxkSW5pdGlhbGl6ZXI6IFwiSW5pdGlhbGl6ZXJzIGFyZSBub3QgYWxsb3dlZCBpbiBmaWVsZHMgd2l0aCB0aGUgYGRlY2xhcmVgIG1vZGlmaWVyLlwiLFxuICBEdXBsaWNhdGVEZWNsYXJlTW9kdWxlRXhwb3J0czogXCJEdXBsaWNhdGUgYGRlY2xhcmUgbW9kdWxlLmV4cG9ydHNgIHN0YXRlbWVudFwiLFxuICBFbnVtQm9vbGVhbk1lbWJlck5vdEluaXRpYWxpemVkOiBcIkJvb2xlYW4gZW51bSBtZW1iZXJzIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQuIFVzZSBlaXRoZXIgYCUwID0gdHJ1ZSxgIG9yIGAlMCA9IGZhbHNlLGAgaW4gZW51bSBgJTFgLlwiLFxuICBFbnVtRHVwbGljYXRlTWVtYmVyTmFtZTogXCJFbnVtIG1lbWJlciBuYW1lcyBuZWVkIHRvIGJlIHVuaXF1ZSwgYnV0IHRoZSBuYW1lIGAlMGAgaGFzIGFscmVhZHkgYmVlbiB1c2VkIGJlZm9yZSBpbiBlbnVtIGAlMWAuXCIsXG4gIEVudW1JbmNvbnNpc3RlbnRNZW1iZXJWYWx1ZXM6IFwiRW51bSBgJTBgIGhhcyBpbmNvbnNpc3RlbnQgbWVtYmVyIGluaXRpYWxpemVycy4gRWl0aGVyIHVzZSBubyBpbml0aWFsaXplcnMsIG9yIGNvbnNpc3RlbnRseSB1c2UgbGl0ZXJhbHMgKGVpdGhlciBib29sZWFucywgbnVtYmVycywgb3Igc3RyaW5ncykgZm9yIGFsbCBtZW1iZXIgaW5pdGlhbGl6ZXJzLlwiLFxuICBFbnVtSW52YWxpZEV4cGxpY2l0VHlwZTogXCJFbnVtIHR5cGUgYCUxYCBpcyBub3QgdmFsaWQuIFVzZSBvbmUgb2YgYGJvb2xlYW5gLCBgbnVtYmVyYCwgYHN0cmluZ2AsIG9yIGBzeW1ib2xgIGluIGVudW0gYCUwYC5cIixcbiAgRW51bUludmFsaWRFeHBsaWNpdFR5cGVVbmtub3duU3VwcGxpZWQ6IFwiU3VwcGxpZWQgZW51bSB0eXBlIGlzIG5vdCB2YWxpZC4gVXNlIG9uZSBvZiBgYm9vbGVhbmAsIGBudW1iZXJgLCBgc3RyaW5nYCwgb3IgYHN5bWJvbGAgaW4gZW51bSBgJTBgLlwiLFxuICBFbnVtSW52YWxpZE1lbWJlckluaXRpYWxpemVyUHJpbWFyeVR5cGU6IFwiRW51bSBgJTBgIGhhcyB0eXBlIGAlMmAsIHNvIHRoZSBpbml0aWFsaXplciBvZiBgJTFgIG5lZWRzIHRvIGJlIGEgJTIgbGl0ZXJhbC5cIixcbiAgRW51bUludmFsaWRNZW1iZXJJbml0aWFsaXplclN5bWJvbFR5cGU6IFwiU3ltYm9sIGVudW0gbWVtYmVycyBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQuIFVzZSBgJTEsYCBpbiBlbnVtIGAlMGAuXCIsXG4gIEVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJVbmtub3duVHlwZTogXCJUaGUgZW51bSBtZW1iZXIgaW5pdGlhbGl6ZXIgZm9yIGAlMWAgbmVlZHMgdG8gYmUgYSBsaXRlcmFsIChlaXRoZXIgYSBib29sZWFuLCBudW1iZXIsIG9yIHN0cmluZykgaW4gZW51bSBgJTBgLlwiLFxuICBFbnVtSW52YWxpZE1lbWJlck5hbWU6IFwiRW51bSBtZW1iZXIgbmFtZXMgY2Fubm90IHN0YXJ0IHdpdGggbG93ZXJjYXNlICdhJyB0aHJvdWdoICd6Jy4gSW5zdGVhZCBvZiB1c2luZyBgJTBgLCBjb25zaWRlciB1c2luZyBgJTFgLCBpbiBlbnVtIGAlMmAuXCIsXG4gIEVudW1OdW1iZXJNZW1iZXJOb3RJbml0aWFsaXplZDogXCJOdW1iZXIgZW51bSBtZW1iZXJzIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQsIGUuZy4gYCUxID0gMWAgaW4gZW51bSBgJTBgLlwiLFxuICBFbnVtU3RyaW5nTWVtYmVySW5jb25zaXN0ZW50bHlJbml0YWlsaXplZDogXCJTdHJpbmcgZW51bSBtZW1iZXJzIG5lZWQgdG8gY29uc2lzdGVudGx5IGVpdGhlciBhbGwgdXNlIGluaXRpYWxpemVycywgb3IgdXNlIG5vIGluaXRpYWxpemVycywgaW4gZW51bSBgJTBgLlwiLFxuICBJbXBvcnRUeXBlU2hvcnRoYW5kT25seUluUHVyZUltcG9ydDogXCJUaGUgYHR5cGVgIGFuZCBgdHlwZW9mYCBrZXl3b3JkcyBvbiBuYW1lZCBpbXBvcnRzIGNhbiBvbmx5IGJlIHVzZWQgb24gcmVndWxhciBgaW1wb3J0YCBzdGF0ZW1lbnRzLiBJdCBjYW5ub3QgYmUgdXNlZCB3aXRoIGBpbXBvcnQgdHlwZWAgb3IgYGltcG9ydCB0eXBlb2ZgIHN0YXRlbWVudHNcIixcbiAgSW5leGFjdEluc2lkZUV4YWN0OiBcIkV4cGxpY2l0IGluZXhhY3Qgc3ludGF4IGNhbm5vdCBhcHBlYXIgaW5zaWRlIGFuIGV4cGxpY2l0IGV4YWN0IG9iamVjdCB0eXBlXCIsXG4gIEluZXhhY3RJbnNpZGVOb25PYmplY3Q6IFwiRXhwbGljaXQgaW5leGFjdCBzeW50YXggY2Fubm90IGFwcGVhciBpbiBjbGFzcyBvciBpbnRlcmZhY2UgZGVmaW5pdGlvbnNcIixcbiAgSW5leGFjdFZhcmlhbmNlOiBcIkV4cGxpY2l0IGluZXhhY3Qgc3ludGF4IGNhbm5vdCBoYXZlIHZhcmlhbmNlXCIsXG4gIEludmFsaWROb25UeXBlSW1wb3J0SW5EZWNsYXJlTW9kdWxlOiBcIkltcG9ydHMgd2l0aGluIGEgYGRlY2xhcmUgbW9kdWxlYCBib2R5IG11c3QgYWx3YXlzIGJlIGBpbXBvcnQgdHlwZWAgb3IgYGltcG9ydCB0eXBlb2ZgXCIsXG4gIE1pc3NpbmdUeXBlUGFyYW1EZWZhdWx0OiBcIlR5cGUgcGFyYW1ldGVyIGRlY2xhcmF0aW9uIG5lZWRzIGEgZGVmYXVsdCwgc2luY2UgYSBwcmVjZWRpbmcgdHlwZSBwYXJhbWV0ZXIgZGVjbGFyYXRpb24gaGFzIGEgZGVmYXVsdC5cIixcbiAgTmVzdGVkRGVjbGFyZU1vZHVsZTogXCJgZGVjbGFyZSBtb2R1bGVgIGNhbm5vdCBiZSB1c2VkIGluc2lkZSBhbm90aGVyIGBkZWNsYXJlIG1vZHVsZWBcIixcbiAgTmVzdGVkRmxvd0NvbW1lbnQ6IFwiQ2Fubm90IGhhdmUgYSBmbG93IGNvbW1lbnQgaW5zaWRlIGFub3RoZXIgZmxvdyBjb21tZW50XCIsXG4gIE9wdGlvbmFsQmluZGluZ1BhdHRlcm46IFwiQSBiaW5kaW5nIHBhdHRlcm4gcGFyYW1ldGVyIGNhbm5vdCBiZSBvcHRpb25hbCBpbiBhbiBpbXBsZW1lbnRhdGlvbiBzaWduYXR1cmUuXCIsXG4gIFNwcmVhZFZhcmlhbmNlOiBcIlNwcmVhZCBwcm9wZXJ0aWVzIGNhbm5vdCBoYXZlIHZhcmlhbmNlXCIsXG4gIFR5cGVCZWZvcmVJbml0aWFsaXplcjogXCJUeXBlIGFubm90YXRpb25zIG11c3QgY29tZSBiZWZvcmUgZGVmYXVsdCBhc3NpZ25tZW50cywgZS5nLiBpbnN0ZWFkIG9mIGBhZ2UgPSAyNTogbnVtYmVyYCB1c2UgYGFnZTogbnVtYmVyID0gMjVgXCIsXG4gIFR5cGVDYXN0SW5QYXR0ZXJuOiBcIlRoZSB0eXBlIGNhc3QgZXhwcmVzc2lvbiBpcyBleHBlY3RlZCB0byBiZSB3cmFwcGVkIHdpdGggcGFyZW50aGVzaXNcIixcbiAgVW5leHBlY3RlZEV4cGxpY2l0SW5leGFjdEluT2JqZWN0OiBcIkV4cGxpY2l0IGluZXhhY3Qgc3ludGF4IG11c3QgYXBwZWFyIGF0IHRoZSBlbmQgb2YgYW4gaW5leGFjdCBvYmplY3RcIixcbiAgVW5leHBlY3RlZFJlc2VydmVkVHlwZTogXCJVbmV4cGVjdGVkIHJlc2VydmVkIHR5cGUgJTBcIixcbiAgVW5leHBlY3RlZFJlc2VydmVkVW5kZXJzY29yZTogXCJgX2AgaXMgb25seSBhbGxvd2VkIGFzIGEgdHlwZSBhcmd1bWVudCB0byBjYWxsIG9yIG5ld1wiLFxuICBVbmV4cGVjdGVkU3BhY2VCZXR3ZWVuTW9kdWxvQ2hlY2tzOiBcIlNwYWNlcyBiZXR3ZWVuIGAlYCBhbmQgYGNoZWNrc2AgYXJlIG5vdCBhbGxvd2VkIGhlcmUuXCIsXG4gIFVuZXhwZWN0ZWRTcHJlYWRUeXBlOiBcIlNwcmVhZCBvcGVyYXRvciBjYW5ub3QgYXBwZWFyIGluIGNsYXNzIG9yIGludGVyZmFjZSBkZWZpbml0aW9uc1wiLFxuICBVbmV4cGVjdGVkU3VidHJhY3Rpb25PcGVyYW5kOiAnVW5leHBlY3RlZCB0b2tlbiwgZXhwZWN0ZWQgXCJudW1iZXJcIiBvciBcImJpZ2ludFwiJyxcbiAgVW5leHBlY3RlZFRva2VuQWZ0ZXJUeXBlUGFyYW1ldGVyOiBcIkV4cGVjdGVkIGFuIGFycm93IGZ1bmN0aW9uIGFmdGVyIHRoaXMgdHlwZSBwYXJhbWV0ZXIgZGVjbGFyYXRpb25cIixcbiAgVW5zdXBwb3J0ZWREZWNsYXJlRXhwb3J0S2luZDogXCJgZGVjbGFyZSBleHBvcnQgJTBgIGlzIG5vdCBzdXBwb3J0ZWQuIFVzZSBgJTFgIGluc3RlYWRcIixcbiAgVW5zdXBwb3J0ZWRTdGF0ZW1lbnRJbkRlY2xhcmVNb2R1bGU6IFwiT25seSBkZWNsYXJlcyBhbmQgdHlwZSBpbXBvcnRzIGFyZSBhbGxvd2VkIGluc2lkZSBkZWNsYXJlIG1vZHVsZVwiLFxuICBVbnRlcm1pbmF0ZWRGbG93Q29tbWVudDogXCJVbnRlcm1pbmF0ZWQgZmxvdy1jb21tZW50XCJcbn0pO1xuXG5mdW5jdGlvbiBpc0VzTW9kdWxlVHlwZShib2R5RWxlbWVudCkge1xuICByZXR1cm4gYm9keUVsZW1lbnQudHlwZSA9PT0gXCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIiB8fCBib2R5RWxlbWVudC50eXBlID09PSBcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiICYmICghYm9keUVsZW1lbnQuZGVjbGFyYXRpb24gfHwgYm9keUVsZW1lbnQuZGVjbGFyYXRpb24udHlwZSAhPT0gXCJUeXBlQWxpYXNcIiAmJiBib2R5RWxlbWVudC5kZWNsYXJhdGlvbi50eXBlICE9PSBcIkludGVyZmFjZURlY2xhcmF0aW9uXCIpO1xufVxuXG5mdW5jdGlvbiBoYXNUeXBlSW1wb3J0S2luZChub2RlKSB7XG4gIHJldHVybiBub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZVwiIHx8IG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlb2ZcIjtcbn1cblxuZnVuY3Rpb24gaXNNYXliZURlZmF1bHRJbXBvcnQoc3RhdGUpIHtcbiAgcmV0dXJuIChzdGF0ZS50eXBlID09PSB0eXBlcy5uYW1lIHx8ICEhc3RhdGUudHlwZS5rZXl3b3JkKSAmJiBzdGF0ZS52YWx1ZSAhPT0gXCJmcm9tXCI7XG59XG5cbmNvbnN0IGV4cG9ydFN1Z2dlc3Rpb25zID0ge1xuICBjb25zdDogXCJkZWNsYXJlIGV4cG9ydCB2YXJcIixcbiAgbGV0OiBcImRlY2xhcmUgZXhwb3J0IHZhclwiLFxuICB0eXBlOiBcImV4cG9ydCB0eXBlXCIsXG4gIGludGVyZmFjZTogXCJleHBvcnQgaW50ZXJmYWNlXCJcbn07XG5cbmZ1bmN0aW9uIHBhcnRpdGlvbihsaXN0LCB0ZXN0KSB7XG4gIGNvbnN0IGxpc3QxID0gW107XG4gIGNvbnN0IGxpc3QyID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgKHRlc3QobGlzdFtpXSwgaSwgbGlzdCkgPyBsaXN0MSA6IGxpc3QyKS5wdXNoKGxpc3RbaV0pO1xuICB9XG5cbiAgcmV0dXJuIFtsaXN0MSwgbGlzdDJdO1xufVxuXG5jb25zdCBGTE9XX1BSQUdNQV9SRUdFWCA9IC9cXCo/XFxzKkAoKD86bm8pP2Zsb3cpXFxiLztcbnZhciBmbG93ID0gKHN1cGVyQ2xhc3MgPT4gY2xhc3MgZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgaW5wdXQpIHtcbiAgICBzdXBlcihvcHRpb25zLCBpbnB1dCk7XG4gICAgdGhpcy5mbG93UHJhZ21hID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgc2hvdWxkUGFyc2VUeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJmbG93XCIsIFwiYWxsXCIpIHx8IHRoaXMuZmxvd1ByYWdtYSA9PT0gXCJmbG93XCI7XG4gIH1cblxuICBzaG91bGRQYXJzZUVudW1zKCkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZmxvd1wiLCBcImVudW1zXCIpO1xuICB9XG5cbiAgZmluaXNoVG9rZW4odHlwZSwgdmFsKSB7XG4gICAgaWYgKHR5cGUgIT09IHR5cGVzLnN0cmluZyAmJiB0eXBlICE9PSB0eXBlcy5zZW1pICYmIHR5cGUgIT09IHR5cGVzLmludGVycHJldGVyRGlyZWN0aXZlKSB7XG4gICAgICBpZiAodGhpcy5mbG93UHJhZ21hID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5mbG93UHJhZ21hID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuZmluaXNoVG9rZW4odHlwZSwgdmFsKTtcbiAgfVxuXG4gIGFkZENvbW1lbnQoY29tbWVudCkge1xuICAgIGlmICh0aGlzLmZsb3dQcmFnbWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IEZMT1dfUFJBR01BX1JFR0VYLmV4ZWMoY29tbWVudC52YWx1ZSk7XG5cbiAgICAgIGlmICghbWF0Y2hlcykgOyBlbHNlIGlmIChtYXRjaGVzWzFdID09PSBcImZsb3dcIikge1xuICAgICAgICB0aGlzLmZsb3dQcmFnbWEgPSBcImZsb3dcIjtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hlc1sxXSA9PT0gXCJub2Zsb3dcIikge1xuICAgICAgICB0aGlzLmZsb3dQcmFnbWEgPSBcIm5vZmxvd1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBmbG93IHByYWdtYVwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuYWRkQ29tbWVudChjb21tZW50KTtcbiAgfVxuXG4gIGZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcih0b2spIHtcbiAgICBjb25zdCBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IHRydWU7XG4gICAgdGhpcy5leHBlY3QodG9rIHx8IHR5cGVzLmNvbG9uKTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBmbG93UGFyc2VQcmVkaWNhdGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgbW9kdWxvTG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBtb2R1bG9Qb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLm1vZHVsbyk7XG4gICAgY29uc3QgY2hlY2tzTG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJjaGVja3NcIik7XG5cbiAgICBpZiAobW9kdWxvTG9jLmxpbmUgIT09IGNoZWNrc0xvYy5saW5lIHx8IG1vZHVsb0xvYy5jb2x1bW4gIT09IGNoZWNrc0xvYy5jb2x1bW4gLSAxKSB7XG4gICAgICB0aGlzLnJhaXNlKG1vZHVsb1BvcywgRmxvd0Vycm9ycy5VbmV4cGVjdGVkU3BhY2VCZXR3ZWVuTW9kdWxvQ2hlY2tzKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lYXQodHlwZXMucGFyZW5MKSkge1xuICAgICAgbm9kZS52YWx1ZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVkUHJlZGljYXRlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW5mZXJyZWRQcmVkaWNhdGVcIik7XG4gICAgfVxuICB9XG5cbiAgZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyKCkge1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb2xvbik7XG4gICAgbGV0IHR5cGUgPSBudWxsO1xuICAgIGxldCBwcmVkaWNhdGUgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMubW9kdWxvKSkge1xuICAgICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgICBwcmVkaWNhdGUgPSB0aGlzLmZsb3dQYXJzZVByZWRpY2F0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcblxuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMubW9kdWxvKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB0aGlzLmZsb3dQYXJzZVByZWRpY2F0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbdHlwZSwgcHJlZGljYXRlXTtcbiAgfVxuXG4gIGZsb3dQYXJzZURlY2xhcmVDbGFzcyhub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5mbG93UGFyc2VJbnRlcmZhY2Vpc2gobm9kZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVDbGFzc1wiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZURlY2xhcmVGdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgY29uc3QgaWQgPSBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICBjb25zdCB0eXBlTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgdHlwZUNvbnRhaW5lciA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICB0eXBlTm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVOb2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICAgIGNvbnN0IHRtcCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKCk7XG4gICAgdHlwZU5vZGUucGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICB0eXBlTm9kZS5yZXN0ID0gdG1wLnJlc3Q7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgICBbdHlwZU5vZGUucmV0dXJuVHlwZSwgbm9kZS5wcmVkaWNhdGVdID0gdGhpcy5mbG93UGFyc2VUeXBlQW5kUHJlZGljYXRlSW5pdGlhbGlzZXIoKTtcbiAgICB0eXBlQ29udGFpbmVyLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5maW5pc2hOb2RlKHR5cGVOb2RlLCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIik7XG4gICAgaWQudHlwZUFubm90YXRpb24gPSB0aGlzLmZpbmlzaE5vZGUodHlwZUNvbnRhaW5lciwgXCJUeXBlQW5ub3RhdGlvblwiKTtcbiAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24oaWQpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVGdW5jdGlvblwiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZURlY2xhcmUobm9kZSwgaW5zaWRlTW9kdWxlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2NsYXNzKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZUNsYXNzKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCh0eXBlcy5fZnVuY3Rpb24pKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlRnVuY3Rpb24obm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHR5cGVzLl92YXIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlVmFyaWFibGUobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJtb2R1bGVcIikpIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmRvdCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZU1vZHVsZUV4cG9ydHMobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW5zaWRlTW9kdWxlKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLmxhc3RUb2tTdGFydCwgRmxvd0Vycm9ycy5OZXN0ZWREZWNsYXJlTW9kdWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVNb2R1bGUobm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbChcInR5cGVcIikpIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVUeXBlQWxpYXMobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbChcIm9wYXF1ZVwiKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZU9wYXF1ZVR5cGUobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbChcImludGVyZmFjZVwiKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZUludGVyZmFjZShub2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2godHlwZXMuX2V4cG9ydCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVFeHBvcnREZWNsYXJhdGlvbihub2RlLCBpbnNpZGVNb2R1bGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH1cblxuICBmbG93UGFyc2VEZWNsYXJlVmFyaWFibGUobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0YWJsZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgdGhpcy5zY29wZS5kZWNsYXJlTmFtZShub2RlLmlkLm5hbWUsIEJJTkRfVkFSLCBub2RlLmlkLnN0YXJ0KTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlVmFyaWFibGVcIik7XG4gIH1cblxuICBmbG93UGFyc2VEZWNsYXJlTW9kdWxlKG5vZGUpIHtcbiAgICB0aGlzLnNjb3BlLmVudGVyKFNDT1BFX09USEVSKTtcblxuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLnN0cmluZykpIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgfVxuXG4gICAgY29uc3QgYm9keU5vZGUgPSBub2RlLmJvZHkgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IGJvZHkgPSBib2R5Tm9kZS5ib2R5ID0gW107XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcblxuICAgIHdoaWxlICghdGhpcy5tYXRjaCh0eXBlcy5icmFjZVIpKSB7XG4gICAgICBsZXQgYm9keU5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5faW1wb3J0KSkge1xuICAgICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKFwidHlwZVwiKSAmJiAhdGhpcy5tYXRjaCh0eXBlcy5fdHlwZW9mKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQsIEZsb3dFcnJvcnMuSW52YWxpZE5vblR5cGVJbXBvcnRJbkRlY2xhcmVNb2R1bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYXJzZUltcG9ydChib2R5Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJkZWNsYXJlXCIsIEZsb3dFcnJvcnMuVW5zdXBwb3J0ZWRTdGF0ZW1lbnRJbkRlY2xhcmVNb2R1bGUpO1xuICAgICAgICBib2R5Tm9kZSA9IHRoaXMuZmxvd1BhcnNlRGVjbGFyZShib2R5Tm9kZSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGJvZHkucHVzaChib2R5Tm9kZSk7XG4gICAgfVxuXG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VSKTtcbiAgICB0aGlzLmZpbmlzaE5vZGUoYm9keU5vZGUsIFwiQmxvY2tTdGF0ZW1lbnRcIik7XG4gICAgbGV0IGtpbmQgPSBudWxsO1xuICAgIGxldCBoYXNNb2R1bGVFeHBvcnQgPSBmYWxzZTtcbiAgICBib2R5LmZvckVhY2goYm9keUVsZW1lbnQgPT4ge1xuICAgICAgaWYgKGlzRXNNb2R1bGVUeXBlKGJvZHlFbGVtZW50KSkge1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJDb21tb25KU1wiKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShib2R5RWxlbWVudC5zdGFydCwgRmxvd0Vycm9ycy5BbWJpZ3VvdXNEZWNsYXJlTW9kdWxlS2luZCk7XG4gICAgICAgIH1cblxuICAgICAgICBraW5kID0gXCJFU1wiO1xuICAgICAgfSBlbHNlIGlmIChib2R5RWxlbWVudC50eXBlID09PSBcIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCIpIHtcbiAgICAgICAgaWYgKGhhc01vZHVsZUV4cG9ydCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoYm9keUVsZW1lbnQuc3RhcnQsIEZsb3dFcnJvcnMuRHVwbGljYXRlRGVjbGFyZU1vZHVsZUV4cG9ydHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtpbmQgPT09IFwiRVNcIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoYm9keUVsZW1lbnQuc3RhcnQsIEZsb3dFcnJvcnMuQW1iaWd1b3VzRGVjbGFyZU1vZHVsZUtpbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAga2luZCA9IFwiQ29tbW9uSlNcIjtcbiAgICAgICAgaGFzTW9kdWxlRXhwb3J0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBub2RlLmtpbmQgPSBraW5kIHx8IFwiQ29tbW9uSlNcIjtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZU1vZHVsZVwiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZURlY2xhcmVFeHBvcnREZWNsYXJhdGlvbihub2RlLCBpbnNpZGVNb2R1bGUpIHtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5fZXhwb3J0KTtcblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5fZGVmYXVsdCkpIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLl9mdW5jdGlvbikgfHwgdGhpcy5tYXRjaCh0eXBlcy5fY2xhc3MpKSB7XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLmZsb3dQYXJzZURlY2xhcmUodGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUuZGVmYXVsdCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5fY29uc3QpIHx8IHRoaXMuaXNMZXQoKSB8fCAodGhpcy5pc0NvbnRleHR1YWwoXCJ0eXBlXCIpIHx8IHRoaXMuaXNDb250ZXh0dWFsKFwiaW50ZXJmYWNlXCIpKSAmJiAhaW5zaWRlTW9kdWxlKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgICAgY29uc3Qgc3VnZ2VzdGlvbiA9IGV4cG9ydFN1Z2dlc3Rpb25zW2xhYmVsXTtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBGbG93RXJyb3JzLlVuc3VwcG9ydGVkRGVjbGFyZUV4cG9ydEtpbmQsIGxhYmVsLCBzdWdnZXN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuX3ZhcikgfHwgdGhpcy5tYXRjaCh0eXBlcy5fZnVuY3Rpb24pIHx8IHRoaXMubWF0Y2godHlwZXMuX2NsYXNzKSB8fCB0aGlzLmlzQ29udGV4dHVhbChcIm9wYXF1ZVwiKSkge1xuICAgICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLmZsb3dQYXJzZURlY2xhcmUodGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICAgICAgbm9kZS5kZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHR5cGVzLnN0YXIpIHx8IHRoaXMubWF0Y2godHlwZXMuYnJhY2VMKSB8fCB0aGlzLmlzQ29udGV4dHVhbChcImludGVyZmFjZVwiKSB8fCB0aGlzLmlzQ29udGV4dHVhbChcInR5cGVcIikgfHwgdGhpcy5pc0NvbnRleHR1YWwoXCJvcGFxdWVcIikpIHtcbiAgICAgICAgICBub2RlID0gdGhpcy5wYXJzZUV4cG9ydChub2RlKTtcblxuICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKSB7XG4gICAgICAgICAgICBub2RlLnR5cGUgPSBcIkV4cG9ydERlY2xhcmF0aW9uXCI7XG4gICAgICAgICAgICBub2RlLmRlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRlbGV0ZSBub2RlLmV4cG9ydEtpbmQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZS50eXBlID0gXCJEZWNsYXJlXCIgKyBub2RlLnR5cGU7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuXG4gIGZsb3dQYXJzZURlY2xhcmVNb2R1bGVFeHBvcnRzKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJleHBvcnRzXCIpO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIik7XG4gIH1cblxuICBmbG93UGFyc2VEZWNsYXJlVHlwZUFsaWFzKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmZsb3dQYXJzZVR5cGVBbGlhcyhub2RlKTtcbiAgICBub2RlLnR5cGUgPSBcIkRlY2xhcmVUeXBlQWxpYXNcIjtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZsb3dQYXJzZURlY2xhcmVPcGFxdWVUeXBlKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmZsb3dQYXJzZU9wYXF1ZVR5cGUobm9kZSwgdHJ1ZSk7XG4gICAgbm9kZS50eXBlID0gXCJEZWNsYXJlT3BhcXVlVHlwZVwiO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZmxvd1BhcnNlRGVjbGFyZUludGVyZmFjZShub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5mbG93UGFyc2VJbnRlcmZhY2Vpc2gobm9kZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVJbnRlcmZhY2VcIik7XG4gIH1cblxuICBmbG93UGFyc2VJbnRlcmZhY2Vpc2gobm9kZSwgaXNDbGFzcyA9IGZhbHNlKSB7XG4gICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIoIWlzQ2xhc3MsIHRydWUpO1xuICAgIHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUobm9kZS5pZC5uYW1lLCBpc0NsYXNzID8gQklORF9GVU5DVElPTiA6IEJJTkRfTEVYSUNBTCwgbm9kZS5pZC5zdGFydCk7XG5cbiAgICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgfVxuXG4gICAgbm9kZS5leHRlbmRzID0gW107XG4gICAgbm9kZS5pbXBsZW1lbnRzID0gW107XG4gICAgbm9kZS5taXhpbnMgPSBbXTtcblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5fZXh0ZW5kcykpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgbm9kZS5leHRlbmRzLnB1c2godGhpcy5mbG93UGFyc2VJbnRlcmZhY2VFeHRlbmRzKCkpO1xuICAgICAgfSB3aGlsZSAoIWlzQ2xhc3MgJiYgdGhpcy5lYXQodHlwZXMuY29tbWEpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJtaXhpbnNcIikpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICBkbyB7XG4gICAgICAgIG5vZGUubWl4aW5zLnB1c2godGhpcy5mbG93UGFyc2VJbnRlcmZhY2VFeHRlbmRzKCkpO1xuICAgICAgfSB3aGlsZSAodGhpcy5lYXQodHlwZXMuY29tbWEpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJpbXBsZW1lbnRzXCIpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgZG8ge1xuICAgICAgICBub2RlLmltcGxlbWVudHMucHVzaCh0aGlzLmZsb3dQYXJzZUludGVyZmFjZUV4dGVuZHMoKSk7XG4gICAgICB9IHdoaWxlICh0aGlzLmVhdCh0eXBlcy5jb21tYSkpO1xuICAgIH1cblxuICAgIG5vZGUuYm9keSA9IHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZSh7XG4gICAgICBhbGxvd1N0YXRpYzogaXNDbGFzcyxcbiAgICAgIGFsbG93RXhhY3Q6IGZhbHNlLFxuICAgICAgYWxsb3dTcHJlYWQ6IGZhbHNlLFxuICAgICAgYWxsb3dQcm90bzogaXNDbGFzcyxcbiAgICAgIGFsbG93SW5leGFjdDogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIGZsb3dQYXJzZUludGVyZmFjZUV4dGVuZHMoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlUXVhbGlmaWVkVHlwZUlkZW50aWZpZXIoKTtcblxuICAgIGlmICh0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbnRlcmZhY2VFeHRlbmRzXCIpO1xuICB9XG5cbiAgZmxvd1BhcnNlSW50ZXJmYWNlKG5vZGUpIHtcbiAgICB0aGlzLmZsb3dQYXJzZUludGVyZmFjZWlzaChub2RlKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIik7XG4gIH1cblxuICBjaGVja05vdFVuZGVyc2NvcmUod29yZCkge1xuICAgIGlmICh3b3JkID09PSBcIl9cIikge1xuICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBGbG93RXJyb3JzLlVuZXhwZWN0ZWRSZXNlcnZlZFVuZGVyc2NvcmUpO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrUmVzZXJ2ZWRUeXBlKHdvcmQsIHN0YXJ0TG9jLCBkZWNsYXJhdGlvbikge1xuICAgIGlmICghcmVzZXJ2ZWRUeXBlcy5oYXMod29yZCkpIHJldHVybjtcbiAgICB0aGlzLnJhaXNlKHN0YXJ0TG9jLCBkZWNsYXJhdGlvbiA/IEZsb3dFcnJvcnMuQXNzaWduUmVzZXJ2ZWRUeXBlIDogRmxvd0Vycm9ycy5VbmV4cGVjdGVkUmVzZXJ2ZWRUeXBlLCB3b3JkKTtcbiAgfVxuXG4gIGZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKGxpYmVyYWwsIGRlY2xhcmF0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Jlc2VydmVkVHlwZSh0aGlzLnN0YXRlLnZhbHVlLCB0aGlzLnN0YXRlLnN0YXJ0LCBkZWNsYXJhdGlvbik7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VJZGVudGlmaWVyKGxpYmVyYWwpO1xuICB9XG5cbiAgZmxvd1BhcnNlVHlwZUFsaWFzKG5vZGUpIHtcbiAgICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VSZXN0cmljdGVkSWRlbnRpZmllcihmYWxzZSwgdHJ1ZSk7XG4gICAgdGhpcy5zY29wZS5kZWNsYXJlTmFtZShub2RlLmlkLm5hbWUsIEJJTkRfTEVYSUNBTCwgbm9kZS5pZC5zdGFydCk7XG5cbiAgICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgfVxuXG4gICAgbm9kZS5yaWdodCA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKHR5cGVzLmVxKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUeXBlQWxpYXNcIik7XG4gIH1cblxuICBmbG93UGFyc2VPcGFxdWVUeXBlKG5vZGUsIGRlY2xhcmUpIHtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJ0eXBlXCIpO1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKHRydWUsIHRydWUpO1xuICAgIHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUobm9kZS5pZC5uYW1lLCBCSU5EX0xFWElDQUwsIG5vZGUuaWQuc3RhcnQpO1xuXG4gICAgaWYgKHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIH1cblxuICAgIG5vZGUuc3VwZXJ0eXBlID0gbnVsbDtcblxuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmNvbG9uKSkge1xuICAgICAgbm9kZS5zdXBlcnR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcih0eXBlcy5jb2xvbik7XG4gICAgfVxuXG4gICAgbm9kZS5pbXBsdHlwZSA9IG51bGw7XG5cbiAgICBpZiAoIWRlY2xhcmUpIHtcbiAgICAgIG5vZGUuaW1wbHR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcih0eXBlcy5lcSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT3BhcXVlVHlwZVwiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZVR5cGVQYXJhbWV0ZXIocmVxdWlyZURlZmF1bHQgPSBmYWxzZSkge1xuICAgIGNvbnN0IG5vZGVTdGFydCA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgdmFyaWFuY2UgPSB0aGlzLmZsb3dQYXJzZVZhcmlhbmNlKCk7XG4gICAgY29uc3QgaWRlbnQgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0YWJsZUlkZW50aWZpZXIoKTtcbiAgICBub2RlLm5hbWUgPSBpZGVudC5uYW1lO1xuICAgIG5vZGUudmFyaWFuY2UgPSB2YXJpYW5jZTtcbiAgICBub2RlLmJvdW5kID0gaWRlbnQudHlwZUFubm90YXRpb247XG5cbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5lcSkpIHtcbiAgICAgIHRoaXMuZWF0KHR5cGVzLmVxKTtcbiAgICAgIG5vZGUuZGVmYXVsdCA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVxdWlyZURlZmF1bHQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShub2RlU3RhcnQsIEZsb3dFcnJvcnMuTWlzc2luZ1R5cGVQYXJhbURlZmF1bHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUeXBlUGFyYW1ldGVyXCIpO1xuICB9XG5cbiAgZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCkge1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUucGFyYW1zID0gW107XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSB8fCB0aGlzLm1hdGNoKHR5cGVzLmpzeFRhZ1N0YXJ0KSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cblxuICAgIGxldCBkZWZhdWx0UmVxdWlyZWQgPSBmYWxzZTtcblxuICAgIGRvIHtcbiAgICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXIgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXIoZGVmYXVsdFJlcXVpcmVkKTtcbiAgICAgIG5vZGUucGFyYW1zLnB1c2godHlwZVBhcmFtZXRlcik7XG5cbiAgICAgIGlmICh0eXBlUGFyYW1ldGVyLmRlZmF1bHQpIHtcbiAgICAgICAgZGVmYXVsdFJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmlzUmVsYXRpb25hbChcIj5cIikpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKCF0aGlzLmlzUmVsYXRpb25hbChcIj5cIikpO1xuXG4gICAgdGhpcy5leHBlY3RSZWxhdGlvbmFsKFwiPlwiKTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpO1xuICB9XG5cbiAgZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3Qgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gICAgbm9kZS5wYXJhbXMgPSBbXTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IHRydWU7XG4gICAgdGhpcy5leHBlY3RSZWxhdGlvbmFsKFwiPFwiKTtcbiAgICBjb25zdCBvbGROb0Fub25GdW5jdGlvblR5cGUgPSB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKCF0aGlzLmlzUmVsYXRpb25hbChcIj5cIikpIHtcbiAgICAgIG5vZGUucGFyYW1zLnB1c2godGhpcy5mbG93UGFyc2VUeXBlKCkpO1xuXG4gICAgICBpZiAoIXRoaXMuaXNSZWxhdGlvbmFsKFwiPlwiKSkge1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSBvbGROb0Fub25GdW5jdGlvblR5cGU7XG4gICAgdGhpcy5leHBlY3RSZWxhdGlvbmFsKFwiPlwiKTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIik7XG4gIH1cblxuICBmbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbkNhbGxPck5ldygpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgICBub2RlLnBhcmFtcyA9IFtdO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdFJlbGF0aW9uYWwoXCI8XCIpO1xuXG4gICAgd2hpbGUgKCF0aGlzLmlzUmVsYXRpb25hbChcIj5cIikpIHtcbiAgICAgIG5vZGUucGFyYW1zLnB1c2godGhpcy5mbG93UGFyc2VUeXBlT3JJbXBsaWNpdEluc3RhbnRpYXRpb24oKSk7XG5cbiAgICAgIGlmICghdGhpcy5pc1JlbGF0aW9uYWwoXCI+XCIpKSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmV4cGVjdFJlbGF0aW9uYWwoXCI+XCIpO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZUludGVyZmFjZVR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiaW50ZXJmYWNlXCIpO1xuICAgIG5vZGUuZXh0ZW5kcyA9IFtdO1xuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLl9leHRlbmRzKSkge1xuICAgICAgZG8ge1xuICAgICAgICBub2RlLmV4dGVuZHMucHVzaCh0aGlzLmZsb3dQYXJzZUludGVyZmFjZUV4dGVuZHMoKSk7XG4gICAgICB9IHdoaWxlICh0aGlzLmVhdCh0eXBlcy5jb21tYSkpO1xuICAgIH1cblxuICAgIG5vZGUuYm9keSA9IHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZSh7XG4gICAgICBhbGxvd1N0YXRpYzogZmFsc2UsXG4gICAgICBhbGxvd0V4YWN0OiBmYWxzZSxcbiAgICAgIGFsbG93U3ByZWFkOiBmYWxzZSxcbiAgICAgIGFsbG93UHJvdG86IGZhbHNlLFxuICAgICAgYWxsb3dJbmV4YWN0OiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbnRlcmZhY2VUeXBlQW5ub3RhdGlvblwiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZU9iamVjdFByb3BlcnR5S2V5KCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKHR5cGVzLm51bSkgfHwgdGhpcy5tYXRjaCh0eXBlcy5zdHJpbmcpID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgfVxuXG4gIGZsb3dQYXJzZU9iamVjdFR5cGVJbmRleGVyKG5vZGUsIGlzU3RhdGljLCB2YXJpYW5jZSkge1xuICAgIG5vZGUuc3RhdGljID0gaXNTdGF0aWM7XG5cbiAgICBpZiAodGhpcy5sb29rYWhlYWQoKS50eXBlID09PSB0eXBlcy5jb2xvbikge1xuICAgICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgIG5vZGUua2V5ID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5pZCA9IG51bGw7XG4gICAgICBub2RlLmtleSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIH1cblxuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRSKTtcbiAgICBub2RlLnZhbHVlID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKTtcbiAgICBub2RlLnZhcmlhbmNlID0gdmFyaWFuY2U7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9iamVjdFR5cGVJbmRleGVyXCIpO1xuICB9XG5cbiAgZmxvd1BhcnNlT2JqZWN0VHlwZUludGVybmFsU2xvdChub2RlLCBpc1N0YXRpYykge1xuICAgIG5vZGUuc3RhdGljID0gaXNTdGF0aWM7XG4gICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFja2V0Uik7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2tldFIpO1xuXG4gICAgaWYgKHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSB8fCB0aGlzLm1hdGNoKHR5cGVzLnBhcmVuTCkpIHtcbiAgICAgIG5vZGUubWV0aG9kID0gdHJ1ZTtcbiAgICAgIG5vZGUub3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVNZXRob2Rpc2godGhpcy5zdGFydE5vZGVBdChub2RlLnN0YXJ0LCBub2RlLmxvYy5zdGFydCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLm1ldGhvZCA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMucXVlc3Rpb24pKSB7XG4gICAgICAgIG5vZGUub3B0aW9uYWwgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBub2RlLnZhbHVlID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZU9iamVjdFR5cGVNZXRob2Rpc2gobm9kZSkge1xuICAgIG5vZGUucGFyYW1zID0gW107XG4gICAgbm9kZS5yZXN0ID0gbnVsbDtcbiAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcblxuICAgIGlmICh0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH1cblxuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG5cbiAgICB3aGlsZSAoIXRoaXMubWF0Y2godHlwZXMucGFyZW5SKSAmJiAhdGhpcy5tYXRjaCh0eXBlcy5lbGxpcHNpcykpIHtcbiAgICAgIG5vZGUucGFyYW1zLnB1c2godGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbSgpKTtcblxuICAgICAgaWYgKCF0aGlzLm1hdGNoKHR5cGVzLnBhcmVuUikpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5lbGxpcHNpcykpIHtcbiAgICAgIG5vZGUucmVzdCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW0oKTtcbiAgICB9XG5cbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIik7XG4gIH1cblxuICBmbG93UGFyc2VPYmplY3RUeXBlQ2FsbFByb3BlcnR5KG5vZGUsIGlzU3RhdGljKSB7XG4gICAgY29uc3QgdmFsdWVOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljO1xuICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVNZXRob2Rpc2godmFsdWVOb2RlKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZU9iamVjdFR5cGUoe1xuICAgIGFsbG93U3RhdGljLFxuICAgIGFsbG93RXhhY3QsXG4gICAgYWxsb3dTcHJlYWQsXG4gICAgYWxsb3dQcm90byxcbiAgICBhbGxvd0luZXhhY3RcbiAgfSkge1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICBjb25zdCBub2RlU3RhcnQgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGVTdGFydC5jYWxsUHJvcGVydGllcyA9IFtdO1xuICAgIG5vZGVTdGFydC5wcm9wZXJ0aWVzID0gW107XG4gICAgbm9kZVN0YXJ0LmluZGV4ZXJzID0gW107XG4gICAgbm9kZVN0YXJ0LmludGVybmFsU2xvdHMgPSBbXTtcbiAgICBsZXQgZW5kRGVsaW07XG4gICAgbGV0IGV4YWN0O1xuICAgIGxldCBpbmV4YWN0ID0gZmFsc2U7XG5cbiAgICBpZiAoYWxsb3dFeGFjdCAmJiB0aGlzLm1hdGNoKHR5cGVzLmJyYWNlQmFyTCkpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlQmFyTCk7XG4gICAgICBlbmREZWxpbSA9IHR5cGVzLmJyYWNlQmFyUjtcbiAgICAgIGV4YWN0ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgICAgIGVuZERlbGltID0gdHlwZXMuYnJhY2VSO1xuICAgICAgZXhhY3QgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBub2RlU3RhcnQuZXhhY3QgPSBleGFjdDtcblxuICAgIHdoaWxlICghdGhpcy5tYXRjaChlbmREZWxpbSkpIHtcbiAgICAgIGxldCBpc1N0YXRpYyA9IGZhbHNlO1xuICAgICAgbGV0IHByb3RvU3RhcnQgPSBudWxsO1xuICAgICAgbGV0IGluZXhhY3RTdGFydCA9IG51bGw7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgICAgaWYgKGFsbG93UHJvdG8gJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJwcm90b1wiKSkge1xuICAgICAgICBjb25zdCBsb29rYWhlYWQgPSB0aGlzLmxvb2thaGVhZCgpO1xuXG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gdHlwZXMuY29sb24gJiYgbG9va2FoZWFkLnR5cGUgIT09IHR5cGVzLnF1ZXN0aW9uKSB7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgcHJvdG9TdGFydCA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgICAgICAgYWxsb3dTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWxsb3dTdGF0aWMgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJzdGF0aWNcIikpIHtcbiAgICAgICAgY29uc3QgbG9va2FoZWFkID0gdGhpcy5sb29rYWhlYWQoKTtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IHR5cGVzLmNvbG9uICYmIGxvb2thaGVhZC50eXBlICE9PSB0eXBlcy5xdWVzdGlvbikge1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGlzU3RhdGljID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB2YXJpYW5jZSA9IHRoaXMuZmxvd1BhcnNlVmFyaWFuY2UoKTtcblxuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmJyYWNrZXRMKSkge1xuICAgICAgICBpZiAocHJvdG9TdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKHByb3RvU3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmJyYWNrZXRMKSkge1xuICAgICAgICAgIGlmICh2YXJpYW5jZSkge1xuICAgICAgICAgICAgdGhpcy51bmV4cGVjdGVkKHZhcmlhbmNlLnN0YXJ0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBub2RlU3RhcnQuaW50ZXJuYWxTbG90cy5wdXNoKHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZUludGVybmFsU2xvdChub2RlLCBpc1N0YXRpYykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGVTdGFydC5pbmRleGVycy5wdXNoKHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZUluZGV4ZXIobm9kZSwgaXNTdGF0aWMsIHZhcmlhbmNlKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCh0eXBlcy5wYXJlbkwpIHx8IHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgICAgICBpZiAocHJvdG9TdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKHByb3RvU3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhcmlhbmNlKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKHZhcmlhbmNlLnN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGVTdGFydC5jYWxsUHJvcGVydGllcy5wdXNoKHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eShub2RlLCBpc1N0YXRpYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGtpbmQgPSBcImluaXRcIjtcblxuICAgICAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJnZXRcIikgfHwgdGhpcy5pc0NvbnRleHR1YWwoXCJzZXRcIikpIHtcbiAgICAgICAgICBjb25zdCBsb29rYWhlYWQgPSB0aGlzLmxvb2thaGVhZCgpO1xuXG4gICAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSB0eXBlcy5uYW1lIHx8IGxvb2thaGVhZC50eXBlID09PSB0eXBlcy5zdHJpbmcgfHwgbG9va2FoZWFkLnR5cGUgPT09IHR5cGVzLm51bSkge1xuICAgICAgICAgICAga2luZCA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcm9wT3JJbmV4YWN0ID0gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlUHJvcGVydHkobm9kZSwgaXNTdGF0aWMsIHByb3RvU3RhcnQsIHZhcmlhbmNlLCBraW5kLCBhbGxvd1NwcmVhZCwgYWxsb3dJbmV4YWN0ICE9IG51bGwgPyBhbGxvd0luZXhhY3QgOiAhZXhhY3QpO1xuXG4gICAgICAgIGlmIChwcm9wT3JJbmV4YWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgaW5leGFjdCA9IHRydWU7XG4gICAgICAgICAgaW5leGFjdFN0YXJ0ID0gdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZVN0YXJ0LnByb3BlcnRpZXMucHVzaChwcm9wT3JJbmV4YWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmZsb3dPYmplY3RUeXBlU2VtaWNvbG9uKCk7XG5cbiAgICAgIGlmIChpbmV4YWN0U3RhcnQgJiYgIXRoaXMubWF0Y2godHlwZXMuYnJhY2VSKSAmJiAhdGhpcy5tYXRjaCh0eXBlcy5icmFjZUJhclIpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoaW5leGFjdFN0YXJ0LCBGbG93RXJyb3JzLlVuZXhwZWN0ZWRFeHBsaWNpdEluZXhhY3RJbk9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5leHBlY3QoZW5kRGVsaW0pO1xuXG4gICAgaWYgKGFsbG93U3ByZWFkKSB7XG4gICAgICBub2RlU3RhcnQuaW5leGFjdCA9IGluZXhhY3Q7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0ID0gdGhpcy5maW5pc2hOb2RlKG5vZGVTdGFydCwgXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiKTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgZmxvd1BhcnNlT2JqZWN0VHlwZVByb3BlcnR5KG5vZGUsIGlzU3RhdGljLCBwcm90b1N0YXJ0LCB2YXJpYW5jZSwga2luZCwgYWxsb3dTcHJlYWQsIGFsbG93SW5leGFjdCkge1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5lbGxpcHNpcykpIHtcbiAgICAgIGNvbnN0IGlzSW5leGFjdFRva2VuID0gdGhpcy5tYXRjaCh0eXBlcy5jb21tYSkgfHwgdGhpcy5tYXRjaCh0eXBlcy5zZW1pKSB8fCB0aGlzLm1hdGNoKHR5cGVzLmJyYWNlUikgfHwgdGhpcy5tYXRjaCh0eXBlcy5icmFjZUJhclIpO1xuXG4gICAgICBpZiAoaXNJbmV4YWN0VG9rZW4pIHtcbiAgICAgICAgaWYgKCFhbGxvd1NwcmVhZCkge1xuICAgICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQsIEZsb3dFcnJvcnMuSW5leGFjdEluc2lkZU5vbk9iamVjdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWFsbG93SW5leGFjdCkge1xuICAgICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQsIEZsb3dFcnJvcnMuSW5leGFjdEluc2lkZUV4YWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YXJpYW5jZSkge1xuICAgICAgICAgIHRoaXMucmFpc2UodmFyaWFuY2Uuc3RhcnQsIEZsb3dFcnJvcnMuSW5leGFjdFZhcmlhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFsbG93U3ByZWFkKSB7XG4gICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQsIEZsb3dFcnJvcnMuVW5leHBlY3RlZFNwcmVhZFR5cGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvdG9TdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChwcm90b1N0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhcmlhbmNlKSB7XG4gICAgICAgIHRoaXMucmFpc2UodmFyaWFuY2Uuc3RhcnQsIEZsb3dFcnJvcnMuU3ByZWFkVmFyaWFuY2UpO1xuICAgICAgfVxuXG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmtleSA9IHRoaXMuZmxvd1BhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgIG5vZGUuc3RhdGljID0gaXNTdGF0aWM7XG4gICAgICBub2RlLnByb3RvID0gcHJvdG9TdGFydCAhPSBudWxsO1xuICAgICAgbm9kZS5raW5kID0ga2luZDtcbiAgICAgIGxldCBvcHRpb25hbCA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpIHx8IHRoaXMubWF0Y2godHlwZXMucGFyZW5MKSkge1xuICAgICAgICBub2RlLm1ldGhvZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHByb3RvU3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMudW5leHBlY3RlZChwcm90b1N0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YXJpYW5jZSkge1xuICAgICAgICAgIHRoaXMudW5leHBlY3RlZCh2YXJpYW5jZS5zdGFydCk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLnZhbHVlID0gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKHRoaXMuc3RhcnROb2RlQXQobm9kZS5zdGFydCwgbm9kZS5sb2Muc3RhcnQpKTtcblxuICAgICAgICBpZiAoa2luZCA9PT0gXCJnZXRcIiB8fCBraW5kID09PSBcInNldFwiKSB7XG4gICAgICAgICAgdGhpcy5mbG93Q2hlY2tHZXR0ZXJTZXR0ZXJQYXJhbXMobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChraW5kICE9PSBcImluaXRcIikgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIG5vZGUubWV0aG9kID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLnF1ZXN0aW9uKSkge1xuICAgICAgICAgIG9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgICAgICBub2RlLnZhcmlhbmNlID0gdmFyaWFuY2U7XG4gICAgICB9XG5cbiAgICAgIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RUeXBlUHJvcGVydHlcIik7XG4gICAgfVxuICB9XG5cbiAgZmxvd0NoZWNrR2V0dGVyU2V0dGVyUGFyYW1zKHByb3BlcnR5KSB7XG4gICAgY29uc3QgcGFyYW1Db3VudCA9IHByb3BlcnR5LmtpbmQgPT09IFwiZ2V0XCIgPyAwIDogMTtcbiAgICBjb25zdCBzdGFydCA9IHByb3BlcnR5LnN0YXJ0O1xuICAgIGNvbnN0IGxlbmd0aCA9IHByb3BlcnR5LnZhbHVlLnBhcmFtcy5sZW5ndGggKyAocHJvcGVydHkudmFsdWUucmVzdCA/IDEgOiAwKTtcblxuICAgIGlmIChsZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICAgIGlmIChwcm9wZXJ0eS5raW5kID09PSBcImdldFwiKSB7XG4gICAgICAgIHRoaXMucmFpc2Uoc3RhcnQsIEVycm9yTWVzc2FnZXMuQmFkR2V0dGVyQXJpdHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yYWlzZShzdGFydCwgRXJyb3JNZXNzYWdlcy5CYWRTZXR0ZXJBcml0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5LmtpbmQgPT09IFwic2V0XCIgJiYgcHJvcGVydHkudmFsdWUucmVzdCkge1xuICAgICAgdGhpcy5yYWlzZShzdGFydCwgRXJyb3JNZXNzYWdlcy5CYWRTZXR0ZXJSZXN0UGFyYW1ldGVyKTtcbiAgICB9XG4gIH1cblxuICBmbG93T2JqZWN0VHlwZVNlbWljb2xvbigpIHtcbiAgICBpZiAoIXRoaXMuZWF0KHR5cGVzLnNlbWkpICYmICF0aGlzLmVhdCh0eXBlcy5jb21tYSkgJiYgIXRoaXMubWF0Y2godHlwZXMuYnJhY2VSKSAmJiAhdGhpcy5tYXRjaCh0eXBlcy5icmFjZUJhclIpKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH1cblxuICBmbG93UGFyc2VRdWFsaWZpZWRUeXBlSWRlbnRpZmllcihzdGFydFBvcywgc3RhcnRMb2MsIGlkKSB7XG4gICAgc3RhcnRQb3MgPSBzdGFydFBvcyB8fCB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIHN0YXJ0TG9jID0gc3RhcnRMb2MgfHwgdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBsZXQgbm9kZSA9IGlkIHx8IHRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIodHJ1ZSk7XG5cbiAgICB3aGlsZSAodGhpcy5lYXQodHlwZXMuZG90KSkge1xuICAgICAgY29uc3Qgbm9kZTIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlMi5xdWFsaWZpY2F0aW9uID0gbm9kZTtcbiAgICAgIG5vZGUyLmlkID0gdGhpcy5mbG93UGFyc2VSZXN0cmljdGVkSWRlbnRpZmllcih0cnVlKTtcbiAgICAgIG5vZGUgPSB0aGlzLmZpbmlzaE5vZGUobm9kZTIsIFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmbG93UGFyc2VHZW5lcmljVHlwZShzdGFydFBvcywgc3RhcnRMb2MsIGlkKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VRdWFsaWZpZWRUeXBlSWRlbnRpZmllcihzdGFydFBvcywgc3RhcnRMb2MsIGlkKTtcblxuICAgIGlmICh0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZVR5cGVvZlR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuX3R5cGVvZik7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMuZmxvd1BhcnNlUHJpbWFyeVR5cGUoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZW9mVHlwZUFubm90YXRpb25cIik7XG4gIH1cblxuICBmbG93UGFyc2VUdXBsZVR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS50eXBlcyA9IFtdO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRMKTtcblxuICAgIHdoaWxlICh0aGlzLnN0YXRlLnBvcyA8IHRoaXMubGVuZ3RoICYmICF0aGlzLm1hdGNoKHR5cGVzLmJyYWNrZXRSKSkge1xuICAgICAgbm9kZS50eXBlcy5wdXNoKHRoaXMuZmxvd1BhcnNlVHlwZSgpKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmJyYWNrZXRSKSkgYnJlYWs7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgfVxuXG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2tldFIpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG5cbiAgZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW0oKSB7XG4gICAgbGV0IG5hbWUgPSBudWxsO1xuICAgIGxldCBvcHRpb25hbCA9IGZhbHNlO1xuICAgIGxldCB0eXBlQW5ub3RhdGlvbiA9IG51bGw7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgbGggPSB0aGlzLmxvb2thaGVhZCgpO1xuXG4gICAgaWYgKGxoLnR5cGUgPT09IHR5cGVzLmNvbG9uIHx8IGxoLnR5cGUgPT09IHR5cGVzLnF1ZXN0aW9uKSB7XG4gICAgICBuYW1lID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcblxuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLnF1ZXN0aW9uKSkge1xuICAgICAgICBvcHRpb25hbCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICB9XG5cbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICAgIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZUFubm90YXRpb247XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uVHlwZVBhcmFtXCIpO1xuICB9XG5cbiAgcmVpbnRlcnByZXRUeXBlQXNGdW5jdGlvblR5cGVQYXJhbSh0eXBlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQodHlwZS5zdGFydCwgdHlwZS5sb2Muc3RhcnQpO1xuICAgIG5vZGUubmFtZSA9IG51bGw7XG4gICAgbm9kZS5vcHRpb25hbCA9IGZhbHNlO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvblR5cGVQYXJhbVwiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtcyhwYXJhbXMgPSBbXSkge1xuICAgIGxldCByZXN0ID0gbnVsbDtcblxuICAgIHdoaWxlICghdGhpcy5tYXRjaCh0eXBlcy5wYXJlblIpICYmICF0aGlzLm1hdGNoKHR5cGVzLmVsbGlwc2lzKSkge1xuICAgICAgcGFyYW1zLnB1c2godGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbSgpKTtcblxuICAgICAgaWYgKCF0aGlzLm1hdGNoKHR5cGVzLnBhcmVuUikpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5lbGxpcHNpcykpIHtcbiAgICAgIHJlc3QgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmFtcyxcbiAgICAgIHJlc3RcbiAgICB9O1xuICB9XG5cbiAgZmxvd0lkZW50VG9UeXBlQW5ub3RhdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIG5vZGUsIGlkKSB7XG4gICAgc3dpdGNoIChpZC5uYW1lKSB7XG4gICAgICBjYXNlIFwiYW55XCI6XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBbnlUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCb29sZWFuVHlwZUFubm90YXRpb25cIik7XG5cbiAgICAgIGNhc2UgXCJtaXhlZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWl4ZWRUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgICAgY2FzZSBcImVtcHR5XCI6XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbXB0eVR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3RyaW5nVHlwZUFubm90YXRpb25cIik7XG5cbiAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN5bWJvbFR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmNoZWNrTm90VW5kZXJzY29yZShpZC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlR2VuZXJpY1R5cGUoc3RhcnRQb3MsIHN0YXJ0TG9jLCBpZCk7XG4gICAgfVxuICB9XG5cbiAgZmxvd1BhcnNlUHJpbWFyeVR5cGUoKSB7XG4gICAgY29uc3Qgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBsZXQgdG1wO1xuICAgIGxldCB0eXBlO1xuICAgIGxldCBpc0dyb3VwZWRUeXBlID0gZmFsc2U7XG4gICAgY29uc3Qgb2xkTm9Bbm9uRnVuY3Rpb25UeXBlID0gdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGU7XG5cbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSB0eXBlcy5uYW1lOlxuICAgICAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJpbnRlcmZhY2VcIikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2VUeXBlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mbG93SWRlbnRUb1R5cGVBbm5vdGF0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgbm9kZSwgdGhpcy5wYXJzZUlkZW50aWZpZXIoKSk7XG5cbiAgICAgIGNhc2UgdHlwZXMuYnJhY2VMOlxuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlKHtcbiAgICAgICAgICBhbGxvd1N0YXRpYzogZmFsc2UsXG4gICAgICAgICAgYWxsb3dFeGFjdDogZmFsc2UsXG4gICAgICAgICAgYWxsb3dTcHJlYWQ6IHRydWUsXG4gICAgICAgICAgYWxsb3dQcm90bzogZmFsc2UsXG4gICAgICAgICAgYWxsb3dJbmV4YWN0OiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlIHR5cGVzLmJyYWNlQmFyTDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZSh7XG4gICAgICAgICAgYWxsb3dTdGF0aWM6IGZhbHNlLFxuICAgICAgICAgIGFsbG93RXhhY3Q6IHRydWUsXG4gICAgICAgICAgYWxsb3dTcHJlYWQ6IHRydWUsXG4gICAgICAgICAgYWxsb3dQcm90bzogZmFsc2UsXG4gICAgICAgICAgYWxsb3dJbmV4YWN0OiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgY2FzZSB0eXBlcy5icmFja2V0TDpcbiAgICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSBmYWxzZTtcbiAgICAgICAgdHlwZSA9IHRoaXMuZmxvd1BhcnNlVHVwbGVUeXBlKCk7XG4gICAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gb2xkTm9Bbm9uRnVuY3Rpb25UeXBlO1xuICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgICAgY2FzZSB0eXBlcy5yZWxhdGlvbmFsOlxuICAgICAgICBpZiAodGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCI8XCIpIHtcbiAgICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICAgICAgICAgIHRtcCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKCk7XG4gICAgICAgICAgbm9kZS5wYXJhbXMgPSB0bXAucGFyYW1zO1xuICAgICAgICAgIG5vZGUucmVzdCA9IHRtcC5yZXN0O1xuICAgICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuYXJyb3cpO1xuICAgICAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgdHlwZXMucGFyZW5MOlxuICAgICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgICBpZiAoIXRoaXMubWF0Y2godHlwZXMucGFyZW5SKSAmJiAhdGhpcy5tYXRjaCh0eXBlcy5lbGxpcHNpcykpIHtcbiAgICAgICAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5uYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmxvb2thaGVhZCgpLnR5cGU7XG4gICAgICAgICAgICBpc0dyb3VwZWRUeXBlID0gdG9rZW4gIT09IHR5cGVzLnF1ZXN0aW9uICYmIHRva2VuICE9PSB0eXBlcy5jb2xvbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNHcm91cGVkVHlwZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzR3JvdXBlZFR5cGUpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IGZhbHNlO1xuICAgICAgICAgIHR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IG9sZE5vQW5vbkZ1bmN0aW9uVHlwZTtcblxuICAgICAgICAgIGlmICh0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSB8fCAhKHRoaXMubWF0Y2godHlwZXMuY29tbWEpIHx8IHRoaXMubWF0Y2godHlwZXMucGFyZW5SKSAmJiB0aGlzLmxvb2thaGVhZCgpLnR5cGUgPT09IHR5cGVzLmFycm93KSkge1xuICAgICAgICAgICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVhdCh0eXBlcy5jb21tYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICB0bXAgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtcyhbdGhpcy5yZWludGVycHJldFR5cGVBc0Z1bmN0aW9uVHlwZVBhcmFtKHR5cGUpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG1wID0gdGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUucGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICAgICAgbm9kZS5yZXN0ID0gdG1wLnJlc3Q7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmFycm93KTtcbiAgICAgICAgbm9kZS5yZXR1cm5UeXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKTtcblxuICAgICAgY2FzZSB0eXBlcy5zdHJpbmc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlLCBcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgICAgY2FzZSB0eXBlcy5fdHJ1ZTpcbiAgICAgIGNhc2UgdHlwZXMuX2ZhbHNlOlxuICAgICAgICBub2RlLnZhbHVlID0gdGhpcy5tYXRjaCh0eXBlcy5fdHJ1ZSk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgICAgY2FzZSB0eXBlcy5wbHVzTWluOlxuICAgICAgICBpZiAodGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCItXCIpIHtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLm51bSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCgtdGhpcy5zdGF0ZS52YWx1ZSwgXCJOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb25cIiwgbm9kZS5zdGFydCwgbm9kZS5sb2Muc3RhcnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmJpZ2ludCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCgtdGhpcy5zdGF0ZS52YWx1ZSwgXCJCaWdJbnRMaXRlcmFsVHlwZUFubm90YXRpb25cIiwgbm9kZS5zdGFydCwgbm9kZS5sb2Muc3RhcnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCwgRmxvd0Vycm9ycy5VbmV4cGVjdGVkU3VidHJhY3Rpb25PcGVyYW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuXG4gICAgICBjYXNlIHR5cGVzLm51bTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUsIFwiTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgICBjYXNlIHR5cGVzLmJpZ2ludDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUsIFwiQmlnSW50TGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgICBjYXNlIHR5cGVzLl92b2lkOlxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZvaWRUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgICAgY2FzZSB0eXBlcy5fbnVsbDpcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgICBjYXNlIHR5cGVzLl90aGlzOlxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRoaXNUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgICAgY2FzZSB0eXBlcy5zdGFyOlxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4aXN0c1R5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodGhpcy5zdGF0ZS50eXBlLmtleXdvcmQgPT09IFwidHlwZW9mXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VUeXBlb2ZUeXBlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS50eXBlLmtleXdvcmQpIHtcbiAgICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMuc3RhdGUudHlwZS5sYWJlbDtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gc3VwZXIuY3JlYXRlSWRlbnRpZmllcihub2RlLCBsYWJlbCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG5cbiAgZmxvd1BhcnNlUG9zdGZpeFR5cGUoKSB7XG4gICAgY29uc3Qgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0LFxuICAgICAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBsZXQgdHlwZSA9IHRoaXMuZmxvd1BhcnNlUHJpbWFyeVR5cGUoKTtcblxuICAgIHdoaWxlICh0aGlzLm1hdGNoKHR5cGVzLmJyYWNrZXRMKSAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUuZWxlbWVudFR5cGUgPSB0eXBlO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2tldEwpO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2tldFIpO1xuICAgICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5VHlwZUFubm90YXRpb25cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBmbG93UGFyc2VQcmVmaXhUeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnF1ZXN0aW9uKSkge1xuICAgICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlUHJlZml4VHlwZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVBvc3RmaXhUeXBlKCk7XG4gICAgfVxuICB9XG5cbiAgZmxvd1BhcnNlQW5vbkZ1bmN0aW9uV2l0aG91dFBhcmVucygpIHtcbiAgICBjb25zdCBwYXJhbSA9IHRoaXMuZmxvd1BhcnNlUHJlZml4VHlwZSgpO1xuXG4gICAgaWYgKCF0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSAmJiB0aGlzLmVhdCh0eXBlcy5hcnJvdykpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHBhcmFtLnN0YXJ0LCBwYXJhbS5sb2Muc3RhcnQpO1xuICAgICAgbm9kZS5wYXJhbXMgPSBbdGhpcy5yZWludGVycHJldFR5cGVBc0Z1bmN0aW9uVHlwZVBhcmFtKHBhcmFtKV07XG4gICAgICBub2RlLnJlc3QgPSBudWxsO1xuICAgICAgbm9kZS5yZXR1cm5UeXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbTtcbiAgfVxuXG4gIGZsb3dQYXJzZUludGVyc2VjdGlvblR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5lYXQodHlwZXMuYml0d2lzZUFORCk7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZmxvd1BhcnNlQW5vbkZ1bmN0aW9uV2l0aG91dFBhcmVucygpO1xuICAgIG5vZGUudHlwZXMgPSBbdHlwZV07XG5cbiAgICB3aGlsZSAodGhpcy5lYXQodHlwZXMuYml0d2lzZUFORCkpIHtcbiAgICAgIG5vZGUudHlwZXMucHVzaCh0aGlzLmZsb3dQYXJzZUFub25GdW5jdGlvbldpdGhvdXRQYXJlbnMoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGUudHlwZXMubGVuZ3RoID09PSAxID8gdHlwZSA6IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG5cbiAgZmxvd1BhcnNlVW5pb25UeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZWF0KHR5cGVzLmJpdHdpc2VPUik7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZmxvd1BhcnNlSW50ZXJzZWN0aW9uVHlwZSgpO1xuICAgIG5vZGUudHlwZXMgPSBbdHlwZV07XG5cbiAgICB3aGlsZSAodGhpcy5lYXQodHlwZXMuYml0d2lzZU9SKSkge1xuICAgICAgbm9kZS50eXBlcy5wdXNoKHRoaXMuZmxvd1BhcnNlSW50ZXJzZWN0aW9uVHlwZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZS50eXBlcy5sZW5ndGggPT09IDEgPyB0eXBlIDogdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVW5pb25UeXBlQW5ub3RhdGlvblwiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZVR5cGUoKSB7XG4gICAgY29uc3Qgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmZsb3dQYXJzZVVuaW9uVHlwZSgpO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICAgIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkIHx8IHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgZmxvd1BhcnNlVHlwZU9ySW1wbGljaXRJbnN0YW50aWF0aW9uKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnR5cGUgPT09IHR5cGVzLm5hbWUgJiYgdGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCJfXCIpIHtcbiAgICAgIGNvbnN0IHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlR2VuZXJpY1R5cGUoc3RhcnRQb3MsIHN0YXJ0TG9jLCBub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUeXBlQW5ub3RhdGlvblwiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZVR5cGVBbm5vdGF0YWJsZUlkZW50aWZpZXIoYWxsb3dQcmltaXRpdmVPdmVycmlkZSkge1xuICAgIGNvbnN0IGlkZW50ID0gYWxsb3dQcmltaXRpdmVPdmVycmlkZSA/IHRoaXMucGFyc2VJZGVudGlmaWVyKCkgOiB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKCk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5jb2xvbikpIHtcbiAgICAgIGlkZW50LnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKGlkZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaWRlbnQ7XG4gIH1cblxuICB0eXBlQ2FzdFRvUGFyYW1ldGVyKG5vZGUpIHtcbiAgICBub2RlLmV4cHJlc3Npb24udHlwZUFubm90YXRpb24gPSBub2RlLnR5cGVBbm5vdGF0aW9uO1xuICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudHlwZUFubm90YXRpb24uZW5kLCBub2RlLnR5cGVBbm5vdGF0aW9uLmxvYy5lbmQpO1xuICAgIHJldHVybiBub2RlLmV4cHJlc3Npb247XG4gIH1cblxuICBmbG93UGFyc2VWYXJpYW5jZSgpIHtcbiAgICBsZXQgdmFyaWFuY2UgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMucGx1c01pbikpIHtcbiAgICAgIHZhcmlhbmNlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgICAgaWYgKHRoaXMuc3RhdGUudmFsdWUgPT09IFwiK1wiKSB7XG4gICAgICAgIHZhcmlhbmNlLmtpbmQgPSBcInBsdXNcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhcmlhbmNlLmtpbmQgPSBcIm1pbnVzXCI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5maW5pc2hOb2RlKHZhcmlhbmNlLCBcIlZhcmlhbmNlXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB2YXJpYW5jZTtcbiAgfVxuXG4gIHBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGFsbG93RXhwcmVzc2lvbkJvZHksIGlzTWV0aG9kID0gZmFsc2UpIHtcbiAgICBpZiAoYWxsb3dFeHByZXNzaW9uQm9keSkge1xuICAgICAgcmV0dXJuIHRoaXMuZm9yd2FyZE5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQobm9kZSwgKCkgPT4gc3VwZXIucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgdHJ1ZSwgaXNNZXRob2QpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgZmFsc2UsIGlzTWV0aG9kKTtcbiAgfVxuXG4gIHBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIHR5cGUsIGlzTWV0aG9kID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5jb2xvbikpIHtcbiAgICAgIGNvbnN0IHR5cGVOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIFt0eXBlTm9kZS50eXBlQW5ub3RhdGlvbiwgbm9kZS5wcmVkaWNhdGVdID0gdGhpcy5mbG93UGFyc2VUeXBlQW5kUHJlZGljYXRlSW5pdGlhbGlzZXIoKTtcbiAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHR5cGVOb2RlLnR5cGVBbm5vdGF0aW9uID8gdGhpcy5maW5pc2hOb2RlKHR5cGVOb2RlLCBcIlR5cGVBbm5vdGF0aW9uXCIpIDogbnVsbDtcbiAgICB9XG5cbiAgICBzdXBlci5wYXJzZUZ1bmN0aW9uQm9keUFuZEZpbmlzaChub2RlLCB0eXBlLCBpc01ldGhvZCk7XG4gIH1cblxuICBwYXJzZVN0YXRlbWVudChjb250ZXh0LCB0b3BMZXZlbCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnN0cmljdCAmJiB0aGlzLm1hdGNoKHR5cGVzLm5hbWUpICYmIHRoaXMuc3RhdGUudmFsdWUgPT09IFwiaW50ZXJmYWNlXCIpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2Uobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNob3VsZFBhcnNlRW51bXMoKSAmJiB0aGlzLmlzQ29udGV4dHVhbChcImVudW1cIikpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VFbnVtRGVjbGFyYXRpb24obm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0bXQgPSBzdXBlci5wYXJzZVN0YXRlbWVudChjb250ZXh0LCB0b3BMZXZlbCk7XG5cbiAgICAgIGlmICh0aGlzLmZsb3dQcmFnbWEgPT09IHVuZGVmaW5lZCAmJiAhdGhpcy5pc1ZhbGlkRGlyZWN0aXZlKHN0bXQpKSB7XG4gICAgICAgIHRoaXMuZmxvd1ByYWdtYSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdG10O1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByKSB7XG4gICAgaWYgKGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgIGlmIChleHByLm5hbWUgPT09IFwiZGVjbGFyZVwiKSB7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLl9jbGFzcykgfHwgdGhpcy5tYXRjaCh0eXBlcy5uYW1lKSB8fCB0aGlzLm1hdGNoKHR5cGVzLl9mdW5jdGlvbikgfHwgdGhpcy5tYXRjaCh0eXBlcy5fdmFyKSB8fCB0aGlzLm1hdGNoKHR5cGVzLl9leHBvcnQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHR5cGVzLm5hbWUpKSB7XG4gICAgICAgIGlmIChleHByLm5hbWUgPT09IFwiaW50ZXJmYWNlXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2Uobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXhwci5uYW1lID09PSBcInR5cGVcIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVR5cGVBbGlhcyhub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChleHByLm5hbWUgPT09IFwib3BhcXVlXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPcGFxdWVUeXBlKG5vZGUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwcik7XG4gIH1cblxuICBzaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzQ29udGV4dHVhbChcInR5cGVcIikgfHwgdGhpcy5pc0NvbnRleHR1YWwoXCJpbnRlcmZhY2VcIikgfHwgdGhpcy5pc0NvbnRleHR1YWwoXCJvcGFxdWVcIikgfHwgdGhpcy5zaG91bGRQYXJzZUVudW1zKCkgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJlbnVtXCIpIHx8IHN1cGVyLnNob3VsZFBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKTtcbiAgfVxuXG4gIGlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpIHtcbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5uYW1lKSAmJiAodGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCJ0eXBlXCIgfHwgdGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCJpbnRlcmZhY2VcIiB8fCB0aGlzLnN0YXRlLnZhbHVlID09PSBcIm9wYXF1ZVwiIHx8IHRoaXMuc2hvdWxkUGFyc2VFbnVtcygpICYmIHRoaXMuc3RhdGUudmFsdWUgPT09IFwiZW51bVwiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5pc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIoKTtcbiAgfVxuXG4gIHBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkUGFyc2VFbnVtcygpICYmIHRoaXMuaXNDb250ZXh0dWFsKFwiZW51bVwiKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZUVudW1EZWNsYXJhdGlvbihub2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnREZWZhdWx0RXhwcmVzc2lvbigpO1xuICB9XG5cbiAgcGFyc2VDb25kaXRpb25hbChleHByLCBub0luLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZk5lZWRzQXJyb3dQb3MpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2godHlwZXMucXVlc3Rpb24pKSByZXR1cm4gZXhwcjtcblxuICAgIGlmIChyZWZOZWVkc0Fycm93UG9zKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKCgpID0+IHN1cGVyLnBhcnNlQ29uZGl0aW9uYWwoZXhwciwgbm9Jbiwgc3RhcnRQb3MsIHN0YXJ0TG9jKSk7XG5cbiAgICAgIGlmICghcmVzdWx0Lm5vZGUpIHtcbiAgICAgICAgcmVmTmVlZHNBcnJvd1Bvcy5zdGFydCA9IHJlc3VsdC5lcnJvci5wb3MgfHwgdGhpcy5zdGF0ZS5zdGFydDtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHRoaXMuc3RhdGUgPSByZXN1bHQuZmFpbFN0YXRlO1xuICAgICAgcmV0dXJuIHJlc3VsdC5ub2RlO1xuICAgIH1cblxuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnF1ZXN0aW9uKTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICBjb25zdCBvcmlnaW5hbE5vQXJyb3dBdCA9IHRoaXMuc3RhdGUubm9BcnJvd0F0O1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbGV0IHtcbiAgICAgIGNvbnNlcXVlbnQsXG4gICAgICBmYWlsZWRcbiAgICB9ID0gdGhpcy50cnlQYXJzZUNvbmRpdGlvbmFsQ29uc2VxdWVudCgpO1xuICAgIGxldCBbdmFsaWQsIGludmFsaWRdID0gdGhpcy5nZXRBcnJvd0xpa2VFeHByZXNzaW9ucyhjb25zZXF1ZW50KTtcblxuICAgIGlmIChmYWlsZWQgfHwgaW52YWxpZC5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBub0Fycm93QXQgPSBbLi4ub3JpZ2luYWxOb0Fycm93QXRdO1xuXG4gICAgICBpZiAoaW52YWxpZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5ub0Fycm93QXQgPSBub0Fycm93QXQ7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnZhbGlkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9BcnJvd0F0LnB1c2goaW52YWxpZFtpXS5zdGFydCk7XG4gICAgICAgIH1cblxuICAgICAgICAoe1xuICAgICAgICAgIGNvbnNlcXVlbnQsXG4gICAgICAgICAgZmFpbGVkXG4gICAgICAgIH0gPSB0aGlzLnRyeVBhcnNlQ29uZGl0aW9uYWxDb25zZXF1ZW50KCkpO1xuICAgICAgICBbdmFsaWQsIGludmFsaWRdID0gdGhpcy5nZXRBcnJvd0xpa2VFeHByZXNzaW9ucyhjb25zZXF1ZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZhaWxlZCAmJiB2YWxpZC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMucmFpc2Uoc3RhdGUuc3RhcnQsIEZsb3dFcnJvcnMuQW1iaWd1b3VzQ29uZGl0aW9uYWxBcnJvdyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmYWlsZWQgJiYgdmFsaWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5ub0Fycm93QXQgPSBub0Fycm93QXQuY29uY2F0KHZhbGlkWzBdLnN0YXJ0KTtcbiAgICAgICAgKHtcbiAgICAgICAgICBjb25zZXF1ZW50LFxuICAgICAgICAgIGZhaWxlZFxuICAgICAgICB9ID0gdGhpcy50cnlQYXJzZUNvbmRpdGlvbmFsQ29uc2VxdWVudCgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmdldEFycm93TGlrZUV4cHJlc3Npb25zKGNvbnNlcXVlbnQsIHRydWUpO1xuICAgIHRoaXMuc3RhdGUubm9BcnJvd0F0ID0gb3JpZ2luYWxOb0Fycm93QXQ7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuY29sb24pO1xuICAgIG5vZGUudGVzdCA9IGV4cHI7XG4gICAgbm9kZS5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcbiAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMuZm9yd2FyZE5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQobm9kZSwgKCkgPT4gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpO1xuICB9XG5cbiAgdHJ5UGFyc2VDb25kaXRpb25hbENvbnNlcXVlbnQoKSB7XG4gICAgdGhpcy5zdGF0ZS5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0LnB1c2godGhpcy5zdGF0ZS5zdGFydCk7XG4gICAgY29uc3QgY29uc2VxdWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIGNvbnN0IGZhaWxlZCA9ICF0aGlzLm1hdGNoKHR5cGVzLmNvbG9uKTtcbiAgICB0aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQucG9wKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnNlcXVlbnQsXG4gICAgICBmYWlsZWRcbiAgICB9O1xuICB9XG5cbiAgZ2V0QXJyb3dMaWtlRXhwcmVzc2lvbnMobm9kZSwgZGlzYWxsb3dJbnZhbGlkKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBbbm9kZV07XG4gICAgY29uc3QgYXJyb3dzID0gW107XG5cbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCBub2RlID0gc3RhY2sucG9wKCk7XG5cbiAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIikge1xuICAgICAgICBpZiAobm9kZS50eXBlUGFyYW1ldGVycyB8fCAhbm9kZS5yZXR1cm5UeXBlKSB7XG4gICAgICAgICAgdGhpcy5maW5pc2hBcnJvd1ZhbGlkYXRpb24obm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyb3dzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFjay5wdXNoKG5vZGUuYm9keSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIikge1xuICAgICAgICBzdGFjay5wdXNoKG5vZGUuY29uc2VxdWVudCk7XG4gICAgICAgIHN0YWNrLnB1c2gobm9kZS5hbHRlcm5hdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaXNhbGxvd0ludmFsaWQpIHtcbiAgICAgIGFycm93cy5mb3JFYWNoKG5vZGUgPT4gdGhpcy5maW5pc2hBcnJvd1ZhbGlkYXRpb24obm9kZSkpO1xuICAgICAgcmV0dXJuIFthcnJvd3MsIFtdXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFydGl0aW9uKGFycm93cywgbm9kZSA9PiBub2RlLnBhcmFtcy5ldmVyeShwYXJhbSA9PiB0aGlzLmlzQXNzaWduYWJsZShwYXJhbSwgdHJ1ZSkpKTtcbiAgfVxuXG4gIGZpbmlzaEFycm93VmFsaWRhdGlvbihub2RlKSB7XG4gICAgdmFyIF9ub2RlJGV4dHJhO1xuXG4gICAgdGhpcy50b0Fzc2lnbmFibGVMaXN0KG5vZGUucGFyYW1zLCAoX25vZGUkZXh0cmEgPSBub2RlLmV4dHJhKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkZXh0cmEudHJhaWxpbmdDb21tYSk7XG4gICAgdGhpcy5zY29wZS5lbnRlcihTQ09QRV9GVU5DVElPTiB8IFNDT1BFX0FSUk9XKTtcbiAgICBzdXBlci5jaGVja1BhcmFtcyhub2RlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gIH1cblxuICBmb3J3YXJkTm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdChub2RlLCBwYXJzZSkge1xuICAgIGxldCByZXN1bHQ7XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0LmluZGV4T2Yobm9kZS5zdGFydCkgIT09IC0xKSB7XG4gICAgICB0aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQucHVzaCh0aGlzLnN0YXRlLnN0YXJ0KTtcbiAgICAgIHJlc3VsdCA9IHBhcnNlKCk7XG4gICAgICB0aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHBhcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHBhcnNlUGFyZW5JdGVtKG5vZGUsIHN0YXJ0UG9zLCBzdGFydExvYykge1xuICAgIG5vZGUgPSBzdXBlci5wYXJzZVBhcmVuSXRlbShub2RlLCBzdGFydFBvcywgc3RhcnRMb2MpO1xuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnF1ZXN0aW9uKSkge1xuICAgICAgbm9kZS5vcHRpb25hbCA9IHRydWU7XG4gICAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24obm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29sb24pKSB7XG4gICAgICBjb25zdCB0eXBlQ2FzdE5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICB0eXBlQ2FzdE5vZGUuZXhwcmVzc2lvbiA9IG5vZGU7XG4gICAgICB0eXBlQ2FzdE5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHR5cGVDYXN0Tm9kZSwgXCJUeXBlQ2FzdEV4cHJlc3Npb25cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBhc3NlcnRNb2R1bGVOb2RlQWxsb3dlZChub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJJbXBvcnREZWNsYXJhdGlvblwiICYmIChub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZVwiIHx8IG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlb2ZcIikgfHwgbm9kZS50eXBlID09PSBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIiAmJiBub2RlLmV4cG9ydEtpbmQgPT09IFwidHlwZVwiIHx8IG5vZGUudHlwZSA9PT0gXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiICYmIG5vZGUuZXhwb3J0S2luZCA9PT0gXCJ0eXBlXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdXBlci5hc3NlcnRNb2R1bGVOb2RlQWxsb3dlZChub2RlKTtcbiAgfVxuXG4gIHBhcnNlRXhwb3J0KG5vZGUpIHtcbiAgICBjb25zdCBkZWNsID0gc3VwZXIucGFyc2VFeHBvcnQobm9kZSk7XG5cbiAgICBpZiAoZGVjbC50eXBlID09PSBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIiB8fCBkZWNsLnR5cGUgPT09IFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIikge1xuICAgICAgZGVjbC5leHBvcnRLaW5kID0gZGVjbC5leHBvcnRLaW5kIHx8IFwidmFsdWVcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVjbDtcbiAgfVxuXG4gIHBhcnNlRXhwb3J0RGVjbGFyYXRpb24obm9kZSkge1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbChcInR5cGVcIikpIHtcbiAgICAgIG5vZGUuZXhwb3J0S2luZCA9IFwidHlwZVwiO1xuICAgICAgY29uc3QgZGVjbGFyYXRpb25Ob2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5icmFjZUwpKSB7XG4gICAgICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzKCk7XG4gICAgICAgIHRoaXMucGFyc2VFeHBvcnRGcm9tKG5vZGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVR5cGVBbGlhcyhkZWNsYXJhdGlvbk5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJvcGFxdWVcIikpIHtcbiAgICAgIG5vZGUuZXhwb3J0S2luZCA9IFwidHlwZVwiO1xuICAgICAgY29uc3QgZGVjbGFyYXRpb25Ob2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlT3BhcXVlVHlwZShkZWNsYXJhdGlvbk5vZGUsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwiaW50ZXJmYWNlXCIpKSB7XG4gICAgICBub2RlLmV4cG9ydEtpbmQgPSBcInR5cGVcIjtcbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZUludGVyZmFjZShkZWNsYXJhdGlvbk5vZGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zaG91bGRQYXJzZUVudW1zKCkgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJlbnVtXCIpKSB7XG4gICAgICBub2RlLmV4cG9ydEtpbmQgPSBcInZhbHVlXCI7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VFbnVtRGVjbGFyYXRpb24oZGVjbGFyYXRpb25Ob2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlRXhwb3J0RGVjbGFyYXRpb24obm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZWF0RXhwb3J0U3Rhcihub2RlKSB7XG4gICAgaWYgKHN1cGVyLmVhdEV4cG9ydFN0YXIoLi4uYXJndW1lbnRzKSkgcmV0dXJuIHRydWU7XG5cbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJ0eXBlXCIpICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gdHlwZXMuc3Rhcikge1xuICAgICAgbm9kZS5leHBvcnRLaW5kID0gXCJ0eXBlXCI7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbWF5YmVQYXJzZUV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICBjb25zdCBoYXNOYW1lc3BhY2UgPSBzdXBlci5tYXliZVBhcnNlRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUpO1xuXG4gICAgaWYgKGhhc05hbWVzcGFjZSAmJiBub2RlLmV4cG9ydEtpbmQgPT09IFwidHlwZVwiKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQocG9zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzTmFtZXNwYWNlO1xuICB9XG5cbiAgcGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkKSB7XG4gICAgc3VwZXIucGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkKTtcblxuICAgIGlmICh0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlQ2xhc3NNZW1iZXIoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlLCBjb25zdHJ1Y3RvckFsbG93c1N1cGVyKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcblxuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbChcImRlY2xhcmVcIikpIHtcbiAgICAgIGlmICh0aGlzLnBhcnNlQ2xhc3NNZW1iZXJGcm9tTW9kaWZpZXIoY2xhc3NCb2R5LCBtZW1iZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbWVtYmVyLmRlY2xhcmUgPSB0cnVlO1xuICAgIH1cblxuICAgIHN1cGVyLnBhcnNlQ2xhc3NNZW1iZXIoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlLCBjb25zdHJ1Y3RvckFsbG93c1N1cGVyKTtcblxuICAgIGlmIChtZW1iZXIuZGVjbGFyZSkge1xuICAgICAgaWYgKG1lbWJlci50eXBlICE9PSBcIkNsYXNzUHJvcGVydHlcIiAmJiBtZW1iZXIudHlwZSAhPT0gXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UocG9zLCBGbG93RXJyb3JzLkRlY2xhcmVDbGFzc0VsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChtZW1iZXIudmFsdWUpIHtcbiAgICAgICAgdGhpcy5yYWlzZShtZW1iZXIudmFsdWUuc3RhcnQsIEZsb3dFcnJvcnMuRGVjbGFyZUNsYXNzRmllbGRJbml0aWFsaXplcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuXG4gICAgaWYgKGNvZGUgPT09IDEyMyAmJiBuZXh0ID09PSAxMjQpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmJyYWNlQmFyTCwgMik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmluVHlwZSAmJiAoY29kZSA9PT0gNjIgfHwgY29kZSA9PT0gNjApKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5yZWxhdGlvbmFsLCAxKTtcbiAgICB9IGVsc2UgaWYgKGlzSXRlcmF0b3JTdGFydChjb2RlLCBuZXh0KSkge1xuICAgICAgdGhpcy5zdGF0ZS5pc0l0ZXJhdG9yID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzdXBlci5yZWFkV29yZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKTtcbiAgICB9XG4gIH1cblxuICBpc0Fzc2lnbmFibGUobm9kZSwgaXNCaW5kaW5nKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbGFzdCA9IG5vZGUucHJvcGVydGllcy5sZW5ndGggLSAxO1xuICAgICAgICAgIHJldHVybiBub2RlLnByb3BlcnRpZXMuZXZlcnkoKHByb3AsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wLnR5cGUgIT09IFwiT2JqZWN0TWV0aG9kXCIgJiYgKGkgPT09IGxhc3QgfHwgcHJvcC50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIikgJiYgdGhpcy5pc0Fzc2lnbmFibGUocHJvcCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIk9iamVjdFByb3BlcnR5XCI6XG4gICAgICAgIHJldHVybiB0aGlzLmlzQXNzaWduYWJsZShub2RlLnZhbHVlKTtcblxuICAgICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBc3NpZ25hYmxlKG5vZGUuYXJndW1lbnQpO1xuXG4gICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBub2RlLmVsZW1lbnRzLmV2ZXJ5KGVsZW1lbnQgPT4gdGhpcy5pc0Fzc2lnbmFibGUoZWxlbWVudCkpO1xuXG4gICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIG5vZGUub3BlcmF0b3IgPT09IFwiPVwiO1xuXG4gICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUeXBlQ2FzdEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbik7XG5cbiAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiAhaXNCaW5kaW5nO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdG9Bc3NpZ25hYmxlKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIlR5cGVDYXN0RXhwcmVzc2lvblwiKSB7XG4gICAgICByZXR1cm4gc3VwZXIudG9Bc3NpZ25hYmxlKHRoaXMudHlwZUNhc3RUb1BhcmFtZXRlcihub2RlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci50b0Fzc2lnbmFibGUobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgdG9Bc3NpZ25hYmxlTGlzdChleHByTGlzdCwgdHJhaWxpbmdDb21tYVBvcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGV4cHIgPSBleHByTGlzdFtpXTtcblxuICAgICAgaWYgKChleHByID09IG51bGwgPyB2b2lkIDAgOiBleHByLnR5cGUpID09PSBcIlR5cGVDYXN0RXhwcmVzc2lvblwiKSB7XG4gICAgICAgIGV4cHJMaXN0W2ldID0gdGhpcy50eXBlQ2FzdFRvUGFyYW1ldGVyKGV4cHIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci50b0Fzc2lnbmFibGVMaXN0KGV4cHJMaXN0LCB0cmFpbGluZ0NvbW1hUG9zKTtcbiAgfVxuXG4gIHRvUmVmZXJlbmNlZExpc3QoZXhwckxpc3QsIGlzUGFyZW50aGVzaXplZEV4cHIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2V4cHIkZXh0cmE7XG5cbiAgICAgIGNvbnN0IGV4cHIgPSBleHByTGlzdFtpXTtcblxuICAgICAgaWYgKGV4cHIgJiYgZXhwci50eXBlID09PSBcIlR5cGVDYXN0RXhwcmVzc2lvblwiICYmICEoKF9leHByJGV4dHJhID0gZXhwci5leHRyYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9leHByJGV4dHJhLnBhcmVudGhlc2l6ZWQpICYmIChleHByTGlzdC5sZW5ndGggPiAxIHx8ICFpc1BhcmVudGhlc2l6ZWRFeHByKSkge1xuICAgICAgICB0aGlzLnJhaXNlKGV4cHIudHlwZUFubm90YXRpb24uc3RhcnQsIEZsb3dFcnJvcnMuVHlwZUNhc3RJblBhdHRlcm4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBleHByTGlzdDtcbiAgfVxuXG4gIGNoZWNrTFZhbChleHByLCBiaW5kaW5nVHlwZSA9IEJJTkRfTk9ORSwgY2hlY2tDbGFzaGVzLCBjb250ZXh0RGVzY3JpcHRpb24pIHtcbiAgICBpZiAoZXhwci50eXBlICE9PSBcIlR5cGVDYXN0RXhwcmVzc2lvblwiKSB7XG4gICAgICByZXR1cm4gc3VwZXIuY2hlY2tMVmFsKGV4cHIsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMsIGNvbnRleHREZXNjcmlwdGlvbik7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VDbGFzc1Byb3BlcnR5KG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5jb2xvbikpIHtcbiAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQ2xhc3NQcm9wZXJ0eShub2RlKTtcbiAgfVxuXG4gIHBhcnNlQ2xhc3NQcml2YXRlUHJvcGVydHkobm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmNvbG9uKSkge1xuICAgICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIucGFyc2VDbGFzc1ByaXZhdGVQcm9wZXJ0eShub2RlKTtcbiAgfVxuXG4gIGlzQ2xhc3NNZXRob2QoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSB8fCBzdXBlci5pc0NsYXNzTWV0aG9kKCk7XG4gIH1cblxuICBpc0NsYXNzUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2godHlwZXMuY29sb24pIHx8IHN1cGVyLmlzQ2xhc3NQcm9wZXJ0eSgpO1xuICB9XG5cbiAgaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICByZXR1cm4gIXRoaXMubWF0Y2godHlwZXMuY29sb24pICYmIHN1cGVyLmlzTm9uc3RhdGljQ29uc3RydWN0b3IobWV0aG9kKTtcbiAgfVxuXG4gIHB1c2hDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93c0RpcmVjdFN1cGVyKSB7XG4gICAgaWYgKG1ldGhvZC52YXJpYW5jZSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKG1ldGhvZC52YXJpYW5jZS5zdGFydCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIG1ldGhvZC52YXJpYW5jZTtcblxuICAgIGlmICh0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgIG1ldGhvZC50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfVxuXG4gICAgc3VwZXIucHVzaENsYXNzTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dzRGlyZWN0U3VwZXIpO1xuICB9XG5cbiAgcHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpIHtcbiAgICBpZiAobWV0aG9kLnZhcmlhbmNlKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQobWV0aG9kLnZhcmlhbmNlLnN0YXJ0KTtcbiAgICB9XG5cbiAgICBkZWxldGUgbWV0aG9kLnZhcmlhbmNlO1xuXG4gICAgaWYgKHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgICAgbWV0aG9kLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICB9XG5cbiAgICBzdXBlci5wdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYyk7XG4gIH1cblxuICBwYXJzZUNsYXNzU3VwZXIobm9kZSkge1xuICAgIHN1cGVyLnBhcnNlQ2xhc3NTdXBlcihub2RlKTtcblxuICAgIGlmIChub2RlLnN1cGVyQ2xhc3MgJiYgdGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICBub2RlLnN1cGVyVHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwiaW1wbGVtZW50c1wiKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBjb25zdCBpbXBsZW1lbnRlZCA9IG5vZGUuaW1wbGVtZW50cyA9IFtdO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VSZXN0cmljdGVkSWRlbnRpZmllcih0cnVlKTtcblxuICAgICAgICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGltcGxlbWVudGVkLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ2xhc3NJbXBsZW1lbnRzXCIpKTtcbiAgICAgIH0gd2hpbGUgKHRoaXMuZWF0KHR5cGVzLmNvbW1hKSk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VQcm9wZXJ0eU5hbWUobm9kZSwgaXNQcml2YXRlTmFtZUFsbG93ZWQpIHtcbiAgICBjb25zdCB2YXJpYW5jZSA9IHRoaXMuZmxvd1BhcnNlVmFyaWFuY2UoKTtcbiAgICBjb25zdCBrZXkgPSBzdXBlci5wYXJzZVByb3BlcnR5TmFtZShub2RlLCBpc1ByaXZhdGVOYW1lQWxsb3dlZCk7XG4gICAgbm9kZS52YXJpYW5jZSA9IHZhcmlhbmNlO1xuICAgIHJldHVybiBrZXk7XG4gIH1cblxuICBwYXJzZU9ialByb3BWYWx1ZShwcm9wLCBzdGFydFBvcywgc3RhcnRMb2MsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIHJlZkV4cHJlc3Npb25FcnJvcnMsIGNvbnRhaW5zRXNjKSB7XG4gICAgaWYgKHByb3AudmFyaWFuY2UpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChwcm9wLnZhcmlhbmNlLnN0YXJ0KTtcbiAgICB9XG5cbiAgICBkZWxldGUgcHJvcC52YXJpYW5jZTtcbiAgICBsZXQgdHlwZVBhcmFtZXRlcnM7XG5cbiAgICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICB0eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgICBpZiAoIXRoaXMubWF0Y2godHlwZXMucGFyZW5MKSkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgc3VwZXIucGFyc2VPYmpQcm9wVmFsdWUocHJvcCwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuLCByZWZFeHByZXNzaW9uRXJyb3JzLCBjb250YWluc0VzYyk7XG5cbiAgICBpZiAodHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgIChwcm9wLnZhbHVlIHx8IHByb3ApLnR5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnM7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VBc3NpZ25hYmxlTGlzdEl0ZW1UeXBlcyhwYXJhbSkge1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5xdWVzdGlvbikpIHtcbiAgICAgIGlmIChwYXJhbS50eXBlICE9PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgICB0aGlzLnJhaXNlKHBhcmFtLnN0YXJ0LCBGbG93RXJyb3JzLk9wdGlvbmFsQmluZGluZ1BhdHRlcm4pO1xuICAgICAgfVxuXG4gICAgICBwYXJhbS5vcHRpb25hbCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29sb24pKSB7XG4gICAgICBwYXJhbS50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24ocGFyYW0pO1xuICAgIHJldHVybiBwYXJhbTtcbiAgfVxuXG4gIHBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCkge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQpO1xuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiICYmIG5vZGUudHlwZUFubm90YXRpb24gJiYgbm9kZS5yaWdodC5zdGFydCA8IG5vZGUudHlwZUFubm90YXRpb24uc3RhcnQpIHtcbiAgICAgIHRoaXMucmFpc2Uobm9kZS50eXBlQW5ub3RhdGlvbi5zdGFydCwgRmxvd0Vycm9ycy5UeXBlQmVmb3JlSW5pdGlhbGl6ZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgc2hvdWxkUGFyc2VEZWZhdWx0SW1wb3J0KG5vZGUpIHtcbiAgICBpZiAoIWhhc1R5cGVJbXBvcnRLaW5kKG5vZGUpKSB7XG4gICAgICByZXR1cm4gc3VwZXIuc2hvdWxkUGFyc2VEZWZhdWx0SW1wb3J0KG5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBpc01heWJlRGVmYXVsdEltcG9ydCh0aGlzLnN0YXRlKTtcbiAgfVxuXG4gIHBhcnNlSW1wb3J0U3BlY2lmaWVyTG9jYWwobm9kZSwgc3BlY2lmaWVyLCB0eXBlLCBjb250ZXh0RGVzY3JpcHRpb24pIHtcbiAgICBzcGVjaWZpZXIubG9jYWwgPSBoYXNUeXBlSW1wb3J0S2luZChub2RlKSA/IHRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIodHJ1ZSwgdHJ1ZSkgOiB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIHRoaXMuY2hlY2tMVmFsKHNwZWNpZmllci5sb2NhbCwgQklORF9MRVhJQ0FMLCB1bmRlZmluZWQsIGNvbnRleHREZXNjcmlwdGlvbik7XG4gICAgbm9kZS5zcGVjaWZpZXJzLnB1c2godGhpcy5maW5pc2hOb2RlKHNwZWNpZmllciwgdHlwZSkpO1xuICB9XG5cbiAgbWF5YmVQYXJzZURlZmF1bHRJbXBvcnRTcGVjaWZpZXIobm9kZSkge1xuICAgIG5vZGUuaW1wb3J0S2luZCA9IFwidmFsdWVcIjtcbiAgICBsZXQga2luZCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5fdHlwZW9mKSkge1xuICAgICAga2luZCA9IFwidHlwZW9mXCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbChcInR5cGVcIikpIHtcbiAgICAgIGtpbmQgPSBcInR5cGVcIjtcbiAgICB9XG5cbiAgICBpZiAoa2luZCkge1xuICAgICAgY29uc3QgbGggPSB0aGlzLmxvb2thaGVhZCgpO1xuXG4gICAgICBpZiAoa2luZCA9PT0gXCJ0eXBlXCIgJiYgbGgudHlwZSA9PT0gdHlwZXMuc3Rhcikge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQobGguc3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNNYXliZURlZmF1bHRJbXBvcnQobGgpIHx8IGxoLnR5cGUgPT09IHR5cGVzLmJyYWNlTCB8fCBsaC50eXBlID09PSB0eXBlcy5zdGFyKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBub2RlLmltcG9ydEtpbmQgPSBraW5kO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5tYXliZVBhcnNlRGVmYXVsdEltcG9ydFNwZWNpZmllcihub2RlKTtcbiAgfVxuXG4gIHBhcnNlSW1wb3J0U3BlY2lmaWVyKG5vZGUpIHtcbiAgICBjb25zdCBzcGVjaWZpZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IGZpcnN0SWRlbnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIGNvbnN0IGZpcnN0SWRlbnQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICBsZXQgc3BlY2lmaWVyVHlwZUtpbmQgPSBudWxsO1xuXG4gICAgaWYgKGZpcnN0SWRlbnQubmFtZSA9PT0gXCJ0eXBlXCIpIHtcbiAgICAgIHNwZWNpZmllclR5cGVLaW5kID0gXCJ0eXBlXCI7XG4gICAgfSBlbHNlIGlmIChmaXJzdElkZW50Lm5hbWUgPT09IFwidHlwZW9mXCIpIHtcbiAgICAgIHNwZWNpZmllclR5cGVLaW5kID0gXCJ0eXBlb2ZcIjtcbiAgICB9XG5cbiAgICBsZXQgaXNCaW5kaW5nID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJhc1wiKSAmJiAhdGhpcy5pc0xvb2thaGVhZENvbnRleHR1YWwoXCJhc1wiKSkge1xuICAgICAgY29uc3QgYXNfaWRlbnQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcblxuICAgICAgaWYgKHNwZWNpZmllclR5cGVLaW5kICE9PSBudWxsICYmICF0aGlzLm1hdGNoKHR5cGVzLm5hbWUpICYmICF0aGlzLnN0YXRlLnR5cGUua2V5d29yZCkge1xuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0ZWQgPSBhc19pZGVudDtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydEtpbmQgPSBzcGVjaWZpZXJUeXBlS2luZDtcbiAgICAgICAgc3BlY2lmaWVyLmxvY2FsID0gYXNfaWRlbnQuX19jbG9uZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydGVkID0gZmlyc3RJZGVudDtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydEtpbmQgPSBudWxsO1xuICAgICAgICBzcGVjaWZpZXIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3BlY2lmaWVyVHlwZUtpbmQgIT09IG51bGwgJiYgKHRoaXMubWF0Y2godHlwZXMubmFtZSkgfHwgdGhpcy5zdGF0ZS50eXBlLmtleXdvcmQpKSB7XG4gICAgICBzcGVjaWZpZXIuaW1wb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgIHNwZWNpZmllci5pbXBvcnRLaW5kID0gc3BlY2lmaWVyVHlwZUtpbmQ7XG5cbiAgICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSkge1xuICAgICAgICBzcGVjaWZpZXIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNCaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgc3BlY2lmaWVyLmxvY2FsID0gc3BlY2lmaWVyLmltcG9ydGVkLl9fY2xvbmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXNCaW5kaW5nID0gdHJ1ZTtcbiAgICAgIHNwZWNpZmllci5pbXBvcnRlZCA9IGZpcnN0SWRlbnQ7XG4gICAgICBzcGVjaWZpZXIuaW1wb3J0S2luZCA9IG51bGw7XG4gICAgICBzcGVjaWZpZXIubG9jYWwgPSBzcGVjaWZpZXIuaW1wb3J0ZWQuX19jbG9uZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGVJc1R5cGVJbXBvcnQgPSBoYXNUeXBlSW1wb3J0S2luZChub2RlKTtcbiAgICBjb25zdCBzcGVjaWZpZXJJc1R5cGVJbXBvcnQgPSBoYXNUeXBlSW1wb3J0S2luZChzcGVjaWZpZXIpO1xuXG4gICAgaWYgKG5vZGVJc1R5cGVJbXBvcnQgJiYgc3BlY2lmaWVySXNUeXBlSW1wb3J0KSB7XG4gICAgICB0aGlzLnJhaXNlKGZpcnN0SWRlbnRMb2MsIEZsb3dFcnJvcnMuSW1wb3J0VHlwZVNob3J0aGFuZE9ubHlJblB1cmVJbXBvcnQpO1xuICAgIH1cblxuICAgIGlmIChub2RlSXNUeXBlSW1wb3J0IHx8IHNwZWNpZmllcklzVHlwZUltcG9ydCkge1xuICAgICAgdGhpcy5jaGVja1Jlc2VydmVkVHlwZShzcGVjaWZpZXIubG9jYWwubmFtZSwgc3BlY2lmaWVyLmxvY2FsLnN0YXJ0LCB0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAoaXNCaW5kaW5nICYmICFub2RlSXNUeXBlSW1wb3J0ICYmICFzcGVjaWZpZXJJc1R5cGVJbXBvcnQpIHtcbiAgICAgIHRoaXMuY2hlY2tSZXNlcnZlZFdvcmQoc3BlY2lmaWVyLmxvY2FsLm5hbWUsIHNwZWNpZmllci5zdGFydCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5jaGVja0xWYWwoc3BlY2lmaWVyLmxvY2FsLCBCSU5EX0xFWElDQUwsIHVuZGVmaW5lZCwgXCJpbXBvcnQgc3BlY2lmaWVyXCIpO1xuICAgIG5vZGUuc3BlY2lmaWVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIFwiSW1wb3J0U3BlY2lmaWVyXCIpKTtcbiAgfVxuXG4gIHBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSwgYWxsb3dNb2RpZmllcnMpIHtcbiAgICBjb25zdCBraW5kID0gbm9kZS5raW5kO1xuXG4gICAgaWYgKGtpbmQgIT09IFwiZ2V0XCIgJiYga2luZCAhPT0gXCJzZXRcIiAmJiB0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH1cblxuICAgIHN1cGVyLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSwgYWxsb3dNb2RpZmllcnMpO1xuICB9XG5cbiAgcGFyc2VWYXJJZChkZWNsLCBraW5kKSB7XG4gICAgc3VwZXIucGFyc2VWYXJJZChkZWNsLCBraW5kKTtcblxuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmNvbG9uKSkge1xuICAgICAgZGVjbC5pZC50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihkZWNsLmlkKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUFzeW5jQXJyb3dGcm9tQ2FsbEV4cHJlc3Npb24obm9kZSwgY2FsbCkge1xuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmNvbG9uKSkge1xuICAgICAgY29uc3Qgb2xkTm9Bbm9uRnVuY3Rpb25UeXBlID0gdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGU7XG4gICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IHRydWU7XG4gICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IG9sZE5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIucGFyc2VBc3luY0Fycm93RnJvbUNhbGxFeHByZXNzaW9uKG5vZGUsIGNhbGwpO1xuICB9XG5cbiAgc2hvdWxkUGFyc2VBc3luY0Fycm93KCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKHR5cGVzLmNvbG9uKSB8fCBzdXBlci5zaG91bGRQYXJzZUFzeW5jQXJyb3coKTtcbiAgfVxuXG4gIHBhcnNlTWF5YmVBc3NpZ24obm9JbiwgcmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UsIHJlZk5lZWRzQXJyb3dQb3MpIHtcbiAgICB2YXIgX2pzeDtcblxuICAgIGxldCBzdGF0ZSA9IG51bGw7XG4gICAgbGV0IGpzeDtcblxuICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImpzeFwiKSAmJiAodGhpcy5tYXRjaCh0eXBlcy5qc3hUYWdTdGFydCkgfHwgdGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSkge1xuICAgICAgc3RhdGUgPSB0aGlzLnN0YXRlLmNsb25lKCk7XG4gICAgICBqc3ggPSB0aGlzLnRyeVBhcnNlKCgpID0+IHN1cGVyLnBhcnNlTWF5YmVBc3NpZ24obm9JbiwgcmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UsIHJlZk5lZWRzQXJyb3dQb3MpLCBzdGF0ZSk7XG4gICAgICBpZiAoIWpzeC5lcnJvcikgcmV0dXJuIGpzeC5ub2RlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb250ZXh0XG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgaWYgKGNvbnRleHRbY29udGV4dC5sZW5ndGggLSAxXSA9PT0gdHlwZXMkMS5qX29UYWcpIHtcbiAgICAgICAgY29udGV4dC5sZW5ndGggLT0gMjtcbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdID09PSB0eXBlcyQxLmpfZXhwcikge1xuICAgICAgICBjb250ZXh0Lmxlbmd0aCAtPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgoKF9qc3ggPSBqc3gpID09IG51bGwgPyB2b2lkIDAgOiBfanN4LmVycm9yKSB8fCB0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgIHZhciBfYXJyb3ckbm9kZSwgX2pzeDIsIF9qc3gzO1xuXG4gICAgICBzdGF0ZSA9IHN0YXRlIHx8IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICAgIGxldCB0eXBlUGFyYW1ldGVycztcbiAgICAgIGNvbnN0IGFycm93ID0gdGhpcy50cnlQYXJzZSgoKSA9PiB7XG4gICAgICAgIHR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgICAgY29uc3QgYXJyb3dFeHByZXNzaW9uID0gdGhpcy5mb3J3YXJkTm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdCh0eXBlUGFyYW1ldGVycywgKCkgPT4gc3VwZXIucGFyc2VNYXliZUFzc2lnbihub0luLCByZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSwgcmVmTmVlZHNBcnJvd1BvcykpO1xuICAgICAgICBhcnJvd0V4cHJlc3Npb24udHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShhcnJvd0V4cHJlc3Npb24sIHR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgICAgcmV0dXJuIGFycm93RXhwcmVzc2lvbjtcbiAgICAgIH0sIHN0YXRlKTtcbiAgICAgIGNvbnN0IGFycm93RXhwcmVzc2lvbiA9ICgoX2Fycm93JG5vZGUgPSBhcnJvdy5ub2RlKSA9PSBudWxsID8gdm9pZCAwIDogX2Fycm93JG5vZGUudHlwZSkgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiA/IGFycm93Lm5vZGUgOiBudWxsO1xuICAgICAgaWYgKCFhcnJvdy5lcnJvciAmJiBhcnJvd0V4cHJlc3Npb24pIHJldHVybiBhcnJvd0V4cHJlc3Npb247XG5cbiAgICAgIGlmICgoX2pzeDIgPSBqc3gpID09IG51bGwgPyB2b2lkIDAgOiBfanN4Mi5ub2RlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBqc3guZmFpbFN0YXRlO1xuICAgICAgICByZXR1cm4ganN4Lm5vZGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcnJvd0V4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGFycm93LmZhaWxTdGF0ZTtcbiAgICAgICAgcmV0dXJuIGFycm93RXhwcmVzc2lvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKChfanN4MyA9IGpzeCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9qc3gzLnRocm93bikgdGhyb3cganN4LmVycm9yO1xuICAgICAgaWYgKGFycm93LnRocm93bikgdGhyb3cgYXJyb3cuZXJyb3I7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKHR5cGVQYXJhbWV0ZXJzLnN0YXJ0LCBGbG93RXJyb3JzLlVuZXhwZWN0ZWRUb2tlbkFmdGVyVHlwZVBhcmFtZXRlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlTWF5YmVBc3NpZ24obm9JbiwgcmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UsIHJlZk5lZWRzQXJyb3dQb3MpO1xuICB9XG5cbiAgcGFyc2VBcnJvdyhub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29sb24pKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKCgpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkTm9Bbm9uRnVuY3Rpb25UeXBlID0gdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGU7XG4gICAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdHlwZU5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICBbdHlwZU5vZGUudHlwZUFubm90YXRpb24sIG5vZGUucHJlZGljYXRlXSA9IHRoaXMuZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyKCk7XG4gICAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gb2xkTm9Bbm9uRnVuY3Rpb25UeXBlO1xuICAgICAgICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIGlmICghdGhpcy5tYXRjaCh0eXBlcy5hcnJvdykpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICByZXR1cm4gdHlwZU5vZGU7XG4gICAgICB9KTtcbiAgICAgIGlmIChyZXN1bHQudGhyb3duKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHRoaXMuc3RhdGUgPSByZXN1bHQuZmFpbFN0YXRlO1xuICAgICAgbm9kZS5yZXR1cm5UeXBlID0gcmVzdWx0Lm5vZGUudHlwZUFubm90YXRpb24gPyB0aGlzLmZpbmlzaE5vZGUocmVzdWx0Lm5vZGUsIFwiVHlwZUFubm90YXRpb25cIikgOiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5wYXJzZUFycm93KG5vZGUpO1xuICB9XG5cbiAgc2hvdWxkUGFyc2VBcnJvdygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCh0eXBlcy5jb2xvbikgfHwgc3VwZXIuc2hvdWxkUGFyc2VBcnJvdygpO1xuICB9XG5cbiAgc2V0QXJyb3dGdW5jdGlvblBhcmFtZXRlcnMobm9kZSwgcGFyYW1zKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5pbmRleE9mKG5vZGUuc3RhcnQpICE9PSAtMSkge1xuICAgICAgbm9kZS5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnNldEFycm93RnVuY3Rpb25QYXJhbWV0ZXJzKG5vZGUsIHBhcmFtcyk7XG4gICAgfVxuICB9XG5cbiAgY2hlY2tQYXJhbXMobm9kZSwgYWxsb3dEdXBsaWNhdGVzLCBpc0Fycm93RnVuY3Rpb24pIHtcbiAgICBpZiAoaXNBcnJvd0Z1bmN0aW9uICYmIHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5pbmRleE9mKG5vZGUuc3RhcnQpICE9PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5jaGVja1BhcmFtcyguLi5hcmd1bWVudHMpO1xuICB9XG5cbiAgcGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93KSB7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24oY2FuQmVBcnJvdyAmJiB0aGlzLnN0YXRlLm5vQXJyb3dBdC5pbmRleE9mKHRoaXMuc3RhdGUuc3RhcnQpID09PSAtMSk7XG4gIH1cblxuICBwYXJzZVN1YnNjcmlwdHMoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzKSB7XG4gICAgaWYgKGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy5zdGF0ZS5ub0Fycm93QXQuaW5kZXhPZihzdGFydFBvcykgIT09IC0xKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLmNhbGxlZSA9IGJhc2U7XG4gICAgICBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cyh0eXBlcy5wYXJlblIsIGZhbHNlKTtcbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICAgIGNvbnN0IGFycm93ID0gdGhpcy50cnlQYXJzZShhYm9ydCA9PiB0aGlzLnBhcnNlQXN5bmNBcnJvd1dpdGhUeXBlUGFyYW1ldGVycyhzdGFydFBvcywgc3RhcnRMb2MpIHx8IGFib3J0KCksIHN0YXRlKTtcbiAgICAgIGlmICghYXJyb3cuZXJyb3IgJiYgIWFycm93LmFib3J0ZWQpIHJldHVybiBhcnJvdy5ub2RlO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50cnlQYXJzZSgoKSA9PiBzdXBlci5wYXJzZVN1YnNjcmlwdHMoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzKSwgc3RhdGUpO1xuICAgICAgaWYgKHJlc3VsdC5ub2RlICYmICFyZXN1bHQuZXJyb3IpIHJldHVybiByZXN1bHQubm9kZTtcblxuICAgICAgaWYgKGFycm93Lm5vZGUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGFycm93LmZhaWxTdGF0ZTtcbiAgICAgICAgcmV0dXJuIGFycm93Lm5vZGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQubm9kZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gcmVzdWx0LmZhaWxTdGF0ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5ub2RlO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBhcnJvdy5lcnJvciB8fCByZXN1bHQuZXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlU3Vic2NyaXB0cyhiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMpO1xuICB9XG5cbiAgcGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBzdWJzY3JpcHRTdGF0ZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLnF1ZXN0aW9uRG90KSAmJiB0aGlzLmlzTG9va2FoZWFkUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgIHN1YnNjcmlwdFN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIgPSB0cnVlO1xuXG4gICAgICBpZiAobm9DYWxscykge1xuICAgICAgICBzdWJzY3JpcHRTdGF0ZS5zdG9wID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUuY2FsbGVlID0gYmFzZTtcbiAgICAgIG5vZGUudHlwZUFyZ3VtZW50cyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gICAgICBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cyh0eXBlcy5wYXJlblIsIGZhbHNlKTtcbiAgICAgIG5vZGUub3B0aW9uYWwgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoQ2FsbEV4cHJlc3Npb24obm9kZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICghbm9DYWxscyAmJiB0aGlzLnNob3VsZFBhcnNlVHlwZXMoKSAmJiB0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLmNhbGxlZSA9IGJhc2U7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKCgpID0+IHtcbiAgICAgICAgbm9kZS50eXBlQXJndW1lbnRzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbkNhbGxPck5ldygpO1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICAgICAgICBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cyh0eXBlcy5wYXJlblIsIGZhbHNlKTtcbiAgICAgICAgaWYgKHN1YnNjcmlwdFN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIpIG5vZGUub3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoQ2FsbEV4cHJlc3Npb24obm9kZSwgc3Vic2NyaXB0U3RhdGUub3B0aW9uYWxDaGFpbk1lbWJlcik7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHJlc3VsdC5ub2RlKSB7XG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHRoaXMuc3RhdGUgPSByZXN1bHQuZmFpbFN0YXRlO1xuICAgICAgICByZXR1cm4gcmVzdWx0Lm5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscywgc3Vic2NyaXB0U3RhdGUpO1xuICB9XG5cbiAgcGFyc2VOZXdBcmd1bWVudHMobm9kZSkge1xuICAgIGxldCB0YXJncyA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5zaG91bGRQYXJzZVR5cGVzKCkgJiYgdGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICB0YXJncyA9IHRoaXMudHJ5UGFyc2UoKCkgPT4gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbkNhbGxPck5ldygpKS5ub2RlO1xuICAgIH1cblxuICAgIG5vZGUudHlwZUFyZ3VtZW50cyA9IHRhcmdzO1xuICAgIHN1cGVyLnBhcnNlTmV3QXJndW1lbnRzKG5vZGUpO1xuICB9XG5cbiAgcGFyc2VBc3luY0Fycm93V2l0aFR5cGVQYXJhbWV0ZXJzKHN0YXJ0UG9zLCBzdGFydExvYykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUpO1xuICAgIGlmICghdGhpcy5wYXJzZUFycm93KG5vZGUpKSByZXR1cm47XG4gICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24obm9kZSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgfVxuXG4gIHJlYWRUb2tlbl9tdWx0X21vZHVsbyhjb2RlKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuXG4gICAgaWYgKGNvZGUgPT09IDQyICYmIG5leHQgPT09IDQ3ICYmIHRoaXMuc3RhdGUuaGFzRmxvd0NvbW1lbnQpIHtcbiAgICAgIHRoaXMuc3RhdGUuaGFzRmxvd0NvbW1lbnQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN1cGVyLnJlYWRUb2tlbl9tdWx0X21vZHVsbyhjb2RlKTtcbiAgfVxuXG4gIHJlYWRUb2tlbl9waXBlX2FtcChjb2RlKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuXG4gICAgaWYgKGNvZGUgPT09IDEyNCAmJiBuZXh0ID09PSAxMjUpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AodHlwZXMuYnJhY2VCYXJSLCAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdXBlci5yZWFkVG9rZW5fcGlwZV9hbXAoY29kZSk7XG4gIH1cblxuICBwYXJzZVRvcExldmVsKGZpbGUsIHByb2dyYW0pIHtcbiAgICBjb25zdCBmaWxlTm9kZSA9IHN1cGVyLnBhcnNlVG9wTGV2ZWwoZmlsZSwgcHJvZ3JhbSk7XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5oYXNGbG93Q29tbWVudCkge1xuICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnBvcywgRmxvd0Vycm9ycy5VbnRlcm1pbmF0ZWRGbG93Q29tbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbGVOb2RlO1xuICB9XG5cbiAgc2tpcEJsb2NrQ29tbWVudCgpIHtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJmbG93Q29tbWVudHNcIikgJiYgdGhpcy5za2lwRmxvd0NvbW1lbnQoKSkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuaGFzRmxvd0NvbW1lbnQpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKG51bGwsIEZsb3dFcnJvcnMuTmVzdGVkRmxvd0NvbW1lbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhhc0Zsb3dDb21tZW50Q29tcGxldGlvbigpO1xuICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gdGhpcy5za2lwRmxvd0NvbW1lbnQoKTtcbiAgICAgIHRoaXMuc3RhdGUuaGFzRmxvd0NvbW1lbnQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXRlLmhhc0Zsb3dDb21tZW50KSB7XG4gICAgICBjb25zdCBlbmQgPSB0aGlzLmlucHV0LmluZGV4T2YoXCIqLS9cIiwgdGhpcy5zdGF0ZS5wb3MgKz0gMik7XG5cbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UodGhpcy5zdGF0ZS5wb3MgLSAyLCBFcnJvck1lc3NhZ2VzLlVudGVybWluYXRlZENvbW1lbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlLnBvcyA9IGVuZCArIDM7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3VwZXIuc2tpcEJsb2NrQ29tbWVudCgpO1xuICB9XG5cbiAgc2tpcEZsb3dDb21tZW50KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBvc1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCBzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlID0gMjtcblxuICAgIHdoaWxlIChbMzIsIDldLmluY2x1ZGVzKHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyBzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlKSkpIHtcbiAgICAgIHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UrKztcbiAgICB9XG5cbiAgICBjb25zdCBjaDIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSArIHBvcyk7XG4gICAgY29uc3QgY2gzID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UgKyBwb3MgKyAxKTtcblxuICAgIGlmIChjaDIgPT09IDU4ICYmIGNoMyA9PT0gNTgpIHtcbiAgICAgIHJldHVybiBzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlICsgMjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbnB1dC5zbGljZShzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlICsgcG9zLCBzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlICsgcG9zICsgMTIpID09PSBcImZsb3ctaW5jbHVkZVwiKSB7XG4gICAgICByZXR1cm4gc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSArIDEyO1xuICAgIH1cblxuICAgIGlmIChjaDIgPT09IDU4ICYmIGNoMyAhPT0gNTgpIHtcbiAgICAgIHJldHVybiBzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhc0Zsb3dDb21tZW50Q29tcGxldGlvbigpIHtcbiAgICBjb25zdCBlbmQgPSB0aGlzLmlucHV0LmluZGV4T2YoXCIqL1wiLCB0aGlzLnN0YXRlLnBvcyk7XG5cbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnBvcywgRXJyb3JNZXNzYWdlcy5VbnRlcm1pbmF0ZWRDb21tZW50KTtcbiAgICB9XG4gIH1cblxuICBmbG93RW51bUVycm9yQm9vbGVhbk1lbWJlck5vdEluaXRpYWxpemVkKHBvcywge1xuICAgIGVudW1OYW1lLFxuICAgIG1lbWJlck5hbWVcbiAgfSkge1xuICAgIHRoaXMucmFpc2UocG9zLCBGbG93RXJyb3JzLkVudW1Cb29sZWFuTWVtYmVyTm90SW5pdGlhbGl6ZWQsIG1lbWJlck5hbWUsIGVudW1OYW1lKTtcbiAgfVxuXG4gIGZsb3dFbnVtRXJyb3JJbnZhbGlkTWVtYmVyTmFtZShwb3MsIHtcbiAgICBlbnVtTmFtZSxcbiAgICBtZW1iZXJOYW1lXG4gIH0pIHtcbiAgICBjb25zdCBzdWdnZXN0aW9uID0gbWVtYmVyTmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbWVtYmVyTmFtZS5zbGljZSgxKTtcbiAgICB0aGlzLnJhaXNlKHBvcywgRmxvd0Vycm9ycy5FbnVtSW52YWxpZE1lbWJlck5hbWUsIG1lbWJlck5hbWUsIHN1Z2dlc3Rpb24sIGVudW1OYW1lKTtcbiAgfVxuXG4gIGZsb3dFbnVtRXJyb3JEdXBsaWNhdGVNZW1iZXJOYW1lKHBvcywge1xuICAgIGVudW1OYW1lLFxuICAgIG1lbWJlck5hbWVcbiAgfSkge1xuICAgIHRoaXMucmFpc2UocG9zLCBGbG93RXJyb3JzLkVudW1EdXBsaWNhdGVNZW1iZXJOYW1lLCBtZW1iZXJOYW1lLCBlbnVtTmFtZSk7XG4gIH1cblxuICBmbG93RW51bUVycm9ySW5jb25zaXN0ZW50TWVtYmVyVmFsdWVzKHBvcywge1xuICAgIGVudW1OYW1lXG4gIH0pIHtcbiAgICB0aGlzLnJhaXNlKHBvcywgRmxvd0Vycm9ycy5FbnVtSW5jb25zaXN0ZW50TWVtYmVyVmFsdWVzLCBlbnVtTmFtZSk7XG4gIH1cblxuICBmbG93RW51bUVycm9ySW52YWxpZEV4cGxpY2l0VHlwZShwb3MsIHtcbiAgICBlbnVtTmFtZSxcbiAgICBzdXBwbGllZFR5cGVcbiAgfSkge1xuICAgIHJldHVybiB0aGlzLnJhaXNlKHBvcywgc3VwcGxpZWRUeXBlID09PSBudWxsID8gRmxvd0Vycm9ycy5FbnVtSW52YWxpZEV4cGxpY2l0VHlwZVVua25vd25TdXBwbGllZCA6IEZsb3dFcnJvcnMuRW51bUludmFsaWRFeHBsaWNpdFR5cGUsIGVudW1OYW1lLCBzdXBwbGllZFR5cGUpO1xuICB9XG5cbiAgZmxvd0VudW1FcnJvckludmFsaWRNZW1iZXJJbml0aWFsaXplcihwb3MsIHtcbiAgICBlbnVtTmFtZSxcbiAgICBleHBsaWNpdFR5cGUsXG4gICAgbWVtYmVyTmFtZVxuICB9KSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBudWxsO1xuXG4gICAgc3dpdGNoIChleHBsaWNpdFR5cGUpIHtcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIG1lc3NhZ2UgPSBGbG93RXJyb3JzLkVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJQcmltYXJ5VHlwZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgbWVzc2FnZSA9IEZsb3dFcnJvcnMuRW51bUludmFsaWRNZW1iZXJJbml0aWFsaXplclN5bWJvbFR5cGU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBtZXNzYWdlID0gRmxvd0Vycm9ycy5FbnVtSW52YWxpZE1lbWJlckluaXRpYWxpemVyVW5rbm93blR5cGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmFpc2UocG9zLCBtZXNzYWdlLCBlbnVtTmFtZSwgbWVtYmVyTmFtZSwgZXhwbGljaXRUeXBlKTtcbiAgfVxuXG4gIGZsb3dFbnVtRXJyb3JOdW1iZXJNZW1iZXJOb3RJbml0aWFsaXplZChwb3MsIHtcbiAgICBlbnVtTmFtZSxcbiAgICBtZW1iZXJOYW1lXG4gIH0pIHtcbiAgICB0aGlzLnJhaXNlKHBvcywgRmxvd0Vycm9ycy5FbnVtTnVtYmVyTWVtYmVyTm90SW5pdGlhbGl6ZWQsIGVudW1OYW1lLCBtZW1iZXJOYW1lKTtcbiAgfVxuXG4gIGZsb3dFbnVtRXJyb3JTdHJpbmdNZW1iZXJJbmNvbnNpc3RlbnRseUluaXRhaWxpemVkKHBvcywge1xuICAgIGVudW1OYW1lXG4gIH0pIHtcbiAgICB0aGlzLnJhaXNlKHBvcywgRmxvd0Vycm9ycy5FbnVtU3RyaW5nTWVtYmVySW5jb25zaXN0ZW50bHlJbml0YWlsaXplZCwgZW51bU5hbWUpO1xuICB9XG5cbiAgZmxvd0VudW1NZW1iZXJJbml0KCkge1xuICAgIGNvbnN0IHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcblxuICAgIGNvbnN0IGVuZE9mSW5pdCA9ICgpID0+IHRoaXMubWF0Y2godHlwZXMuY29tbWEpIHx8IHRoaXMubWF0Y2godHlwZXMuYnJhY2VSKTtcblxuICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIHR5cGVzLm51bTpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGxpdGVyYWwgPSB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlLCBcIk51bWVyaWNMaXRlcmFsXCIpO1xuXG4gICAgICAgICAgaWYgKGVuZE9mSW5pdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICBwb3M6IGxpdGVyYWwuc3RhcnQsXG4gICAgICAgICAgICAgIHZhbHVlOiBsaXRlcmFsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImludmFsaWRcIixcbiAgICAgICAgICAgIHBvczogc3RhcnRQb3NcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgdHlwZXMuc3RyaW5nOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbGl0ZXJhbCA9IHRoaXMucGFyc2VMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUsIFwiU3RyaW5nTGl0ZXJhbFwiKTtcblxuICAgICAgICAgIGlmIChlbmRPZkluaXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgcG9zOiBsaXRlcmFsLnN0YXJ0LFxuICAgICAgICAgICAgICB2YWx1ZTogbGl0ZXJhbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkXCIsXG4gICAgICAgICAgICBwb3M6IHN0YXJ0UG9zXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIHR5cGVzLl90cnVlOlxuICAgICAgY2FzZSB0eXBlcy5fZmFsc2U6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsaXRlcmFsID0gdGhpcy5wYXJzZUJvb2xlYW5MaXRlcmFsKCk7XG5cbiAgICAgICAgICBpZiAoZW5kT2ZJbml0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICBwb3M6IGxpdGVyYWwuc3RhcnQsXG4gICAgICAgICAgICAgIHZhbHVlOiBsaXRlcmFsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImludmFsaWRcIixcbiAgICAgICAgICAgIHBvczogc3RhcnRQb3NcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJpbnZhbGlkXCIsXG4gICAgICAgICAgcG9zOiBzdGFydFBvc1xuICAgICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGZsb3dFbnVtTWVtYmVyUmF3KCkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3QgaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICBjb25zdCBpbml0ID0gdGhpcy5lYXQodHlwZXMuZXEpID8gdGhpcy5mbG93RW51bU1lbWJlckluaXQoKSA6IHtcbiAgICAgIHR5cGU6IFwibm9uZVwiLFxuICAgICAgcG9zXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICBpbml0XG4gICAgfTtcbiAgfVxuXG4gIGZsb3dFbnVtQ2hlY2tFeHBsaWNpdFR5cGVNaXNtYXRjaChwb3MsIGNvbnRleHQsIGV4cGVjdGVkVHlwZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGV4cGxpY2l0VHlwZVxuICAgIH0gPSBjb250ZXh0O1xuXG4gICAgaWYgKGV4cGxpY2l0VHlwZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChleHBsaWNpdFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgdGhpcy5mbG93RW51bUVycm9ySW52YWxpZE1lbWJlckluaXRpYWxpemVyKHBvcywgY29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgZmxvd0VudW1NZW1iZXJzKHtcbiAgICBlbnVtTmFtZSxcbiAgICBleHBsaWNpdFR5cGVcbiAgfSkge1xuICAgIGNvbnN0IHNlZW5OYW1lcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBtZW1iZXJzID0ge1xuICAgICAgYm9vbGVhbk1lbWJlcnM6IFtdLFxuICAgICAgbnVtYmVyTWVtYmVyczogW10sXG4gICAgICBzdHJpbmdNZW1iZXJzOiBbXSxcbiAgICAgIGRlZmF1bHRlZE1lbWJlcnM6IFtdXG4gICAgfTtcblxuICAgIHdoaWxlICghdGhpcy5tYXRjaCh0eXBlcy5icmFjZVIpKSB7XG4gICAgICBjb25zdCBtZW1iZXJOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGluaXRcbiAgICAgIH0gPSB0aGlzLmZsb3dFbnVtTWVtYmVyUmF3KCk7XG4gICAgICBjb25zdCBtZW1iZXJOYW1lID0gaWQubmFtZTtcblxuICAgICAgaWYgKG1lbWJlck5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgvXlthLXpdLy50ZXN0KG1lbWJlck5hbWUpKSB7XG4gICAgICAgIHRoaXMuZmxvd0VudW1FcnJvckludmFsaWRNZW1iZXJOYW1lKGlkLnN0YXJ0LCB7XG4gICAgICAgICAgZW51bU5hbWUsXG4gICAgICAgICAgbWVtYmVyTmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlZW5OYW1lcy5oYXMobWVtYmVyTmFtZSkpIHtcbiAgICAgICAgdGhpcy5mbG93RW51bUVycm9yRHVwbGljYXRlTWVtYmVyTmFtZShpZC5zdGFydCwge1xuICAgICAgICAgIGVudW1OYW1lLFxuICAgICAgICAgIG1lbWJlck5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHNlZW5OYW1lcy5hZGQobWVtYmVyTmFtZSk7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBlbnVtTmFtZSxcbiAgICAgICAgZXhwbGljaXRUeXBlLFxuICAgICAgICBtZW1iZXJOYW1lXG4gICAgICB9O1xuICAgICAgbWVtYmVyTm9kZS5pZCA9IGlkO1xuXG4gICAgICBzd2l0Y2ggKGluaXQudHlwZSkge1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZmxvd0VudW1DaGVja0V4cGxpY2l0VHlwZU1pc21hdGNoKGluaXQucG9zLCBjb250ZXh0LCBcImJvb2xlYW5cIik7XG4gICAgICAgICAgICBtZW1iZXJOb2RlLmluaXQgPSBpbml0LnZhbHVlO1xuICAgICAgICAgICAgbWVtYmVycy5ib29sZWFuTWVtYmVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShtZW1iZXJOb2RlLCBcIkVudW1Cb29sZWFuTWVtYmVyXCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5mbG93RW51bUNoZWNrRXhwbGljaXRUeXBlTWlzbWF0Y2goaW5pdC5wb3MsIGNvbnRleHQsIFwibnVtYmVyXCIpO1xuICAgICAgICAgICAgbWVtYmVyTm9kZS5pbml0ID0gaW5pdC52YWx1ZTtcbiAgICAgICAgICAgIG1lbWJlcnMubnVtYmVyTWVtYmVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShtZW1iZXJOb2RlLCBcIkVudW1OdW1iZXJNZW1iZXJcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmZsb3dFbnVtQ2hlY2tFeHBsaWNpdFR5cGVNaXNtYXRjaChpbml0LnBvcywgY29udGV4dCwgXCJzdHJpbmdcIik7XG4gICAgICAgICAgICBtZW1iZXJOb2RlLmluaXQgPSBpbml0LnZhbHVlO1xuICAgICAgICAgICAgbWVtYmVycy5zdHJpbmdNZW1iZXJzLnB1c2godGhpcy5maW5pc2hOb2RlKG1lbWJlck5vZGUsIFwiRW51bVN0cmluZ01lbWJlclwiKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBcImludmFsaWRcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmZsb3dFbnVtRXJyb3JJbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXIoaW5pdC5wb3MsIGNvbnRleHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXhwbGljaXRUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93RW51bUVycm9yQm9vbGVhbk1lbWJlck5vdEluaXRpYWxpemVkKGluaXQucG9zLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93RW51bUVycm9yTnVtYmVyTWVtYmVyTm90SW5pdGlhbGl6ZWQoaW5pdC5wb3MsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzLnB1c2godGhpcy5maW5pc2hOb2RlKG1lbWJlck5vZGUsIFwiRW51bURlZmF1bHRlZE1lbWJlclwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMubWF0Y2godHlwZXMuYnJhY2VSKSkge1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbWJlcnM7XG4gIH1cblxuICBmbG93RW51bVN0cmluZ01lbWJlcnMoaW5pdGlhbGl6ZWRNZW1iZXJzLCBkZWZhdWx0ZWRNZW1iZXJzLCB7XG4gICAgZW51bU5hbWVcbiAgfSkge1xuICAgIGlmIChpbml0aWFsaXplZE1lbWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdGVkTWVtYmVycztcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRlZE1lbWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gaW5pdGlhbGl6ZWRNZW1iZXJzO1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdGVkTWVtYmVycy5sZW5ndGggPiBpbml0aWFsaXplZE1lbWJlcnMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBfaSA9IDA7IF9pIDwgaW5pdGlhbGl6ZWRNZW1iZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBjb25zdCBtZW1iZXIgPSBpbml0aWFsaXplZE1lbWJlcnNbX2ldO1xuICAgICAgICB0aGlzLmZsb3dFbnVtRXJyb3JTdHJpbmdNZW1iZXJJbmNvbnNpc3RlbnRseUluaXRhaWxpemVkKG1lbWJlci5zdGFydCwge1xuICAgICAgICAgIGVudW1OYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVmYXVsdGVkTWVtYmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgX2kyID0gMDsgX2kyIDwgZGVmYXVsdGVkTWVtYmVycy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIGNvbnN0IG1lbWJlciA9IGRlZmF1bHRlZE1lbWJlcnNbX2kyXTtcbiAgICAgICAgdGhpcy5mbG93RW51bUVycm9yU3RyaW5nTWVtYmVySW5jb25zaXN0ZW50bHlJbml0YWlsaXplZChtZW1iZXIuc3RhcnQsIHtcbiAgICAgICAgICBlbnVtTmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluaXRpYWxpemVkTWVtYmVycztcbiAgICB9XG4gIH1cblxuICBmbG93RW51bVBhcnNlRXhwbGljaXRUeXBlKHtcbiAgICBlbnVtTmFtZVxuICB9KSB7XG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcIm9mXCIpKSB7XG4gICAgICBpZiAoIXRoaXMubWF0Y2godHlwZXMubmFtZSkpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5mbG93RW51bUVycm9ySW52YWxpZEV4cGxpY2l0VHlwZSh0aGlzLnN0YXRlLnN0YXJ0LCB7XG4gICAgICAgICAgZW51bU5hbWUsXG4gICAgICAgICAgc3VwcGxpZWRUeXBlOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHZhbHVlXG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICBpZiAodmFsdWUgIT09IFwiYm9vbGVhblwiICYmIHZhbHVlICE9PSBcIm51bWJlclwiICYmIHZhbHVlICE9PSBcInN0cmluZ1wiICYmIHZhbHVlICE9PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIHRoaXMuZmxvd0VudW1FcnJvckludmFsaWRFeHBsaWNpdFR5cGUodGhpcy5zdGF0ZS5zdGFydCwge1xuICAgICAgICAgIGVudW1OYW1lLFxuICAgICAgICAgIHN1cHBsaWVkVHlwZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZsb3dFbnVtQm9keShub2RlLCB7XG4gICAgZW51bU5hbWUsXG4gICAgbmFtZUxvY1xuICB9KSB7XG4gICAgY29uc3QgZXhwbGljaXRUeXBlID0gdGhpcy5mbG93RW51bVBhcnNlRXhwbGljaXRUeXBlKHtcbiAgICAgIGVudW1OYW1lXG4gICAgfSk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgICBjb25zdCBtZW1iZXJzID0gdGhpcy5mbG93RW51bU1lbWJlcnMoe1xuICAgICAgZW51bU5hbWUsXG4gICAgICBleHBsaWNpdFR5cGVcbiAgICB9KTtcblxuICAgIHN3aXRjaCAoZXhwbGljaXRUeXBlKSB7XG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICBub2RlLmV4cGxpY2l0VHlwZSA9IHRydWU7XG4gICAgICAgIG5vZGUubWVtYmVycyA9IG1lbWJlcnMuYm9vbGVhbk1lbWJlcnM7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlUik7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtQm9vbGVhbkJvZHlcIik7XG5cbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgbm9kZS5leHBsaWNpdFR5cGUgPSB0cnVlO1xuICAgICAgICBub2RlLm1lbWJlcnMgPSBtZW1iZXJzLm51bWJlck1lbWJlcnM7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlUik7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtTnVtYmVyQm9keVwiKTtcblxuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBub2RlLmV4cGxpY2l0VHlwZSA9IHRydWU7XG4gICAgICAgIG5vZGUubWVtYmVycyA9IHRoaXMuZmxvd0VudW1TdHJpbmdNZW1iZXJzKG1lbWJlcnMuc3RyaW5nTWVtYmVycywgbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzLCB7XG4gICAgICAgICAgZW51bU5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlUik7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtU3RyaW5nQm9keVwiKTtcblxuICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICBub2RlLm1lbWJlcnMgPSBtZW1iZXJzLmRlZmF1bHRlZE1lbWJlcnM7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlUik7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtU3ltYm9sQm9keVwiKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGVtcHR5ID0gKCkgPT4ge1xuICAgICAgICAgICAgbm9kZS5tZW1iZXJzID0gW107XG4gICAgICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZVIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVudW1TdHJpbmdCb2R5XCIpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBub2RlLmV4cGxpY2l0VHlwZSA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IGJvb2xzTGVuID0gbWVtYmVycy5ib29sZWFuTWVtYmVycy5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgbnVtc0xlbiA9IG1lbWJlcnMubnVtYmVyTWVtYmVycy5sZW5ndGg7XG4gICAgICAgICAgY29uc3Qgc3Ryc0xlbiA9IG1lbWJlcnMuc3RyaW5nTWVtYmVycy5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgZGVmYXVsdGVkTGVuID0gbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzLmxlbmd0aDtcblxuICAgICAgICAgIGlmICghYm9vbHNMZW4gJiYgIW51bXNMZW4gJiYgIXN0cnNMZW4gJiYgIWRlZmF1bHRlZExlbikge1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5KCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghYm9vbHNMZW4gJiYgIW51bXNMZW4pIHtcbiAgICAgICAgICAgIG5vZGUubWVtYmVycyA9IHRoaXMuZmxvd0VudW1TdHJpbmdNZW1iZXJzKG1lbWJlcnMuc3RyaW5nTWVtYmVycywgbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzLCB7XG4gICAgICAgICAgICAgIGVudW1OYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlUik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW51bVN0cmluZ0JvZHlcIik7XG4gICAgICAgICAgfSBlbHNlIGlmICghbnVtc0xlbiAmJiAhc3Ryc0xlbiAmJiBib29sc0xlbiA+PSBkZWZhdWx0ZWRMZW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IF9pMyA9IDAsIF9tZW1iZXJzJGRlZmF1bHRlZE1lbSA9IG1lbWJlcnMuZGVmYXVsdGVkTWVtYmVyczsgX2kzIDwgX21lbWJlcnMkZGVmYXVsdGVkTWVtLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgbWVtYmVyID0gX21lbWJlcnMkZGVmYXVsdGVkTWVtW19pM107XG4gICAgICAgICAgICAgIHRoaXMuZmxvd0VudW1FcnJvckJvb2xlYW5NZW1iZXJOb3RJbml0aWFsaXplZChtZW1iZXIuc3RhcnQsIHtcbiAgICAgICAgICAgICAgICBlbnVtTmFtZSxcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lOiBtZW1iZXIuaWQubmFtZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZS5tZW1iZXJzID0gbWVtYmVycy5ib29sZWFuTWVtYmVycztcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlUik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW51bUJvb2xlYW5Cb2R5XCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWJvb2xzTGVuICYmICFzdHJzTGVuICYmIG51bXNMZW4gPj0gZGVmYXVsdGVkTGVuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBfaTQgPSAwLCBfbWVtYmVycyRkZWZhdWx0ZWRNZW0yID0gbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzOyBfaTQgPCBfbWVtYmVycyRkZWZhdWx0ZWRNZW0yLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgICAgICAgY29uc3QgbWVtYmVyID0gX21lbWJlcnMkZGVmYXVsdGVkTWVtMltfaTRdO1xuICAgICAgICAgICAgICB0aGlzLmZsb3dFbnVtRXJyb3JOdW1iZXJNZW1iZXJOb3RJbml0aWFsaXplZChtZW1iZXIuc3RhcnQsIHtcbiAgICAgICAgICAgICAgICBlbnVtTmFtZSxcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lOiBtZW1iZXIuaWQubmFtZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZS5tZW1iZXJzID0gbWVtYmVycy5udW1iZXJNZW1iZXJzO1xuICAgICAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VSKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtTnVtYmVyQm9keVwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mbG93RW51bUVycm9ySW5jb25zaXN0ZW50TWVtYmVyVmFsdWVzKG5hbWVMb2MsIHtcbiAgICAgICAgICAgICAgZW51bU5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZmxvd1BhcnNlRW51bURlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgbm9kZS5pZCA9IGlkO1xuICAgIG5vZGUuYm9keSA9IHRoaXMuZmxvd0VudW1Cb2R5KHRoaXMuc3RhcnROb2RlKCksIHtcbiAgICAgIGVudW1OYW1lOiBpZC5uYW1lLFxuICAgICAgbmFtZUxvYzogaWQuc3RhcnRcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW51bURlY2xhcmF0aW9uXCIpO1xuICB9XG5cbiAgdXBkYXRlQ29udGV4dChwcmV2VHlwZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLm5hbWUpICYmIHRoaXMuc3RhdGUudmFsdWUgPT09IFwib2ZcIiAmJiBwcmV2VHlwZSA9PT0gdHlwZXMubmFtZSAmJiB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0LCB0aGlzLnN0YXRlLmxhc3RUb2tFbmQpID09PSBcImludGVyZmFjZVwiKSB7XG4gICAgICB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnVwZGF0ZUNvbnRleHQocHJldlR5cGUpO1xuICAgIH1cbiAgfVxuXG59KTtcblxuY29uc3QgZW50aXRpZXMgPSB7XG4gIHF1b3Q6IFwiXFx1MDAyMlwiLFxuICBhbXA6IFwiJlwiLFxuICBhcG9zOiBcIlxcdTAwMjdcIixcbiAgbHQ6IFwiPFwiLFxuICBndDogXCI+XCIsXG4gIG5ic3A6IFwiXFx1MDBBMFwiLFxuICBpZXhjbDogXCJcXHUwMEExXCIsXG4gIGNlbnQ6IFwiXFx1MDBBMlwiLFxuICBwb3VuZDogXCJcXHUwMEEzXCIsXG4gIGN1cnJlbjogXCJcXHUwMEE0XCIsXG4gIHllbjogXCJcXHUwMEE1XCIsXG4gIGJydmJhcjogXCJcXHUwMEE2XCIsXG4gIHNlY3Q6IFwiXFx1MDBBN1wiLFxuICB1bWw6IFwiXFx1MDBBOFwiLFxuICBjb3B5OiBcIlxcdTAwQTlcIixcbiAgb3JkZjogXCJcXHUwMEFBXCIsXG4gIGxhcXVvOiBcIlxcdTAwQUJcIixcbiAgbm90OiBcIlxcdTAwQUNcIixcbiAgc2h5OiBcIlxcdTAwQURcIixcbiAgcmVnOiBcIlxcdTAwQUVcIixcbiAgbWFjcjogXCJcXHUwMEFGXCIsXG4gIGRlZzogXCJcXHUwMEIwXCIsXG4gIHBsdXNtbjogXCJcXHUwMEIxXCIsXG4gIHN1cDI6IFwiXFx1MDBCMlwiLFxuICBzdXAzOiBcIlxcdTAwQjNcIixcbiAgYWN1dGU6IFwiXFx1MDBCNFwiLFxuICBtaWNybzogXCJcXHUwMEI1XCIsXG4gIHBhcmE6IFwiXFx1MDBCNlwiLFxuICBtaWRkb3Q6IFwiXFx1MDBCN1wiLFxuICBjZWRpbDogXCJcXHUwMEI4XCIsXG4gIHN1cDE6IFwiXFx1MDBCOVwiLFxuICBvcmRtOiBcIlxcdTAwQkFcIixcbiAgcmFxdW86IFwiXFx1MDBCQlwiLFxuICBmcmFjMTQ6IFwiXFx1MDBCQ1wiLFxuICBmcmFjMTI6IFwiXFx1MDBCRFwiLFxuICBmcmFjMzQ6IFwiXFx1MDBCRVwiLFxuICBpcXVlc3Q6IFwiXFx1MDBCRlwiLFxuICBBZ3JhdmU6IFwiXFx1MDBDMFwiLFxuICBBYWN1dGU6IFwiXFx1MDBDMVwiLFxuICBBY2lyYzogXCJcXHUwMEMyXCIsXG4gIEF0aWxkZTogXCJcXHUwMEMzXCIsXG4gIEF1bWw6IFwiXFx1MDBDNFwiLFxuICBBcmluZzogXCJcXHUwMEM1XCIsXG4gIEFFbGlnOiBcIlxcdTAwQzZcIixcbiAgQ2NlZGlsOiBcIlxcdTAwQzdcIixcbiAgRWdyYXZlOiBcIlxcdTAwQzhcIixcbiAgRWFjdXRlOiBcIlxcdTAwQzlcIixcbiAgRWNpcmM6IFwiXFx1MDBDQVwiLFxuICBFdW1sOiBcIlxcdTAwQ0JcIixcbiAgSWdyYXZlOiBcIlxcdTAwQ0NcIixcbiAgSWFjdXRlOiBcIlxcdTAwQ0RcIixcbiAgSWNpcmM6IFwiXFx1MDBDRVwiLFxuICBJdW1sOiBcIlxcdTAwQ0ZcIixcbiAgRVRIOiBcIlxcdTAwRDBcIixcbiAgTnRpbGRlOiBcIlxcdTAwRDFcIixcbiAgT2dyYXZlOiBcIlxcdTAwRDJcIixcbiAgT2FjdXRlOiBcIlxcdTAwRDNcIixcbiAgT2NpcmM6IFwiXFx1MDBENFwiLFxuICBPdGlsZGU6IFwiXFx1MDBENVwiLFxuICBPdW1sOiBcIlxcdTAwRDZcIixcbiAgdGltZXM6IFwiXFx1MDBEN1wiLFxuICBPc2xhc2g6IFwiXFx1MDBEOFwiLFxuICBVZ3JhdmU6IFwiXFx1MDBEOVwiLFxuICBVYWN1dGU6IFwiXFx1MDBEQVwiLFxuICBVY2lyYzogXCJcXHUwMERCXCIsXG4gIFV1bWw6IFwiXFx1MDBEQ1wiLFxuICBZYWN1dGU6IFwiXFx1MDBERFwiLFxuICBUSE9STjogXCJcXHUwMERFXCIsXG4gIHN6bGlnOiBcIlxcdTAwREZcIixcbiAgYWdyYXZlOiBcIlxcdTAwRTBcIixcbiAgYWFjdXRlOiBcIlxcdTAwRTFcIixcbiAgYWNpcmM6IFwiXFx1MDBFMlwiLFxuICBhdGlsZGU6IFwiXFx1MDBFM1wiLFxuICBhdW1sOiBcIlxcdTAwRTRcIixcbiAgYXJpbmc6IFwiXFx1MDBFNVwiLFxuICBhZWxpZzogXCJcXHUwMEU2XCIsXG4gIGNjZWRpbDogXCJcXHUwMEU3XCIsXG4gIGVncmF2ZTogXCJcXHUwMEU4XCIsXG4gIGVhY3V0ZTogXCJcXHUwMEU5XCIsXG4gIGVjaXJjOiBcIlxcdTAwRUFcIixcbiAgZXVtbDogXCJcXHUwMEVCXCIsXG4gIGlncmF2ZTogXCJcXHUwMEVDXCIsXG4gIGlhY3V0ZTogXCJcXHUwMEVEXCIsXG4gIGljaXJjOiBcIlxcdTAwRUVcIixcbiAgaXVtbDogXCJcXHUwMEVGXCIsXG4gIGV0aDogXCJcXHUwMEYwXCIsXG4gIG50aWxkZTogXCJcXHUwMEYxXCIsXG4gIG9ncmF2ZTogXCJcXHUwMEYyXCIsXG4gIG9hY3V0ZTogXCJcXHUwMEYzXCIsXG4gIG9jaXJjOiBcIlxcdTAwRjRcIixcbiAgb3RpbGRlOiBcIlxcdTAwRjVcIixcbiAgb3VtbDogXCJcXHUwMEY2XCIsXG4gIGRpdmlkZTogXCJcXHUwMEY3XCIsXG4gIG9zbGFzaDogXCJcXHUwMEY4XCIsXG4gIHVncmF2ZTogXCJcXHUwMEY5XCIsXG4gIHVhY3V0ZTogXCJcXHUwMEZBXCIsXG4gIHVjaXJjOiBcIlxcdTAwRkJcIixcbiAgdXVtbDogXCJcXHUwMEZDXCIsXG4gIHlhY3V0ZTogXCJcXHUwMEZEXCIsXG4gIHRob3JuOiBcIlxcdTAwRkVcIixcbiAgeXVtbDogXCJcXHUwMEZGXCIsXG4gIE9FbGlnOiBcIlxcdTAxNTJcIixcbiAgb2VsaWc6IFwiXFx1MDE1M1wiLFxuICBTY2Fyb246IFwiXFx1MDE2MFwiLFxuICBzY2Fyb246IFwiXFx1MDE2MVwiLFxuICBZdW1sOiBcIlxcdTAxNzhcIixcbiAgZm5vZjogXCJcXHUwMTkyXCIsXG4gIGNpcmM6IFwiXFx1MDJDNlwiLFxuICB0aWxkZTogXCJcXHUwMkRDXCIsXG4gIEFscGhhOiBcIlxcdTAzOTFcIixcbiAgQmV0YTogXCJcXHUwMzkyXCIsXG4gIEdhbW1hOiBcIlxcdTAzOTNcIixcbiAgRGVsdGE6IFwiXFx1MDM5NFwiLFxuICBFcHNpbG9uOiBcIlxcdTAzOTVcIixcbiAgWmV0YTogXCJcXHUwMzk2XCIsXG4gIEV0YTogXCJcXHUwMzk3XCIsXG4gIFRoZXRhOiBcIlxcdTAzOThcIixcbiAgSW90YTogXCJcXHUwMzk5XCIsXG4gIEthcHBhOiBcIlxcdTAzOUFcIixcbiAgTGFtYmRhOiBcIlxcdTAzOUJcIixcbiAgTXU6IFwiXFx1MDM5Q1wiLFxuICBOdTogXCJcXHUwMzlEXCIsXG4gIFhpOiBcIlxcdTAzOUVcIixcbiAgT21pY3JvbjogXCJcXHUwMzlGXCIsXG4gIFBpOiBcIlxcdTAzQTBcIixcbiAgUmhvOiBcIlxcdTAzQTFcIixcbiAgU2lnbWE6IFwiXFx1MDNBM1wiLFxuICBUYXU6IFwiXFx1MDNBNFwiLFxuICBVcHNpbG9uOiBcIlxcdTAzQTVcIixcbiAgUGhpOiBcIlxcdTAzQTZcIixcbiAgQ2hpOiBcIlxcdTAzQTdcIixcbiAgUHNpOiBcIlxcdTAzQThcIixcbiAgT21lZ2E6IFwiXFx1MDNBOVwiLFxuICBhbHBoYTogXCJcXHUwM0IxXCIsXG4gIGJldGE6IFwiXFx1MDNCMlwiLFxuICBnYW1tYTogXCJcXHUwM0IzXCIsXG4gIGRlbHRhOiBcIlxcdTAzQjRcIixcbiAgZXBzaWxvbjogXCJcXHUwM0I1XCIsXG4gIHpldGE6IFwiXFx1MDNCNlwiLFxuICBldGE6IFwiXFx1MDNCN1wiLFxuICB0aGV0YTogXCJcXHUwM0I4XCIsXG4gIGlvdGE6IFwiXFx1MDNCOVwiLFxuICBrYXBwYTogXCJcXHUwM0JBXCIsXG4gIGxhbWJkYTogXCJcXHUwM0JCXCIsXG4gIG11OiBcIlxcdTAzQkNcIixcbiAgbnU6IFwiXFx1MDNCRFwiLFxuICB4aTogXCJcXHUwM0JFXCIsXG4gIG9taWNyb246IFwiXFx1MDNCRlwiLFxuICBwaTogXCJcXHUwM0MwXCIsXG4gIHJobzogXCJcXHUwM0MxXCIsXG4gIHNpZ21hZjogXCJcXHUwM0MyXCIsXG4gIHNpZ21hOiBcIlxcdTAzQzNcIixcbiAgdGF1OiBcIlxcdTAzQzRcIixcbiAgdXBzaWxvbjogXCJcXHUwM0M1XCIsXG4gIHBoaTogXCJcXHUwM0M2XCIsXG4gIGNoaTogXCJcXHUwM0M3XCIsXG4gIHBzaTogXCJcXHUwM0M4XCIsXG4gIG9tZWdhOiBcIlxcdTAzQzlcIixcbiAgdGhldGFzeW06IFwiXFx1MDNEMVwiLFxuICB1cHNpaDogXCJcXHUwM0QyXCIsXG4gIHBpdjogXCJcXHUwM0Q2XCIsXG4gIGVuc3A6IFwiXFx1MjAwMlwiLFxuICBlbXNwOiBcIlxcdTIwMDNcIixcbiAgdGhpbnNwOiBcIlxcdTIwMDlcIixcbiAgenduajogXCJcXHUyMDBDXCIsXG4gIHp3ajogXCJcXHUyMDBEXCIsXG4gIGxybTogXCJcXHUyMDBFXCIsXG4gIHJsbTogXCJcXHUyMDBGXCIsXG4gIG5kYXNoOiBcIlxcdTIwMTNcIixcbiAgbWRhc2g6IFwiXFx1MjAxNFwiLFxuICBsc3F1bzogXCJcXHUyMDE4XCIsXG4gIHJzcXVvOiBcIlxcdTIwMTlcIixcbiAgc2JxdW86IFwiXFx1MjAxQVwiLFxuICBsZHF1bzogXCJcXHUyMDFDXCIsXG4gIHJkcXVvOiBcIlxcdTIwMURcIixcbiAgYmRxdW86IFwiXFx1MjAxRVwiLFxuICBkYWdnZXI6IFwiXFx1MjAyMFwiLFxuICBEYWdnZXI6IFwiXFx1MjAyMVwiLFxuICBidWxsOiBcIlxcdTIwMjJcIixcbiAgaGVsbGlwOiBcIlxcdTIwMjZcIixcbiAgcGVybWlsOiBcIlxcdTIwMzBcIixcbiAgcHJpbWU6IFwiXFx1MjAzMlwiLFxuICBQcmltZTogXCJcXHUyMDMzXCIsXG4gIGxzYXF1bzogXCJcXHUyMDM5XCIsXG4gIHJzYXF1bzogXCJcXHUyMDNBXCIsXG4gIG9saW5lOiBcIlxcdTIwM0VcIixcbiAgZnJhc2w6IFwiXFx1MjA0NFwiLFxuICBldXJvOiBcIlxcdTIwQUNcIixcbiAgaW1hZ2U6IFwiXFx1MjExMVwiLFxuICB3ZWllcnA6IFwiXFx1MjExOFwiLFxuICByZWFsOiBcIlxcdTIxMUNcIixcbiAgdHJhZGU6IFwiXFx1MjEyMlwiLFxuICBhbGVmc3ltOiBcIlxcdTIxMzVcIixcbiAgbGFycjogXCJcXHUyMTkwXCIsXG4gIHVhcnI6IFwiXFx1MjE5MVwiLFxuICByYXJyOiBcIlxcdTIxOTJcIixcbiAgZGFycjogXCJcXHUyMTkzXCIsXG4gIGhhcnI6IFwiXFx1MjE5NFwiLFxuICBjcmFycjogXCJcXHUyMUI1XCIsXG4gIGxBcnI6IFwiXFx1MjFEMFwiLFxuICB1QXJyOiBcIlxcdTIxRDFcIixcbiAgckFycjogXCJcXHUyMUQyXCIsXG4gIGRBcnI6IFwiXFx1MjFEM1wiLFxuICBoQXJyOiBcIlxcdTIxRDRcIixcbiAgZm9yYWxsOiBcIlxcdTIyMDBcIixcbiAgcGFydDogXCJcXHUyMjAyXCIsXG4gIGV4aXN0OiBcIlxcdTIyMDNcIixcbiAgZW1wdHk6IFwiXFx1MjIwNVwiLFxuICBuYWJsYTogXCJcXHUyMjA3XCIsXG4gIGlzaW46IFwiXFx1MjIwOFwiLFxuICBub3RpbjogXCJcXHUyMjA5XCIsXG4gIG5pOiBcIlxcdTIyMEJcIixcbiAgcHJvZDogXCJcXHUyMjBGXCIsXG4gIHN1bTogXCJcXHUyMjExXCIsXG4gIG1pbnVzOiBcIlxcdTIyMTJcIixcbiAgbG93YXN0OiBcIlxcdTIyMTdcIixcbiAgcmFkaWM6IFwiXFx1MjIxQVwiLFxuICBwcm9wOiBcIlxcdTIyMURcIixcbiAgaW5maW46IFwiXFx1MjIxRVwiLFxuICBhbmc6IFwiXFx1MjIyMFwiLFxuICBhbmQ6IFwiXFx1MjIyN1wiLFxuICBvcjogXCJcXHUyMjI4XCIsXG4gIGNhcDogXCJcXHUyMjI5XCIsXG4gIGN1cDogXCJcXHUyMjJBXCIsXG4gIGludDogXCJcXHUyMjJCXCIsXG4gIHRoZXJlNDogXCJcXHUyMjM0XCIsXG4gIHNpbTogXCJcXHUyMjNDXCIsXG4gIGNvbmc6IFwiXFx1MjI0NVwiLFxuICBhc3ltcDogXCJcXHUyMjQ4XCIsXG4gIG5lOiBcIlxcdTIyNjBcIixcbiAgZXF1aXY6IFwiXFx1MjI2MVwiLFxuICBsZTogXCJcXHUyMjY0XCIsXG4gIGdlOiBcIlxcdTIyNjVcIixcbiAgc3ViOiBcIlxcdTIyODJcIixcbiAgc3VwOiBcIlxcdTIyODNcIixcbiAgbnN1YjogXCJcXHUyMjg0XCIsXG4gIHN1YmU6IFwiXFx1MjI4NlwiLFxuICBzdXBlOiBcIlxcdTIyODdcIixcbiAgb3BsdXM6IFwiXFx1MjI5NVwiLFxuICBvdGltZXM6IFwiXFx1MjI5N1wiLFxuICBwZXJwOiBcIlxcdTIyQTVcIixcbiAgc2RvdDogXCJcXHUyMkM1XCIsXG4gIGxjZWlsOiBcIlxcdTIzMDhcIixcbiAgcmNlaWw6IFwiXFx1MjMwOVwiLFxuICBsZmxvb3I6IFwiXFx1MjMwQVwiLFxuICByZmxvb3I6IFwiXFx1MjMwQlwiLFxuICBsYW5nOiBcIlxcdTIzMjlcIixcbiAgcmFuZzogXCJcXHUyMzJBXCIsXG4gIGxvejogXCJcXHUyNUNBXCIsXG4gIHNwYWRlczogXCJcXHUyNjYwXCIsXG4gIGNsdWJzOiBcIlxcdTI2NjNcIixcbiAgaGVhcnRzOiBcIlxcdTI2NjVcIixcbiAgZGlhbXM6IFwiXFx1MjY2NlwiXG59O1xuXG5jb25zdCBIRVhfTlVNQkVSID0gL15bXFxkYS1mQS1GXSskLztcbmNvbnN0IERFQ0lNQUxfTlVNQkVSID0gL15cXGQrJC87XG5jb25zdCBKc3hFcnJvcnMgPSBPYmplY3QuZnJlZXplKHtcbiAgQXR0cmlidXRlSXNFbXB0eTogXCJKU1ggYXR0cmlidXRlcyBtdXN0IG9ubHkgYmUgYXNzaWduZWQgYSBub24tZW1wdHkgZXhwcmVzc2lvblwiLFxuICBNaXNzaW5nQ2xvc2luZ1RhZ0ZyYWdtZW50OiBcIkV4cGVjdGVkIGNvcnJlc3BvbmRpbmcgSlNYIGNsb3NpbmcgdGFnIGZvciA8PlwiLFxuICBNaXNzaW5nQ2xvc2luZ1RhZ0VsZW1lbnQ6IFwiRXhwZWN0ZWQgY29ycmVzcG9uZGluZyBKU1ggY2xvc2luZyB0YWcgZm9yIDwlMD5cIixcbiAgVW5zdXBwb3J0ZWRKc3hWYWx1ZTogXCJKU1ggdmFsdWUgc2hvdWxkIGJlIGVpdGhlciBhbiBleHByZXNzaW9uIG9yIGEgcXVvdGVkIEpTWCB0ZXh0XCIsXG4gIFVudGVybWluYXRlZEpzeENvbnRlbnQ6IFwiVW50ZXJtaW5hdGVkIEpTWCBjb250ZW50c1wiLFxuICBVbndyYXBwZWRBZGphY2VudEpTWEVsZW1lbnRzOiBcIkFkamFjZW50IEpTWCBlbGVtZW50cyBtdXN0IGJlIHdyYXBwZWQgaW4gYW4gZW5jbG9zaW5nIHRhZy4gRGlkIHlvdSB3YW50IGEgSlNYIGZyYWdtZW50IDw+Li4uPC8+P1wiXG59KTtcbnR5cGVzJDEual9vVGFnID0gbmV3IFRva0NvbnRleHQoXCI8dGFnXCIsIGZhbHNlKTtcbnR5cGVzJDEual9jVGFnID0gbmV3IFRva0NvbnRleHQoXCI8L3RhZ1wiLCBmYWxzZSk7XG50eXBlcyQxLmpfZXhwciA9IG5ldyBUb2tDb250ZXh0KFwiPHRhZz4uLi48L3RhZz5cIiwgdHJ1ZSwgdHJ1ZSk7XG50eXBlcy5qc3hOYW1lID0gbmV3IFRva2VuVHlwZShcImpzeE5hbWVcIik7XG50eXBlcy5qc3hUZXh0ID0gbmV3IFRva2VuVHlwZShcImpzeFRleHRcIiwge1xuICBiZWZvcmVFeHByOiB0cnVlXG59KTtcbnR5cGVzLmpzeFRhZ1N0YXJ0ID0gbmV3IFRva2VuVHlwZShcImpzeFRhZ1N0YXJ0XCIsIHtcbiAgc3RhcnRzRXhwcjogdHJ1ZVxufSk7XG50eXBlcy5qc3hUYWdFbmQgPSBuZXcgVG9rZW5UeXBlKFwianN4VGFnRW5kXCIpO1xuXG50eXBlcy5qc3hUYWdTdGFydC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnN0YXRlLmNvbnRleHQucHVzaCh0eXBlcyQxLmpfZXhwcik7XG4gIHRoaXMuc3RhdGUuY29udGV4dC5wdXNoKHR5cGVzJDEual9vVGFnKTtcbiAgdGhpcy5zdGF0ZS5leHByQWxsb3dlZCA9IGZhbHNlO1xufTtcblxudHlwZXMuanN4VGFnRW5kLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAocHJldlR5cGUpIHtcbiAgY29uc3Qgb3V0ID0gdGhpcy5zdGF0ZS5jb250ZXh0LnBvcCgpO1xuXG4gIGlmIChvdXQgPT09IHR5cGVzJDEual9vVGFnICYmIHByZXZUeXBlID09PSB0eXBlcy5zbGFzaCB8fCBvdXQgPT09IHR5cGVzJDEual9jVGFnKSB7XG4gICAgdGhpcy5zdGF0ZS5jb250ZXh0LnBvcCgpO1xuICAgIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSB0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMkMS5qX2V4cHI7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zdGF0ZS5leHByQWxsb3dlZCA9IHRydWU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPyBvYmplY3QudHlwZSA9PT0gXCJKU1hPcGVuaW5nRnJhZ21lbnRcIiB8fCBvYmplY3QudHlwZSA9PT0gXCJKU1hDbG9zaW5nRnJhZ21lbnRcIiA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdCkge1xuICBpZiAob2JqZWN0LnR5cGUgPT09IFwiSlNYSWRlbnRpZmllclwiKSB7XG4gICAgcmV0dXJuIG9iamVjdC5uYW1lO1xuICB9XG5cbiAgaWYgKG9iamVjdC50eXBlID09PSBcIkpTWE5hbWVzcGFjZWROYW1lXCIpIHtcbiAgICByZXR1cm4gb2JqZWN0Lm5hbWVzcGFjZS5uYW1lICsgXCI6XCIgKyBvYmplY3QubmFtZS5uYW1lO1xuICB9XG5cbiAgaWYgKG9iamVjdC50eXBlID09PSBcIkpTWE1lbWJlckV4cHJlc3Npb25cIikge1xuICAgIHJldHVybiBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdC5vYmplY3QpICsgXCIuXCIgKyBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdC5wcm9wZXJ0eSk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlIGhhZCB1bmV4cGVjdGVkIHR5cGU6IFwiICsgb2JqZWN0LnR5cGUpO1xufVxuXG52YXIganN4ID0gKHN1cGVyQ2xhc3MgPT4gY2xhc3MgZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAganN4UmVhZFRva2VuKCkge1xuICAgIGxldCBvdXQgPSBcIlwiO1xuICAgIGxldCBjaHVua1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBKc3hFcnJvcnMuVW50ZXJtaW5hdGVkSnN4Q29udGVudCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcblxuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIDYwOlxuICAgICAgICBjYXNlIDEyMzpcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPT09IHRoaXMuc3RhdGUuc3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gNjAgJiYgdGhpcy5zdGF0ZS5leHByQWxsb3dlZCkge1xuICAgICAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5qc3hUYWdTdGFydCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdXBlci5nZXRUb2tlbkZyb21Db2RlKGNoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuanN4VGV4dCwgb3V0KTtcblxuICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgICBvdXQgKz0gdGhpcy5qc3hSZWFkRW50aXR5KCk7XG4gICAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGlzTmV3TGluZShjaCkpIHtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLmpzeFJlYWROZXdMaW5lKHRydWUpO1xuICAgICAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIH1cblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGpzeFJlYWROZXdMaW5lKG5vcm1hbGl6ZUNSTEYpIHtcbiAgICBjb25zdCBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgbGV0IG91dDtcbiAgICArK3RoaXMuc3RhdGUucG9zO1xuXG4gICAgaWYgKGNoID09PSAxMyAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpID09PSAxMCkge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIG91dCA9IG5vcm1hbGl6ZUNSTEYgPyBcIlxcblwiIDogXCJcXHJcXG5cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgfVxuXG4gICAgKyt0aGlzLnN0YXRlLmN1ckxpbmU7XG4gICAgdGhpcy5zdGF0ZS5saW5lU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAganN4UmVhZFN0cmluZyhxdW90ZSkge1xuICAgIGxldCBvdXQgPSBcIlwiO1xuICAgIGxldCBjaHVua1N0YXJ0ID0gKyt0aGlzLnN0YXRlLnBvcztcblxuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLnBvcyA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIEVycm9yTWVzc2FnZXMuVW50ZXJtaW5hdGVkU3RyaW5nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgaWYgKGNoID09PSBxdW90ZSkgYnJlYWs7XG5cbiAgICAgIGlmIChjaCA9PT0gMzgpIHtcbiAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgICBvdXQgKz0gdGhpcy5qc3hSZWFkRW50aXR5KCk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgIG91dCArPSB0aGlzLmpzeFJlYWROZXdMaW5lKGZhbHNlKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcysrKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5zdHJpbmcsIG91dCk7XG4gIH1cblxuICBqc3hSZWFkRW50aXR5KCkge1xuICAgIGxldCBzdHIgPSBcIlwiO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgbGV0IGVudGl0eTtcbiAgICBsZXQgY2ggPSB0aGlzLmlucHV0W3RoaXMuc3RhdGUucG9zXTtcbiAgICBjb25zdCBzdGFydFBvcyA9ICsrdGhpcy5zdGF0ZS5wb3M7XG5cbiAgICB3aGlsZSAodGhpcy5zdGF0ZS5wb3MgPCB0aGlzLmxlbmd0aCAmJiBjb3VudCsrIDwgMTApIHtcbiAgICAgIGNoID0gdGhpcy5pbnB1dFt0aGlzLnN0YXRlLnBvcysrXTtcblxuICAgICAgaWYgKGNoID09PSBcIjtcIikge1xuICAgICAgICBpZiAoc3RyWzBdID09PSBcIiNcIikge1xuICAgICAgICAgIGlmIChzdHJbMV0gPT09IFwieFwiKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDIpO1xuXG4gICAgICAgICAgICBpZiAoSEVYX05VTUJFUi50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgICAgZW50aXR5ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQocGFyc2VJbnQoc3RyLCAxNikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDEpO1xuXG4gICAgICAgICAgICBpZiAoREVDSU1BTF9OVU1CRVIudGVzdChzdHIpKSB7XG4gICAgICAgICAgICAgIGVudGl0eSA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHBhcnNlSW50KHN0ciwgMTApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW50aXR5ID0gZW50aXRpZXNbc3RyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzdHIgKz0gY2g7XG4gICAgfVxuXG4gICAgaWYgKCFlbnRpdHkpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zID0gc3RhcnRQb3M7XG4gICAgICByZXR1cm4gXCImXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudGl0eTtcbiAgfVxuXG4gIGpzeFJlYWRXb3JkKCkge1xuICAgIGxldCBjaDtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuXG4gICAgZG8ge1xuICAgICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnN0YXRlLnBvcyk7XG4gICAgfSB3aGlsZSAoaXNJZGVudGlmaWVyQ2hhcihjaCkgfHwgY2ggPT09IDQ1KTtcblxuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmpzeE5hbWUsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMuc3RhdGUucG9zKSk7XG4gIH1cblxuICBqc3hQYXJzZUlkZW50aWZpZXIoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5qc3hOYW1lKSkge1xuICAgICAgbm9kZS5uYW1lID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUudHlwZS5rZXl3b3JkKSB7XG4gICAgICBub2RlLm5hbWUgPSB0aGlzLnN0YXRlLnR5cGUua2V5d29yZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWElkZW50aWZpZXJcIik7XG4gIH1cblxuICBqc3hQYXJzZU5hbWVzcGFjZWROYW1lKCkge1xuICAgIGNvbnN0IHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuanN4UGFyc2VJZGVudGlmaWVyKCk7XG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlcy5jb2xvbikpIHJldHVybiBuYW1lO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5uYW1lc3BhY2UgPSBuYW1lO1xuICAgIG5vZGUubmFtZSA9IHRoaXMuanN4UGFyc2VJZGVudGlmaWVyKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWE5hbWVzcGFjZWROYW1lXCIpO1xuICB9XG5cbiAganN4UGFyc2VFbGVtZW50TmFtZSgpIHtcbiAgICBjb25zdCBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGxldCBub2RlID0gdGhpcy5qc3hQYXJzZU5hbWVzcGFjZWROYW1lKCk7XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcIkpTWE5hbWVzcGFjZWROYW1lXCIpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHdoaWxlICh0aGlzLmVhdCh0eXBlcy5kb3QpKSB7XG4gICAgICBjb25zdCBuZXdOb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbmV3Tm9kZS5vYmplY3QgPSBub2RlO1xuICAgICAgbmV3Tm9kZS5wcm9wZXJ0eSA9IHRoaXMuanN4UGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICBub2RlID0gdGhpcy5maW5pc2hOb2RlKG5ld05vZGUsIFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGpzeFBhcnNlQXR0cmlidXRlVmFsdWUoKSB7XG4gICAgbGV0IG5vZGU7XG5cbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSB0eXBlcy5icmFjZUw6XG4gICAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgbm9kZSA9IHRoaXMuanN4UGFyc2VFeHByZXNzaW9uQ29udGFpbmVyKG5vZGUpO1xuXG4gICAgICAgIGlmIChub2RlLmV4cHJlc3Npb24udHlwZSA9PT0gXCJKU1hFbXB0eUV4cHJlc3Npb25cIikge1xuICAgICAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgSnN4RXJyb3JzLkF0dHJpYnV0ZUlzRW1wdHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG5cbiAgICAgIGNhc2UgdHlwZXMuanN4VGFnU3RhcnQ6XG4gICAgICBjYXNlIHR5cGVzLnN0cmluZzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByQXRvbSgpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIEpzeEVycm9ycy5VbnN1cHBvcnRlZEpzeFZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBqc3hQYXJzZUVtcHR5RXhwcmVzc2lvbigpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdCh0aGlzLnN0YXRlLmxhc3RUb2tFbmQsIHRoaXMuc3RhdGUubGFzdFRva0VuZExvYyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZUF0KG5vZGUsIFwiSlNYRW1wdHlFeHByZXNzaW9uXCIsIHRoaXMuc3RhdGUuc3RhcnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICB9XG5cbiAganN4UGFyc2VTcHJlYWRDaGlsZChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5leHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZVIpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hTcHJlYWRDaGlsZFwiKTtcbiAgfVxuXG4gIGpzeFBhcnNlRXhwcmVzc2lvbkNvbnRhaW5lcihub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuYnJhY2VSKSkge1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gdGhpcy5qc3hQYXJzZUVtcHR5RXhwcmVzc2lvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIH1cblxuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlUik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIik7XG4gIH1cblxuICBqc3hQYXJzZUF0dHJpYnV0ZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5icmFjZUwpKSB7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5lbGxpcHNpcyk7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZVIpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWFNwcmVhZEF0dHJpYnV0ZVwiKTtcbiAgICB9XG5cbiAgICBub2RlLm5hbWUgPSB0aGlzLmpzeFBhcnNlTmFtZXNwYWNlZE5hbWUoKTtcbiAgICBub2RlLnZhbHVlID0gdGhpcy5lYXQodHlwZXMuZXEpID8gdGhpcy5qc3hQYXJzZUF0dHJpYnV0ZVZhbHVlKCkgOiBudWxsO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hBdHRyaWJ1dGVcIik7XG4gIH1cblxuICBqc3hQYXJzZU9wZW5pbmdFbGVtZW50QXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcblxuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmpzeFRhZ0VuZCkpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmpzeFRhZ0VuZCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYT3BlbmluZ0ZyYWdtZW50XCIpO1xuICAgIH1cblxuICAgIG5vZGUubmFtZSA9IHRoaXMuanN4UGFyc2VFbGVtZW50TmFtZSgpO1xuICAgIHJldHVybiB0aGlzLmpzeFBhcnNlT3BlbmluZ0VsZW1lbnRBZnRlck5hbWUobm9kZSk7XG4gIH1cblxuICBqc3hQYXJzZU9wZW5pbmdFbGVtZW50QWZ0ZXJOYW1lKG5vZGUpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gW107XG5cbiAgICB3aGlsZSAoIXRoaXMubWF0Y2godHlwZXMuc2xhc2gpICYmICF0aGlzLm1hdGNoKHR5cGVzLmpzeFRhZ0VuZCkpIHtcbiAgICAgIGF0dHJpYnV0ZXMucHVzaCh0aGlzLmpzeFBhcnNlQXR0cmlidXRlKCkpO1xuICAgIH1cblxuICAgIG5vZGUuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgbm9kZS5zZWxmQ2xvc2luZyA9IHRoaXMuZWF0KHR5cGVzLnNsYXNoKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5qc3hUYWdFbmQpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hPcGVuaW5nRWxlbWVudFwiKTtcbiAgfVxuXG4gIGpzeFBhcnNlQ2xvc2luZ0VsZW1lbnRBdChzdGFydFBvcywgc3RhcnRMb2MpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuanN4VGFnRW5kKSkge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuanN4VGFnRW5kKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hDbG9zaW5nRnJhZ21lbnRcIik7XG4gICAgfVxuXG4gICAgbm9kZS5uYW1lID0gdGhpcy5qc3hQYXJzZUVsZW1lbnROYW1lKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuanN4VGFnRW5kKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYQ2xvc2luZ0VsZW1lbnRcIik7XG4gIH1cblxuICBqc3hQYXJzZUVsZW1lbnRBdChzdGFydFBvcywgc3RhcnRMb2MpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG4gICAgY29uc3Qgb3BlbmluZ0VsZW1lbnQgPSB0aGlzLmpzeFBhcnNlT3BlbmluZ0VsZW1lbnRBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIGxldCBjbG9zaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICBpZiAoIW9wZW5pbmdFbGVtZW50LnNlbGZDbG9zaW5nKSB7XG4gICAgICBjb250ZW50czogZm9yICg7Oykge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgICAgIGNhc2UgdHlwZXMuanN4VGFnU3RhcnQ6XG4gICAgICAgICAgICBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgICAgICAgICBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLnNsYXNoKSkge1xuICAgICAgICAgICAgICBjbG9zaW5nRWxlbWVudCA9IHRoaXMuanN4UGFyc2VDbG9zaW5nRWxlbWVudEF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICAgICAgICAgIGJyZWFrIGNvbnRlbnRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuanN4UGFyc2VFbGVtZW50QXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgdHlwZXMuanN4VGV4dDpcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5wYXJzZUV4cHJBdG9tKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmVsbGlwc2lzKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5qc3hQYXJzZVNwcmVhZENoaWxkKG5vZGUpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuanN4UGFyc2VFeHByZXNzaW9uQ29udGFpbmVyKG5vZGUpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZyYWdtZW50KG9wZW5pbmdFbGVtZW50KSAmJiAhaXNGcmFnbWVudChjbG9zaW5nRWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShjbG9zaW5nRWxlbWVudC5zdGFydCwgSnN4RXJyb3JzLk1pc3NpbmdDbG9zaW5nVGFnRnJhZ21lbnQpO1xuICAgICAgfSBlbHNlIGlmICghaXNGcmFnbWVudChvcGVuaW5nRWxlbWVudCkgJiYgaXNGcmFnbWVudChjbG9zaW5nRWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShjbG9zaW5nRWxlbWVudC5zdGFydCwgSnN4RXJyb3JzLk1pc3NpbmdDbG9zaW5nVGFnRWxlbWVudCwgZ2V0UXVhbGlmaWVkSlNYTmFtZShvcGVuaW5nRWxlbWVudC5uYW1lKSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0ZyYWdtZW50KG9wZW5pbmdFbGVtZW50KSAmJiAhaXNGcmFnbWVudChjbG9zaW5nRWxlbWVudCkpIHtcbiAgICAgICAgaWYgKGdldFF1YWxpZmllZEpTWE5hbWUoY2xvc2luZ0VsZW1lbnQubmFtZSkgIT09IGdldFF1YWxpZmllZEpTWE5hbWUob3BlbmluZ0VsZW1lbnQubmFtZSkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKGNsb3NpbmdFbGVtZW50LnN0YXJ0LCBKc3hFcnJvcnMuTWlzc2luZ0Nsb3NpbmdUYWdFbGVtZW50LCBnZXRRdWFsaWZpZWRKU1hOYW1lKG9wZW5pbmdFbGVtZW50Lm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0ZyYWdtZW50KG9wZW5pbmdFbGVtZW50KSkge1xuICAgICAgbm9kZS5vcGVuaW5nRnJhZ21lbnQgPSBvcGVuaW5nRWxlbWVudDtcbiAgICAgIG5vZGUuY2xvc2luZ0ZyYWdtZW50ID0gY2xvc2luZ0VsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUub3BlbmluZ0VsZW1lbnQgPSBvcGVuaW5nRWxlbWVudDtcbiAgICAgIG5vZGUuY2xvc2luZ0VsZW1lbnQgPSBjbG9zaW5nRWxlbWVudDtcbiAgICB9XG5cbiAgICBub2RlLmNoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIEpzeEVycm9ycy5VbndyYXBwZWRBZGphY2VudEpTWEVsZW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNGcmFnbWVudChvcGVuaW5nRWxlbWVudCkgPyB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hGcmFnbWVudFwiKSA6IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWEVsZW1lbnRcIik7XG4gIH1cblxuICBqc3hQYXJzZUVsZW1lbnQoKSB7XG4gICAgY29uc3Qgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5qc3hQYXJzZUVsZW1lbnRBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICB9XG5cbiAgcGFyc2VFeHByQXRvbShyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuanN4VGV4dCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlLCBcIkpTWFRleHRcIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHR5cGVzLmpzeFRhZ1N0YXJ0KSkge1xuICAgICAgcmV0dXJuIHRoaXMuanN4UGFyc2VFbGVtZW50KCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzUmVsYXRpb25hbChcIjxcIikgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKSAhPT0gMzMpIHtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuanN4VGFnU3RhcnQpO1xuICAgICAgcmV0dXJuIHRoaXMuanN4UGFyc2VFbGVtZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci5wYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIH1cbiAgfVxuXG4gIGdldFRva2VuRnJvbUNvZGUoY29kZSkge1xuICAgIGlmICh0aGlzLnN0YXRlLmluUHJvcGVydHlOYW1lKSByZXR1cm4gc3VwZXIuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKTtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG5cbiAgICBpZiAoY29udGV4dCA9PT0gdHlwZXMkMS5qX2V4cHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmpzeFJlYWRUb2tlbigpO1xuICAgIH1cblxuICAgIGlmIChjb250ZXh0ID09PSB0eXBlcyQxLmpfb1RhZyB8fCBjb250ZXh0ID09PSB0eXBlcyQxLmpfY1RhZykge1xuICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpzeFJlYWRXb3JkKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2RlID09PSA2Mikge1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5qc3hUYWdFbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGNvZGUgPT09IDM0IHx8IGNvZGUgPT09IDM5KSAmJiBjb250ZXh0ID09PSB0eXBlcyQxLmpfb1RhZykge1xuICAgICAgICByZXR1cm4gdGhpcy5qc3hSZWFkU3RyaW5nKGNvZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA2MCAmJiB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpICE9PSAzMykge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmpzeFRhZ1N0YXJ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKTtcbiAgfVxuXG4gIHVwZGF0ZUNvbnRleHQocHJldlR5cGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5icmFjZUwpKSB7XG4gICAgICBjb25zdCBjdXJDb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG5cbiAgICAgIGlmIChjdXJDb250ZXh0ID09PSB0eXBlcyQxLmpfb1RhZykge1xuICAgICAgICB0aGlzLnN0YXRlLmNvbnRleHQucHVzaCh0eXBlcyQxLmJyYWNlRXhwcmVzc2lvbik7XG4gICAgICB9IGVsc2UgaWYgKGN1ckNvbnRleHQgPT09IHR5cGVzJDEual9leHByKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuY29udGV4dC5wdXNoKHR5cGVzJDEudGVtcGxhdGVRdWFzaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdXBlci51cGRhdGVDb250ZXh0KHByZXZUeXBlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGF0ZS5leHByQWxsb3dlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHR5cGVzLnNsYXNoKSAmJiBwcmV2VHlwZSA9PT0gdHlwZXMuanN4VGFnU3RhcnQpIHtcbiAgICAgIHRoaXMuc3RhdGUuY29udGV4dC5sZW5ndGggLT0gMjtcbiAgICAgIHRoaXMuc3RhdGUuY29udGV4dC5wdXNoKHR5cGVzJDEual9jVGFnKTtcbiAgICAgIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUNvbnRleHQocHJldlR5cGUpO1xuICAgIH1cbiAgfVxuXG59KTtcblxuY2xhc3MgU2NvcGUge1xuICBjb25zdHJ1Y3RvcihmbGFncykge1xuICAgIHRoaXMudmFyID0gW107XG4gICAgdGhpcy5sZXhpY2FsID0gW107XG4gICAgdGhpcy5mdW5jdGlvbnMgPSBbXTtcbiAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gIH1cblxufVxuY2xhc3MgU2NvcGVIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IocmFpc2UsIGluTW9kdWxlKSB7XG4gICAgdGhpcy5zY29wZVN0YWNrID0gW107XG4gICAgdGhpcy51bmRlZmluZWRFeHBvcnRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudW5kZWZpbmVkUHJpdmF0ZU5hbWVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucmFpc2UgPSByYWlzZTtcbiAgICB0aGlzLmluTW9kdWxlID0gaW5Nb2R1bGU7XG4gIH1cblxuICBnZXQgaW5GdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgPiAwO1xuICB9XG5cbiAgZ2V0IGFsbG93U3VwZXIoKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5mbGFncyAmIFNDT1BFX1NVUEVSKSA+IDA7XG4gIH1cblxuICBnZXQgYWxsb3dEaXJlY3RTdXBlcigpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzICYgU0NPUEVfRElSRUNUX1NVUEVSKSA+IDA7XG4gIH1cblxuICBnZXQgaW5DbGFzcygpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzICYgU0NPUEVfQ0xBU1MpID4gMDtcbiAgfVxuXG4gIGdldCBpbk5vbkFycm93RnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5mbGFncyAmIFNDT1BFX0ZVTkNUSU9OKSA+IDA7XG4gIH1cblxuICBnZXQgdHJlYXRGdW5jdGlvbnNBc1ZhcigpIHtcbiAgICByZXR1cm4gdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSh0aGlzLmN1cnJlbnRTY29wZSgpKTtcbiAgfVxuXG4gIGNyZWF0ZVNjb3BlKGZsYWdzKSB7XG4gICAgcmV0dXJuIG5ldyBTY29wZShmbGFncyk7XG4gIH1cblxuICBlbnRlcihmbGFncykge1xuICAgIHRoaXMuc2NvcGVTdGFjay5wdXNoKHRoaXMuY3JlYXRlU2NvcGUoZmxhZ3MpKTtcbiAgfVxuXG4gIGV4aXQoKSB7XG4gICAgdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xuICB9XG5cbiAgdHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUoc2NvcGUpIHtcbiAgICByZXR1cm4gISEoc2NvcGUuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTiB8fCAhdGhpcy5pbk1vZHVsZSAmJiBzY29wZS5mbGFncyAmIFNDT1BFX1BST0dSQU0pO1xuICB9XG5cbiAgZGVjbGFyZU5hbWUobmFtZSwgYmluZGluZ1R5cGUsIHBvcykge1xuICAgIGxldCBzY29wZSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG5cbiAgICBpZiAoYmluZGluZ1R5cGUgJiBCSU5EX1NDT1BFX0xFWElDQUwgfHwgYmluZGluZ1R5cGUgJiBCSU5EX1NDT1BFX0ZVTkNUSU9OKSB7XG4gICAgICB0aGlzLmNoZWNrUmVkZWNsYXJhdGlvbkluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlLCBwb3MpO1xuXG4gICAgICBpZiAoYmluZGluZ1R5cGUgJiBCSU5EX1NDT1BFX0ZVTkNUSU9OKSB7XG4gICAgICAgIHNjb3BlLmZ1bmN0aW9ucy5wdXNoKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NvcGUubGV4aWNhbC5wdXNoKG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmluZGluZ1R5cGUgJiBCSU5EX1NDT1BFX0xFWElDQUwpIHtcbiAgICAgICAgdGhpcy5tYXliZUV4cG9ydERlZmluZWQoc2NvcGUsIG5hbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYmluZGluZ1R5cGUgJiBCSU5EX1NDT1BFX1ZBUikge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBzY29wZSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgICAgdGhpcy5jaGVja1JlZGVjbGFyYXRpb25JblNjb3BlKHNjb3BlLCBuYW1lLCBiaW5kaW5nVHlwZSwgcG9zKTtcbiAgICAgICAgc2NvcGUudmFyLnB1c2gobmFtZSk7XG4gICAgICAgIHRoaXMubWF5YmVFeHBvcnREZWZpbmVkKHNjb3BlLCBuYW1lKTtcbiAgICAgICAgaWYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVkFSKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbk1vZHVsZSAmJiBzY29wZS5mbGFncyAmIFNDT1BFX1BST0dSQU0pIHtcbiAgICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0cy5kZWxldGUobmFtZSk7XG4gICAgfVxuICB9XG5cbiAgbWF5YmVFeHBvcnREZWZpbmVkKHNjb3BlLCBuYW1lKSB7XG4gICAgaWYgKHRoaXMuaW5Nb2R1bGUgJiYgc2NvcGUuZmxhZ3MgJiBTQ09QRV9QUk9HUkFNKSB7XG4gICAgICB0aGlzLnVuZGVmaW5lZEV4cG9ydHMuZGVsZXRlKG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrUmVkZWNsYXJhdGlvbkluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlLCBwb3MpIHtcbiAgICBpZiAodGhpcy5pc1JlZGVjbGFyZWRJblNjb3BlKHNjb3BlLCBuYW1lLCBiaW5kaW5nVHlwZSkpIHtcbiAgICAgIHRoaXMucmFpc2UocG9zLCBFcnJvck1lc3NhZ2VzLlZhclJlZGVjbGFyYXRpb24sIG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIGlzUmVkZWNsYXJlZEluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlKSB7XG4gICAgaWYgKCEoYmluZGluZ1R5cGUgJiBCSU5EX0tJTkRfVkFMVUUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoYmluZGluZ1R5cGUgJiBCSU5EX1NDT1BFX0xFWElDQUwpIHtcbiAgICAgIHJldHVybiBzY29wZS5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZS5mdW5jdGlvbnMuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlLnZhci5pbmRleE9mKG5hbWUpID4gLTE7XG4gICAgfVxuXG4gICAgaWYgKGJpbmRpbmdUeXBlICYgQklORF9TQ09QRV9GVU5DVElPTikge1xuICAgICAgcmV0dXJuIHNjb3BlLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xIHx8ICF0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHNjb3BlKSAmJiBzY29wZS52YXIuaW5kZXhPZihuYW1lKSA+IC0xO1xuICAgIH1cblxuICAgIHJldHVybiBzY29wZS5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSAmJiAhKHNjb3BlLmZsYWdzICYgU0NPUEVfU0lNUExFX0NBVENIICYmIHNjb3BlLmxleGljYWxbMF0gPT09IG5hbWUpIHx8ICF0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHNjb3BlKSAmJiBzY29wZS5mdW5jdGlvbnMuaW5kZXhPZihuYW1lKSA+IC0xO1xuICB9XG5cbiAgY2hlY2tMb2NhbEV4cG9ydChpZCkge1xuICAgIGlmICh0aGlzLnNjb3BlU3RhY2tbMF0ubGV4aWNhbC5pbmRleE9mKGlkLm5hbWUpID09PSAtMSAmJiB0aGlzLnNjb3BlU3RhY2tbMF0udmFyLmluZGV4T2YoaWQubmFtZSkgPT09IC0xICYmIHRoaXMuc2NvcGVTdGFja1swXS5mdW5jdGlvbnMuaW5kZXhPZihpZC5uYW1lKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0cy5zZXQoaWQubmFtZSwgaWQuc3RhcnQpO1xuICAgIH1cbiAgfVxuXG4gIGN1cnJlbnRTY29wZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIGN1cnJlbnRWYXJTY29wZSgpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuXG4gICAgICBpZiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9WQVIpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGN1cnJlbnRUaGlzU2NvcGUoKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcblxuICAgICAgaWYgKChzY29wZS5mbGFncyAmIFNDT1BFX1ZBUiB8fCBzY29wZS5mbGFncyAmIFNDT1BFX0NMQVNTKSAmJiAhKHNjb3BlLmZsYWdzICYgU0NPUEVfQVJST1cpKSB7XG4gICAgICAgIHJldHVybiBzY29wZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuXG5jbGFzcyBUeXBlU2NyaXB0U2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLnR5cGVzID0gW107XG4gICAgdGhpcy5lbnVtcyA9IFtdO1xuICAgIHRoaXMuY29uc3RFbnVtcyA9IFtdO1xuICAgIHRoaXMuY2xhc3NlcyA9IFtdO1xuICAgIHRoaXMuZXhwb3J0T25seUJpbmRpbmdzID0gW107XG4gIH1cblxufVxuXG5jbGFzcyBUeXBlU2NyaXB0U2NvcGVIYW5kbGVyIGV4dGVuZHMgU2NvcGVIYW5kbGVyIHtcbiAgY3JlYXRlU2NvcGUoZmxhZ3MpIHtcbiAgICByZXR1cm4gbmV3IFR5cGVTY3JpcHRTY29wZShmbGFncyk7XG4gIH1cblxuICBkZWNsYXJlTmFtZShuYW1lLCBiaW5kaW5nVHlwZSwgcG9zKSB7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuXG4gICAgaWYgKGJpbmRpbmdUeXBlICYgQklORF9GTEFHU19UU19FWFBPUlRfT05MWSkge1xuICAgICAgdGhpcy5tYXliZUV4cG9ydERlZmluZWQoc2NvcGUsIG5hbWUpO1xuICAgICAgc2NvcGUuZXhwb3J0T25seUJpbmRpbmdzLnB1c2gobmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3VwZXIuZGVjbGFyZU5hbWUoLi4uYXJndW1lbnRzKTtcblxuICAgIGlmIChiaW5kaW5nVHlwZSAmIEJJTkRfS0lORF9UWVBFKSB7XG4gICAgICBpZiAoIShiaW5kaW5nVHlwZSAmIEJJTkRfS0lORF9WQUxVRSkpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlZGVjbGFyYXRpb25JblNjb3BlKHNjb3BlLCBuYW1lLCBiaW5kaW5nVHlwZSwgcG9zKTtcbiAgICAgICAgdGhpcy5tYXliZUV4cG9ydERlZmluZWQoc2NvcGUsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBzY29wZS50eXBlcy5wdXNoKG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChiaW5kaW5nVHlwZSAmIEJJTkRfRkxBR1NfVFNfRU5VTSkgc2NvcGUuZW51bXMucHVzaChuYW1lKTtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiBCSU5EX0ZMQUdTX1RTX0NPTlNUX0VOVU0pIHNjb3BlLmNvbnN0RW51bXMucHVzaChuYW1lKTtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiBCSU5EX0ZMQUdTX0NMQVNTKSBzY29wZS5jbGFzc2VzLnB1c2gobmFtZSk7XG4gIH1cblxuICBpc1JlZGVjbGFyZWRJblNjb3BlKHNjb3BlLCBuYW1lLCBiaW5kaW5nVHlwZSkge1xuICAgIGlmIChzY29wZS5lbnVtcy5pbmRleE9mKG5hbWUpID4gLTEpIHtcbiAgICAgIGlmIChiaW5kaW5nVHlwZSAmIEJJTkRfRkxBR1NfVFNfRU5VTSkge1xuICAgICAgICBjb25zdCBpc0NvbnN0ID0gISEoYmluZGluZ1R5cGUgJiBCSU5EX0ZMQUdTX1RTX0NPTlNUX0VOVU0pO1xuICAgICAgICBjb25zdCB3YXNDb25zdCA9IHNjb3BlLmNvbnN0RW51bXMuaW5kZXhPZihuYW1lKSA+IC0xO1xuICAgICAgICByZXR1cm4gaXNDb25zdCAhPT0gd2FzQ29uc3Q7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChiaW5kaW5nVHlwZSAmIEJJTkRfRkxBR1NfQ0xBU1MgJiYgc2NvcGUuY2xhc3Nlcy5pbmRleE9mKG5hbWUpID4gLTEpIHtcbiAgICAgIGlmIChzY29wZS5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgICByZXR1cm4gISEoYmluZGluZ1R5cGUgJiBCSU5EX0tJTkRfVkFMVUUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChiaW5kaW5nVHlwZSAmIEJJTkRfS0lORF9UWVBFICYmIHNjb3BlLnR5cGVzLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmlzUmVkZWNsYXJlZEluU2NvcGUoLi4uYXJndW1lbnRzKTtcbiAgfVxuXG4gIGNoZWNrTG9jYWxFeHBvcnQoaWQpIHtcbiAgICBpZiAodGhpcy5zY29wZVN0YWNrWzBdLnR5cGVzLmluZGV4T2YoaWQubmFtZSkgPT09IC0xICYmIHRoaXMuc2NvcGVTdGFja1swXS5leHBvcnRPbmx5QmluZGluZ3MuaW5kZXhPZihpZC5uYW1lKSA9PT0gLTEpIHtcbiAgICAgIHN1cGVyLmNoZWNrTG9jYWxFeHBvcnQoaWQpO1xuICAgIH1cbiAgfVxuXG59XG5cbmNvbnN0IFBBUkFNID0gMGIwMDAsXG4gICAgICBQQVJBTV9ZSUVMRCA9IDBiMDAxLFxuICAgICAgUEFSQU1fQVdBSVQgPSAwYjAxMCxcbiAgICAgIFBBUkFNX1JFVFVSTiA9IDBiMTAwO1xuY2xhc3MgUHJvZHVjdGlvblBhcmFtZXRlckhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0YWNrcyA9IFtdO1xuICB9XG5cbiAgZW50ZXIoZmxhZ3MpIHtcbiAgICB0aGlzLnN0YWNrcy5wdXNoKGZsYWdzKTtcbiAgfVxuXG4gIGV4aXQoKSB7XG4gICAgdGhpcy5zdGFja3MucG9wKCk7XG4gIH1cblxuICBjdXJyZW50RmxhZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2tzW3RoaXMuc3RhY2tzLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgZ2V0IGhhc0F3YWl0KCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50RmxhZ3MoKSAmIFBBUkFNX0FXQUlUKSA+IDA7XG4gIH1cblxuICBnZXQgaGFzWWllbGQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRGbGFncygpICYgUEFSQU1fWUlFTEQpID4gMDtcbiAgfVxuXG4gIGdldCBoYXNSZXR1cm4oKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRGbGFncygpICYgUEFSQU1fUkVUVVJOKSA+IDA7XG4gIH1cblxufVxuZnVuY3Rpb24gZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBpc0dlbmVyYXRvcikge1xuICByZXR1cm4gKGlzQXN5bmMgPyBQQVJBTV9BV0FJVCA6IDApIHwgKGlzR2VuZXJhdG9yID8gUEFSQU1fWUlFTEQgOiAwKTtcbn1cblxuZnVuY3Rpb24gbm9uTnVsbCh4KSB7XG4gIGlmICh4ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgJHt4fSB2YWx1ZS5gKTtcbiAgfVxuXG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiBhc3NlcnQoeCkge1xuICBpZiAoIXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnQgZmFpbFwiKTtcbiAgfVxufVxuXG5jb25zdCBUU0Vycm9ycyA9IE9iamVjdC5mcmVlemUoe1xuICBDbGFzc01ldGhvZEhhc0RlY2xhcmU6IFwiQ2xhc3MgbWV0aG9kcyBjYW5ub3QgaGF2ZSB0aGUgJ2RlY2xhcmUnIG1vZGlmaWVyXCIsXG4gIENsYXNzTWV0aG9kSGFzUmVhZG9ubHk6IFwiQ2xhc3MgbWV0aG9kcyBjYW5ub3QgaGF2ZSB0aGUgJ3JlYWRvbmx5JyBtb2RpZmllclwiLFxuICBEZWNsYXJlQ2xhc3NGaWVsZEhhc0luaXRpYWxpemVyOiBcIidkZWNsYXJlJyBjbGFzcyBmaWVsZHMgY2Fubm90IGhhdmUgYW4gaW5pdGlhbGl6ZXJcIixcbiAgRHVwbGljYXRlTW9kaWZpZXI6IFwiRHVwbGljYXRlIG1vZGlmaWVyOiAnJTAnXCIsXG4gIEVtcHR5SGVyaXRhZ2VDbGF1c2VUeXBlOiBcIiclMCcgbGlzdCBjYW5ub3QgYmUgZW1wdHkuXCIsXG4gIEluZGV4U2lnbmF0dXJlSGFzQWJzdHJhY3Q6IFwiSW5kZXggc2lnbmF0dXJlcyBjYW5ub3QgaGF2ZSB0aGUgJ2Fic3RyYWN0JyBtb2RpZmllclwiLFxuICBJbmRleFNpZ25hdHVyZUhhc0FjY2Vzc2liaWxpdHk6IFwiSW5kZXggc2lnbmF0dXJlcyBjYW5ub3QgaGF2ZSBhbiBhY2Nlc3NpYmlsaXR5IG1vZGlmaWVyICgnJTAnKVwiLFxuICBJbmRleFNpZ25hdHVyZUhhc1N0YXRpYzogXCJJbmRleCBzaWduYXR1cmVzIGNhbm5vdCBoYXZlIHRoZSAnc3RhdGljJyBtb2RpZmllclwiLFxuICBPcHRpb25hbFR5cGVCZWZvcmVSZXF1aXJlZDogXCJBIHJlcXVpcmVkIGVsZW1lbnQgY2Fubm90IGZvbGxvdyBhbiBvcHRpb25hbCBlbGVtZW50LlwiLFxuICBQYXR0ZXJuSXNPcHRpb25hbDogXCJBIGJpbmRpbmcgcGF0dGVybiBwYXJhbWV0ZXIgY2Fubm90IGJlIG9wdGlvbmFsIGluIGFuIGltcGxlbWVudGF0aW9uIHNpZ25hdHVyZS5cIixcbiAgUHJpdmF0ZUVsZW1lbnRIYXNBYnN0cmFjdDogXCJQcml2YXRlIGVsZW1lbnRzIGNhbm5vdCBoYXZlIHRoZSAnYWJzdHJhY3QnIG1vZGlmaWVyLlwiLFxuICBQcml2YXRlRWxlbWVudEhhc0FjY2Vzc2liaWxpdHk6IFwiUHJpdmF0ZSBlbGVtZW50cyBjYW5ub3QgaGF2ZSBhbiBhY2Nlc3NpYmlsaXR5IG1vZGlmaWVyICgnJTAnKVwiLFxuICBUZW1wbGF0ZVR5cGVIYXNTdWJzdGl0dXRpb246IFwiVGVtcGxhdGUgbGl0ZXJhbCB0eXBlcyBjYW5ub3QgaGF2ZSBhbnkgc3Vic3RpdHV0aW9uXCIsXG4gIFR5cGVBbm5vdGF0aW9uQWZ0ZXJBc3NpZ246IFwiVHlwZSBhbm5vdGF0aW9ucyBtdXN0IGNvbWUgYmVmb3JlIGRlZmF1bHQgYXNzaWdubWVudHMsIGUuZy4gaW5zdGVhZCBvZiBgYWdlID0gMjU6IG51bWJlcmAgdXNlIGBhZ2U6IG51bWJlciA9IDI1YFwiLFxuICBVbmV4cGVjdGVkUmVhZG9ubHk6IFwiJ3JlYWRvbmx5JyB0eXBlIG1vZGlmaWVyIGlzIG9ubHkgcGVybWl0dGVkIG9uIGFycmF5IGFuZCB0dXBsZSBsaXRlcmFsIHR5cGVzLlwiLFxuICBVbmV4cGVjdGVkVHlwZUFubm90YXRpb246IFwiRGlkIG5vdCBleHBlY3QgYSB0eXBlIGFubm90YXRpb24gaGVyZS5cIixcbiAgVW5leHBlY3RlZFR5cGVDYXN0SW5QYXJhbWV0ZXI6IFwiVW5leHBlY3RlZCB0eXBlIGNhc3QgaW4gcGFyYW1ldGVyIHBvc2l0aW9uLlwiLFxuICBVbnN1cHBvcnRlZEltcG9ydFR5cGVBcmd1bWVudDogXCJBcmd1bWVudCBpbiBhIHR5cGUgaW1wb3J0IG11c3QgYmUgYSBzdHJpbmcgbGl0ZXJhbFwiLFxuICBVbnN1cHBvcnRlZFBhcmFtZXRlclByb3BlcnR5S2luZDogXCJBIHBhcmFtZXRlciBwcm9wZXJ0eSBtYXkgbm90IGJlIGRlY2xhcmVkIHVzaW5nIGEgYmluZGluZyBwYXR0ZXJuLlwiLFxuICBVbnN1cHBvcnRlZFNpZ25hdHVyZVBhcmFtZXRlcktpbmQ6IFwiTmFtZSBpbiBhIHNpZ25hdHVyZSBtdXN0IGJlIGFuIElkZW50aWZpZXIsIE9iamVjdFBhdHRlcm4gb3IgQXJyYXlQYXR0ZXJuLCBpbnN0ZWFkIGdvdCAlMFwiXG59KTtcblxuZnVuY3Rpb24ga2V5d29yZFR5cGVGcm9tTmFtZSh2YWx1ZSkge1xuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSBcImFueVwiOlxuICAgICAgcmV0dXJuIFwiVFNBbnlLZXl3b3JkXCI7XG5cbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIFwiVFNCb29sZWFuS2V5d29yZFwiO1xuXG4gICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgcmV0dXJuIFwiVFNCaWdJbnRLZXl3b3JkXCI7XG5cbiAgICBjYXNlIFwibmV2ZXJcIjpcbiAgICAgIHJldHVybiBcIlRTTmV2ZXJLZXl3b3JkXCI7XG5cbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gXCJUU051bWJlcktleXdvcmRcIjtcblxuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHJldHVybiBcIlRTT2JqZWN0S2V5d29yZFwiO1xuXG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIFwiVFNTdHJpbmdLZXl3b3JkXCI7XG5cbiAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICByZXR1cm4gXCJUU1N5bWJvbEtleXdvcmRcIjtcblxuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIHJldHVybiBcIlRTVW5kZWZpbmVkS2V5d29yZFwiO1xuXG4gICAgY2FzZSBcInVua25vd25cIjpcbiAgICAgIHJldHVybiBcIlRTVW5rbm93bktleXdvcmRcIjtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbnZhciB0eXBlc2NyaXB0ID0gKHN1cGVyQ2xhc3MgPT4gY2xhc3MgZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgZ2V0U2NvcGVIYW5kbGVyKCkge1xuICAgIHJldHVybiBUeXBlU2NyaXB0U2NvcGVIYW5kbGVyO1xuICB9XG5cbiAgdHNJc0lkZW50aWZpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2godHlwZXMubmFtZSk7XG4gIH1cblxuICB0c05leHRUb2tlbkNhbkZvbGxvd01vZGlmaWVyKCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiAhdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSAmJiAhdGhpcy5tYXRjaCh0eXBlcy5wYXJlbkwpICYmICF0aGlzLm1hdGNoKHR5cGVzLnBhcmVuUikgJiYgIXRoaXMubWF0Y2godHlwZXMuY29sb24pICYmICF0aGlzLm1hdGNoKHR5cGVzLmVxKSAmJiAhdGhpcy5tYXRjaCh0eXBlcy5xdWVzdGlvbikgJiYgIXRoaXMubWF0Y2godHlwZXMuYmFuZyk7XG4gIH1cblxuICB0c1BhcnNlTW9kaWZpZXIoYWxsb3dlZE1vZGlmaWVycykge1xuICAgIGlmICghdGhpcy5tYXRjaCh0eXBlcy5uYW1lKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBtb2RpZmllciA9IHRoaXMuc3RhdGUudmFsdWU7XG5cbiAgICBpZiAoYWxsb3dlZE1vZGlmaWVycy5pbmRleE9mKG1vZGlmaWVyKSAhPT0gLTEgJiYgdGhpcy50c1RyeVBhcnNlKHRoaXMudHNOZXh0VG9rZW5DYW5Gb2xsb3dNb2RpZmllci5iaW5kKHRoaXMpKSkge1xuICAgICAgcmV0dXJuIG1vZGlmaWVyO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB0c1BhcnNlTW9kaWZpZXJzKG1vZGlmaWVkLCBhbGxvd2VkTW9kaWZpZXJzKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgY29uc3Qgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgICAgY29uc3QgbW9kaWZpZXIgPSB0aGlzLnRzUGFyc2VNb2RpZmllcihhbGxvd2VkTW9kaWZpZXJzKTtcbiAgICAgIGlmICghbW9kaWZpZXIpIGJyZWFrO1xuXG4gICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kaWZpZWQsIG1vZGlmaWVyKSkge1xuICAgICAgICB0aGlzLnJhaXNlKHN0YXJ0UG9zLCBUU0Vycm9ycy5EdXBsaWNhdGVNb2RpZmllciwgbW9kaWZpZXIpO1xuICAgICAgfVxuXG4gICAgICBtb2RpZmllZFttb2RpZmllcl0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHRzSXNMaXN0VGVybWluYXRvcihraW5kKSB7XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIFwiRW51bU1lbWJlcnNcIjpcbiAgICAgIGNhc2UgXCJUeXBlTWVtYmVyc1wiOlxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaCh0eXBlcy5icmFjZVIpO1xuXG4gICAgICBjYXNlIFwiSGVyaXRhZ2VDbGF1c2VFbGVtZW50XCI6XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoKHR5cGVzLmJyYWNlTCk7XG5cbiAgICAgIGNhc2UgXCJUdXBsZUVsZW1lbnRUeXBlc1wiOlxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaCh0eXBlcy5icmFja2V0Uik7XG5cbiAgICAgIGNhc2UgXCJUeXBlUGFyYW1ldGVyc09yQXJndW1lbnRzXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmlzUmVsYXRpb25hbChcIj5cIik7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWFjaGFibGVcIik7XG4gIH1cblxuICB0c1BhcnNlTGlzdChraW5kLCBwYXJzZUVsZW1lbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICghdGhpcy50c0lzTGlzdFRlcm1pbmF0b3Ioa2luZCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHBhcnNlRWxlbWVudCgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdHNQYXJzZURlbGltaXRlZExpc3Qoa2luZCwgcGFyc2VFbGVtZW50KSB7XG4gICAgcmV0dXJuIG5vbk51bGwodGhpcy50c1BhcnNlRGVsaW1pdGVkTGlzdFdvcmtlcihraW5kLCBwYXJzZUVsZW1lbnQsIHRydWUpKTtcbiAgfVxuXG4gIHRzUGFyc2VEZWxpbWl0ZWRMaXN0V29ya2VyKGtpbmQsIHBhcnNlRWxlbWVudCwgZXhwZWN0U3VjY2Vzcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMudHNJc0xpc3RUZXJtaW5hdG9yKGtpbmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlbGVtZW50ID0gcGFyc2VFbGVtZW50KCk7XG5cbiAgICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0LnB1c2goZWxlbWVudCk7XG5cbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5jb21tYSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRzSXNMaXN0VGVybWluYXRvcihraW5kKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGV4cGVjdFN1Y2Nlc3MpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB0c1BhcnNlQnJhY2tldGVkTGlzdChraW5kLCBwYXJzZUVsZW1lbnQsIGJyYWNrZXQsIHNraXBGaXJzdFRva2VuKSB7XG4gICAgaWYgKCFza2lwRmlyc3RUb2tlbikge1xuICAgICAgaWYgKGJyYWNrZXQpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2tldEwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3RSZWxhdGlvbmFsKFwiPFwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRzUGFyc2VEZWxpbWl0ZWRMaXN0KGtpbmQsIHBhcnNlRWxlbWVudCk7XG5cbiAgICBpZiAoYnJhY2tldCkge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2tldFIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cGVjdFJlbGF0aW9uYWwoXCI+XCIpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB0c1BhcnNlSW1wb3J0VHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5faW1wb3J0KTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuXG4gICAgaWYgKCF0aGlzLm1hdGNoKHR5cGVzLnN0cmluZykpIHtcbiAgICAgIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCwgVFNFcnJvcnMuVW5zdXBwb3J0ZWRJbXBvcnRUeXBlQXJndW1lbnQpO1xuICAgIH1cblxuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLmRvdCkpIHtcbiAgICAgIG5vZGUucXVhbGlmaWVyID0gdGhpcy50c1BhcnNlRW50aXR5TmFtZSh0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50cygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0ltcG9ydFR5cGVcIik7XG4gIH1cblxuICB0c1BhcnNlRW50aXR5TmFtZShhbGxvd1Jlc2VydmVkV29yZHMpIHtcbiAgICBsZXQgZW50aXR5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcblxuICAgIHdoaWxlICh0aGlzLmVhdCh0eXBlcy5kb3QpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdE5vZGUoZW50aXR5KTtcbiAgICAgIG5vZGUubGVmdCA9IGVudGl0eTtcbiAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcihhbGxvd1Jlc2VydmVkV29yZHMpO1xuICAgICAgZW50aXR5ID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNRdWFsaWZpZWROYW1lXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBlbnRpdHk7XG4gIH1cblxuICB0c1BhcnNlVHlwZVJlZmVyZW5jZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnR5cGVOYW1lID0gdGhpcy50c1BhcnNlRW50aXR5TmFtZShmYWxzZSk7XG5cbiAgICBpZiAoIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkgJiYgdGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50cygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVSZWZlcmVuY2VcIik7XG4gIH1cblxuICB0c1BhcnNlVGhpc1R5cGVQcmVkaWNhdGUobGhzKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXROb2RlKGxocyk7XG4gICAgbm9kZS5wYXJhbWV0ZXJOYW1lID0gbGhzO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLnRzUGFyc2VUeXBlQW5ub3RhdGlvbihmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZVByZWRpY2F0ZVwiKTtcbiAgfVxuXG4gIHRzUGFyc2VUaGlzVHlwZU5vZGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVGhpc1R5cGVcIik7XG4gIH1cblxuICB0c1BhcnNlVHlwZVF1ZXJ5KCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLl90eXBlb2YpO1xuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2ltcG9ydCkpIHtcbiAgICAgIG5vZGUuZXhwck5hbWUgPSB0aGlzLnRzUGFyc2VJbXBvcnRUeXBlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuZXhwck5hbWUgPSB0aGlzLnRzUGFyc2VFbnRpdHlOYW1lKHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVRdWVyeVwiKTtcbiAgfVxuXG4gIHRzUGFyc2VUeXBlUGFyYW1ldGVyKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubmFtZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZShub2RlLnN0YXJ0KTtcbiAgICBub2RlLmNvbnN0cmFpbnQgPSB0aGlzLnRzRWF0VGhlblBhcnNlVHlwZSh0eXBlcy5fZXh0ZW5kcyk7XG4gICAgbm9kZS5kZWZhdWx0ID0gdGhpcy50c0VhdFRoZW5QYXJzZVR5cGUodHlwZXMuZXEpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVQYXJhbWV0ZXJcIik7XG4gIH1cblxuICB0c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnMoKSB7XG4gICAgaWYgKHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVQYXJhbWV0ZXJzKCk7XG4gICAgfVxuICB9XG5cbiAgdHNQYXJzZVR5cGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgaWYgKHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSB8fCB0aGlzLm1hdGNoKHR5cGVzLmpzeFRhZ1N0YXJ0KSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cblxuICAgIG5vZGUucGFyYW1zID0gdGhpcy50c1BhcnNlQnJhY2tldGVkTGlzdChcIlR5cGVQYXJhbWV0ZXJzT3JBcmd1bWVudHNcIiwgdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlci5iaW5kKHRoaXMpLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpO1xuICB9XG5cbiAgdHNUcnlOZXh0UGFyc2VDb25zdGFudENvbnRleHQoKSB7XG4gICAgaWYgKHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gdHlwZXMuX2NvbnN0KSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlUmVmZXJlbmNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0c0ZpbGxTaWduYXR1cmUocmV0dXJuVG9rZW4sIHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHJldHVyblRva2VuUmVxdWlyZWQgPSByZXR1cm5Ub2tlbiA9PT0gdHlwZXMuYXJyb3c7XG4gICAgc2lnbmF0dXJlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnMoKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICAgIHNpZ25hdHVyZS5wYXJhbWV0ZXJzID0gdGhpcy50c1BhcnNlQmluZGluZ0xpc3RGb3JTaWduYXR1cmUoKTtcblxuICAgIGlmIChyZXR1cm5Ub2tlblJlcXVpcmVkKSB7XG4gICAgICBzaWduYXR1cmUudHlwZUFubm90YXRpb24gPSB0aGlzLnRzUGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbihyZXR1cm5Ub2tlbik7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHJldHVyblRva2VuKSkge1xuICAgICAgc2lnbmF0dXJlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c1BhcnNlVHlwZU9yVHlwZVByZWRpY2F0ZUFubm90YXRpb24ocmV0dXJuVG9rZW4pO1xuICAgIH1cbiAgfVxuXG4gIHRzUGFyc2VCaW5kaW5nTGlzdEZvclNpZ25hdHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzLnBhcmVuUiwgNDEpLm1hcChwYXR0ZXJuID0+IHtcbiAgICAgIGlmIChwYXR0ZXJuLnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmIHBhdHRlcm4udHlwZSAhPT0gXCJSZXN0RWxlbWVudFwiICYmIHBhdHRlcm4udHlwZSAhPT0gXCJPYmplY3RQYXR0ZXJuXCIgJiYgcGF0dGVybi50eXBlICE9PSBcIkFycmF5UGF0dGVyblwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UocGF0dGVybi5zdGFydCwgVFNFcnJvcnMuVW5zdXBwb3J0ZWRTaWduYXR1cmVQYXJhbWV0ZXJLaW5kLCBwYXR0ZXJuLnR5cGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0dGVybjtcbiAgICB9KTtcbiAgfVxuXG4gIHRzUGFyc2VUeXBlTWVtYmVyU2VtaWNvbG9uKCkge1xuICAgIGlmICghdGhpcy5lYXQodHlwZXMuY29tbWEpKSB7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIH1cbiAgfVxuXG4gIHRzUGFyc2VTaWduYXR1cmVNZW1iZXIoa2luZCwgbm9kZSkge1xuICAgIHRoaXMudHNGaWxsU2lnbmF0dXJlKHR5cGVzLmNvbG9uLCBub2RlKTtcbiAgICB0aGlzLnRzUGFyc2VUeXBlTWVtYmVyU2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBraW5kKTtcbiAgfVxuXG4gIHRzSXNVbmFtYmlndW91c2x5SW5kZXhTaWduYXR1cmUoKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZWF0KHR5cGVzLm5hbWUpICYmIHRoaXMubWF0Y2godHlwZXMuY29sb24pO1xuICB9XG5cbiAgdHNUcnlQYXJzZUluZGV4U2lnbmF0dXJlKG5vZGUpIHtcbiAgICBpZiAoISh0aGlzLm1hdGNoKHR5cGVzLmJyYWNrZXRMKSAmJiB0aGlzLnRzTG9va0FoZWFkKHRoaXMudHNJc1VuYW1iaWd1b3VzbHlJbmRleFNpZ25hdHVyZS5iaW5kKHRoaXMpKSkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2tldEwpO1xuICAgIGNvbnN0IGlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICBpZC50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKGlkKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFja2V0Uik7XG4gICAgbm9kZS5wYXJhbWV0ZXJzID0gW2lkXTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICBpZiAodHlwZSkgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gICAgdGhpcy50c1BhcnNlVHlwZU1lbWJlclNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0luZGV4U2lnbmF0dXJlXCIpO1xuICB9XG5cbiAgdHNQYXJzZVByb3BlcnR5T3JNZXRob2RTaWduYXR1cmUobm9kZSwgcmVhZG9ubHkpIHtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMucXVlc3Rpb24pKSBub2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICBjb25zdCBub2RlQW55ID0gbm9kZTtcblxuICAgIGlmICghcmVhZG9ubHkgJiYgKHRoaXMubWF0Y2godHlwZXMucGFyZW5MKSB8fCB0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpKSB7XG4gICAgICBjb25zdCBtZXRob2QgPSBub2RlQW55O1xuICAgICAgdGhpcy50c0ZpbGxTaWduYXR1cmUodHlwZXMuY29sb24sIG1ldGhvZCk7XG4gICAgICB0aGlzLnRzUGFyc2VUeXBlTWVtYmVyU2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG1ldGhvZCwgXCJUU01ldGhvZFNpZ25hdHVyZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSBub2RlQW55O1xuICAgICAgaWYgKHJlYWRvbmx5KSBwcm9wZXJ0eS5yZWFkb25seSA9IHRydWU7XG4gICAgICBjb25zdCB0eXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgIGlmICh0eXBlKSBwcm9wZXJ0eS50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gICAgICB0aGlzLnRzUGFyc2VUeXBlTWVtYmVyU2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3BlcnR5LCBcIlRTUHJvcGVydHlTaWduYXR1cmVcIik7XG4gICAgfVxuICB9XG5cbiAgdHNQYXJzZVR5cGVNZW1iZXIoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5wYXJlbkwpIHx8IHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVNpZ25hdHVyZU1lbWJlcihcIlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uXCIsIG5vZGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLl9uZXcpKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMucGFyZW5MKSB8fCB0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVNpZ25hdHVyZU1lbWJlcihcIlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb25cIiwgbm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmtleSA9IHRoaXMuY3JlYXRlSWRlbnRpZmllcihpZCwgXCJuZXdcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VQcm9wZXJ0eU9yTWV0aG9kU2lnbmF0dXJlKG5vZGUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZWFkb25seSA9ICEhdGhpcy50c1BhcnNlTW9kaWZpZXIoW1wicmVhZG9ubHlcIl0pO1xuICAgIGNvbnN0IGlkeCA9IHRoaXMudHNUcnlQYXJzZUluZGV4U2lnbmF0dXJlKG5vZGUpO1xuXG4gICAgaWYgKGlkeCkge1xuICAgICAgaWYgKHJlYWRvbmx5KSBub2RlLnJlYWRvbmx5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuXG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShub2RlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMudHNQYXJzZVByb3BlcnR5T3JNZXRob2RTaWduYXR1cmUobm9kZSwgcmVhZG9ubHkpO1xuICB9XG5cbiAgdHNQYXJzZVR5cGVMaXRlcmFsKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubWVtYmVycyA9IHRoaXMudHNQYXJzZU9iamVjdFR5cGVNZW1iZXJzKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZUxpdGVyYWxcIik7XG4gIH1cblxuICB0c1BhcnNlT2JqZWN0VHlwZU1lbWJlcnMoKSB7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgICBjb25zdCBtZW1iZXJzID0gdGhpcy50c1BhcnNlTGlzdChcIlR5cGVNZW1iZXJzXCIsIHRoaXMudHNQYXJzZVR5cGVNZW1iZXIuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VSKTtcbiAgICByZXR1cm4gbWVtYmVycztcbiAgfVxuXG4gIHRzSXNTdGFydE9mTWFwcGVkVHlwZSgpIHtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5wbHVzTWluKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNDb250ZXh0dWFsKFwicmVhZG9ubHlcIik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwicmVhZG9ubHlcIikpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5tYXRjaCh0eXBlcy5icmFja2V0TCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLm5leHQoKTtcblxuICAgIGlmICghdGhpcy50c0lzSWRlbnRpZmllcigpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2godHlwZXMuX2luKTtcbiAgfVxuXG4gIHRzUGFyc2VNYXBwZWRUeXBlUGFyYW1ldGVyKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubmFtZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZShub2RlLnN0YXJ0KTtcbiAgICBub2RlLmNvbnN0cmFpbnQgPSB0aGlzLnRzRXhwZWN0VGhlblBhcnNlVHlwZSh0eXBlcy5faW4pO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVQYXJhbWV0ZXJcIik7XG4gIH1cblxuICB0c1BhcnNlTWFwcGVkVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMucGx1c01pbikpIHtcbiAgICAgIG5vZGUucmVhZG9ubHkgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJyZWFkb25seVwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcInJlYWRvbmx5XCIpKSB7XG4gICAgICBub2RlLnJlYWRvbmx5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFja2V0TCk7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVyID0gdGhpcy50c1BhcnNlTWFwcGVkVHlwZVBhcmFtZXRlcigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRSKTtcblxuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLnBsdXNNaW4pKSB7XG4gICAgICBub2RlLm9wdGlvbmFsID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMucXVlc3Rpb24pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lYXQodHlwZXMucXVlc3Rpb24pKSB7XG4gICAgICBub2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c1RyeVBhcnNlVHlwZSgpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VSKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNNYXBwZWRUeXBlXCIpO1xuICB9XG5cbiAgdHNQYXJzZVR1cGxlVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLmVsZW1lbnRUeXBlcyA9IHRoaXMudHNQYXJzZUJyYWNrZXRlZExpc3QoXCJUdXBsZUVsZW1lbnRUeXBlc1wiLCB0aGlzLnRzUGFyc2VUdXBsZUVsZW1lbnRUeXBlLmJpbmQodGhpcyksIHRydWUsIGZhbHNlKTtcbiAgICBsZXQgc2Vlbk9wdGlvbmFsRWxlbWVudCA9IGZhbHNlO1xuICAgIG5vZGUuZWxlbWVudFR5cGVzLmZvckVhY2goZWxlbWVudE5vZGUgPT4ge1xuICAgICAgaWYgKGVsZW1lbnROb2RlLnR5cGUgPT09IFwiVFNPcHRpb25hbFR5cGVcIikge1xuICAgICAgICBzZWVuT3B0aW9uYWxFbGVtZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2Vlbk9wdGlvbmFsRWxlbWVudCAmJiBlbGVtZW50Tm9kZS50eXBlICE9PSBcIlRTUmVzdFR5cGVcIikge1xuICAgICAgICB0aGlzLnJhaXNlKGVsZW1lbnROb2RlLnN0YXJ0LCBUU0Vycm9ycy5PcHRpb25hbFR5cGVCZWZvcmVSZXF1aXJlZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHVwbGVUeXBlXCIpO1xuICB9XG5cbiAgdHNQYXJzZVR1cGxlRWxlbWVudFR5cGUoKSB7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuZWxsaXBzaXMpKSB7XG4gICAgICBjb25zdCByZXN0Tm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJlc3ROb2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c1BhcnNlVHlwZSgpO1xuXG4gICAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5jb21tYSkgJiYgdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpICE9PSA5Mykge1xuICAgICAgICB0aGlzLnJhaXNlUmVzdE5vdExhc3QodGhpcy5zdGF0ZS5zdGFydCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocmVzdE5vZGUsIFwiVFNSZXN0VHlwZVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gdGhpcy50c1BhcnNlVHlwZSgpO1xuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnF1ZXN0aW9uKSkge1xuICAgICAgY29uc3Qgb3B0aW9uYWxUeXBlTm9kZSA9IHRoaXMuc3RhcnROb2RlQXROb2RlKHR5cGUpO1xuICAgICAgb3B0aW9uYWxUeXBlTm9kZS50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG9wdGlvbmFsVHlwZU5vZGUsIFwiVFNPcHRpb25hbFR5cGVcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICB0c1BhcnNlUGFyZW50aGVzaXplZFR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTUGFyZW50aGVzaXplZFR5cGVcIik7XG4gIH1cblxuICB0c1BhcnNlRnVuY3Rpb25PckNvbnN0cnVjdG9yVHlwZSh0eXBlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgICBpZiAodHlwZSA9PT0gXCJUU0NvbnN0cnVjdG9yVHlwZVwiKSB7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5fbmV3KTtcbiAgICB9XG5cbiAgICB0aGlzLnRzRmlsbFNpZ25hdHVyZSh0eXBlcy5hcnJvdywgbm9kZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbiAgfVxuXG4gIHRzUGFyc2VMaXRlcmFsVHlwZU5vZGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgICBub2RlLmxpdGVyYWwgPSAoKCkgPT4ge1xuICAgICAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICAgICAgY2FzZSB0eXBlcy5udW06XG4gICAgICAgIGNhc2UgdHlwZXMuYmlnaW50OlxuICAgICAgICBjYXNlIHR5cGVzLnN0cmluZzpcbiAgICAgICAgY2FzZSB0eXBlcy5fdHJ1ZTpcbiAgICAgICAgY2FzZSB0eXBlcy5fZmFsc2U6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByQXRvbSgpO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICB9XG4gICAgfSkoKTtcblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0xpdGVyYWxUeXBlXCIpO1xuICB9XG5cbiAgdHNQYXJzZVRlbXBsYXRlTGl0ZXJhbFR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgdGVtcGxhdGVOb2RlID0gdGhpcy5wYXJzZVRlbXBsYXRlKGZhbHNlKTtcblxuICAgIGlmICh0ZW1wbGF0ZU5vZGUuZXhwcmVzc2lvbnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5yYWlzZSh0ZW1wbGF0ZU5vZGUuZXhwcmVzc2lvbnNbMF0uc3RhcnQsIFRTRXJyb3JzLlRlbXBsYXRlVHlwZUhhc1N1YnN0aXR1dGlvbik7XG4gICAgfVxuXG4gICAgbm9kZS5saXRlcmFsID0gdGVtcGxhdGVOb2RlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0xpdGVyYWxUeXBlXCIpO1xuICB9XG5cbiAgdHNQYXJzZVRoaXNUeXBlT3JUaGlzVHlwZVByZWRpY2F0ZSgpIHtcbiAgICBjb25zdCB0aGlzS2V5d29yZCA9IHRoaXMudHNQYXJzZVRoaXNUeXBlTm9kZSgpO1xuXG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwiaXNcIikgJiYgIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUaGlzVHlwZVByZWRpY2F0ZSh0aGlzS2V5d29yZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzS2V5d29yZDtcbiAgICB9XG4gIH1cblxuICB0c1BhcnNlTm9uQXJyYXlUeXBlKCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIHR5cGVzLm5hbWU6XG4gICAgICBjYXNlIHR5cGVzLl92b2lkOlxuICAgICAgY2FzZSB0eXBlcy5fbnVsbDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLm1hdGNoKHR5cGVzLl92b2lkKSA/IFwiVFNWb2lkS2V5d29yZFwiIDogdGhpcy5tYXRjaCh0eXBlcy5fbnVsbCkgPyBcIlRTTnVsbEtleXdvcmRcIiA6IGtleXdvcmRUeXBlRnJvbU5hbWUodGhpcy5zdGF0ZS52YWx1ZSk7XG5cbiAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSAhPT0gNDYpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHR5cGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlUmVmZXJlbmNlKCk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSB0eXBlcy5zdHJpbmc6XG4gICAgICBjYXNlIHR5cGVzLm51bTpcbiAgICAgIGNhc2UgdHlwZXMuYmlnaW50OlxuICAgICAgY2FzZSB0eXBlcy5fdHJ1ZTpcbiAgICAgIGNhc2UgdHlwZXMuX2ZhbHNlOlxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlTGl0ZXJhbFR5cGVOb2RlKCk7XG5cbiAgICAgIGNhc2UgdHlwZXMucGx1c01pbjpcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUudmFsdWUgPT09IFwiLVwiKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgICAgY29uc3QgbmV4dFRva2VuID0gdGhpcy5sb29rYWhlYWQoKTtcblxuICAgICAgICAgIGlmIChuZXh0VG9rZW4udHlwZSAhPT0gdHlwZXMubnVtICYmIG5leHRUb2tlbi50eXBlICE9PSB0eXBlcy5iaWdpbnQpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vZGUubGl0ZXJhbCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTTGl0ZXJhbFR5cGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSB0eXBlcy5fdGhpczpcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVRoaXNUeXBlT3JUaGlzVHlwZVByZWRpY2F0ZSgpO1xuXG4gICAgICBjYXNlIHR5cGVzLl90eXBlb2Y6XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlUXVlcnkoKTtcblxuICAgICAgY2FzZSB0eXBlcy5faW1wb3J0OlxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlSW1wb3J0VHlwZSgpO1xuXG4gICAgICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICAgICAgcmV0dXJuIHRoaXMudHNMb29rQWhlYWQodGhpcy50c0lzU3RhcnRPZk1hcHBlZFR5cGUuYmluZCh0aGlzKSkgPyB0aGlzLnRzUGFyc2VNYXBwZWRUeXBlKCkgOiB0aGlzLnRzUGFyc2VUeXBlTGl0ZXJhbCgpO1xuXG4gICAgICBjYXNlIHR5cGVzLmJyYWNrZXRMOlxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHVwbGVUeXBlKCk7XG5cbiAgICAgIGNhc2UgdHlwZXMucGFyZW5MOlxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlUGFyZW50aGVzaXplZFR5cGUoKTtcblxuICAgICAgY2FzZSB0eXBlcy5iYWNrUXVvdGU6XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUZW1wbGF0ZUxpdGVyYWxUeXBlKCk7XG4gICAgfVxuXG4gICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cblxuICB0c1BhcnNlQXJyYXlUeXBlT3JIaWdoZXIoKSB7XG4gICAgbGV0IHR5cGUgPSB0aGlzLnRzUGFyc2VOb25BcnJheVR5cGUoKTtcblxuICAgIHdoaWxlICghdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSAmJiB0aGlzLmVhdCh0eXBlcy5icmFja2V0TCkpIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmJyYWNrZXRSKSkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdE5vZGUodHlwZSk7XG4gICAgICAgIG5vZGUuZWxlbWVudFR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFja2V0Uik7XG4gICAgICAgIHR5cGUgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0FycmF5VHlwZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0Tm9kZSh0eXBlKTtcbiAgICAgICAgbm9kZS5vYmplY3RUeXBlID0gdHlwZTtcbiAgICAgICAgbm9kZS5pbmRleFR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRSKTtcbiAgICAgICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW5kZXhlZEFjY2Vzc1R5cGVcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICB0c1BhcnNlVHlwZU9wZXJhdG9yKG9wZXJhdG9yKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKG9wZXJhdG9yKTtcbiAgICBub2RlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNQYXJzZVR5cGVPcGVyYXRvck9ySGlnaGVyKCk7XG5cbiAgICBpZiAob3BlcmF0b3IgPT09IFwicmVhZG9ubHlcIikge1xuICAgICAgdGhpcy50c0NoZWNrVHlwZUFubm90YXRpb25Gb3JSZWFkT25seShub2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlT3BlcmF0b3JcIik7XG4gIH1cblxuICB0c0NoZWNrVHlwZUFubm90YXRpb25Gb3JSZWFkT25seShub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGVBbm5vdGF0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJUU1R1cGxlVHlwZVwiOlxuICAgICAgY2FzZSBcIlRTQXJyYXlUeXBlXCI6XG4gICAgICAgIHJldHVybjtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBUU0Vycm9ycy5VbmV4cGVjdGVkUmVhZG9ubHkpO1xuICAgIH1cbiAgfVxuXG4gIHRzUGFyc2VJbmZlclR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiaW5mZXJcIik7XG4gICAgY29uc3QgdHlwZVBhcmFtZXRlciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdHlwZVBhcmFtZXRlci5uYW1lID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKHR5cGVQYXJhbWV0ZXIuc3RhcnQpO1xuICAgIG5vZGUudHlwZVBhcmFtZXRlciA9IHRoaXMuZmluaXNoTm9kZSh0eXBlUGFyYW1ldGVyLCBcIlRTVHlwZVBhcmFtZXRlclwiKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNJbmZlclR5cGVcIik7XG4gIH1cblxuICB0c1BhcnNlVHlwZU9wZXJhdG9yT3JIaWdoZXIoKSB7XG4gICAgY29uc3Qgb3BlcmF0b3IgPSBbXCJrZXlvZlwiLCBcInVuaXF1ZVwiLCBcInJlYWRvbmx5XCJdLmZpbmQoa3cgPT4gdGhpcy5pc0NvbnRleHR1YWwoa3cpKTtcbiAgICByZXR1cm4gb3BlcmF0b3IgPyB0aGlzLnRzUGFyc2VUeXBlT3BlcmF0b3Iob3BlcmF0b3IpIDogdGhpcy5pc0NvbnRleHR1YWwoXCJpbmZlclwiKSA/IHRoaXMudHNQYXJzZUluZmVyVHlwZSgpIDogdGhpcy50c1BhcnNlQXJyYXlUeXBlT3JIaWdoZXIoKTtcbiAgfVxuXG4gIHRzUGFyc2VVbmlvbk9ySW50ZXJzZWN0aW9uVHlwZShraW5kLCBwYXJzZUNvbnN0aXR1ZW50VHlwZSwgb3BlcmF0b3IpIHtcbiAgICB0aGlzLmVhdChvcGVyYXRvcik7XG4gICAgbGV0IHR5cGUgPSBwYXJzZUNvbnN0aXR1ZW50VHlwZSgpO1xuXG4gICAgaWYgKHRoaXMubWF0Y2gob3BlcmF0b3IpKSB7XG4gICAgICBjb25zdCB0eXBlcyA9IFt0eXBlXTtcblxuICAgICAgd2hpbGUgKHRoaXMuZWF0KG9wZXJhdG9yKSkge1xuICAgICAgICB0eXBlcy5wdXNoKHBhcnNlQ29uc3RpdHVlbnRUeXBlKCkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdE5vZGUodHlwZSk7XG4gICAgICBub2RlLnR5cGVzID0gdHlwZXM7XG4gICAgICB0eXBlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGtpbmQpO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgdHNQYXJzZUludGVyc2VjdGlvblR5cGVPckhpZ2hlcigpIHtcbiAgICByZXR1cm4gdGhpcy50c1BhcnNlVW5pb25PckludGVyc2VjdGlvblR5cGUoXCJUU0ludGVyc2VjdGlvblR5cGVcIiwgdGhpcy50c1BhcnNlVHlwZU9wZXJhdG9yT3JIaWdoZXIuYmluZCh0aGlzKSwgdHlwZXMuYml0d2lzZUFORCk7XG4gIH1cblxuICB0c1BhcnNlVW5pb25UeXBlT3JIaWdoZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHNQYXJzZVVuaW9uT3JJbnRlcnNlY3Rpb25UeXBlKFwiVFNVbmlvblR5cGVcIiwgdGhpcy50c1BhcnNlSW50ZXJzZWN0aW9uVHlwZU9ySGlnaGVyLmJpbmQodGhpcyksIHR5cGVzLmJpdHdpc2VPUik7XG4gIH1cblxuICB0c0lzU3RhcnRPZkZ1bmN0aW9uVHlwZSgpIHtcbiAgICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tYXRjaCh0eXBlcy5wYXJlbkwpICYmIHRoaXMudHNMb29rQWhlYWQodGhpcy50c0lzVW5hbWJpZ3VvdXNseVN0YXJ0T2ZGdW5jdGlvblR5cGUuYmluZCh0aGlzKSk7XG4gIH1cblxuICB0c1NraXBQYXJhbWV0ZXJTdGFydCgpIHtcbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5uYW1lKSB8fCB0aGlzLm1hdGNoKHR5cGVzLl90aGlzKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5icmFjZUwpKSB7XG4gICAgICBsZXQgYnJhY2VTdGFja0NvdW50ZXIgPSAxO1xuICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgIHdoaWxlIChicmFjZVN0YWNrQ291bnRlciA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuYnJhY2VMKSkge1xuICAgICAgICAgICsrYnJhY2VTdGFja0NvdW50ZXI7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCh0eXBlcy5icmFjZVIpKSB7XG4gICAgICAgICAgLS1icmFjZVN0YWNrQ291bnRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5icmFja2V0TCkpIHtcbiAgICAgIGxldCBicmFjZVN0YWNrQ291bnRlciA9IDE7XG4gICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgd2hpbGUgKGJyYWNlU3RhY2tDb3VudGVyID4gMCkge1xuICAgICAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5icmFja2V0TCkpIHtcbiAgICAgICAgICArK2JyYWNlU3RhY2tDb3VudGVyO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2godHlwZXMuYnJhY2tldFIpKSB7XG4gICAgICAgICAgLS1icmFjZVN0YWNrQ291bnRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0c0lzVW5hbWJpZ3VvdXNseVN0YXJ0T2ZGdW5jdGlvblR5cGUoKSB7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5wYXJlblIpIHx8IHRoaXMubWF0Y2godHlwZXMuZWxsaXBzaXMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50c1NraXBQYXJhbWV0ZXJTdGFydCgpKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5jb2xvbikgfHwgdGhpcy5tYXRjaCh0eXBlcy5jb21tYSkgfHwgdGhpcy5tYXRjaCh0eXBlcy5xdWVzdGlvbikgfHwgdGhpcy5tYXRjaCh0eXBlcy5lcSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLnBhcmVuUikpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuYXJyb3cpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0c1BhcnNlVHlwZU9yVHlwZVByZWRpY2F0ZUFubm90YXRpb24ocmV0dXJuVG9rZW4pIHtcbiAgICByZXR1cm4gdGhpcy50c0luVHlwZSgoKSA9PiB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMuZXhwZWN0KHJldHVyblRva2VuKTtcbiAgICAgIGNvbnN0IGFzc2VydHMgPSB0aGlzLnRzVHJ5UGFyc2UodGhpcy50c1BhcnNlVHlwZVByZWRpY2F0ZUFzc2VydHMuYmluZCh0aGlzKSk7XG5cbiAgICAgIGlmIChhc3NlcnRzICYmIHRoaXMubWF0Y2godHlwZXMuX3RoaXMpKSB7XG4gICAgICAgIGxldCB0aGlzVHlwZVByZWRpY2F0ZSA9IHRoaXMudHNQYXJzZVRoaXNUeXBlT3JUaGlzVHlwZVByZWRpY2F0ZSgpO1xuXG4gICAgICAgIGlmICh0aGlzVHlwZVByZWRpY2F0ZS50eXBlID09PSBcIlRTVGhpc1R5cGVcIikge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0Tm9kZSh0KTtcbiAgICAgICAgICBub2RlLnBhcmFtZXRlck5hbWUgPSB0aGlzVHlwZVByZWRpY2F0ZTtcbiAgICAgICAgICBub2RlLmFzc2VydHMgPSB0cnVlO1xuICAgICAgICAgIHRoaXNUeXBlUHJlZGljYXRlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUHJlZGljYXRlXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNUeXBlUHJlZGljYXRlLmFzc2VydHMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdC50eXBlQW5ub3RhdGlvbiA9IHRoaXNUeXBlUHJlZGljYXRlO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHQsIFwiVFNUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHlwZVByZWRpY2F0ZVZhcmlhYmxlID0gdGhpcy50c0lzSWRlbnRpZmllcigpICYmIHRoaXMudHNUcnlQYXJzZSh0aGlzLnRzUGFyc2VUeXBlUHJlZGljYXRlUHJlZml4LmJpbmQodGhpcykpO1xuXG4gICAgICBpZiAoIXR5cGVQcmVkaWNhdGVWYXJpYWJsZSkge1xuICAgICAgICBpZiAoIWFzc2VydHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZUFubm90YXRpb24oZmFsc2UsIHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXROb2RlKHQpO1xuICAgICAgICBub2RlLnBhcmFtZXRlck5hbWUgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICBub2RlLmFzc2VydHMgPSBhc3NlcnRzO1xuICAgICAgICB0LnR5cGVBbm5vdGF0aW9uID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUHJlZGljYXRlXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHQsIFwiVFNUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHlwZSA9IHRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKGZhbHNlKTtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0Tm9kZSh0KTtcbiAgICAgIG5vZGUucGFyYW1ldGVyTmFtZSA9IHR5cGVQcmVkaWNhdGVWYXJpYWJsZTtcbiAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgICAgbm9kZS5hc3NlcnRzID0gYXNzZXJ0cztcbiAgICAgIHQudHlwZUFubm90YXRpb24gPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVQcmVkaWNhdGVcIik7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHQsIFwiVFNUeXBlQW5ub3RhdGlvblwiKTtcbiAgICB9KTtcbiAgfVxuXG4gIHRzVHJ5UGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCh0eXBlcy5jb2xvbikgPyB0aGlzLnRzUGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbih0eXBlcy5jb2xvbikgOiB1bmRlZmluZWQ7XG4gIH1cblxuICB0c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2godHlwZXMuY29sb24pID8gdGhpcy50c1BhcnNlVHlwZUFubm90YXRpb24oKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRzVHJ5UGFyc2VUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnRzRWF0VGhlblBhcnNlVHlwZSh0eXBlcy5jb2xvbik7XG4gIH1cblxuICB0c1BhcnNlVHlwZVByZWRpY2F0ZVByZWZpeCgpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG5cbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJpc1wiKSAmJiAhdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICB9XG5cbiAgdHNQYXJzZVR5cGVQcmVkaWNhdGVBc3NlcnRzKCkge1xuICAgIGlmICghdGhpcy5tYXRjaCh0eXBlcy5uYW1lKSB8fCB0aGlzLnN0YXRlLnZhbHVlICE9PSBcImFzc2VydHNcIiB8fCB0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgY29udGFpbnNFc2MgPSB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjO1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgaWYgKCF0aGlzLm1hdGNoKHR5cGVzLm5hbWUpICYmICF0aGlzLm1hdGNoKHR5cGVzLl90aGlzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChjb250YWluc0VzYykge1xuICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLmxhc3RUb2tTdGFydCwgRXJyb3JNZXNzYWdlcy5JbnZhbGlkRXNjYXBlZFJlc2VydmVkV29yZCwgXCJhc3NlcnRzXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdHNQYXJzZVR5cGVBbm5vdGF0aW9uKGVhdENvbG9uID0gdHJ1ZSwgdCA9IHRoaXMuc3RhcnROb2RlKCkpIHtcbiAgICB0aGlzLnRzSW5UeXBlKCgpID0+IHtcbiAgICAgIGlmIChlYXRDb2xvbikgdGhpcy5leHBlY3QodHlwZXMuY29sb24pO1xuICAgICAgdC50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNQYXJzZVR5cGUoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHQsIFwiVFNUeXBlQW5ub3RhdGlvblwiKTtcbiAgfVxuXG4gIHRzUGFyc2VUeXBlKCkge1xuICAgIGFzc2VydCh0aGlzLnN0YXRlLmluVHlwZSk7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHNQYXJzZU5vbkNvbmRpdGlvbmFsVHlwZSgpO1xuXG4gICAgaWYgKHRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkgfHwgIXRoaXMuZWF0KHR5cGVzLl9leHRlbmRzKSkge1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXROb2RlKHR5cGUpO1xuICAgIG5vZGUuY2hlY2tUeXBlID0gdHlwZTtcbiAgICBub2RlLmV4dGVuZHNUeXBlID0gdGhpcy50c1BhcnNlTm9uQ29uZGl0aW9uYWxUeXBlKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucXVlc3Rpb24pO1xuICAgIG5vZGUudHJ1ZVR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuY29sb24pO1xuICAgIG5vZGUuZmFsc2VUeXBlID0gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0NvbmRpdGlvbmFsVHlwZVwiKTtcbiAgfVxuXG4gIHRzUGFyc2VOb25Db25kaXRpb25hbFR5cGUoKSB7XG4gICAgaWYgKHRoaXMudHNJc1N0YXJ0T2ZGdW5jdGlvblR5cGUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUZ1bmN0aW9uT3JDb25zdHJ1Y3RvclR5cGUoXCJUU0Z1bmN0aW9uVHlwZVwiKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5fbmV3KSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUZ1bmN0aW9uT3JDb25zdHJ1Y3RvclR5cGUoXCJUU0NvbnN0cnVjdG9yVHlwZVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50c1BhcnNlVW5pb25UeXBlT3JIaWdoZXIoKTtcbiAgfVxuXG4gIHRzUGFyc2VUeXBlQXNzZXJ0aW9uKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgY29uc3QgX2NvbnN0ID0gdGhpcy50c1RyeU5leHRQYXJzZUNvbnN0YW50Q29udGV4dCgpO1xuXG4gICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IF9jb25zdCB8fCB0aGlzLnRzTmV4dFRoZW5QYXJzZVR5cGUoKTtcbiAgICB0aGlzLmV4cGVjdFJlbGF0aW9uYWwoXCI+XCIpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZUFzc2VydGlvblwiKTtcbiAgfVxuXG4gIHRzUGFyc2VIZXJpdGFnZUNsYXVzZShkZXNjcmlwdG9yKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxTdGFydCA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3QgZGVsaW1pdGVkTGlzdCA9IHRoaXMudHNQYXJzZURlbGltaXRlZExpc3QoXCJIZXJpdGFnZUNsYXVzZUVsZW1lbnRcIiwgdGhpcy50c1BhcnNlRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzLmJpbmQodGhpcykpO1xuXG4gICAgaWYgKCFkZWxpbWl0ZWRMaXN0Lmxlbmd0aCkge1xuICAgICAgdGhpcy5yYWlzZShvcmlnaW5hbFN0YXJ0LCBUU0Vycm9ycy5FbXB0eUhlcml0YWdlQ2xhdXNlVHlwZSwgZGVzY3JpcHRvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbGltaXRlZExpc3Q7XG4gIH1cblxuICB0c1BhcnNlRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMudHNQYXJzZUVudGl0eU5hbWUoZmFsc2UpO1xuXG4gICAgaWYgKHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMudHNQYXJzZVR5cGVBcmd1bWVudHMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHNcIik7XG4gIH1cblxuICB0c1BhcnNlSW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSkge1xuICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsIEJJTkRfVFNfSU5URVJGQUNFLCB1bmRlZmluZWQsIFwidHlwZXNjcmlwdCBpbnRlcmZhY2UgZGVjbGFyYXRpb25cIik7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMudHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKCk7XG5cbiAgICBpZiAodGhpcy5lYXQodHlwZXMuX2V4dGVuZHMpKSB7XG4gICAgICBub2RlLmV4dGVuZHMgPSB0aGlzLnRzUGFyc2VIZXJpdGFnZUNsYXVzZShcImV4dGVuZHNcIik7XG4gICAgfVxuXG4gICAgY29uc3QgYm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgYm9keS5ib2R5ID0gdGhpcy50c0luVHlwZSh0aGlzLnRzUGFyc2VPYmplY3RUeXBlTWVtYmVycy5iaW5kKHRoaXMpKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLmZpbmlzaE5vZGUoYm9keSwgXCJUU0ludGVyZmFjZUJvZHlcIik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIik7XG4gIH1cblxuICB0c1BhcnNlVHlwZUFsaWFzRGVjbGFyYXRpb24obm9kZSkge1xuICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsIEJJTkRfVFNfVFlQRSwgdW5kZWZpbmVkLCBcInR5cGVzY3JpcHQgdHlwZSBhbGlhc1wiKTtcbiAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnMoKTtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c0V4cGVjdFRoZW5QYXJzZVR5cGUodHlwZXMuZXEpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIik7XG4gIH1cblxuICB0c0luTm9Db250ZXh0KGNiKSB7XG4gICAgY29uc3Qgb2xkQ29udGV4dCA9IHRoaXMuc3RhdGUuY29udGV4dDtcbiAgICB0aGlzLnN0YXRlLmNvbnRleHQgPSBbb2xkQ29udGV4dFswXV07XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUuY29udGV4dCA9IG9sZENvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgdHNJblR5cGUoY2IpIHtcbiAgICBjb25zdCBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IHRydWU7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICAgIH1cbiAgfVxuXG4gIHRzRWF0VGhlblBhcnNlVHlwZSh0b2tlbikge1xuICAgIHJldHVybiAhdGhpcy5tYXRjaCh0b2tlbikgPyB1bmRlZmluZWQgOiB0aGlzLnRzTmV4dFRoZW5QYXJzZVR5cGUoKTtcbiAgfVxuXG4gIHRzRXhwZWN0VGhlblBhcnNlVHlwZSh0b2tlbikge1xuICAgIHJldHVybiB0aGlzLnRzRG9UaGVuUGFyc2VUeXBlKCgpID0+IHRoaXMuZXhwZWN0KHRva2VuKSk7XG4gIH1cblxuICB0c05leHRUaGVuUGFyc2VUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnRzRG9UaGVuUGFyc2VUeXBlKCgpID0+IHRoaXMubmV4dCgpKTtcbiAgfVxuXG4gIHRzRG9UaGVuUGFyc2VUeXBlKGNiKSB7XG4gICAgcmV0dXJuIHRoaXMudHNJblR5cGUoKCkgPT4ge1xuICAgICAgY2IoKTtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgfSk7XG4gIH1cblxuICB0c1BhcnNlRW51bU1lbWJlcigpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLmlkID0gdGhpcy5tYXRjaCh0eXBlcy5zdHJpbmcpID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5lcSkpIHtcbiAgICAgIG5vZGUuaW5pdGlhbGl6ZXIgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNFbnVtTWVtYmVyXCIpO1xuICB9XG5cbiAgdHNQYXJzZUVudW1EZWNsYXJhdGlvbihub2RlLCBpc0NvbnN0KSB7XG4gICAgaWYgKGlzQ29uc3QpIG5vZGUuY29uc3QgPSB0cnVlO1xuICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsIGlzQ29uc3QgPyBCSU5EX1RTX0NPTlNUX0VOVU0gOiBCSU5EX1RTX0VOVU0sIHVuZGVmaW5lZCwgXCJ0eXBlc2NyaXB0IGVudW0gZGVjbGFyYXRpb25cIik7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgICBub2RlLm1lbWJlcnMgPSB0aGlzLnRzUGFyc2VEZWxpbWl0ZWRMaXN0KFwiRW51bU1lbWJlcnNcIiwgdGhpcy50c1BhcnNlRW51bU1lbWJlci5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZVIpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0VudW1EZWNsYXJhdGlvblwiKTtcbiAgfVxuXG4gIHRzUGFyc2VNb2R1bGVCbG9jaygpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLnNjb3BlLmVudGVyKFNDT1BFX09USEVSKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICAgIHRoaXMucGFyc2VCbG9ja09yTW9kdWxlQmxvY2tCb2R5KG5vZGUuYm9keSA9IFtdLCB1bmRlZmluZWQsIHRydWUsIHR5cGVzLmJyYWNlUik7XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTTW9kdWxlQmxvY2tcIik7XG4gIH1cblxuICB0c1BhcnNlTW9kdWxlT3JOYW1lc3BhY2VEZWNsYXJhdGlvbihub2RlLCBuZXN0ZWQgPSBmYWxzZSkge1xuICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuXG4gICAgaWYgKCFuZXN0ZWQpIHtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsIEJJTkRfVFNfTkFNRVNQQUNFLCBudWxsLCBcIm1vZHVsZSBvciBuYW1lc3BhY2UgZGVjbGFyYXRpb25cIik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLmRvdCkpIHtcbiAgICAgIGNvbnN0IGlubmVyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMudHNQYXJzZU1vZHVsZU9yTmFtZXNwYWNlRGVjbGFyYXRpb24oaW5uZXIsIHRydWUpO1xuICAgICAgbm9kZS5ib2R5ID0gaW5uZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2NvcGUuZW50ZXIoU0NPUEVfVFNfTU9EVUxFKTtcbiAgICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKFBBUkFNKTtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMudHNQYXJzZU1vZHVsZUJsb2NrKCk7XG4gICAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiKTtcbiAgfVxuXG4gIHRzUGFyc2VBbWJpZW50RXh0ZXJuYWxNb2R1bGVEZWNsYXJhdGlvbihub2RlKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwiZ2xvYmFsXCIpKSB7XG4gICAgICBub2RlLmdsb2JhbCA9IHRydWU7XG4gICAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2godHlwZXMuc3RyaW5nKSkge1xuICAgICAgbm9kZS5pZCA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5icmFjZUwpKSB7XG4gICAgICB0aGlzLnNjb3BlLmVudGVyKFNDT1BFX1RTX01PRFVMRSk7XG4gICAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihQQVJBTSk7XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnRzUGFyc2VNb2R1bGVCbG9jaygpO1xuICAgICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIik7XG4gIH1cblxuICB0c1BhcnNlSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24obm9kZSwgaXNFeHBvcnQpIHtcbiAgICBub2RlLmlzRXhwb3J0ID0gaXNFeHBvcnQgfHwgZmFsc2U7XG4gICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgdGhpcy5jaGVja0xWYWwobm9kZS5pZCwgQklORF9MRVhJQ0FMLCB1bmRlZmluZWQsIFwiaW1wb3J0IGVxdWFscyBkZWNsYXJhdGlvblwiKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5lcSk7XG4gICAgbm9kZS5tb2R1bGVSZWZlcmVuY2UgPSB0aGlzLnRzUGFyc2VNb2R1bGVSZWZlcmVuY2UoKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uXCIpO1xuICB9XG5cbiAgdHNJc0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlKCkge1xuICAgIHJldHVybiB0aGlzLmlzQ29udGV4dHVhbChcInJlcXVpcmVcIikgJiYgdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSA0MDtcbiAgfVxuXG4gIHRzUGFyc2VNb2R1bGVSZWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudHNJc0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlKCkgPyB0aGlzLnRzUGFyc2VFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZSgpIDogdGhpcy50c1BhcnNlRW50aXR5TmFtZShmYWxzZSk7XG4gIH1cblxuICB0c1BhcnNlRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwicmVxdWlyZVwiKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuXG4gICAgaWYgKCF0aGlzLm1hdGNoKHR5cGVzLnN0cmluZykpIHtcbiAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cblxuICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2VcIik7XG4gIH1cblxuICB0c0xvb2tBaGVhZChmKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLmNsb25lKCk7XG4gICAgY29uc3QgcmVzID0gZigpO1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgdHNUcnlQYXJzZUFuZENhdGNoKGYpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKGFib3J0ID0+IGYoKSB8fCBhYm9ydCgpKTtcbiAgICBpZiAocmVzdWx0LmFib3J0ZWQgfHwgIXJlc3VsdC5ub2RlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmIChyZXN1bHQuZXJyb3IpIHRoaXMuc3RhdGUgPSByZXN1bHQuZmFpbFN0YXRlO1xuICAgIHJldHVybiByZXN1bHQubm9kZTtcbiAgfVxuXG4gIHRzVHJ5UGFyc2UoZikge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGYoKTtcblxuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCAmJiByZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHRzVHJ5UGFyc2VEZWNsYXJlKG5hbnkpIHtcbiAgICBpZiAodGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgc3RhcnR0eXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgIGxldCBraW5kO1xuXG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwibGV0XCIpKSB7XG4gICAgICBzdGFydHR5cGUgPSB0eXBlcy5fdmFyO1xuICAgICAga2luZCA9IFwibGV0XCI7XG4gICAgfVxuXG4gICAgc3dpdGNoIChzdGFydHR5cGUpIHtcbiAgICAgIGNhc2UgdHlwZXMuX2Z1bmN0aW9uOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5hbnksIGZhbHNlLCB0cnVlKTtcblxuICAgICAgY2FzZSB0eXBlcy5fY2xhc3M6XG4gICAgICAgIG5hbnkuZGVjbGFyZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3MobmFueSwgdHJ1ZSwgZmFsc2UpO1xuXG4gICAgICBjYXNlIHR5cGVzLl9jb25zdDpcbiAgICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2NvbnN0KSAmJiB0aGlzLmlzTG9va2FoZWFkQ29udGV4dHVhbChcImVudW1cIikpIHtcbiAgICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5fY29uc3QpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImVudW1cIik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUVudW1EZWNsYXJhdGlvbihuYW55LCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIHR5cGVzLl92YXI6XG4gICAgICAgIGtpbmQgPSBraW5kIHx8IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFyU3RhdGVtZW50KG5hbnksIGtpbmQpO1xuXG4gICAgICBjYXNlIHR5cGVzLm5hbWU6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IFwiZ2xvYmFsXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VBbWJpZW50RXh0ZXJuYWxNb2R1bGVEZWNsYXJhdGlvbihuYW55KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZURlY2xhcmF0aW9uKG5hbnksIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0c1RyeVBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHNQYXJzZURlY2xhcmF0aW9uKHRoaXMuc3RhcnROb2RlKCksIHRoaXMuc3RhdGUudmFsdWUsIHRydWUpO1xuICB9XG5cbiAgdHNQYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwcikge1xuICAgIHN3aXRjaCAoZXhwci5uYW1lKSB7XG4gICAgICBjYXNlIFwiZGVjbGFyZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSB0aGlzLnRzVHJ5UGFyc2VEZWNsYXJlKG5vZGUpO1xuXG4gICAgICAgICAgaWYgKGRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICBkZWNsYXJhdGlvbi5kZWNsYXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWNsYXJhdGlvbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiZ2xvYmFsXCI6XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmJyYWNlTCkpIHtcbiAgICAgICAgICB0aGlzLnNjb3BlLmVudGVyKFNDT1BFX1RTX01PRFVMRSk7XG4gICAgICAgICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoUEFSQU0pO1xuICAgICAgICAgIGNvbnN0IG1vZCA9IG5vZGU7XG4gICAgICAgICAgbW9kLmdsb2JhbCA9IHRydWU7XG4gICAgICAgICAgbW9kLmlkID0gZXhwcjtcbiAgICAgICAgICBtb2QuYm9keSA9IHRoaXMudHNQYXJzZU1vZHVsZUJsb2NrKCk7XG4gICAgICAgICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgICAgICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobW9kLCBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZURlY2xhcmF0aW9uKG5vZGUsIGV4cHIubmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIHRzUGFyc2VEZWNsYXJhdGlvbihub2RlLCB2YWx1ZSwgbmV4dCkge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgIGNhc2UgXCJhYnN0cmFjdFwiOlxuICAgICAgICBpZiAodGhpcy50c0NoZWNrTGluZVRlcm1pbmF0b3JBbmRNYXRjaCh0eXBlcy5fY2xhc3MsIG5leHQpKSB7XG4gICAgICAgICAgY29uc3QgY2xzID0gbm9kZTtcbiAgICAgICAgICBjbHMuYWJzdHJhY3QgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2godHlwZXMuX2NsYXNzKSkge1xuICAgICAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQobnVsbCwgdHlwZXMuX2NsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKGNscywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgIGlmIChuZXh0IHx8IHRoaXMubWF0Y2godHlwZXMubmFtZSkpIHtcbiAgICAgICAgICBpZiAobmV4dCkgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUVudW1EZWNsYXJhdGlvbihub2RlLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcImludGVyZmFjZVwiOlxuICAgICAgICBpZiAodGhpcy50c0NoZWNrTGluZVRlcm1pbmF0b3JBbmRNYXRjaCh0eXBlcy5uYW1lLCBuZXh0KSkge1xuICAgICAgICAgIGlmIChuZXh0KSB0aGlzLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlSW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIm1vZHVsZVwiOlxuICAgICAgICBpZiAobmV4dCkgdGhpcy5uZXh0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuc3RyaW5nKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VBbWJpZW50RXh0ZXJuYWxNb2R1bGVEZWNsYXJhdGlvbihub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRzQ2hlY2tMaW5lVGVybWluYXRvckFuZE1hdGNoKHR5cGVzLm5hbWUsIG5leHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZU1vZHVsZU9yTmFtZXNwYWNlRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIm5hbWVzcGFjZVwiOlxuICAgICAgICBpZiAodGhpcy50c0NoZWNrTGluZVRlcm1pbmF0b3JBbmRNYXRjaCh0eXBlcy5uYW1lLCBuZXh0KSkge1xuICAgICAgICAgIGlmIChuZXh0KSB0aGlzLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlTW9kdWxlT3JOYW1lc3BhY2VEZWNsYXJhdGlvbihub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwidHlwZVwiOlxuICAgICAgICBpZiAodGhpcy50c0NoZWNrTGluZVRlcm1pbmF0b3JBbmRNYXRjaCh0eXBlcy5uYW1lLCBuZXh0KSkge1xuICAgICAgICAgIGlmIChuZXh0KSB0aGlzLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZUFsaWFzRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0c0NoZWNrTGluZVRlcm1pbmF0b3JBbmRNYXRjaCh0b2tlblR5cGUsIG5leHQpIHtcbiAgICByZXR1cm4gKG5leHQgfHwgdGhpcy5tYXRjaCh0b2tlblR5cGUpKSAmJiAhdGhpcy5pc0xpbmVUZXJtaW5hdG9yKCk7XG4gIH1cblxuICB0c1RyeVBhcnNlR2VuZXJpY0FzeW5jQXJyb3dGdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MpIHtcbiAgICBpZiAoIXRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRNYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzO1xuICAgIGNvbnN0IG9sZFlpZWxkUG9zID0gdGhpcy5zdGF0ZS55aWVsZFBvcztcbiAgICBjb25zdCBvbGRBd2FpdFBvcyA9IHRoaXMuc3RhdGUuYXdhaXRQb3M7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdHJ1ZTtcbiAgICB0aGlzLnN0YXRlLnlpZWxkUG9zID0gLTE7XG4gICAgdGhpcy5zdGF0ZS5hd2FpdFBvcyA9IC0xO1xuICAgIGNvbnN0IHJlcyA9IHRoaXMudHNUcnlQYXJzZUFuZENhdGNoKCgpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlcnMoKTtcbiAgICAgIHN1cGVyLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG4gICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbigpO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuYXJyb3cpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICB0aGlzLnN0YXRlLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgdGhpcy5zdGF0ZS5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuXG4gICAgaWYgKCFyZXMpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24ocmVzLCBudWxsLCB0cnVlKTtcbiAgfVxuXG4gIHRzUGFyc2VUeXBlQXJndW1lbnRzKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUucGFyYW1zID0gdGhpcy50c0luVHlwZSgoKSA9PiB0aGlzLnRzSW5Ob0NvbnRleHQoKCkgPT4ge1xuICAgICAgdGhpcy5leHBlY3RSZWxhdGlvbmFsKFwiPFwiKTtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VEZWxpbWl0ZWRMaXN0KFwiVHlwZVBhcmFtZXRlcnNPckFyZ3VtZW50c1wiLCB0aGlzLnRzUGFyc2VUeXBlLmJpbmQodGhpcykpO1xuICAgIH0pKTtcbiAgICB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkID0gZmFsc2U7XG4gICAgdGhpcy5leHBlY3RSZWxhdGlvbmFsKFwiPlwiKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKTtcbiAgfVxuXG4gIHRzSXNEZWNsYXJhdGlvblN0YXJ0KCkge1xuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLm5hbWUpKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudmFsdWUpIHtcbiAgICAgICAgY2FzZSBcImFic3RyYWN0XCI6XG4gICAgICAgIGNhc2UgXCJkZWNsYXJlXCI6XG4gICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgIGNhc2UgXCJpbnRlcmZhY2VcIjpcbiAgICAgICAgY2FzZSBcIm1vZHVsZVwiOlxuICAgICAgICBjYXNlIFwibmFtZXNwYWNlXCI6XG4gICAgICAgIGNhc2UgXCJ0eXBlXCI6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCkge1xuICAgIGlmICh0aGlzLnRzSXNEZWNsYXJhdGlvblN0YXJ0KCkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gc3VwZXIuaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCk7XG4gIH1cblxuICBwYXJzZUFzc2lnbmFibGVMaXN0SXRlbShhbGxvd01vZGlmaWVycywgZGVjb3JhdG9ycykge1xuICAgIGNvbnN0IHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgbGV0IGFjY2Vzc2liaWxpdHk7XG4gICAgbGV0IHJlYWRvbmx5ID0gZmFsc2U7XG5cbiAgICBpZiAoYWxsb3dNb2RpZmllcnMpIHtcbiAgICAgIGFjY2Vzc2liaWxpdHkgPSB0aGlzLnBhcnNlQWNjZXNzTW9kaWZpZXIoKTtcbiAgICAgIHJlYWRvbmx5ID0gISF0aGlzLnRzUGFyc2VNb2RpZmllcihbXCJyZWFkb25seVwiXSk7XG4gICAgfVxuXG4gICAgY29uc3QgbGVmdCA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQoKTtcbiAgICB0aGlzLnBhcnNlQXNzaWduYWJsZUxpc3RJdGVtVHlwZXMobGVmdCk7XG4gICAgY29uc3QgZWx0ID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChsZWZ0LnN0YXJ0LCBsZWZ0LmxvYy5zdGFydCwgbGVmdCk7XG5cbiAgICBpZiAoYWNjZXNzaWJpbGl0eSB8fCByZWFkb25seSkge1xuICAgICAgY29uc3QgcHAgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG5cbiAgICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgICBwcC5kZWNvcmF0b3JzID0gZGVjb3JhdG9ycztcbiAgICAgIH1cblxuICAgICAgaWYgKGFjY2Vzc2liaWxpdHkpIHBwLmFjY2Vzc2liaWxpdHkgPSBhY2Nlc3NpYmlsaXR5O1xuICAgICAgaWYgKHJlYWRvbmx5KSBwcC5yZWFkb25seSA9IHJlYWRvbmx5O1xuXG4gICAgICBpZiAoZWx0LnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmIGVsdC50eXBlICE9PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShwcC5zdGFydCwgVFNFcnJvcnMuVW5zdXBwb3J0ZWRQYXJhbWV0ZXJQcm9wZXJ0eUtpbmQpO1xuICAgICAgfVxuXG4gICAgICBwcC5wYXJhbWV0ZXIgPSBlbHQ7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHBwLCBcIlRTUGFyYW1ldGVyUHJvcGVydHlcIik7XG4gICAgfVxuXG4gICAgaWYgKGRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgICBsZWZ0LmRlY29yYXRvcnMgPSBkZWNvcmF0b3JzO1xuICAgIH1cblxuICAgIHJldHVybiBlbHQ7XG4gIH1cblxuICBwYXJzZUZ1bmN0aW9uQm9keUFuZEZpbmlzaChub2RlLCB0eXBlLCBpc01ldGhvZCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29sb24pKSB7XG4gICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbih0eXBlcy5jb2xvbik7XG4gICAgfVxuXG4gICAgY29uc3QgYm9kaWxlc3NUeXBlID0gdHlwZSA9PT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgPyBcIlRTRGVjbGFyZUZ1bmN0aW9uXCIgOiB0eXBlID09PSBcIkNsYXNzTWV0aG9kXCIgPyBcIlRTRGVjbGFyZU1ldGhvZFwiIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGJvZGlsZXNzVHlwZSAmJiAhdGhpcy5tYXRjaCh0eXBlcy5icmFjZUwpICYmIHRoaXMuaXNMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICB0aGlzLmZpbmlzaE5vZGUobm9kZSwgYm9kaWxlc3NUeXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdXBlci5wYXJzZUZ1bmN0aW9uQm9keUFuZEZpbmlzaChub2RlLCB0eXBlLCBpc01ldGhvZCk7XG4gIH1cblxuICByZWdpc3RlckZ1bmN0aW9uU3RhdGVtZW50SWQobm9kZSkge1xuICAgIGlmICghbm9kZS5ib2R5ICYmIG5vZGUuaWQpIHtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsIEJJTkRfVFNfQU1CSUVOVCwgbnVsbCwgXCJmdW5jdGlvbiBuYW1lXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5yZWdpc3RlckZ1bmN0aW9uU3RhdGVtZW50SWQoLi4uYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKSB7XG4gICAgaWYgKCF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpICYmIHRoaXMubWF0Y2godHlwZXMuYmFuZykpIHtcbiAgICAgIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgY29uc3Qgbm9uTnVsbEV4cHJlc3Npb24gPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub25OdWxsRXhwcmVzc2lvbi5leHByZXNzaW9uID0gYmFzZTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9uTnVsbEV4cHJlc3Npb24sIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRzVHJ5UGFyc2VBbmRDYXRjaCgoKSA9PiB7XG4gICAgICAgIGlmICghbm9DYWxscyAmJiB0aGlzLmF0UG9zc2libGVBc3luY0Fycm93KGJhc2UpKSB7XG4gICAgICAgICAgY29uc3QgYXN5bmNBcnJvd0ZuID0gdGhpcy50c1RyeVBhcnNlR2VuZXJpY0FzeW5jQXJyb3dGdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MpO1xuXG4gICAgICAgICAgaWYgKGFzeW5jQXJyb3dGbikge1xuICAgICAgICAgICAgcmV0dXJuIGFzeW5jQXJyb3dGbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICBub2RlLmNhbGxlZSA9IGJhc2U7XG4gICAgICAgIGNvbnN0IHR5cGVBcmd1bWVudHMgPSB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzKCk7XG5cbiAgICAgICAgaWYgKHR5cGVBcmd1bWVudHMpIHtcbiAgICAgICAgICBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5lYXQodHlwZXMucGFyZW5MKSkge1xuICAgICAgICAgICAgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHModHlwZXMucGFyZW5SLCBmYWxzZSk7XG4gICAgICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdHlwZUFyZ3VtZW50cztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaENhbGxFeHByZXNzaW9uKG5vZGUsIHN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCh0eXBlcy5iYWNrUXVvdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihzdGFydFBvcywgc3RhcnRMb2MsIGJhc2UsIHN0YXRlLCB0eXBlQXJndW1lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBzdGF0ZSk7XG4gIH1cblxuICBwYXJzZU5ld0FyZ3VtZW50cyhub2RlKSB7XG4gICAgaWYgKHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgICAgY29uc3QgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzVHJ5UGFyc2VBbmRDYXRjaCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzKCk7XG4gICAgICAgIGlmICghdGhpcy5tYXRjaCh0eXBlcy5wYXJlbkwpKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdXBlci5wYXJzZU5ld0FyZ3VtZW50cyhub2RlKTtcbiAgfVxuXG4gIHBhcnNlRXhwck9wKGxlZnQsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBub0luKSB7XG4gICAgaWYgKG5vbk51bGwodHlwZXMuX2luLmJpbm9wKSA+IG1pblByZWMgJiYgIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJhc1wiKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQobGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MpO1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gbGVmdDtcblxuICAgICAgY29uc3QgX2NvbnN0ID0gdGhpcy50c1RyeU5leHRQYXJzZUNvbnN0YW50Q29udGV4dCgpO1xuXG4gICAgICBpZiAoX2NvbnN0KSB7XG4gICAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSBfY29uc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c05leHRUaGVuUGFyc2VUeXBlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTQXNFeHByZXNzaW9uXCIpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3Aobm9kZSwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIG5vSW4pO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5wYXJzZUV4cHJPcChsZWZ0LCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYywgbm9Jbik7XG4gIH1cblxuICBjaGVja1Jlc2VydmVkV29yZCh3b3JkLCBzdGFydExvYywgY2hlY2tLZXl3b3JkcywgaXNCaW5kaW5nKSB7fVxuXG4gIGNoZWNrRHVwbGljYXRlRXhwb3J0cygpIHt9XG5cbiAgcGFyc2VJbXBvcnQobm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLm5hbWUpIHx8IHRoaXMubWF0Y2godHlwZXMuc3RhcikgfHwgdGhpcy5tYXRjaCh0eXBlcy5icmFjZUwpKSB7XG4gICAgICBjb25zdCBhaGVhZCA9IHRoaXMubG9va2FoZWFkKCk7XG5cbiAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLm5hbWUpICYmIGFoZWFkLnR5cGUgPT09IHR5cGVzLmVxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbihub2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwidHlwZVwiKSAmJiBhaGVhZC50eXBlICE9PSB0eXBlcy5jb21tYSAmJiAhKGFoZWFkLnR5cGUgPT09IHR5cGVzLm5hbWUgJiYgYWhlYWQudmFsdWUgPT09IFwiZnJvbVwiKSkge1xuICAgICAgICBub2RlLmltcG9ydEtpbmQgPSBcInR5cGVcIjtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmltcG9ydEtpbmQgPSBcInZhbHVlXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW1wb3J0Tm9kZSA9IHN1cGVyLnBhcnNlSW1wb3J0KG5vZGUpO1xuXG4gICAgaWYgKGltcG9ydE5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlXCIgJiYgaW1wb3J0Tm9kZS5zcGVjaWZpZXJzLmxlbmd0aCA+IDEgJiYgaW1wb3J0Tm9kZS5zcGVjaWZpZXJzWzBdLnR5cGUgPT09IFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSB7XG4gICAgICB0aGlzLnJhaXNlKGltcG9ydE5vZGUuc3RhcnQsIFwiQSB0eXBlLW9ubHkgaW1wb3J0IGNhbiBzcGVjaWZ5IGEgZGVmYXVsdCBpbXBvcnQgb3IgbmFtZWQgYmluZGluZ3MsIGJ1dCBub3QgYm90aC5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGltcG9ydE5vZGU7XG4gIH1cblxuICBwYXJzZUV4cG9ydChub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2ltcG9ydCkpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLl9pbXBvcnQpO1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUltcG9ydEVxdWFsc0RlY2xhcmF0aW9uKG5vZGUsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lYXQodHlwZXMuZXEpKSB7XG4gICAgICBjb25zdCBhc3NpZ24gPSBub2RlO1xuICAgICAgYXNzaWduLmV4cHJlc3Npb24gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoYXNzaWduLCBcIlRTRXhwb3J0QXNzaWdubWVudFwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICBjb25zdCBkZWNsID0gbm9kZTtcbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcIm5hbWVzcGFjZVwiKTtcbiAgICAgIGRlY2wuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZGVjbCwgXCJUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJ0eXBlXCIpICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gdHlwZXMuYnJhY2VMKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBub2RlLmV4cG9ydEtpbmQgPSBcInR5cGVcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuZXhwb3J0S2luZCA9IFwidmFsdWVcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlRXhwb3J0KG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGlzQWJzdHJhY3RDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0NvbnRleHR1YWwoXCJhYnN0cmFjdFwiKSAmJiB0aGlzLmxvb2thaGVhZCgpLnR5cGUgPT09IHR5cGVzLl9jbGFzcztcbiAgfVxuXG4gIHBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKSB7XG4gICAgaWYgKHRoaXMuaXNBYnN0cmFjdENsYXNzKCkpIHtcbiAgICAgIGNvbnN0IGNscyA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMucGFyc2VDbGFzcyhjbHMsIHRydWUsIHRydWUpO1xuICAgICAgY2xzLmFic3RyYWN0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBjbHM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhdGUudmFsdWUgPT09IFwiaW50ZXJmYWNlXCIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHNQYXJzZURlY2xhcmF0aW9uKHRoaXMuc3RhcnROb2RlKCksIHRoaXMuc3RhdGUudmFsdWUsIHRydWUpO1xuICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnREZWZhdWx0RXhwcmVzc2lvbigpO1xuICB9XG5cbiAgcGFyc2VTdGF0ZW1lbnRDb250ZW50KGNvbnRleHQsIHRvcExldmVsKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUudHlwZSA9PT0gdHlwZXMuX2NvbnN0KSB7XG4gICAgICBjb25zdCBhaGVhZCA9IHRoaXMubG9va2FoZWFkKCk7XG5cbiAgICAgIGlmIChhaGVhZC50eXBlID09PSB0eXBlcy5uYW1lICYmIGFoZWFkLnZhbHVlID09PSBcImVudW1cIikge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuX2NvbnN0KTtcbiAgICAgICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiZW51bVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUVudW1EZWNsYXJhdGlvbihub2RlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIucGFyc2VTdGF0ZW1lbnRDb250ZW50KGNvbnRleHQsIHRvcExldmVsKTtcbiAgfVxuXG4gIHBhcnNlQWNjZXNzTW9kaWZpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHNQYXJzZU1vZGlmaWVyKFtcInB1YmxpY1wiLCBcInByb3RlY3RlZFwiLCBcInByaXZhdGVcIl0pO1xuICB9XG5cbiAgcGFyc2VDbGFzc01lbWJlcihjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUsIGNvbnN0cnVjdG9yQWxsb3dzU3VwZXIpIHtcbiAgICB0aGlzLnRzUGFyc2VNb2RpZmllcnMobWVtYmVyLCBbXCJkZWNsYXJlXCJdKTtcbiAgICBjb25zdCBhY2Nlc3NpYmlsaXR5ID0gdGhpcy5wYXJzZUFjY2Vzc01vZGlmaWVyKCk7XG4gICAgaWYgKGFjY2Vzc2liaWxpdHkpIG1lbWJlci5hY2Nlc3NpYmlsaXR5ID0gYWNjZXNzaWJpbGl0eTtcbiAgICB0aGlzLnRzUGFyc2VNb2RpZmllcnMobWVtYmVyLCBbXCJkZWNsYXJlXCJdKTtcbiAgICBzdXBlci5wYXJzZUNsYXNzTWVtYmVyKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSwgY29uc3RydWN0b3JBbGxvd3NTdXBlcik7XG4gIH1cblxuICBwYXJzZUNsYXNzTWVtYmVyV2l0aElzU3RhdGljKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSwgaXNTdGF0aWMsIGNvbnN0cnVjdG9yQWxsb3dzU3VwZXIpIHtcbiAgICB0aGlzLnRzUGFyc2VNb2RpZmllcnMobWVtYmVyLCBbXCJhYnN0cmFjdFwiLCBcInJlYWRvbmx5XCIsIFwiZGVjbGFyZVwiXSk7XG4gICAgY29uc3QgaWR4ID0gdGhpcy50c1RyeVBhcnNlSW5kZXhTaWduYXR1cmUobWVtYmVyKTtcblxuICAgIGlmIChpZHgpIHtcbiAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2goaWR4KTtcblxuICAgICAgaWYgKG1lbWJlci5hYnN0cmFjdCkge1xuICAgICAgICB0aGlzLnJhaXNlKG1lbWJlci5zdGFydCwgVFNFcnJvcnMuSW5kZXhTaWduYXR1cmVIYXNBYnN0cmFjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0YXRpYykge1xuICAgICAgICB0aGlzLnJhaXNlKG1lbWJlci5zdGFydCwgVFNFcnJvcnMuSW5kZXhTaWduYXR1cmVIYXNTdGF0aWMpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVtYmVyLmFjY2Vzc2liaWxpdHkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShtZW1iZXIuc3RhcnQsIFRTRXJyb3JzLkluZGV4U2lnbmF0dXJlSGFzQWNjZXNzaWJpbGl0eSwgbWVtYmVyLmFjY2Vzc2liaWxpdHkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3VwZXIucGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYyhjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUsIGlzU3RhdGljLCBjb25zdHJ1Y3RvckFsbG93c1N1cGVyKTtcbiAgfVxuXG4gIHBhcnNlUG9zdE1lbWJlck5hbWVNb2RpZmllcnMobWV0aG9kT3JQcm9wKSB7XG4gICAgY29uc3Qgb3B0aW9uYWwgPSB0aGlzLmVhdCh0eXBlcy5xdWVzdGlvbik7XG4gICAgaWYgKG9wdGlvbmFsKSBtZXRob2RPclByb3Aub3B0aW9uYWwgPSB0cnVlO1xuXG4gICAgaWYgKG1ldGhvZE9yUHJvcC5yZWFkb25seSAmJiB0aGlzLm1hdGNoKHR5cGVzLnBhcmVuTCkpIHtcbiAgICAgIHRoaXMucmFpc2UobWV0aG9kT3JQcm9wLnN0YXJ0LCBUU0Vycm9ycy5DbGFzc01ldGhvZEhhc1JlYWRvbmx5KTtcbiAgICB9XG5cbiAgICBpZiAobWV0aG9kT3JQcm9wLmRlY2xhcmUgJiYgdGhpcy5tYXRjaCh0eXBlcy5wYXJlbkwpKSB7XG4gICAgICB0aGlzLnJhaXNlKG1ldGhvZE9yUHJvcC5zdGFydCwgVFNFcnJvcnMuQ2xhc3NNZXRob2RIYXNEZWNsYXJlKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwcikge1xuICAgIGNvbnN0IGRlY2wgPSBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiID8gdGhpcy50c1BhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gZGVjbCB8fCBzdXBlci5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwcik7XG4gIH1cblxuICBzaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCkge1xuICAgIGlmICh0aGlzLnRzSXNEZWNsYXJhdGlvblN0YXJ0KCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzdXBlci5zaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCk7XG4gIH1cblxuICBwYXJzZUNvbmRpdGlvbmFsKGV4cHIsIG5vSW4sIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmTmVlZHNBcnJvd1Bvcykge1xuICAgIGlmICghcmVmTmVlZHNBcnJvd1BvcyB8fCAhdGhpcy5tYXRjaCh0eXBlcy5xdWVzdGlvbikpIHtcbiAgICAgIHJldHVybiBzdXBlci5wYXJzZUNvbmRpdGlvbmFsKGV4cHIsIG5vSW4sIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmTmVlZHNBcnJvd1Bvcyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy50cnlQYXJzZSgoKSA9PiBzdXBlci5wYXJzZUNvbmRpdGlvbmFsKGV4cHIsIG5vSW4sIHN0YXJ0UG9zLCBzdGFydExvYykpO1xuXG4gICAgaWYgKCFyZXN1bHQubm9kZSkge1xuICAgICAgcmVmTmVlZHNBcnJvd1Bvcy5zdGFydCA9IHJlc3VsdC5lcnJvci5wb3MgfHwgdGhpcy5zdGF0ZS5zdGFydDtcbiAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQuZXJyb3IpIHRoaXMuc3RhdGUgPSByZXN1bHQuZmFpbFN0YXRlO1xuICAgIHJldHVybiByZXN1bHQubm9kZTtcbiAgfVxuXG4gIHBhcnNlUGFyZW5JdGVtKG5vZGUsIHN0YXJ0UG9zLCBzdGFydExvYykge1xuICAgIG5vZGUgPSBzdXBlci5wYXJzZVBhcmVuSXRlbShub2RlLCBzdGFydFBvcywgc3RhcnRMb2MpO1xuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnF1ZXN0aW9uKSkge1xuICAgICAgbm9kZS5vcHRpb25hbCA9IHRydWU7XG4gICAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24obm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29sb24pKSB7XG4gICAgICBjb25zdCB0eXBlQ2FzdE5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICB0eXBlQ2FzdE5vZGUuZXhwcmVzc2lvbiA9IG5vZGU7XG4gICAgICB0eXBlQ2FzdE5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLnRzUGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZSh0eXBlQ2FzdE5vZGUsIFwiVFNUeXBlQ2FzdEV4cHJlc3Npb25cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBwYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IGlzRGVjbGFyZSA9IHRoaXMuZWF0Q29udGV4dHVhbChcImRlY2xhcmVcIik7XG4gICAgbGV0IGRlY2xhcmF0aW9uO1xuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMubmFtZSkpIHtcbiAgICAgIGRlY2xhcmF0aW9uID0gdGhpcy50c1RyeVBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKTtcbiAgICB9XG5cbiAgICBpZiAoIWRlY2xhcmF0aW9uKSB7XG4gICAgICBkZWNsYXJhdGlvbiA9IHN1cGVyLnBhcnNlRXhwb3J0RGVjbGFyYXRpb24obm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKGRlY2xhcmF0aW9uICYmIChkZWNsYXJhdGlvbi50eXBlID09PSBcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIiB8fCBkZWNsYXJhdGlvbi50eXBlID09PSBcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIiB8fCBpc0RlY2xhcmUpKSB7XG4gICAgICBub2RlLmV4cG9ydEtpbmQgPSBcInR5cGVcIjtcbiAgICB9XG5cbiAgICBpZiAoZGVjbGFyYXRpb24gJiYgaXNEZWNsYXJlKSB7XG4gICAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbihkZWNsYXJhdGlvbiwgc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIGRlY2xhcmF0aW9uLmRlY2xhcmUgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNsYXJhdGlvbjtcbiAgfVxuXG4gIHBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCkge1xuICAgIGlmICgoIWlzU3RhdGVtZW50IHx8IG9wdGlvbmFsSWQpICYmIHRoaXMuaXNDb250ZXh0dWFsKFwiaW1wbGVtZW50c1wiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN1cGVyLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCwgbm9kZS5kZWNsYXJlID8gQklORF9UU19BTUJJRU5UIDogQklORF9DTEFTUyk7XG4gICAgY29uc3QgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycygpO1xuICAgIGlmICh0eXBlUGFyYW1ldGVycykgbm9kZS50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICB9XG5cbiAgcGFyc2VDbGFzc1Byb3BlcnR5QW5ub3RhdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLm9wdGlvbmFsICYmIHRoaXMuZWF0KHR5cGVzLmJhbmcpKSB7XG4gICAgICBub2RlLmRlZmluaXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICBpZiAodHlwZSkgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gIH1cblxuICBwYXJzZUNsYXNzUHJvcGVydHkobm9kZSkge1xuICAgIHRoaXMucGFyc2VDbGFzc1Byb3BlcnR5QW5ub3RhdGlvbihub2RlKTtcblxuICAgIGlmIChub2RlLmRlY2xhcmUgJiYgdGhpcy5tYXRjaCh0eXBlcy5lcXVhbCkpIHtcbiAgICAgIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCwgVFNFcnJvcnMuRGVjbGFyZUNsYXNzRmllbGRIYXNJbml0aWFsaXplcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQ2xhc3NQcm9wZXJ0eShub2RlKTtcbiAgfVxuXG4gIHBhcnNlQ2xhc3NQcml2YXRlUHJvcGVydHkobm9kZSkge1xuICAgIGlmIChub2RlLmFic3RyYWN0KSB7XG4gICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFRTRXJyb3JzLlByaXZhdGVFbGVtZW50SGFzQWJzdHJhY3QpO1xuICAgIH1cblxuICAgIGlmIChub2RlLmFjY2Vzc2liaWxpdHkpIHtcbiAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgVFNFcnJvcnMuUHJpdmF0ZUVsZW1lbnRIYXNBY2Nlc3NpYmlsaXR5LCBub2RlLmFjY2Vzc2liaWxpdHkpO1xuICAgIH1cblxuICAgIHRoaXMucGFyc2VDbGFzc1Byb3BlcnR5QW5ub3RhdGlvbihub2RlKTtcbiAgICByZXR1cm4gc3VwZXIucGFyc2VDbGFzc1ByaXZhdGVQcm9wZXJ0eShub2RlKTtcbiAgfVxuXG4gIHB1c2hDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93c0RpcmVjdFN1cGVyKSB7XG4gICAgY29uc3QgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycygpO1xuICAgIGlmICh0eXBlUGFyYW1ldGVycykgbWV0aG9kLnR5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnM7XG4gICAgc3VwZXIucHVzaENsYXNzTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dzRGlyZWN0U3VwZXIpO1xuICB9XG5cbiAgcHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpIHtcbiAgICBjb25zdCB0eXBlUGFyYW1ldGVycyA9IHRoaXMudHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKCk7XG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJzKSBtZXRob2QudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICBzdXBlci5wdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYyk7XG4gIH1cblxuICBwYXJzZUNsYXNzU3VwZXIobm9kZSkge1xuICAgIHN1cGVyLnBhcnNlQ2xhc3NTdXBlcihub2RlKTtcblxuICAgIGlmIChub2RlLnN1cGVyQ2xhc3MgJiYgdGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICBub2RlLnN1cGVyVHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImltcGxlbWVudHNcIikpIHtcbiAgICAgIG5vZGUuaW1wbGVtZW50cyA9IHRoaXMudHNQYXJzZUhlcml0YWdlQ2xhdXNlKFwiaW1wbGVtZW50c1wiKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZU9ialByb3BWYWx1ZShwcm9wLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycygpO1xuICAgIGlmICh0eXBlUGFyYW1ldGVycykgcHJvcC50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICAgIHN1cGVyLnBhcnNlT2JqUHJvcFZhbHVlKHByb3AsIC4uLmFyZ3MpO1xuICB9XG5cbiAgcGFyc2VGdW5jdGlvblBhcmFtcyhub2RlLCBhbGxvd01vZGlmaWVycykge1xuICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnMoKTtcbiAgICBpZiAodHlwZVBhcmFtZXRlcnMpIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICBzdXBlci5wYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUsIGFsbG93TW9kaWZpZXJzKTtcbiAgfVxuXG4gIHBhcnNlVmFySWQoZGVjbCwga2luZCkge1xuICAgIHN1cGVyLnBhcnNlVmFySWQoZGVjbCwga2luZCk7XG5cbiAgICBpZiAoZGVjbC5pZC50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiB0aGlzLmVhdCh0eXBlcy5iYW5nKSkge1xuICAgICAgZGVjbC5kZWZpbml0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHNUcnlQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG5cbiAgICBpZiAodHlwZSkge1xuICAgICAgZGVjbC5pZC50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gICAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24oZGVjbC5pZCk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VBc3luY0Fycm93RnJvbUNhbGxFeHByZXNzaW9uKG5vZGUsIGNhbGwpIHtcbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5jb2xvbikpIHtcbiAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbihub2RlLCBjYWxsKTtcbiAgfVxuXG4gIHBhcnNlTWF5YmVBc3NpZ24oLi4uYXJncykge1xuICAgIHZhciBfanN4LCBfanN4MiwgX3R5cGVDYXN0LCBfanN4MywgX3R5cGVDYXN0MiwgX2pzeDQsIF90eXBlQ2FzdDM7XG5cbiAgICBsZXQgc3RhdGU7XG4gICAgbGV0IGpzeDtcbiAgICBsZXQgdHlwZUNhc3Q7XG5cbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5qc3hUYWdTdGFydCkpIHtcbiAgICAgIHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgICAganN4ID0gdGhpcy50cnlQYXJzZSgoKSA9PiBzdXBlci5wYXJzZU1heWJlQXNzaWduKC4uLmFyZ3MpLCBzdGF0ZSk7XG4gICAgICBpZiAoIWpzeC5lcnJvcikgcmV0dXJuIGpzeC5ub2RlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb250ZXh0XG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgaWYgKGNvbnRleHRbY29udGV4dC5sZW5ndGggLSAxXSA9PT0gdHlwZXMkMS5qX29UYWcpIHtcbiAgICAgICAgY29udGV4dC5sZW5ndGggLT0gMjtcbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdID09PSB0eXBlcyQxLmpfZXhwcikge1xuICAgICAgICBjb250ZXh0Lmxlbmd0aCAtPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKChfanN4ID0ganN4KSA9PSBudWxsID8gdm9pZCAwIDogX2pzeC5lcnJvcikgJiYgIXRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlTWF5YmVBc3NpZ24oLi4uYXJncyk7XG4gICAgfVxuXG4gICAgbGV0IHR5cGVQYXJhbWV0ZXJzO1xuICAgIHN0YXRlID0gc3RhdGUgfHwgdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgIGNvbnN0IGFycm93ID0gdGhpcy50cnlQYXJzZShhYm9ydCA9PiB7XG4gICAgICB2YXIgX3R5cGVQYXJhbWV0ZXJzO1xuXG4gICAgICB0eXBlUGFyYW1ldGVycyA9IHRoaXMudHNQYXJzZVR5cGVQYXJhbWV0ZXJzKCk7XG4gICAgICBjb25zdCBleHByID0gc3VwZXIucGFyc2VNYXliZUFzc2lnbiguLi5hcmdzKTtcblxuICAgICAgaWYgKGV4cHIudHlwZSAhPT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiIHx8IGV4cHIuZXh0cmEgJiYgZXhwci5leHRyYS5wYXJlbnRoZXNpemVkKSB7XG4gICAgICAgIGFib3J0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoKF90eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX3R5cGVQYXJhbWV0ZXJzLnBhcmFtcy5sZW5ndGgpICE9PSAwKSB7XG4gICAgICAgIHRoaXMucmVzZXRTdGFydExvY2F0aW9uRnJvbU5vZGUoZXhwciwgdHlwZVBhcmFtZXRlcnMpO1xuICAgICAgfVxuXG4gICAgICBleHByLnR5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnM7XG4gICAgICByZXR1cm4gZXhwcjtcbiAgICB9LCBzdGF0ZSk7XG4gICAgaWYgKCFhcnJvdy5lcnJvciAmJiAhYXJyb3cuYWJvcnRlZCkgcmV0dXJuIGFycm93Lm5vZGU7XG5cbiAgICBpZiAoIWpzeCkge1xuICAgICAgYXNzZXJ0KCF0aGlzLmhhc1BsdWdpbihcImpzeFwiKSk7XG4gICAgICB0eXBlQ2FzdCA9IHRoaXMudHJ5UGFyc2UoKCkgPT4gc3VwZXIucGFyc2VNYXliZUFzc2lnbiguLi5hcmdzKSwgc3RhdGUpO1xuICAgICAgaWYgKCF0eXBlQ2FzdC5lcnJvcikgcmV0dXJuIHR5cGVDYXN0Lm5vZGU7XG4gICAgfVxuXG4gICAgaWYgKChfanN4MiA9IGpzeCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9qc3gyLm5vZGUpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBqc3guZmFpbFN0YXRlO1xuICAgICAgcmV0dXJuIGpzeC5ub2RlO1xuICAgIH1cblxuICAgIGlmIChhcnJvdy5ub2RlKSB7XG4gICAgICB0aGlzLnN0YXRlID0gYXJyb3cuZmFpbFN0YXRlO1xuICAgICAgcmV0dXJuIGFycm93Lm5vZGU7XG4gICAgfVxuXG4gICAgaWYgKChfdHlwZUNhc3QgPSB0eXBlQ2FzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90eXBlQ2FzdC5ub2RlKSB7XG4gICAgICB0aGlzLnN0YXRlID0gdHlwZUNhc3QuZmFpbFN0YXRlO1xuICAgICAgcmV0dXJuIHR5cGVDYXN0Lm5vZGU7XG4gICAgfVxuXG4gICAgaWYgKChfanN4MyA9IGpzeCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9qc3gzLnRocm93bikgdGhyb3cganN4LmVycm9yO1xuICAgIGlmIChhcnJvdy50aHJvd24pIHRocm93IGFycm93LmVycm9yO1xuICAgIGlmICgoX3R5cGVDYXN0MiA9IHR5cGVDYXN0KSA9PSBudWxsID8gdm9pZCAwIDogX3R5cGVDYXN0Mi50aHJvd24pIHRocm93IHR5cGVDYXN0LmVycm9yO1xuICAgIHRocm93ICgoX2pzeDQgPSBqc3gpID09IG51bGwgPyB2b2lkIDAgOiBfanN4NC5lcnJvcikgfHwgYXJyb3cuZXJyb3IgfHwgKChfdHlwZUNhc3QzID0gdHlwZUNhc3QpID09IG51bGwgPyB2b2lkIDAgOiBfdHlwZUNhc3QzLmVycm9yKTtcbiAgfVxuXG4gIHBhcnNlTWF5YmVVbmFyeShyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKCF0aGlzLmhhc1BsdWdpbihcImpzeFwiKSAmJiB0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlQXNzZXJ0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci5wYXJzZU1heWJlVW5hcnkocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VBcnJvdyhub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29sb24pKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKGFib3J0ID0+IHtcbiAgICAgICAgY29uc3QgcmV0dXJuVHlwZSA9IHRoaXMudHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKHR5cGVzLmNvbG9uKTtcbiAgICAgICAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgIXRoaXMubWF0Y2godHlwZXMuYXJyb3cpKSBhYm9ydCgpO1xuICAgICAgICByZXR1cm4gcmV0dXJuVHlwZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlc3VsdC5hYm9ydGVkKSByZXR1cm47XG5cbiAgICAgIGlmICghcmVzdWx0LnRocm93bikge1xuICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB0aGlzLnN0YXRlID0gcmVzdWx0LmZhaWxTdGF0ZTtcbiAgICAgICAgbm9kZS5yZXR1cm5UeXBlID0gcmVzdWx0Lm5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQXJyb3cobm9kZSk7XG4gIH1cblxuICBwYXJzZUFzc2lnbmFibGVMaXN0SXRlbVR5cGVzKHBhcmFtKSB7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnF1ZXN0aW9uKSkge1xuICAgICAgaWYgKHBhcmFtLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UocGFyYW0uc3RhcnQsIFRTRXJyb3JzLlBhdHRlcm5Jc09wdGlvbmFsKTtcbiAgICAgIH1cblxuICAgICAgcGFyYW0ub3B0aW9uYWwgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIGlmICh0eXBlKSBwYXJhbS50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKHBhcmFtKTtcbiAgICByZXR1cm4gcGFyYW07XG4gIH1cblxuICB0b0Fzc2lnbmFibGUobm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiVFNUeXBlQ2FzdEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHN1cGVyLnRvQXNzaWduYWJsZSh0aGlzLnR5cGVDYXN0VG9QYXJhbWV0ZXIobm9kZSkpO1xuXG4gICAgICBjYXNlIFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiOlxuICAgICAgICByZXR1cm4gc3VwZXIudG9Bc3NpZ25hYmxlKG5vZGUpO1xuXG4gICAgICBjYXNlIFwiVFNBc0V4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU05vbk51bGxFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiVFNUeXBlQXNzZXJ0aW9uXCI6XG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbik7XG4gICAgICAgIHJldHVybiBub2RlO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3VwZXIudG9Bc3NpZ25hYmxlKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrTFZhbChleHByLCBiaW5kaW5nVHlwZSA9IEJJTkRfTk9ORSwgY2hlY2tDbGFzaGVzLCBjb250ZXh0RGVzY3JpcHRpb24pIHtcbiAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgICAgY2FzZSBcIlRTVHlwZUNhc3RFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcIlRTUGFyYW1ldGVyUHJvcGVydHlcIjpcbiAgICAgICAgdGhpcy5jaGVja0xWYWwoZXhwci5wYXJhbWV0ZXIsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMsIFwicGFyYW1ldGVyIHByb3BlcnR5XCIpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJUU0FzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU1R5cGVBc3NlcnRpb25cIjpcbiAgICAgICAgdGhpcy5jaGVja0xWYWwoZXhwci5leHByZXNzaW9uLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzLCBjb250ZXh0RGVzY3JpcHRpb24pO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN1cGVyLmNoZWNrTFZhbChleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzLCBjb250ZXh0RGVzY3JpcHRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgcGFyc2VCaW5kaW5nQXRvbSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSB0eXBlcy5fdGhpczpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3VwZXIucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlTWF5YmVEZWNvcmF0b3JBcmd1bWVudHMoZXhwcikge1xuICAgIGlmICh0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgIGNvbnN0IHR5cGVBcmd1bWVudHMgPSB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzKCk7XG5cbiAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLnBhcmVuTCkpIHtcbiAgICAgICAgY29uc3QgY2FsbCA9IHN1cGVyLnBhcnNlTWF5YmVEZWNvcmF0b3JBcmd1bWVudHMoZXhwcik7XG4gICAgICAgIGNhbGwudHlwZVBhcmFtZXRlcnMgPSB0eXBlQXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy51bmV4cGVjdGVkKHRoaXMuc3RhdGUuc3RhcnQsIHR5cGVzLnBhcmVuTCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlTWF5YmVEZWNvcmF0b3JBcmd1bWVudHMoZXhwcik7XG4gIH1cblxuICBpc0NsYXNzTWV0aG9kKCkge1xuICAgIHJldHVybiB0aGlzLmlzUmVsYXRpb25hbChcIjxcIikgfHwgc3VwZXIuaXNDbGFzc01ldGhvZCgpO1xuICB9XG5cbiAgaXNDbGFzc1Byb3BlcnR5KCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKHR5cGVzLmJhbmcpIHx8IHRoaXMubWF0Y2godHlwZXMuY29sb24pIHx8IHN1cGVyLmlzQ2xhc3NQcm9wZXJ0eSgpO1xuICB9XG5cbiAgcGFyc2VNYXliZURlZmF1bHQoLi4uYXJncykge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5wYXJzZU1heWJlRGVmYXVsdCguLi5hcmdzKTtcblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIiAmJiBub2RlLnR5cGVBbm5vdGF0aW9uICYmIG5vZGUucmlnaHQuc3RhcnQgPCBub2RlLnR5cGVBbm5vdGF0aW9uLnN0YXJ0KSB7XG4gICAgICB0aGlzLnJhaXNlKG5vZGUudHlwZUFubm90YXRpb24uc3RhcnQsIFRTRXJyb3JzLlR5cGVBbm5vdGF0aW9uQWZ0ZXJBc3NpZ24pO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuaW5UeXBlICYmIChjb2RlID09PSA2MiB8fCBjb2RlID09PSA2MCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnJlbGF0aW9uYWwsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKTtcbiAgICB9XG4gIH1cblxuICB0b0Fzc2lnbmFibGVMaXN0KGV4cHJMaXN0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHByTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZXhwciA9IGV4cHJMaXN0W2ldO1xuICAgICAgaWYgKCFleHByKSBjb250aW51ZTtcblxuICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIlRTVHlwZUNhc3RFeHByZXNzaW9uXCI6XG4gICAgICAgICAgZXhwckxpc3RbaV0gPSB0aGlzLnR5cGVDYXN0VG9QYXJhbWV0ZXIoZXhwcik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIlRTQXNFeHByZXNzaW9uXCI6XG4gICAgICAgIGNhc2UgXCJUU1R5cGVBc3NlcnRpb25cIjpcbiAgICAgICAgICBpZiAoIXRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycykge1xuICAgICAgICAgICAgZXhwckxpc3RbaV0gPSB0aGlzLnR5cGVDYXN0VG9QYXJhbWV0ZXIoZXhwcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoZXhwci5zdGFydCwgVFNFcnJvcnMuVW5leHBlY3RlZFR5cGVDYXN0SW5QYXJhbWV0ZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci50b0Fzc2lnbmFibGVMaXN0KC4uLmFyZ3VtZW50cyk7XG4gIH1cblxuICB0eXBlQ2FzdFRvUGFyYW1ldGVyKG5vZGUpIHtcbiAgICBub2RlLmV4cHJlc3Npb24udHlwZUFubm90YXRpb24gPSBub2RlLnR5cGVBbm5vdGF0aW9uO1xuICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudHlwZUFubm90YXRpb24uZW5kLCBub2RlLnR5cGVBbm5vdGF0aW9uLmxvYy5lbmQpO1xuICAgIHJldHVybiBub2RlLmV4cHJlc3Npb247XG4gIH1cblxuICB0b1JlZmVyZW5jZWRMaXN0KGV4cHJMaXN0LCBpc0luUGFyZW5zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHByTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZXhwciA9IGV4cHJMaXN0W2ldO1xuXG4gICAgICBpZiAoKGV4cHIgPT0gbnVsbCA/IHZvaWQgMCA6IGV4cHIudHlwZSkgPT09IFwiVFNUeXBlQ2FzdEV4cHJlc3Npb25cIikge1xuICAgICAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIFRTRXJyb3JzLlVuZXhwZWN0ZWRUeXBlQW5ub3RhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cHJMaXN0O1xuICB9XG5cbiAgc2hvdWxkUGFyc2VBcnJvdygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCh0eXBlcy5jb2xvbikgfHwgc3VwZXIuc2hvdWxkUGFyc2VBcnJvdygpO1xuICB9XG5cbiAgc2hvdWxkUGFyc2VBc3luY0Fycm93KCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKHR5cGVzLmNvbG9uKSB8fCBzdXBlci5zaG91bGRQYXJzZUFzeW5jQXJyb3coKTtcbiAgfVxuXG4gIGNhbkhhdmVMZWFkaW5nRGVjb3JhdG9yKCkge1xuICAgIHJldHVybiBzdXBlci5jYW5IYXZlTGVhZGluZ0RlY29yYXRvcigpIHx8IHRoaXMuaXNBYnN0cmFjdENsYXNzKCk7XG4gIH1cblxuICBqc3hQYXJzZU9wZW5pbmdFbGVtZW50QWZ0ZXJOYW1lKG5vZGUpIHtcbiAgICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICBjb25zdCB0eXBlQXJndW1lbnRzID0gdGhpcy50c1RyeVBhcnNlQW5kQ2F0Y2goKCkgPT4gdGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50cygpKTtcbiAgICAgIGlmICh0eXBlQXJndW1lbnRzKSBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdHlwZUFyZ3VtZW50cztcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuanN4UGFyc2VPcGVuaW5nRWxlbWVudEFmdGVyTmFtZShub2RlKTtcbiAgfVxuXG4gIGdldEdldHRlclNldHRlckV4cGVjdGVkUGFyYW1Db3VudChtZXRob2QpIHtcbiAgICBjb25zdCBiYXNlQ291bnQgPSBzdXBlci5nZXRHZXR0ZXJTZXR0ZXJFeHBlY3RlZFBhcmFtQ291bnQobWV0aG9kKTtcbiAgICBjb25zdCBmaXJzdFBhcmFtID0gbWV0aG9kLnBhcmFtc1swXTtcbiAgICBjb25zdCBoYXNDb250ZXh0UGFyYW0gPSBmaXJzdFBhcmFtICYmIGZpcnN0UGFyYW0udHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgZmlyc3RQYXJhbS5uYW1lID09PSBcInRoaXNcIjtcbiAgICByZXR1cm4gaGFzQ29udGV4dFBhcmFtID8gYmFzZUNvdW50ICsgMSA6IGJhc2VDb3VudDtcbiAgfVxuXG59KTtcblxudHlwZXMucGxhY2Vob2xkZXIgPSBuZXcgVG9rZW5UeXBlKFwiJSVcIiwge1xuICBzdGFydHNFeHByOiB0cnVlXG59KTtcbnZhciBwbGFjZWhvbGRlcnMgPSAoc3VwZXJDbGFzcyA9PiBjbGFzcyBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuICBwYXJzZVBsYWNlaG9sZGVyKGV4cGVjdGVkTm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLnBsYWNlaG9sZGVyKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMuYXNzZXJ0Tm9TcGFjZShcIlVuZXhwZWN0ZWQgc3BhY2UgaW4gcGxhY2Vob2xkZXIuXCIpO1xuICAgICAgbm9kZS5uYW1lID0gc3VwZXIucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgdGhpcy5hc3NlcnROb1NwYWNlKFwiVW5leHBlY3RlZCBzcGFjZSBpbiBwbGFjZWhvbGRlci5cIik7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5wbGFjZWhvbGRlcik7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hQbGFjZWhvbGRlcihub2RlLCBleHBlY3RlZE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZpbmlzaFBsYWNlaG9sZGVyKG5vZGUsIGV4cGVjdGVkTm9kZSkge1xuICAgIGNvbnN0IGlzRmluaXNoZWQgPSAhIShub2RlLmV4cGVjdGVkTm9kZSAmJiBub2RlLnR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIik7XG4gICAgbm9kZS5leHBlY3RlZE5vZGUgPSBleHBlY3RlZE5vZGU7XG4gICAgcmV0dXJuIGlzRmluaXNoZWQgPyBub2RlIDogdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUGxhY2Vob2xkZXJcIik7XG4gIH1cblxuICBnZXRUb2tlbkZyb21Db2RlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gMzcgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSkgPT09IDM3KSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5wbGFjZWhvbGRlciwgMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmdldFRva2VuRnJvbUNvZGUoLi4uYXJndW1lbnRzKTtcbiAgfVxuXG4gIHBhcnNlRXhwckF0b20oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIkV4cHJlc3Npb25cIikgfHwgc3VwZXIucGFyc2VFeHByQXRvbSguLi5hcmd1bWVudHMpO1xuICB9XG5cbiAgcGFyc2VJZGVudGlmaWVyKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJJZGVudGlmaWVyXCIpIHx8IHN1cGVyLnBhcnNlSWRlbnRpZmllciguLi5hcmd1bWVudHMpO1xuICB9XG5cbiAgY2hlY2tSZXNlcnZlZFdvcmQod29yZCkge1xuICAgIGlmICh3b3JkICE9PSB1bmRlZmluZWQpIHN1cGVyLmNoZWNrUmVzZXJ2ZWRXb3JkKC4uLmFyZ3VtZW50cyk7XG4gIH1cblxuICBwYXJzZUJpbmRpbmdBdG9tKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJQYXR0ZXJuXCIpIHx8IHN1cGVyLnBhcnNlQmluZGluZ0F0b20oLi4uYXJndW1lbnRzKTtcbiAgfVxuXG4gIGNoZWNrTFZhbChleHByKSB7XG4gICAgaWYgKGV4cHIudHlwZSAhPT0gXCJQbGFjZWhvbGRlclwiKSBzdXBlci5jaGVja0xWYWwoLi4uYXJndW1lbnRzKTtcbiAgfVxuXG4gIHRvQXNzaWduYWJsZShub2RlKSB7XG4gICAgaWYgKG5vZGUgJiYgbm9kZS50eXBlID09PSBcIlBsYWNlaG9sZGVyXCIgJiYgbm9kZS5leHBlY3RlZE5vZGUgPT09IFwiRXhwcmVzc2lvblwiKSB7XG4gICAgICBub2RlLmV4cGVjdGVkTm9kZSA9IFwiUGF0dGVyblwiO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnRvQXNzaWduYWJsZSguLi5hcmd1bWVudHMpO1xuICB9XG5cbiAgdmVyaWZ5QnJlYWtDb250aW51ZShub2RlKSB7XG4gICAgaWYgKG5vZGUubGFiZWwgJiYgbm9kZS5sYWJlbC50eXBlID09PSBcIlBsYWNlaG9sZGVyXCIpIHJldHVybjtcbiAgICBzdXBlci52ZXJpZnlCcmVha0NvbnRpbnVlKC4uLmFyZ3VtZW50cyk7XG4gIH1cblxuICBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwcikge1xuICAgIGlmIChleHByLnR5cGUgIT09IFwiUGxhY2Vob2xkZXJcIiB8fCBleHByLmV4dHJhICYmIGV4cHIuZXh0cmEucGFyZW50aGVzaXplZCkge1xuICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCguLi5hcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmNvbG9uKSkge1xuICAgICAgY29uc3Qgc3RtdCA9IG5vZGU7XG4gICAgICBzdG10LmxhYmVsID0gdGhpcy5maW5pc2hQbGFjZWhvbGRlcihleHByLCBcIklkZW50aWZpZXJcIik7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHN0bXQuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJsYWJlbFwiKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoc3RtdCwgXCJMYWJlbGVkU3RhdGVtZW50XCIpO1xuICAgIH1cblxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgbm9kZS5uYW1lID0gZXhwci5uYW1lO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFBsYWNlaG9sZGVyKG5vZGUsIFwiU3RhdGVtZW50XCIpO1xuICB9XG5cbiAgcGFyc2VCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiQmxvY2tTdGF0ZW1lbnRcIikgfHwgc3VwZXIucGFyc2VCbG9jayguLi5hcmd1bWVudHMpO1xuICB9XG5cbiAgcGFyc2VGdW5jdGlvbklkKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJJZGVudGlmaWVyXCIpIHx8IHN1cGVyLnBhcnNlRnVuY3Rpb25JZCguLi5hcmd1bWVudHMpO1xuICB9XG5cbiAgcGFyc2VDbGFzcyhub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCkge1xuICAgIGNvbnN0IHR5cGUgPSBpc1N0YXRlbWVudCA/IFwiQ2xhc3NEZWNsYXJhdGlvblwiIDogXCJDbGFzc0V4cHJlc3Npb25cIjtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnRha2VEZWNvcmF0b3JzKG5vZGUpO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiSWRlbnRpZmllclwiKTtcblxuICAgIGlmIChwbGFjZWhvbGRlcikge1xuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2V4dGVuZHMpIHx8IHRoaXMubWF0Y2godHlwZXMucGxhY2Vob2xkZXIpIHx8IHRoaXMubWF0Y2godHlwZXMuYnJhY2VMKSkge1xuICAgICAgICBub2RlLmlkID0gcGxhY2Vob2xkZXI7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbmFsSWQgfHwgIWlzU3RhdGVtZW50KSB7XG4gICAgICAgIG5vZGUuaWQgPSBudWxsO1xuICAgICAgICBub2RlLmJvZHkgPSB0aGlzLmZpbmlzaFBsYWNlaG9sZGVyKHBsYWNlaG9sZGVyLCBcIkNsYXNzQm9keVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCBcIkEgY2xhc3MgbmFtZSBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQpO1xuICAgIH1cblxuICAgIHRoaXMucGFyc2VDbGFzc1N1cGVyKG5vZGUpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIkNsYXNzQm9keVwiKSB8fCB0aGlzLnBhcnNlQ2xhc3NCb2R5KCEhbm9kZS5zdXBlckNsYXNzKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHR5cGUpO1xuICB9XG5cbiAgcGFyc2VFeHBvcnQobm9kZSkge1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiSWRlbnRpZmllclwiKTtcbiAgICBpZiAoIXBsYWNlaG9sZGVyKSByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnQoLi4uYXJndW1lbnRzKTtcblxuICAgIGlmICghdGhpcy5pc0NvbnRleHR1YWwoXCJmcm9tXCIpICYmICF0aGlzLm1hdGNoKHR5cGVzLmNvbW1hKSkge1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5maW5pc2hQbGFjZWhvbGRlcihwbGFjZWhvbGRlciwgXCJEZWNsYXJhdGlvblwiKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpO1xuICAgIH1cblxuICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZXhwb3J0RGVmYXVsdEZyb21cIik7XG4gICAgY29uc3Qgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBzcGVjaWZpZXIuZXhwb3J0ZWQgPSBwbGFjZWhvbGRlcjtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBbdGhpcy5maW5pc2hOb2RlKHNwZWNpZmllciwgXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCIpXTtcbiAgICByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnQobm9kZSk7XG4gIH1cblxuICBpc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIoKSB7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2RlZmF1bHQpKSB7XG4gICAgICBjb25zdCBuZXh0ID0gdGhpcy5uZXh0VG9rZW5TdGFydCgpO1xuXG4gICAgICBpZiAodGhpcy5pc1VucGFyc2VkQ29udGV4dHVhbChuZXh0LCBcImZyb21cIikpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuc3RhcnRzV2l0aCh0eXBlcy5wbGFjZWhvbGRlci5sYWJlbCwgdGhpcy5uZXh0VG9rZW5TdGFydFNpbmNlKG5leHQgKyA0KSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5pc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIoKTtcbiAgfVxuXG4gIG1heWJlUGFyc2VFeHBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUpIHtcbiAgICBpZiAobm9kZS5zcGVjaWZpZXJzICYmIG5vZGUuc3BlY2lmaWVycy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIubWF5YmVQYXJzZUV4cG9ydERlZmF1bHRTcGVjaWZpZXIoLi4uYXJndW1lbnRzKTtcbiAgfVxuXG4gIGNoZWNrRXhwb3J0KG5vZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzcGVjaWZpZXJzXG4gICAgfSA9IG5vZGU7XG5cbiAgICBpZiAoc3BlY2lmaWVycyA9PSBudWxsID8gdm9pZCAwIDogc3BlY2lmaWVycy5sZW5ndGgpIHtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IHNwZWNpZmllcnMuZmlsdGVyKG5vZGUgPT4gbm9kZS5leHBvcnRlZC50eXBlID09PSBcIlBsYWNlaG9sZGVyXCIpO1xuICAgIH1cblxuICAgIHN1cGVyLmNoZWNrRXhwb3J0KG5vZGUpO1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IHNwZWNpZmllcnM7XG4gIH1cblxuICBwYXJzZUltcG9ydChub2RlKSB7XG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJJZGVudGlmaWVyXCIpO1xuICAgIGlmICghcGxhY2Vob2xkZXIpIHJldHVybiBzdXBlci5wYXJzZUltcG9ydCguLi5hcmd1bWVudHMpO1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuXG4gICAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbChcImZyb21cIikgJiYgIXRoaXMubWF0Y2godHlwZXMuY29tbWEpKSB7XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMuZmluaXNoUGxhY2Vob2xkZXIocGxhY2Vob2xkZXIsIFwiU3RyaW5nTGl0ZXJhbFwiKTtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIik7XG4gICAgfVxuXG4gICAgY29uc3Qgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGVBdE5vZGUocGxhY2Vob2xkZXIpO1xuICAgIHNwZWNpZmllci5sb2NhbCA9IHBsYWNlaG9sZGVyO1xuICAgIHRoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKTtcbiAgICBub2RlLnNwZWNpZmllcnMucHVzaChzcGVjaWZpZXIpO1xuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLmNvbW1hKSkge1xuICAgICAgY29uc3QgaGFzU3RhckltcG9ydCA9IHRoaXMubWF5YmVQYXJzZVN0YXJJbXBvcnRTcGVjaWZpZXIobm9kZSk7XG4gICAgICBpZiAoIWhhc1N0YXJJbXBvcnQpIHRoaXMucGFyc2VOYW1lZEltcG9ydFNwZWNpZmllcnMobm9kZSk7XG4gICAgfVxuXG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiZnJvbVwiKTtcbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VJbXBvcnRTb3VyY2UoKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWNsYXJhdGlvblwiKTtcbiAgfVxuXG4gIHBhcnNlSW1wb3J0U291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJTdHJpbmdMaXRlcmFsXCIpIHx8IHN1cGVyLnBhcnNlSW1wb3J0U291cmNlKC4uLmFyZ3VtZW50cyk7XG4gIH1cblxufSk7XG5cbnZhciB2OGludHJpbnNpYyA9IChzdXBlckNsYXNzID0+IGNsYXNzIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG4gIHBhcnNlVjhJbnRyaW5zaWMoKSB7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMubW9kdWxvKSkge1xuICAgICAgY29uc3QgdjhJbnRyaW5zaWNTdGFydCA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMuZWF0KHR5cGVzLm1vZHVsbyk7XG5cbiAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLm5hbWUpKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUodGhpcy5zdGF0ZS5zdGFydCk7XG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSB0aGlzLmNyZWF0ZUlkZW50aWZpZXIobm9kZSwgbmFtZSk7XG4gICAgICAgIGlkZW50aWZpZXIudHlwZSA9IFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCI7XG5cbiAgICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMucGFyZW5MKSkge1xuICAgICAgICAgIHJldHVybiBpZGVudGlmaWVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudW5leHBlY3RlZCh2OEludHJpbnNpY1N0YXJ0KTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUV4cHJBdG9tKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlVjhJbnRyaW5zaWMoKSB8fCBzdXBlci5wYXJzZUV4cHJBdG9tKC4uLmFyZ3VtZW50cyk7XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIGhhc1BsdWdpbihwbHVnaW5zLCBuYW1lKSB7XG4gIHJldHVybiBwbHVnaW5zLnNvbWUocGx1Z2luID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwbHVnaW4pKSB7XG4gICAgICByZXR1cm4gcGx1Z2luWzBdID09PSBuYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGx1Z2luID09PSBuYW1lO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRQbHVnaW5PcHRpb24ocGx1Z2lucywgbmFtZSwgb3B0aW9uKSB7XG4gIGNvbnN0IHBsdWdpbiA9IHBsdWdpbnMuZmluZChwbHVnaW4gPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBsdWdpbikpIHtcbiAgICAgIHJldHVybiBwbHVnaW5bMF0gPT09IG5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwbHVnaW4gPT09IG5hbWU7XG4gICAgfVxuICB9KTtcblxuICBpZiAocGx1Z2luICYmIEFycmF5LmlzQXJyYXkocGx1Z2luKSkge1xuICAgIHJldHVybiBwbHVnaW5bMV1bb3B0aW9uXTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuY29uc3QgUElQRUxJTkVfUFJPUE9TQUxTID0gW1wibWluaW1hbFwiLCBcInNtYXJ0XCIsIFwiZnNoYXJwXCJdO1xuY29uc3QgUkVDT1JEX0FORF9UVVBMRV9TWU5UQVhfVFlQRVMgPSBbXCJoYXNoXCIsIFwiYmFyXCJdO1xuZnVuY3Rpb24gdmFsaWRhdGVQbHVnaW5zKHBsdWdpbnMpIHtcbiAgaWYgKGhhc1BsdWdpbihwbHVnaW5zLCBcImRlY29yYXRvcnNcIikpIHtcbiAgICBpZiAoaGFzUGx1Z2luKHBsdWdpbnMsIFwiZGVjb3JhdG9ycy1sZWdhY3lcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgdGhlIGRlY29yYXRvcnMgYW5kIGRlY29yYXRvcnMtbGVnYWN5IHBsdWdpbiB0b2dldGhlclwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWNvcmF0b3JzQmVmb3JlRXhwb3J0ID0gZ2V0UGx1Z2luT3B0aW9uKHBsdWdpbnMsIFwiZGVjb3JhdG9yc1wiLCBcImRlY29yYXRvcnNCZWZvcmVFeHBvcnRcIik7XG5cbiAgICBpZiAoZGVjb3JhdG9yc0JlZm9yZUV4cG9ydCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgJ2RlY29yYXRvcnMnIHBsdWdpbiByZXF1aXJlcyBhICdkZWNvcmF0b3JzQmVmb3JlRXhwb3J0JyBvcHRpb24sXCIgKyBcIiB3aG9zZSB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbi4gSWYgeW91IGFyZSBtaWdyYXRpbmcgZnJvbVwiICsgXCIgQmFieWxvbi9CYWJlbCA2IG9yIHdhbnQgdG8gdXNlIHRoZSBvbGQgZGVjb3JhdG9ycyBwcm9wb3NhbCwgeW91XCIgKyBcIiBzaG91bGQgdXNlIHRoZSAnZGVjb3JhdG9ycy1sZWdhY3knIHBsdWdpbiBpbnN0ZWFkIG9mICdkZWNvcmF0b3JzJy5cIik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVjb3JhdG9yc0JlZm9yZUV4cG9ydCAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIidkZWNvcmF0b3JzQmVmb3JlRXhwb3J0JyBtdXN0IGJlIGEgYm9vbGVhbi5cIik7XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhc1BsdWdpbihwbHVnaW5zLCBcImZsb3dcIikgJiYgaGFzUGx1Z2luKHBsdWdpbnMsIFwidHlwZXNjcmlwdFwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21iaW5lIGZsb3cgYW5kIHR5cGVzY3JpcHQgcGx1Z2lucy5cIik7XG4gIH1cblxuICBpZiAoaGFzUGx1Z2luKHBsdWdpbnMsIFwicGxhY2Vob2xkZXJzXCIpICYmIGhhc1BsdWdpbihwbHVnaW5zLCBcInY4aW50cmluc2ljXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmUgcGxhY2Vob2xkZXJzIGFuZCB2OGludHJpbnNpYyBwbHVnaW5zLlwiKTtcbiAgfVxuXG4gIGlmIChoYXNQbHVnaW4ocGx1Z2lucywgXCJwaXBlbGluZU9wZXJhdG9yXCIpICYmICFQSVBFTElORV9QUk9QT1NBTFMuaW5jbHVkZXMoZ2V0UGx1Z2luT3B0aW9uKHBsdWdpbnMsIFwicGlwZWxpbmVPcGVyYXRvclwiLCBcInByb3Bvc2FsXCIpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIidwaXBlbGluZU9wZXJhdG9yJyByZXF1aXJlcyAncHJvcG9zYWwnIG9wdGlvbiB3aG9zZSB2YWx1ZSBzaG91bGQgYmUgb25lIG9mOiBcIiArIFBJUEVMSU5FX1BST1BPU0FMUy5tYXAocCA9PiBgJyR7cH0nYCkuam9pbihcIiwgXCIpKTtcbiAgfVxuXG4gIGlmIChoYXNQbHVnaW4ocGx1Z2lucywgXCJtb2R1bGVBdHRyaWJ1dGVzXCIpKSB7XG4gICAgY29uc3QgbW9kdWxlQXR0cmlidXRlc1ZlcmlvblBsdWdpbk9wdGlvbiA9IGdldFBsdWdpbk9wdGlvbihwbHVnaW5zLCBcIm1vZHVsZUF0dHJpYnV0ZXNcIiwgXCJ2ZXJzaW9uXCIpO1xuXG4gICAgaWYgKG1vZHVsZUF0dHJpYnV0ZXNWZXJpb25QbHVnaW5PcHRpb24gIT09IFwibWF5LTIwMjBcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlICdtb2R1bGVBdHRyaWJ1dGVzJyBwbHVnaW4gcmVxdWlyZXMgYSAndmVyc2lvbicgb3B0aW9uLFwiICsgXCIgcmVwcmVzZW50aW5nIHRoZSBsYXN0IHByb3Bvc2FsIHVwZGF0ZS4gQ3VycmVudGx5LCB0aGVcIiArIFwiIG9ubHkgc3VwcG9ydGVkIHZhbHVlIGlzICdtYXktMjAyMCcuXCIpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoYXNQbHVnaW4ocGx1Z2lucywgXCJyZWNvcmRBbmRUdXBsZVwiKSAmJiAhUkVDT1JEX0FORF9UVVBMRV9TWU5UQVhfVFlQRVMuaW5jbHVkZXMoZ2V0UGx1Z2luT3B0aW9uKHBsdWdpbnMsIFwicmVjb3JkQW5kVHVwbGVcIiwgXCJzeW50YXhUeXBlXCIpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIidyZWNvcmRBbmRUdXBsZScgcmVxdWlyZXMgJ3N5bnRheFR5cGUnIG9wdGlvbiB3aG9zZSB2YWx1ZSBzaG91bGQgYmUgb25lIG9mOiBcIiArIFJFQ09SRF9BTkRfVFVQTEVfU1lOVEFYX1RZUEVTLm1hcChwID0+IGAnJHtwfSdgKS5qb2luKFwiLCBcIikpO1xuICB9XG59XG5jb25zdCBtaXhpblBsdWdpbnMgPSB7XG4gIGVzdHJlZSxcbiAganN4LFxuICBmbG93LFxuICB0eXBlc2NyaXB0LFxuICB2OGludHJpbnNpYyxcbiAgcGxhY2Vob2xkZXJzXG59O1xuY29uc3QgbWl4aW5QbHVnaW5OYW1lcyA9IE9iamVjdC5rZXlzKG1peGluUGx1Z2lucyk7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBzb3VyY2VUeXBlOiBcInNjcmlwdFwiLFxuICBzb3VyY2VGaWxlbmFtZTogdW5kZWZpbmVkLFxuICBzdGFydExpbmU6IDEsXG4gIGFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gIGFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZTogZmFsc2UsXG4gIGFsbG93U3VwZXJPdXRzaWRlTWV0aG9kOiBmYWxzZSxcbiAgYWxsb3dVbmRlY2xhcmVkRXhwb3J0czogZmFsc2UsXG4gIHBsdWdpbnM6IFtdLFxuICBzdHJpY3RNb2RlOiBudWxsLFxuICByYW5nZXM6IGZhbHNlLFxuICB0b2tlbnM6IGZhbHNlLFxuICBjcmVhdGVQYXJlbnRoZXNpemVkRXhwcmVzc2lvbnM6IGZhbHNlLFxuICBlcnJvclJlY292ZXJ5OiBmYWxzZVxufTtcbmZ1bmN0aW9uIGdldE9wdGlvbnMob3B0cykge1xuICBjb25zdCBvcHRpb25zID0ge307XG5cbiAgZm9yIChsZXQgX2kgPSAwLCBfT2JqZWN0JGtleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0T3B0aW9ucyk7IF9pIDwgX09iamVjdCRrZXlzLmxlbmd0aDsgX2krKykge1xuICAgIGNvbnN0IGtleSA9IF9PYmplY3Qka2V5c1tfaV07XG4gICAgb3B0aW9uc1trZXldID0gb3B0cyAmJiBvcHRzW2tleV0gIT0gbnVsbCA/IG9wdHNba2V5XSA6IGRlZmF1bHRPcHRpb25zW2tleV07XG4gIH1cblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuY2xhc3MgU3RhdGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IC0xO1xuICAgIHRoaXMubm9BcnJvd0F0ID0gW107XG4gICAgdGhpcy5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0ID0gW107XG4gICAgdGhpcy5pblBhcmFtZXRlcnMgPSBmYWxzZTtcbiAgICB0aGlzLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSBmYWxzZTtcbiAgICB0aGlzLm1heWJlSW5Bc3luY0Fycm93SGVhZCA9IGZhbHNlO1xuICAgIHRoaXMuaW5QaXBlbGluZSA9IGZhbHNlO1xuICAgIHRoaXMuaW5UeXBlID0gZmFsc2U7XG4gICAgdGhpcy5ub0Fub25GdW5jdGlvblR5cGUgPSBmYWxzZTtcbiAgICB0aGlzLmluUHJvcGVydHlOYW1lID0gZmFsc2U7XG4gICAgdGhpcy5oYXNGbG93Q29tbWVudCA9IGZhbHNlO1xuICAgIHRoaXMuaXNJdGVyYXRvciA9IGZhbHNlO1xuICAgIHRoaXMudG9waWNDb250ZXh0ID0ge1xuICAgICAgbWF4TnVtT2ZSZXNvbHZhYmxlVG9waWNzOiAwLFxuICAgICAgbWF4VG9waWNJbmRleDogbnVsbFxuICAgIH07XG4gICAgdGhpcy5zb2xvQXdhaXQgPSBmYWxzZTtcbiAgICB0aGlzLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gZmFsc2U7XG4gICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICB0aGlzLmRlY29yYXRvclN0YWNrID0gW1tdXTtcbiAgICB0aGlzLnlpZWxkUG9zID0gLTE7XG4gICAgdGhpcy5hd2FpdFBvcyA9IC0xO1xuICAgIHRoaXMuY29tbWVudHMgPSBbXTtcbiAgICB0aGlzLnRyYWlsaW5nQ29tbWVudHMgPSBbXTtcbiAgICB0aGlzLmxlYWRpbmdDb21tZW50cyA9IFtdO1xuICAgIHRoaXMuY29tbWVudFN0YWNrID0gW107XG4gICAgdGhpcy5jb21tZW50UHJldmlvdXNOb2RlID0gbnVsbDtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5saW5lU3RhcnQgPSAwO1xuICAgIHRoaXMudHlwZSA9IHR5cGVzLmVvZjtcbiAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLmVuZCA9IDA7XG4gICAgdGhpcy5sYXN0VG9rRW5kTG9jID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb2tTdGFydExvYyA9IG51bGw7XG4gICAgdGhpcy5sYXN0VG9rU3RhcnQgPSAwO1xuICAgIHRoaXMubGFzdFRva0VuZCA9IDA7XG4gICAgdGhpcy5jb250ZXh0ID0gW3R5cGVzJDEuYnJhY2VTdGF0ZW1lbnRdO1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICAgIHRoaXMuY29udGFpbnNFc2MgPSBmYWxzZTtcbiAgICB0aGlzLm9jdGFsUG9zaXRpb25zID0gW107XG4gICAgdGhpcy5leHBvcnRlZElkZW50aWZpZXJzID0gW107XG4gICAgdGhpcy50b2tlbnNMZW5ndGggPSAwO1xuICB9XG5cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgdGhpcy5zdHJpY3QgPSBvcHRpb25zLnN0cmljdE1vZGUgPT09IGZhbHNlID8gZmFsc2UgOiBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG4gICAgdGhpcy5jdXJMaW5lID0gb3B0aW9ucy5zdGFydExpbmU7XG4gICAgdGhpcy5zdGFydExvYyA9IHRoaXMuZW5kTG9jID0gdGhpcy5jdXJQb3NpdGlvbigpO1xuICB9XG5cbiAgY3VyUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmN1ckxpbmUsIHRoaXMucG9zIC0gdGhpcy5saW5lU3RhcnQpO1xuICB9XG5cbiAgY2xvbmUoc2tpcEFycmF5cykge1xuICAgIGNvbnN0IHN0YXRlID0gbmV3IFN0YXRlKCk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBsZXQgdmFsID0gdGhpc1trZXldO1xuXG4gICAgICBpZiAoIXNraXBBcnJheXMgJiYgQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhbCA9IHZhbC5zbGljZSgpO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZVtrZXldID0gdmFsO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG59XG5cbnZhciBfaXNEaWdpdCA9IGZ1bmN0aW9uIGlzRGlnaXQoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3O1xufTtcbmNvbnN0IFZBTElEX1JFR0VYX0ZMQUdTID0gbmV3IFNldChbXCJnXCIsIFwibVwiLCBcInNcIiwgXCJpXCIsIFwieVwiLCBcInVcIl0pO1xuY29uc3QgZm9yYmlkZGVuTnVtZXJpY1NlcGFyYXRvclNpYmxpbmdzID0ge1xuICBkZWNCaW5PY3Q6IFs0NiwgNjYsIDY5LCA3OSwgOTUsIDk4LCAxMDEsIDExMV0sXG4gIGhleDogWzQ2LCA4OCwgOTUsIDEyMF1cbn07XG5jb25zdCBhbGxvd2VkTnVtZXJpY1NlcGFyYXRvclNpYmxpbmdzID0ge307XG5hbGxvd2VkTnVtZXJpY1NlcGFyYXRvclNpYmxpbmdzLmJpbiA9IFs0OCwgNDldO1xuYWxsb3dlZE51bWVyaWNTZXBhcmF0b3JTaWJsaW5ncy5vY3QgPSBbLi4uYWxsb3dlZE51bWVyaWNTZXBhcmF0b3JTaWJsaW5ncy5iaW4sIDUwLCA1MSwgNTIsIDUzLCA1NCwgNTVdO1xuYWxsb3dlZE51bWVyaWNTZXBhcmF0b3JTaWJsaW5ncy5kZWMgPSBbLi4uYWxsb3dlZE51bWVyaWNTZXBhcmF0b3JTaWJsaW5ncy5vY3QsIDU2LCA1N107XG5hbGxvd2VkTnVtZXJpY1NlcGFyYXRvclNpYmxpbmdzLmhleCA9IFsuLi5hbGxvd2VkTnVtZXJpY1NlcGFyYXRvclNpYmxpbmdzLmRlYywgNjUsIDY2LCA2NywgNjgsIDY5LCA3MCwgOTcsIDk4LCA5OSwgMTAwLCAxMDEsIDEwMl07XG5jbGFzcyBUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKHN0YXRlKSB7XG4gICAgdGhpcy50eXBlID0gc3RhdGUudHlwZTtcbiAgICB0aGlzLnZhbHVlID0gc3RhdGUudmFsdWU7XG4gICAgdGhpcy5zdGFydCA9IHN0YXRlLnN0YXJ0O1xuICAgIHRoaXMuZW5kID0gc3RhdGUuZW5kO1xuICAgIHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHN0YXRlLnN0YXJ0TG9jLCBzdGF0ZS5lbmRMb2MpO1xuICB9XG5cbn1cbmNsYXNzIFRva2VuaXplciBleHRlbmRzIFBhcnNlckVycm9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgaW5wdXQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgdGhpcy5zdGF0ZSA9IG5ldyBTdGF0ZSgpO1xuICAgIHRoaXMuc3RhdGUuaW5pdChvcHRpb25zKTtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgdGhpcy5pc0xvb2thaGVhZCA9IGZhbHNlO1xuICB9XG5cbiAgcHVzaFRva2VuKHRva2VuKSB7XG4gICAgdGhpcy50b2tlbnMubGVuZ3RoID0gdGhpcy5zdGF0ZS50b2tlbnNMZW5ndGg7XG4gICAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gICAgKyt0aGlzLnN0YXRlLnRva2Vuc0xlbmd0aDtcbiAgfVxuXG4gIG5leHQoKSB7XG4gICAgaWYgKCF0aGlzLmlzTG9va2FoZWFkKSB7XG4gICAgICB0aGlzLmNoZWNrS2V5d29yZEVzY2FwZXMoKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50b2tlbnMpIHtcbiAgICAgICAgdGhpcy5wdXNoVG9rZW4obmV3IFRva2VuKHRoaXMuc3RhdGUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLmxhc3RUb2tFbmQgPSB0aGlzLnN0YXRlLmVuZDtcbiAgICB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydCA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jID0gdGhpcy5zdGF0ZS5lbmRMb2M7XG4gICAgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHRoaXMubmV4dFRva2VuKCk7XG4gIH1cblxuICBlYXQodHlwZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKHR5cGUpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgbWF0Y2godHlwZSkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnR5cGUgPT09IHR5cGU7XG4gIH1cblxuICBsb29rYWhlYWQoKSB7XG4gICAgY29uc3Qgb2xkID0gdGhpcy5zdGF0ZTtcbiAgICB0aGlzLnN0YXRlID0gb2xkLmNsb25lKHRydWUpO1xuICAgIHRoaXMuaXNMb29rYWhlYWQgPSB0cnVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuaXNMb29rYWhlYWQgPSBmYWxzZTtcbiAgICBjb25zdCBjdXJyID0gdGhpcy5zdGF0ZTtcbiAgICB0aGlzLnN0YXRlID0gb2xkO1xuICAgIHJldHVybiBjdXJyO1xuICB9XG5cbiAgbmV4dFRva2VuU3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubmV4dFRva2VuU3RhcnRTaW5jZSh0aGlzLnN0YXRlLnBvcyk7XG4gIH1cblxuICBuZXh0VG9rZW5TdGFydFNpbmNlKHBvcykge1xuICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHBvcztcbiAgICBjb25zdCBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgICByZXR1cm4gcG9zICsgc2tpcFswXS5sZW5ndGg7XG4gIH1cblxuICBsb29rYWhlYWRDaGFyQ29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMubmV4dFRva2VuU3RhcnQoKSk7XG4gIH1cblxuICBzZXRTdHJpY3Qoc3RyaWN0KSB7XG4gICAgdGhpcy5zdGF0ZS5zdHJpY3QgPSBzdHJpY3Q7XG4gICAgaWYgKCF0aGlzLm1hdGNoKHR5cGVzLm51bSkgJiYgIXRoaXMubWF0Y2godHlwZXMuc3RyaW5nKSkgcmV0dXJuO1xuICAgIHRoaXMuc3RhdGUucG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcblxuICAgIHdoaWxlICh0aGlzLnN0YXRlLnBvcyA8IHRoaXMuc3RhdGUubGluZVN0YXJ0KSB7XG4gICAgICB0aGlzLnN0YXRlLmxpbmVTdGFydCA9IHRoaXMuaW5wdXQubGFzdEluZGV4T2YoXCJcXG5cIiwgdGhpcy5zdGF0ZS5saW5lU3RhcnQgLSAyKSArIDE7XG4gICAgICAtLXRoaXMuc3RhdGUuY3VyTGluZTtcbiAgICB9XG5cbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICB9XG5cbiAgY3VyQ29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5jb250ZXh0W3RoaXMuc3RhdGUuY29udGV4dC5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIG5leHRUb2tlbigpIHtcbiAgICBjb25zdCBjdXJDb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gICAgaWYgKCEoY3VyQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogY3VyQ29udGV4dC5wcmVzZXJ2ZVNwYWNlKSkgdGhpcy5za2lwU3BhY2UoKTtcbiAgICB0aGlzLnN0YXRlLm9jdGFsUG9zaXRpb25zID0gW107XG4gICAgdGhpcy5zdGF0ZS5zdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIHRoaXMuc3RhdGUuc3RhcnRMb2MgPSB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCk7XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZW9mKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBvdmVycmlkZSA9IGN1ckNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IGN1ckNvbnRleHQub3ZlcnJpZGU7XG5cbiAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgIG92ZXJyaWRlKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdldFRva2VuRnJvbUNvZGUodGhpcy5pbnB1dC5jb2RlUG9pbnRBdCh0aGlzLnN0YXRlLnBvcykpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2hDb21tZW50KGJsb2NrLCB0ZXh0LCBzdGFydCwgZW5kLCBzdGFydExvYywgZW5kTG9jKSB7XG4gICAgY29uc3QgY29tbWVudCA9IHtcbiAgICAgIHR5cGU6IGJsb2NrID8gXCJDb21tZW50QmxvY2tcIiA6IFwiQ29tbWVudExpbmVcIixcbiAgICAgIHZhbHVlOiB0ZXh0LFxuICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgZW5kOiBlbmQsXG4gICAgICBsb2M6IG5ldyBTb3VyY2VMb2NhdGlvbihzdGFydExvYywgZW5kTG9jKVxuICAgIH07XG4gICAgaWYgKHRoaXMub3B0aW9ucy50b2tlbnMpIHRoaXMucHVzaFRva2VuKGNvbW1lbnQpO1xuICAgIHRoaXMuc3RhdGUuY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICB0aGlzLmFkZENvbW1lbnQoY29tbWVudCk7XG4gIH1cblxuICBza2lwQmxvY2tDb21tZW50KCkge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgY29uc3QgZW5kID0gdGhpcy5pbnB1dC5pbmRleE9mKFwiKi9cIiwgdGhpcy5zdGF0ZS5wb3MgKyAyKTtcbiAgICBpZiAoZW5kID09PSAtMSkgdGhyb3cgdGhpcy5yYWlzZShzdGFydCwgRXJyb3JNZXNzYWdlcy5VbnRlcm1pbmF0ZWRDb21tZW50KTtcbiAgICB0aGlzLnN0YXRlLnBvcyA9IGVuZCArIDI7XG4gICAgbGluZUJyZWFrRy5sYXN0SW5kZXggPSBzdGFydDtcbiAgICBsZXQgbWF0Y2g7XG5cbiAgICB3aGlsZSAoKG1hdGNoID0gbGluZUJyZWFrRy5leGVjKHRoaXMuaW5wdXQpKSAmJiBtYXRjaC5pbmRleCA8IHRoaXMuc3RhdGUucG9zKSB7XG4gICAgICArK3RoaXMuc3RhdGUuY3VyTGluZTtcbiAgICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNMb29rYWhlYWQpIHJldHVybjtcbiAgICB0aGlzLnB1c2hDb21tZW50KHRydWUsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyAyLCBlbmQpLCBzdGFydCwgdGhpcy5zdGF0ZS5wb3MsIHN0YXJ0TG9jLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICB9XG5cbiAgc2tpcExpbmVDb21tZW50KHN0YXJ0U2tpcCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCk7XG4gICAgbGV0IGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICs9IHN0YXJ0U2tpcCk7XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgd2hpbGUgKCFpc05ld0xpbmUoY2gpICYmICsrdGhpcy5zdGF0ZS5wb3MgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNMb29rYWhlYWQpIHJldHVybjtcbiAgICB0aGlzLnB1c2hDb21tZW50KGZhbHNlLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgc3RhcnRTa2lwLCB0aGlzLnN0YXRlLnBvcyksIHN0YXJ0LCB0aGlzLnN0YXRlLnBvcywgc3RhcnRMb2MsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gIH1cblxuICBza2lwU3BhY2UoKSB7XG4gICAgbG9vcDogd2hpbGUgKHRoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcblxuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIDMyOlxuICAgICAgICBjYXNlIDE2MDpcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSkgPT09IDEwKSB7XG4gICAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIDEwOlxuICAgICAgICBjYXNlIDgyMzI6XG4gICAgICAgIGNhc2UgODIzMzpcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgICsrdGhpcy5zdGF0ZS5jdXJMaW5lO1xuICAgICAgICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpKSB7XG4gICAgICAgICAgICBjYXNlIDQyOlxuICAgICAgICAgICAgICB0aGlzLnNraXBCbG9ja0NvbW1lbnQoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDIpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoY2gpKSB7XG4gICAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIH1cblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZpbmlzaFRva2VuKHR5cGUsIHZhbCkge1xuICAgIHRoaXMuc3RhdGUuZW5kID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgdGhpcy5zdGF0ZS5lbmRMb2MgPSB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCk7XG4gICAgY29uc3QgcHJldlR5cGUgPSB0aGlzLnN0YXRlLnR5cGU7XG4gICAgdGhpcy5zdGF0ZS50eXBlID0gdHlwZTtcbiAgICB0aGlzLnN0YXRlLnZhbHVlID0gdmFsO1xuICAgIGlmICghdGhpcy5pc0xvb2thaGVhZCkgdGhpcy51cGRhdGVDb250ZXh0KHByZXZUeXBlKTtcbiAgfVxuXG4gIHJlYWRUb2tlbl9udW1iZXJTaWduKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnBvcyA9PT0gMCAmJiB0aGlzLnJlYWRUb2tlbl9pbnRlcnByZXRlcigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbmV4dFBvcyA9IHRoaXMuc3RhdGUucG9zICsgMTtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHRQb3MpO1xuXG4gICAgaWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1Nykge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnBvcywgRXJyb3JNZXNzYWdlcy5VbmV4cGVjdGVkRGlnaXRBZnRlckhhc2gpO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSAxMjMgfHwgbmV4dCA9PT0gOTEgJiYgdGhpcy5oYXNQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKSkge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKTtcblxuICAgICAgaWYgKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicmVjb3JkQW5kVHVwbGVcIiwgXCJzeW50YXhUeXBlXCIpICE9PSBcImhhc2hcIikge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKHRoaXMuc3RhdGUucG9zLCBuZXh0ID09PSAxMjMgPyBFcnJvck1lc3NhZ2VzLlJlY29yZEV4cHJlc3Npb25IYXNoSW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlIDogRXJyb3JNZXNzYWdlcy5UdXBsZUV4cHJlc3Npb25IYXNoSW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHQgPT09IDEyMykge1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNlSGFzaEwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFja2V0SGFzaEwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKHR5cGVzLmhhc2gsIDEpO1xuICAgIH1cbiAgfVxuXG4gIHJlYWRUb2tlbl9kb3QoKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuXG4gICAgaWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1Nykge1xuICAgICAgdGhpcy5yZWFkTnVtYmVyKHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSA0NiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAyKSA9PT0gNDYpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zICs9IDM7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmVsbGlwc2lzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZG90KTtcbiAgICB9XG4gIH1cblxuICByZWFkVG9rZW5fc2xhc2goKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgJiYgIXRoaXMuc3RhdGUuaW5UeXBlKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgdGhpcy5yZWFkUmVnZXhwKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuXG4gICAgaWYgKG5leHQgPT09IDYxKSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmluaXNoT3AodHlwZXMuc2xhc2gsIDEpO1xuICAgIH1cbiAgfVxuXG4gIHJlYWRUb2tlbl9pbnRlcnByZXRlcigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5wb3MgIT09IDAgfHwgdGhpcy5sZW5ndGggPCAyKSByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKGNoICE9PSAzMykgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgdGhpcy5zdGF0ZS5wb3MgKz0gMTtcblxuICAgIHdoaWxlICghaXNOZXdMaW5lKGNoKSAmJiArK3RoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyAyLCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgdGhpcy5maW5pc2hUb2tlbih0eXBlcy5pbnRlcnByZXRlckRpcmVjdGl2ZSwgdmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmVhZFRva2VuX211bHRfbW9kdWxvKGNvZGUpIHtcbiAgICBsZXQgdHlwZSA9IGNvZGUgPT09IDQyID8gdHlwZXMuc3RhciA6IHR5cGVzLm1vZHVsbztcbiAgICBsZXQgd2lkdGggPSAxO1xuICAgIGxldCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgY29uc3QgZXhwckFsbG93ZWQgPSB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkO1xuXG4gICAgaWYgKGNvZGUgPT09IDQyICYmIG5leHQgPT09IDQyKSB7XG4gICAgICB3aWR0aCsrO1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpO1xuICAgICAgdHlwZSA9IHR5cGVzLmV4cG9uZW50O1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSA2MSAmJiAhZXhwckFsbG93ZWQpIHtcbiAgICAgIHdpZHRoKys7XG4gICAgICB0eXBlID0gdHlwZXMuYXNzaWduO1xuICAgIH1cblxuICAgIHRoaXMuZmluaXNoT3AodHlwZSwgd2lkdGgpO1xuICB9XG5cbiAgcmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG5cbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpID09PSA2MSkge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IHR5cGVzLmxvZ2ljYWxPUiA6IHR5cGVzLmxvZ2ljYWxBTkQsIDIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDEyNCkge1xuICAgICAgaWYgKG5leHQgPT09IDYyKSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AodHlwZXMucGlwZWxpbmUsIDIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpICYmIG5leHQgPT09IDEyNSkge1xuICAgICAgICBpZiAodGhpcy5nZXRQbHVnaW5PcHRpb24oXCJyZWNvcmRBbmRUdXBsZVwiLCBcInN5bnRheFR5cGVcIikgIT09IFwiYmFyXCIpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKHRoaXMuc3RhdGUucG9zLCBFcnJvck1lc3NhZ2VzLlJlY29yZEV4cHJlc3Npb25CYXJJbmNvcnJlY3RFbmRTeW50YXhUeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmluaXNoT3AodHlwZXMuYnJhY2VCYXJSLCAyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKSAmJiBuZXh0ID09PSA5Mykge1xuICAgICAgICBpZiAodGhpcy5nZXRQbHVnaW5PcHRpb24oXCJyZWNvcmRBbmRUdXBsZVwiLCBcInN5bnRheFR5cGVcIikgIT09IFwiYmFyXCIpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKHRoaXMuc3RhdGUucG9zLCBFcnJvck1lc3NhZ2VzLlR1cGxlRXhwcmVzc2lvbkJhckluY29ycmVjdEVuZFN5bnRheFR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maW5pc2hPcCh0eXBlcy5icmFja2V0QmFyUiwgMik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IHR5cGVzLmJpdHdpc2VPUiA6IHR5cGVzLmJpdHdpc2VBTkQsIDEpO1xuICB9XG5cbiAgcmVhZFRva2VuX2NhcmV0KCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcblxuICAgIGlmIChuZXh0ID09PSA2MSkge1xuICAgICAgdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKHR5cGVzLmJpdHdpc2VYT1IsIDEpO1xuICAgIH1cbiAgfVxuXG4gIHJlYWRUb2tlbl9wbHVzX21pbihjb2RlKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuXG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIGlmIChuZXh0ID09PSA0NSAmJiAhdGhpcy5pbk1vZHVsZSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAyKSA9PT0gNjIgJiYgKHRoaXMuc3RhdGUubGFzdFRva0VuZCA9PT0gMCB8fCBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhdGUubGFzdFRva0VuZCwgdGhpcy5zdGF0ZS5wb3MpKSkpIHtcbiAgICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoMyk7XG4gICAgICAgIHRoaXMuc2tpcFNwYWNlKCk7XG4gICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5maW5pc2hPcCh0eXBlcy5pbmNEZWMsIDIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSA2MSkge1xuICAgICAgdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKHR5cGVzLnBsdXNNaW4sIDEpO1xuICAgIH1cbiAgfVxuXG4gIHJlYWRUb2tlbl9sdF9ndChjb2RlKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuICAgIGxldCBzaXplID0gMTtcblxuICAgIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgICBzaXplID0gY29kZSA9PT0gNjIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMikgPT09IDYyID8gMyA6IDI7XG5cbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyBzaXplKSA9PT0gNjEpIHtcbiAgICAgICAgdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIHNpemUgKyAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZpbmlzaE9wKHR5cGVzLmJpdFNoaWZ0LCBzaXplKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gMzMgJiYgY29kZSA9PT0gNjAgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMikgPT09IDQ1ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDMpID09PSA0NSkge1xuICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoNCk7XG4gICAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHNpemUgPSAyO1xuICAgIH1cblxuICAgIHRoaXMuZmluaXNoT3AodHlwZXMucmVsYXRpb25hbCwgc2l6ZSk7XG4gIH1cblxuICByZWFkVG9rZW5fZXFfZXhjbChjb2RlKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuXG4gICAgaWYgKG5leHQgPT09IDYxKSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKHR5cGVzLmVxdWFsaXR5LCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAyKSA9PT0gNjEgPyAzIDogMik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDYxICYmIG5leHQgPT09IDYyKSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbih0eXBlcy5hcnJvdyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5maW5pc2hPcChjb2RlID09PSA2MSA/IHR5cGVzLmVxIDogdHlwZXMuYmFuZywgMSk7XG4gIH1cblxuICByZWFkVG9rZW5fcXVlc3Rpb24oKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuICAgIGNvbnN0IG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMik7XG5cbiAgICBpZiAobmV4dCA9PT0gNjMgJiYgIXRoaXMuc3RhdGUuaW5UeXBlKSB7XG4gICAgICBpZiAobmV4dDIgPT09IDYxKSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AodHlwZXMubnVsbGlzaENvYWxlc2NpbmcsIDIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gNDYgJiYgIShuZXh0MiA+PSA0OCAmJiBuZXh0MiA8PSA1NykpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnF1ZXN0aW9uRG90KTtcbiAgICB9IGVsc2Uge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucXVlc3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIGdldFRva2VuRnJvbUNvZGUoY29kZSkge1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSA0NjpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fZG90KCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSA0MDpcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbih0eXBlcy5wYXJlbkwpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgNDE6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucGFyZW5SKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIDU5OlxuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnNlbWkpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgNDQ6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuY29tbWEpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgOTE6XG4gICAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpID09PSAxMjQpIHtcbiAgICAgICAgICBpZiAodGhpcy5nZXRQbHVnaW5PcHRpb24oXCJyZWNvcmRBbmRUdXBsZVwiLCBcInN5bnRheFR5cGVcIikgIT09IFwiYmFyXCIpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucmFpc2UodGhpcy5zdGF0ZS5wb3MsIEVycm9yTWVzc2FnZXMuVHVwbGVFeHByZXNzaW9uQmFySW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNrZXRCYXJMKTtcbiAgICAgICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFja2V0TCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgOTM6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2tldFIpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgMTIzOlxuICAgICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSA9PT0gMTI0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicmVjb3JkQW5kVHVwbGVcIiwgXCJzeW50YXhUeXBlXCIpICE9PSBcImJhclwiKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKHRoaXMuc3RhdGUucG9zLCBFcnJvck1lc3NhZ2VzLlJlY29yZEV4cHJlc3Npb25CYXJJbmNvcnJlY3RTdGFydFN5bnRheFR5cGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2VCYXJMKTtcbiAgICAgICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFjZUwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIDEyNTpcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFjZVIpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgNTg6XG4gICAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImZ1bmN0aW9uQmluZFwiKSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSA9PT0gNTgpIHtcbiAgICAgICAgICB0aGlzLmZpbmlzaE9wKHR5cGVzLmRvdWJsZUNvbG9uLCAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuY29sb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIDYzOlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9xdWVzdGlvbigpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgOTY6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYmFja1F1b3RlKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIDQ4OlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuXG4gICAgICAgICAgaWYgKG5leHQgPT09IDEyMCB8fCBuZXh0ID09PSA4OCkge1xuICAgICAgICAgICAgdGhpcy5yZWFkUmFkaXhOdW1iZXIoMTYpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXh0ID09PSAxMTEgfHwgbmV4dCA9PT0gNzkpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFJhZGl4TnVtYmVyKDgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXh0ID09PSA5OCB8fCBuZXh0ID09PSA2Nikge1xuICAgICAgICAgICAgdGhpcy5yZWFkUmFkaXhOdW1iZXIoMik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgNDk6XG4gICAgICBjYXNlIDUwOlxuICAgICAgY2FzZSA1MTpcbiAgICAgIGNhc2UgNTI6XG4gICAgICBjYXNlIDUzOlxuICAgICAgY2FzZSA1NDpcbiAgICAgIGNhc2UgNTU6XG4gICAgICBjYXNlIDU2OlxuICAgICAgY2FzZSA1NzpcbiAgICAgICAgdGhpcy5yZWFkTnVtYmVyKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIDM0OlxuICAgICAgY2FzZSAzOTpcbiAgICAgICAgdGhpcy5yZWFkU3RyaW5nKGNvZGUpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgNDc6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX3NsYXNoKCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSAzNzpcbiAgICAgIGNhc2UgNDI6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX211bHRfbW9kdWxvKGNvZGUpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgMTI0OlxuICAgICAgY2FzZSAzODpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fcGlwZV9hbXAoY29kZSk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSA5NDpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fY2FyZXQoKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIDQzOlxuICAgICAgY2FzZSA0NTpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fcGx1c19taW4oY29kZSk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSA2MDpcbiAgICAgIGNhc2UgNjI6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX2x0X2d0KGNvZGUpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgNjE6XG4gICAgICBjYXNlIDMzOlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9lcV9leGNsKGNvZGUpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgMTI2OlxuICAgICAgICB0aGlzLmZpbmlzaE9wKHR5cGVzLnRpbGRlLCAxKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIDY0OlxuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmF0KTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIDM1OlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9udW1iZXJTaWduKCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSA5MjpcbiAgICAgICAgdGhpcy5yZWFkV29yZCgpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjb2RlKSkge1xuICAgICAgICAgIHRoaXMucmVhZFdvcmQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRocm93IHRoaXMucmFpc2UodGhpcy5zdGF0ZS5wb3MsIEVycm9yTWVzc2FnZXMuSW52YWxpZE9yVW5leHBlY3RlZFRva2VuLCBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKSk7XG4gIH1cblxuICBmaW5pc2hPcCh0eXBlLCBzaXplKSB7XG4gICAgY29uc3Qgc3RyID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXRlLnBvcywgdGhpcy5zdGF0ZS5wb3MgKyBzaXplKTtcbiAgICB0aGlzLnN0YXRlLnBvcyArPSBzaXplO1xuICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgc3RyKTtcbiAgfVxuXG4gIHJlYWRSZWdleHAoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICBsZXQgZXNjYXBlZCwgaW5DbGFzcztcblxuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLnBvcyA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKHN0YXJ0LCBFcnJvck1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoID0gdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5zdGF0ZS5wb3MpO1xuXG4gICAgICBpZiAobGluZUJyZWFrLnRlc3QoY2gpKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2Uoc3RhcnQsIEVycm9yTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNoID09PSBcIltcIikge1xuICAgICAgICAgIGluQ2xhc3MgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIl1cIiAmJiBpbkNsYXNzKSB7XG4gICAgICAgICAgaW5DbGFzcyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIi9cIiAmJiAhaW5DbGFzcykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZXNjYXBlZCA9IGNoID09PSBcIlxcXFxcIjtcbiAgICAgIH1cblxuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgbGV0IG1vZHMgPSBcIlwiO1xuXG4gICAgd2hpbGUgKHRoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNoYXIgPSB0aGlzLmlucHV0W3RoaXMuc3RhdGUucG9zXTtcbiAgICAgIGNvbnN0IGNoYXJDb2RlID0gdGhpcy5pbnB1dC5jb2RlUG9pbnRBdCh0aGlzLnN0YXRlLnBvcyk7XG5cbiAgICAgIGlmIChWQUxJRF9SRUdFWF9GTEFHUy5oYXMoY2hhcikpIHtcbiAgICAgICAgaWYgKG1vZHMuaW5kZXhPZihjaGFyKSA+IC0xKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnBvcyArIDEsIEVycm9yTWVzc2FnZXMuRHVwbGljYXRlUmVnRXhwRmxhZ3MpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzSWRlbnRpZmllckNoYXIoY2hhckNvZGUpIHx8IGNoYXJDb2RlID09PSA5Mikge1xuICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUucG9zICsgMSwgRXJyb3JNZXNzYWdlcy5NYWxmb3JtZWRSZWdFeHBGbGFncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIG1vZHMgKz0gY2hhcjtcbiAgICB9XG5cbiAgICB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnJlZ2V4cCwge1xuICAgICAgcGF0dGVybjogY29udGVudCxcbiAgICAgIGZsYWdzOiBtb2RzXG4gICAgfSk7XG4gIH1cblxuICByZWFkSW50KHJhZGl4LCBsZW4sIGZvcmNlTGVuLCBhbGxvd051bVNlcGFyYXRvciA9IHRydWUpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGNvbnN0IGZvcmJpZGRlblNpYmxpbmdzID0gcmFkaXggPT09IDE2ID8gZm9yYmlkZGVuTnVtZXJpY1NlcGFyYXRvclNpYmxpbmdzLmhleCA6IGZvcmJpZGRlbk51bWVyaWNTZXBhcmF0b3JTaWJsaW5ncy5kZWNCaW5PY3Q7XG4gICAgY29uc3QgYWxsb3dlZFNpYmxpbmdzID0gcmFkaXggPT09IDE2ID8gYWxsb3dlZE51bWVyaWNTZXBhcmF0b3JTaWJsaW5ncy5oZXggOiByYWRpeCA9PT0gMTAgPyBhbGxvd2VkTnVtZXJpY1NlcGFyYXRvclNpYmxpbmdzLmRlYyA6IHJhZGl4ID09PSA4ID8gYWxsb3dlZE51bWVyaWNTZXBhcmF0b3JTaWJsaW5ncy5vY3QgOiBhbGxvd2VkTnVtZXJpY1NlcGFyYXRvclNpYmxpbmdzLmJpbjtcbiAgICBsZXQgaW52YWxpZCA9IGZhbHNlO1xuICAgIGxldCB0b3RhbCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgZSA9IGxlbiA9PSBudWxsID8gSW5maW5pdHkgOiBsZW47IGkgPCBlOyArK2kpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgbGV0IHZhbDtcblxuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwibnVtZXJpY1NlcGFyYXRvclwiKSkge1xuICAgICAgICBpZiAoY29kZSA9PT0gOTUpIHtcbiAgICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zIC0gMSk7XG4gICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuXG4gICAgICAgICAgaWYgKGFsbG93ZWRTaWJsaW5ncy5pbmRleE9mKG5leHQpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnBvcywgRXJyb3JNZXNzYWdlcy5VbmV4cGVjdGVkTnVtZXJpY1NlcGFyYXRvcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChmb3JiaWRkZW5TaWJsaW5ncy5pbmRleE9mKHByZXYpID4gLTEgfHwgZm9yYmlkZGVuU2libGluZ3MuaW5kZXhPZihuZXh0KSA+IC0xIHx8IE51bWJlci5pc05hTihuZXh0KSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnBvcywgRXJyb3JNZXNzYWdlcy5VbmV4cGVjdGVkTnVtZXJpY1NlcGFyYXRvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFhbGxvd051bVNlcGFyYXRvcikge1xuICAgICAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnBvcywgRXJyb3JNZXNzYWdlcy5OdW1lcmljU2VwYXJhdG9ySW5Fc2NhcGVTZXF1ZW5jZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY29kZSA+PSA5Nykge1xuICAgICAgICB2YWwgPSBjb2RlIC0gOTcgKyAxMDtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA+PSA2NSkge1xuICAgICAgICB2YWwgPSBjb2RlIC0gNjUgKyAxMDtcbiAgICAgIH0gZWxzZSBpZiAoX2lzRGlnaXQoY29kZSkpIHtcbiAgICAgICAgdmFsID0gY29kZSAtIDQ4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gSW5maW5pdHk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWwgPj0gcmFkaXgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lcnJvclJlY292ZXJ5ICYmIHZhbCA8PSA5KSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQgKyBpICsgMiwgRXJyb3JNZXNzYWdlcy5JbnZhbGlkRGlnaXQsIHJhZGl4KTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JjZUxlbikge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgICAgaW52YWxpZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIHRvdGFsID0gdG90YWwgKiByYWRpeCArIHZhbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHRoaXMuc3RhdGUucG9zIC0gc3RhcnQgIT09IGxlbiB8fCBpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cblxuICByZWFkUmFkaXhOdW1iZXIocmFkaXgpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGxldCBpc0JpZ0ludCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgY29uc3QgdmFsID0gdGhpcy5yZWFkSW50KHJhZGl4KTtcblxuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0ICsgMiwgRXJyb3JNZXNzYWdlcy5JbnZhbGlkRGlnaXQsIHJhZGl4KTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcblxuICAgIGlmIChuZXh0ID09PSA5NSkge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJudW1lcmljU2VwYXJhdG9yXCIsIHRoaXMuc3RhdGUucG9zKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gMTEwKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgaXNCaWdJbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmlucHV0LmNvZGVQb2ludEF0KHRoaXMuc3RhdGUucG9zKSkpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UodGhpcy5zdGF0ZS5wb3MsIEVycm9yTWVzc2FnZXMuTnVtYmVySWRlbnRpZmllcik7XG4gICAgfVxuXG4gICAgaWYgKGlzQmlnSW50KSB7XG4gICAgICBjb25zdCBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnN0YXRlLnBvcykucmVwbGFjZSgvW19uXS9nLCBcIlwiKTtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYmlnaW50LCBzdHIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZXMubnVtLCB2YWwpO1xuICB9XG5cbiAgcmVhZE51bWJlcihzdGFydHNXaXRoRG90KSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICBsZXQgaXNGbG9hdCA9IGZhbHNlO1xuICAgIGxldCBpc0JpZ0ludCA9IGZhbHNlO1xuICAgIGxldCBpc05vbk9jdGFsRGVjaW1hbEludCA9IGZhbHNlO1xuXG4gICAgaWYgKCFzdGFydHNXaXRoRG90ICYmIHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHtcbiAgICAgIHRoaXMucmFpc2Uoc3RhcnQsIEVycm9yTWVzc2FnZXMuSW52YWxpZE51bWJlcik7XG4gICAgfVxuXG4gICAgbGV0IG9jdGFsID0gdGhpcy5zdGF0ZS5wb3MgLSBzdGFydCA+PSAyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdChzdGFydCkgPT09IDQ4O1xuXG4gICAgaWYgKG9jdGFsKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5zdHJpY3QpIHtcbiAgICAgICAgdGhpcy5yYWlzZShzdGFydCwgRXJyb3JNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoL1s4OV0vLnRlc3QodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5zdGF0ZS5wb3MpKSkge1xuICAgICAgICBvY3RhbCA9IGZhbHNlO1xuICAgICAgICBpc05vbk9jdGFsRGVjaW1hbEludCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpO1xuXG4gICAgaWYgKG5leHQgPT09IDQ2ICYmICFvY3RhbCkge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIHRoaXMucmVhZEludCgxMCk7XG4gICAgICBpc0Zsb2F0ID0gdHJ1ZTtcbiAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpO1xuICAgIH1cblxuICAgIGlmICgobmV4dCA9PT0gNjkgfHwgbmV4dCA9PT0gMTAxKSAmJiAhb2N0YWwpIHtcbiAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnN0YXRlLnBvcyk7XG5cbiAgICAgIGlmIChuZXh0ID09PSA0MyB8fCBuZXh0ID09PSA0NSkge1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkgdGhpcy5yYWlzZShzdGFydCwgRXJyb3JNZXNzYWdlcy5JbnZhbGlkTnVtYmVyKTtcbiAgICAgIGlzRmxvYXQgPSB0cnVlO1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwibnVtZXJpY1NlcGFyYXRvclwiKSAmJiAob2N0YWwgfHwgaXNOb25PY3RhbERlY2ltYWxJbnQpKSB7XG4gICAgICBjb25zdCB1bmRlcnNjb3JlUG9zID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5zdGF0ZS5wb3MpLmluZGV4T2YoXCJfXCIpO1xuXG4gICAgICBpZiAodW5kZXJzY29yZVBvcyA+IDApIHtcbiAgICAgICAgdGhpcy5yYWlzZSh1bmRlcnNjb3JlUG9zICsgc3RhcnQsIEVycm9yTWVzc2FnZXMuWmVyb0RpZ2l0TnVtZXJpY1NlcGFyYXRvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IDk1KSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcIm51bWVyaWNTZXBhcmF0b3JcIiwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSAxMTApIHtcbiAgICAgIGlmIChpc0Zsb2F0IHx8IG9jdGFsIHx8IGlzTm9uT2N0YWxEZWNpbWFsSW50KSB7XG4gICAgICAgIHRoaXMucmFpc2Uoc3RhcnQsIEVycm9yTWVzc2FnZXMuSW52YWxpZEJpZ0ludExpdGVyYWwpO1xuICAgICAgfVxuXG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgaXNCaWdJbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmlucHV0LmNvZGVQb2ludEF0KHRoaXMuc3RhdGUucG9zKSkpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UodGhpcy5zdGF0ZS5wb3MsIEVycm9yTWVzc2FnZXMuTnVtYmVySWRlbnRpZmllcik7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5zdGF0ZS5wb3MpLnJlcGxhY2UoL1tfbl0vZywgXCJcIik7XG5cbiAgICBpZiAoaXNCaWdJbnQpIHtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYmlnaW50LCBzdHIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbCA9IG9jdGFsID8gcGFyc2VJbnQoc3RyLCA4KSA6IHBhcnNlRmxvYXQoc3RyKTtcbiAgICB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLm51bSwgdmFsKTtcbiAgfVxuXG4gIHJlYWRDb2RlUG9pbnQodGhyb3dPbkludmFsaWQpIHtcbiAgICBjb25zdCBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgbGV0IGNvZGU7XG5cbiAgICBpZiAoY2ggPT09IDEyMykge1xuICAgICAgY29uc3QgY29kZVBvcyA9ICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcih0aGlzLmlucHV0LmluZGV4T2YoXCJ9XCIsIHRoaXMuc3RhdGUucG9zKSAtIHRoaXMuc3RhdGUucG9zLCB0cnVlLCB0aHJvd09uSW52YWxpZCk7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuXG4gICAgICBpZiAoY29kZSAhPT0gbnVsbCAmJiBjb2RlID4gMHgxMGZmZmYpIHtcbiAgICAgICAgaWYgKHRocm93T25JbnZhbGlkKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShjb2RlUG9zLCBFcnJvck1lc3NhZ2VzLkludmFsaWRDb2RlUG9pbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKDQsIGZhbHNlLCB0aHJvd09uSW52YWxpZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvZGU7XG4gIH1cblxuICByZWFkU3RyaW5nKHF1b3RlKSB7XG4gICAgbGV0IG91dCA9IFwiXCIsXG4gICAgICAgIGNodW5rU3RhcnQgPSArK3RoaXMuc3RhdGUucG9zO1xuXG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMuc3RhdGUucG9zID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCwgRXJyb3JNZXNzYWdlcy5VbnRlcm1pbmF0ZWRTdHJpbmcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgICBpZiAoY2ggPT09IHF1b3RlKSBicmVhaztcblxuICAgICAgaWYgKGNoID09PSA5Mikge1xuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgIG91dCArPSB0aGlzLnJlYWRFc2NhcGVkQ2hhcihmYWxzZSk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDgyMzIgfHwgY2ggPT09IDgyMzMpIHtcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgKyt0aGlzLnN0YXRlLmN1ckxpbmU7XG4gICAgICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB9IGVsc2UgaWYgKGlzTmV3TGluZShjaCkpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLlVudGVybWluYXRlZFN0cmluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgfVxuICAgIH1cblxuICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKyspO1xuICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuc3RyaW5nLCBvdXQpO1xuICB9XG5cbiAgcmVhZFRtcGxUb2tlbigpIHtcbiAgICBsZXQgb3V0ID0gXCJcIixcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zLFxuICAgICAgICBjb250YWluc0ludmFsaWQgPSBmYWxzZTtcblxuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLnBvcyA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIEVycm9yTWVzc2FnZXMuVW50ZXJtaW5hdGVkVGVtcGxhdGUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG5cbiAgICAgIGlmIChjaCA9PT0gOTYgfHwgY2ggPT09IDM2ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpID09PSAxMjMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucG9zID09PSB0aGlzLnN0YXRlLnN0YXJ0ICYmIHRoaXMubWF0Y2godHlwZXMudGVtcGxhdGUpKSB7XG4gICAgICAgICAgaWYgKGNoID09PSAzNikge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gMjtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZG9sbGFyQnJhY2VMKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYmFja1F1b3RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZXMudGVtcGxhdGUsIGNvbnRhaW5zSW52YWxpZCA/IG51bGwgOiBvdXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gOTIpIHtcbiAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgICBjb25zdCBlc2NhcGVkID0gdGhpcy5yZWFkRXNjYXBlZENoYXIodHJ1ZSk7XG5cbiAgICAgICAgaWYgKGVzY2FwZWQgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250YWluc0ludmFsaWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSBlc2NhcGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgfSBlbHNlIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcblxuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpID09PSAxMCkge1xuICAgICAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIG91dCArPSBcIlxcblwiO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICArK3RoaXMuc3RhdGUuY3VyTGluZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5saW5lU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZWFkRXNjYXBlZENoYXIoaW5UZW1wbGF0ZSkge1xuICAgIGNvbnN0IHRocm93T25JbnZhbGlkID0gIWluVGVtcGxhdGU7XG4gICAgY29uc3QgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnN0YXRlLnBvcyk7XG4gICAgKyt0aGlzLnN0YXRlLnBvcztcblxuICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgIGNhc2UgMTEwOlxuICAgICAgICByZXR1cm4gXCJcXG5cIjtcblxuICAgICAgY2FzZSAxMTQ6XG4gICAgICAgIHJldHVybiBcIlxcclwiO1xuXG4gICAgICBjYXNlIDEyMDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKDIsIGZhbHNlLCB0aHJvd09uSW52YWxpZCk7XG4gICAgICAgICAgcmV0dXJuIGNvZGUgPT09IG51bGwgPyBudWxsIDogU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIDExNzpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLnJlYWRDb2RlUG9pbnQodGhyb3dPbkludmFsaWQpO1xuICAgICAgICAgIHJldHVybiBjb2RlID09PSBudWxsID8gbnVsbCA6IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgMTE2OlxuICAgICAgICByZXR1cm4gXCJcXHRcIjtcblxuICAgICAgY2FzZSA5ODpcbiAgICAgICAgcmV0dXJuIFwiXFxiXCI7XG5cbiAgICAgIGNhc2UgMTE4OlxuICAgICAgICByZXR1cm4gXCJcXHUwMDBiXCI7XG5cbiAgICAgIGNhc2UgMTAyOlxuICAgICAgICByZXR1cm4gXCJcXGZcIjtcblxuICAgICAgY2FzZSAxMzpcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcykgPT09IDEwKSB7XG4gICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIDEwOlxuICAgICAgICB0aGlzLnN0YXRlLmxpbmVTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgICArK3RoaXMuc3RhdGUuY3VyTGluZTtcblxuICAgICAgY2FzZSA4MjMyOlxuICAgICAgY2FzZSA4MjMzOlxuICAgICAgICByZXR1cm4gXCJcIjtcblxuICAgICAgY2FzZSA1NjpcbiAgICAgIGNhc2UgNTc6XG4gICAgICAgIGlmIChpblRlbXBsYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGNoID49IDQ4ICYmIGNoIDw9IDU1KSB7XG4gICAgICAgICAgY29uc3QgY29kZVBvcyA9IHRoaXMuc3RhdGUucG9zIC0gMTtcbiAgICAgICAgICBjb25zdCBtYXRjaCA9IHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMuc3RhdGUucG9zIC0gMSwgMykubWF0Y2goL15bMC03XSsvKTtcbiAgICAgICAgICBsZXQgb2N0YWxTdHIgPSBtYXRjaFswXTtcbiAgICAgICAgICBsZXQgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG5cbiAgICAgICAgICBpZiAob2N0YWwgPiAyNTUpIHtcbiAgICAgICAgICAgIG9jdGFsU3RyID0gb2N0YWxTdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gb2N0YWxTdHIubGVuZ3RoIC0gMTtcbiAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcblxuICAgICAgICAgIGlmIChvY3RhbFN0ciAhPT0gXCIwXCIgfHwgbmV4dCA9PT0gNTYgfHwgbmV4dCA9PT0gNTcpIHtcbiAgICAgICAgICAgIGlmIChpblRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLnN0cmljdCkge1xuICAgICAgICAgICAgICB0aGlzLnJhaXNlKGNvZGVQb3MsIEVycm9yTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUub2N0YWxQb3NpdGlvbnMucHVzaChjb2RlUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvY3RhbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgfVxuICB9XG5cbiAgcmVhZEhleENoYXIobGVuLCBmb3JjZUxlbiwgdGhyb3dPbkludmFsaWQpIHtcbiAgICBjb25zdCBjb2RlUG9zID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgY29uc3QgbiA9IHRoaXMucmVhZEludCgxNiwgbGVuLCBmb3JjZUxlbiwgZmFsc2UpO1xuXG4gICAgaWYgKG4gPT09IG51bGwpIHtcbiAgICAgIGlmICh0aHJvd09uSW52YWxpZCkge1xuICAgICAgICB0aGlzLnJhaXNlKGNvZGVQb3MsIEVycm9yTWVzc2FnZXMuSW52YWxpZEVzY2FwZVNlcXVlbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUucG9zID0gY29kZVBvcyAtIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG47XG4gIH1cblxuICByZWFkV29yZDEoKSB7XG4gICAgbGV0IHdvcmQgPSBcIlwiO1xuICAgIHRoaXMuc3RhdGUuY29udGFpbnNFc2MgPSBmYWxzZTtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGxldCBjaHVua1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG5cbiAgICB3aGlsZSAodGhpcy5zdGF0ZS5wb3MgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgY29uc3QgY2ggPSB0aGlzLmlucHV0LmNvZGVQb2ludEF0KHRoaXMuc3RhdGUucG9zKTtcblxuICAgICAgaWYgKGlzSWRlbnRpZmllckNoYXIoY2gpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUucG9zICs9IGNoIDw9IDB4ZmZmZiA/IDEgOiAyO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmlzSXRlcmF0b3IgJiYgY2ggPT09IDY0KSB7XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSA5Mikge1xuICAgICAgICB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjID0gdHJ1ZTtcbiAgICAgICAgd29yZCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgY29uc3QgZXNjU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgY29uc3QgaWRlbnRpZmllckNoZWNrID0gdGhpcy5zdGF0ZS5wb3MgPT09IHN0YXJ0ID8gaXNJZGVudGlmaWVyU3RhcnQgOiBpc0lkZW50aWZpZXJDaGFyO1xuXG4gICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnN0YXRlLnBvcykgIT09IDExNykge1xuICAgICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5wb3MsIEVycm9yTWVzc2FnZXMuTWlzc2luZ1VuaWNvZGVFc2NhcGUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgY29uc3QgZXNjID0gdGhpcy5yZWFkQ29kZVBvaW50KHRydWUpO1xuXG4gICAgICAgIGlmIChlc2MgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIWlkZW50aWZpZXJDaGVjayhlc2MpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKGVzY1N0YXJ0LCBFcnJvck1lc3NhZ2VzLkVzY2FwZWRDaGFyTm90QW5JZGVudGlmaWVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3b3JkICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGVzYyk7XG4gICAgICAgIH1cblxuICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd29yZCArIHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICB9XG5cbiAgaXNJdGVyYXRvcih3b3JkKSB7XG4gICAgcmV0dXJuIHdvcmQgPT09IFwiQEBpdGVyYXRvclwiIHx8IHdvcmQgPT09IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIH1cblxuICByZWFkV29yZCgpIHtcbiAgICBjb25zdCB3b3JkID0gdGhpcy5yZWFkV29yZDEoKTtcbiAgICBjb25zdCB0eXBlID0ga2V5d29yZHMuZ2V0KHdvcmQpIHx8IHR5cGVzLm5hbWU7XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5pc0l0ZXJhdG9yICYmICghdGhpcy5pc0l0ZXJhdG9yKHdvcmQpIHx8ICF0aGlzLnN0YXRlLmluVHlwZSkpIHtcbiAgICAgIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5wb3MsIEVycm9yTWVzc2FnZXMuSW52YWxpZElkZW50aWZpZXIsIHdvcmQpO1xuICAgIH1cblxuICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgd29yZCk7XG4gIH1cblxuICBjaGVja0tleXdvcmRFc2NhcGVzKCkge1xuICAgIGNvbnN0IGt3ID0gdGhpcy5zdGF0ZS50eXBlLmtleXdvcmQ7XG5cbiAgICBpZiAoa3cgJiYgdGhpcy5zdGF0ZS5jb250YWluc0VzYykge1xuICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLkludmFsaWRFc2NhcGVkUmVzZXJ2ZWRXb3JkLCBrdyk7XG4gICAgfVxuICB9XG5cbiAgYnJhY2VJc0Jsb2NrKHByZXZUeXBlKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5jdXJDb250ZXh0KCk7XG5cbiAgICBpZiAocGFyZW50ID09PSB0eXBlcyQxLmZ1bmN0aW9uRXhwcmVzc2lvbiB8fCBwYXJlbnQgPT09IHR5cGVzJDEuZnVuY3Rpb25TdGF0ZW1lbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuY29sb24gJiYgKHBhcmVudCA9PT0gdHlwZXMkMS5icmFjZVN0YXRlbWVudCB8fCBwYXJlbnQgPT09IHR5cGVzJDEuYnJhY2VFeHByZXNzaW9uKSkge1xuICAgICAgcmV0dXJuICFwYXJlbnQuaXNFeHByO1xuICAgIH1cblxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX3JldHVybiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMubmFtZSAmJiB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkKSB7XG4gICAgICByZXR1cm4gbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXRlLmxhc3RUb2tFbmQsIHRoaXMuc3RhdGUuc3RhcnQpKTtcbiAgICB9XG5cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9lbHNlIHx8IHByZXZUeXBlID09PSB0eXBlcy5zZW1pIHx8IHByZXZUeXBlID09PSB0eXBlcy5lb2YgfHwgcHJldlR5cGUgPT09IHR5cGVzLnBhcmVuUiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuYXJyb3cpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuYnJhY2VMKSB7XG4gICAgICByZXR1cm4gcGFyZW50ID09PSB0eXBlcyQxLmJyYWNlU3RhdGVtZW50O1xuICAgIH1cblxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX3ZhciB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX2NvbnN0IHx8IHByZXZUeXBlID09PSB0eXBlcy5uYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5yZWxhdGlvbmFsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gIXRoaXMuc3RhdGUuZXhwckFsbG93ZWQ7XG4gIH1cblxuICB1cGRhdGVDb250ZXh0KHByZXZUeXBlKSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuc3RhdGUudHlwZTtcbiAgICBsZXQgdXBkYXRlO1xuXG4gICAgaWYgKHR5cGUua2V5d29yZCAmJiAocHJldlR5cGUgPT09IHR5cGVzLmRvdCB8fCBwcmV2VHlwZSA9PT0gdHlwZXMucXVlc3Rpb25Eb3QpKSB7XG4gICAgICB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh1cGRhdGUgPSB0eXBlLnVwZGF0ZUNvbnRleHQpIHtcbiAgICAgIHVwZGF0ZS5jYWxsKHRoaXMsIHByZXZUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZS5leHByQWxsb3dlZCA9IHR5cGUuYmVmb3JlRXhwcjtcbiAgICB9XG4gIH1cblxufVxuXG5jbGFzcyBVdGlsUGFyc2VyIGV4dGVuZHMgVG9rZW5pemVyIHtcbiAgYWRkRXh0cmEobm9kZSwga2V5LCB2YWwpIHtcbiAgICBpZiAoIW5vZGUpIHJldHVybjtcbiAgICBjb25zdCBleHRyYSA9IG5vZGUuZXh0cmEgPSBub2RlLmV4dHJhIHx8IHt9O1xuICAgIGV4dHJhW2tleV0gPSB2YWw7XG4gIH1cblxuICBpc1JlbGF0aW9uYWwob3ApIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCh0eXBlcy5yZWxhdGlvbmFsKSAmJiB0aGlzLnN0YXRlLnZhbHVlID09PSBvcDtcbiAgfVxuXG4gIGlzTG9va2FoZWFkUmVsYXRpb25hbChvcCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlblN0YXJ0KCk7XG5cbiAgICBpZiAodGhpcy5pbnB1dC5jaGFyQXQobmV4dCkgPT09IG9wKSB7XG4gICAgICBpZiAobmV4dCArIDEgPT09IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhZnRlck5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCArIDEpO1xuICAgICAgcmV0dXJuIGFmdGVyTmV4dCAhPT0gb3AuY2hhckNvZGVBdCgwKSAmJiBhZnRlck5leHQgIT09IDYxO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGV4cGVjdFJlbGF0aW9uYWwob3ApIHtcbiAgICBpZiAodGhpcy5pc1JlbGF0aW9uYWwob3ApKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKG51bGwsIHR5cGVzLnJlbGF0aW9uYWwpO1xuICAgIH1cbiAgfVxuXG4gIGlzQ29udGV4dHVhbChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2godHlwZXMubmFtZSkgJiYgdGhpcy5zdGF0ZS52YWx1ZSA9PT0gbmFtZSAmJiAhdGhpcy5zdGF0ZS5jb250YWluc0VzYztcbiAgfVxuXG4gIGlzVW5wYXJzZWRDb250ZXh0dWFsKG5hbWVTdGFydCwgbmFtZSkge1xuICAgIGNvbnN0IG5hbWVFbmQgPSBuYW1lU3RhcnQgKyBuYW1lLmxlbmd0aDtcbiAgICByZXR1cm4gdGhpcy5pbnB1dC5zbGljZShuYW1lU3RhcnQsIG5hbWVFbmQpID09PSBuYW1lICYmIChuYW1lRW5kID09PSB0aGlzLmlucHV0Lmxlbmd0aCB8fCAhaXNJZGVudGlmaWVyQ2hhcih0aGlzLmlucHV0LmNoYXJDb2RlQXQobmFtZUVuZCkpKTtcbiAgfVxuXG4gIGlzTG9va2FoZWFkQ29udGV4dHVhbChuYW1lKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcbiAgICByZXR1cm4gdGhpcy5pc1VucGFyc2VkQ29udGV4dHVhbChuZXh0LCBuYW1lKTtcbiAgfVxuXG4gIGVhdENvbnRleHR1YWwobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmlzQ29udGV4dHVhbChuYW1lKSAmJiB0aGlzLmVhdCh0eXBlcy5uYW1lKTtcbiAgfVxuXG4gIGV4cGVjdENvbnRleHR1YWwobmFtZSwgbWVzc2FnZSkge1xuICAgIGlmICghdGhpcy5lYXRDb250ZXh0dWFsKG5hbWUpKSB0aGlzLnVuZXhwZWN0ZWQobnVsbCwgbWVzc2FnZSk7XG4gIH1cblxuICBjYW5JbnNlcnRTZW1pY29sb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2godHlwZXMuZW9mKSB8fCB0aGlzLm1hdGNoKHR5cGVzLmJyYWNlUikgfHwgdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKTtcbiAgfVxuXG4gIGhhc1ByZWNlZGluZ0xpbmVCcmVhaygpIHtcbiAgICByZXR1cm4gbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXRlLmxhc3RUb2tFbmQsIHRoaXMuc3RhdGUuc3RhcnQpKTtcbiAgfVxuXG4gIGlzTGluZVRlcm1pbmF0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWF0KHR5cGVzLnNlbWkpIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCk7XG4gIH1cblxuICBzZW1pY29sb24oKSB7XG4gICAgaWYgKCF0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkgdGhpcy51bmV4cGVjdGVkKG51bGwsIHR5cGVzLnNlbWkpO1xuICB9XG5cbiAgZXhwZWN0KHR5cGUsIHBvcykge1xuICAgIHRoaXMuZWF0KHR5cGUpIHx8IHRoaXMudW5leHBlY3RlZChwb3MsIHR5cGUpO1xuICB9XG5cbiAgYXNzZXJ0Tm9TcGFjZShtZXNzYWdlID0gXCJVbmV4cGVjdGVkIHNwYWNlLlwiKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuc3RhcnQgPiB0aGlzLnN0YXRlLmxhc3RUb2tFbmQpIHtcbiAgICAgIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5sYXN0VG9rRW5kLCBtZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICB1bmV4cGVjdGVkKHBvcywgbWVzc2FnZU9yVHlwZSA9IFwiVW5leHBlY3RlZCB0b2tlblwiKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlT3JUeXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBtZXNzYWdlT3JUeXBlID0gYFVuZXhwZWN0ZWQgdG9rZW4sIGV4cGVjdGVkIFwiJHttZXNzYWdlT3JUeXBlLmxhYmVsfVwiYDtcbiAgICB9XG5cbiAgICB0aHJvdyB0aGlzLnJhaXNlKHBvcyAhPSBudWxsID8gcG9zIDogdGhpcy5zdGF0ZS5zdGFydCwgbWVzc2FnZU9yVHlwZSk7XG4gIH1cblxuICBleHBlY3RQbHVnaW4obmFtZSwgcG9zKSB7XG4gICAgaWYgKCF0aGlzLmhhc1BsdWdpbihuYW1lKSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZVdpdGhEYXRhKHBvcyAhPSBudWxsID8gcG9zIDogdGhpcy5zdGF0ZS5zdGFydCwge1xuICAgICAgICBtaXNzaW5nUGx1Z2luOiBbbmFtZV1cbiAgICAgIH0sIGBUaGlzIGV4cGVyaW1lbnRhbCBzeW50YXggcmVxdWlyZXMgZW5hYmxpbmcgdGhlIHBhcnNlciBwbHVnaW46ICcke25hbWV9J2ApO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZXhwZWN0T25lUGx1Z2luKG5hbWVzLCBwb3MpIHtcbiAgICBpZiAoIW5hbWVzLnNvbWUobiA9PiB0aGlzLmhhc1BsdWdpbihuKSkpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2VXaXRoRGF0YShwb3MgIT0gbnVsbCA/IHBvcyA6IHRoaXMuc3RhdGUuc3RhcnQsIHtcbiAgICAgICAgbWlzc2luZ1BsdWdpbjogbmFtZXNcbiAgICAgIH0sIGBUaGlzIGV4cGVyaW1lbnRhbCBzeW50YXggcmVxdWlyZXMgZW5hYmxpbmcgb25lIG9mIHRoZSBmb2xsb3dpbmcgcGFyc2VyIHBsdWdpbihzKTogJyR7bmFtZXMuam9pbihcIiwgXCIpfSdgKTtcbiAgICB9XG4gIH1cblxuICBjaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUueWllbGRQb3MgIT09IC0xICYmICh0aGlzLnN0YXRlLmF3YWl0UG9zID09PSAtMSB8fCB0aGlzLnN0YXRlLnlpZWxkUG9zIDwgdGhpcy5zdGF0ZS5hd2FpdFBvcykpIHtcbiAgICAgIHRoaXMucmFpc2UodGhpcy5zdGF0ZS55aWVsZFBvcywgRXJyb3JNZXNzYWdlcy5ZaWVsZEJpbmRpbmdJZGVudGlmaWVyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5hd2FpdFBvcyAhPT0gLTEpIHtcbiAgICAgIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5hd2FpdFBvcywgRXJyb3JNZXNzYWdlcy5Bd2FpdEJpbmRpbmdJZGVudGlmaWVyKTtcbiAgICB9XG4gIH1cblxuICB0cnlQYXJzZShmbiwgb2xkU3RhdGUgPSB0aGlzLnN0YXRlLmNsb25lKCkpIHtcbiAgICBjb25zdCBhYm9ydFNpZ25hbCA9IHtcbiAgICAgIG5vZGU6IG51bGxcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5vZGUgPSBmbigobm9kZSA9IG51bGwpID0+IHtcbiAgICAgICAgYWJvcnRTaWduYWwubm9kZSA9IG5vZGU7XG4gICAgICAgIHRocm93IGFib3J0U2lnbmFsO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLnN0YXRlLmVycm9ycy5sZW5ndGggPiBvbGRTdGF0ZS5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGZhaWxTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIGVycm9yOiBmYWlsU3RhdGUuZXJyb3JzW29sZFN0YXRlLmVycm9ycy5sZW5ndGhdLFxuICAgICAgICAgIHRocm93bjogZmFsc2UsXG4gICAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgICAgICAgZmFpbFN0YXRlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICB0aHJvd246IGZhbHNlLFxuICAgICAgICBhYm9ydGVkOiBmYWxzZSxcbiAgICAgICAgZmFpbFN0YXRlOiBudWxsXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBmYWlsU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgdGhpcy5zdGF0ZSA9IG9sZFN0YXRlO1xuXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG51bGwsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgdGhyb3duOiB0cnVlLFxuICAgICAgICAgIGFib3J0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGZhaWxTdGF0ZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyb3IgPT09IGFib3J0U2lnbmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogYWJvcnRTaWduYWwubm9kZSxcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB0aHJvd246IGZhbHNlLFxuICAgICAgICAgIGFib3J0ZWQ6IHRydWUsXG4gICAgICAgICAgZmFpbFN0YXRlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCBhbmRUaHJvdykge1xuICAgIGlmICghcmVmRXhwcmVzc2lvbkVycm9ycykgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHNob3J0aGFuZEFzc2lnbixcbiAgICAgIGRvdWJsZVByb3RvXG4gICAgfSA9IHJlZkV4cHJlc3Npb25FcnJvcnM7XG4gICAgaWYgKCFhbmRUaHJvdykgcmV0dXJuIHNob3J0aGFuZEFzc2lnbiA+PSAwIHx8IGRvdWJsZVByb3RvID49IDA7XG5cbiAgICBpZiAoc2hvcnRoYW5kQXNzaWduID49IDApIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChzaG9ydGhhbmRBc3NpZ24pO1xuICAgIH1cblxuICAgIGlmIChkb3VibGVQcm90byA+PSAwKSB7XG4gICAgICB0aGlzLnJhaXNlKGRvdWJsZVByb3RvLCBFcnJvck1lc3NhZ2VzLkR1cGxpY2F0ZVByb3RvKTtcbiAgICB9XG4gIH1cblxuICBpc0xpdGVyYWxQcm9wZXJ0eU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2godHlwZXMubmFtZSkgfHwgISF0aGlzLnN0YXRlLnR5cGUua2V5d29yZCB8fCB0aGlzLm1hdGNoKHR5cGVzLnN0cmluZykgfHwgdGhpcy5tYXRjaCh0eXBlcy5udW0pIHx8IHRoaXMubWF0Y2godHlwZXMuYmlnaW50KTtcbiAgfVxuXG59XG5jbGFzcyBFeHByZXNzaW9uRXJyb3JzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zaG9ydGhhbmRBc3NpZ24gPSAtMTtcbiAgICB0aGlzLmRvdWJsZVByb3RvID0gLTE7XG4gIH1cblxufVxuXG5jbGFzcyBOb2RlIHtcbiAgY29uc3RydWN0b3IocGFyc2VyLCBwb3MsIGxvYykge1xuICAgIHRoaXMudHlwZSA9IFwiXCI7XG4gICAgdGhpcy5zdGFydCA9IHBvcztcbiAgICB0aGlzLmVuZCA9IDA7XG4gICAgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24obG9jKTtcbiAgICBpZiAocGFyc2VyID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZXIub3B0aW9ucy5yYW5nZXMpIHRoaXMucmFuZ2UgPSBbcG9zLCAwXTtcbiAgICBpZiAocGFyc2VyID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZXIuZmlsZW5hbWUpIHRoaXMubG9jLmZpbGVuYW1lID0gcGFyc2VyLmZpbGVuYW1lO1xuICB9XG5cbiAgX19jbG9uZSgpIHtcbiAgICBjb25zdCBuZXdOb2RlID0gbmV3IE5vZGUoKTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gXCJsZWFkaW5nQ29tbWVudHNcIiAmJiBrZXkgIT09IFwidHJhaWxpbmdDb21tZW50c1wiICYmIGtleSAhPT0gXCJpbm5lckNvbW1lbnRzXCIpIHtcbiAgICAgICAgbmV3Tm9kZVtrZXldID0gdGhpc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG5cbn1cblxuY2xhc3MgTm9kZVV0aWxzIGV4dGVuZHMgVXRpbFBhcnNlciB7XG4gIHN0YXJ0Tm9kZSgpIHtcbiAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5zdGF0ZS5zdGFydCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gIH1cblxuICBzdGFydE5vZGVBdChwb3MsIGxvYykge1xuICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCBwb3MsIGxvYyk7XG4gIH1cblxuICBzdGFydE5vZGVBdE5vZGUodHlwZSkge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0Tm9kZUF0KHR5cGUuc3RhcnQsIHR5cGUubG9jLnN0YXJ0KTtcbiAgfVxuXG4gIGZpbmlzaE5vZGUobm9kZSwgdHlwZSkge1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGVBdChub2RlLCB0eXBlLCB0aGlzLnN0YXRlLmxhc3RUb2tFbmQsIHRoaXMuc3RhdGUubGFzdFRva0VuZExvYyk7XG4gIH1cblxuICBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcblxuICAgIG5vZGUudHlwZSA9IHR5cGU7XG4gICAgbm9kZS5lbmQgPSBwb3M7XG4gICAgbm9kZS5sb2MuZW5kID0gbG9jO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSBub2RlLnJhbmdlWzFdID0gcG9zO1xuICAgIHRoaXMucHJvY2Vzc0NvbW1lbnQobm9kZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXNldFN0YXJ0TG9jYXRpb24obm9kZSwgc3RhcnQsIHN0YXJ0TG9jKSB7XG4gICAgbm9kZS5zdGFydCA9IHN0YXJ0O1xuICAgIG5vZGUubG9jLnN0YXJ0ID0gc3RhcnRMb2M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIG5vZGUucmFuZ2VbMF0gPSBzdGFydDtcbiAgfVxuXG4gIHJlc2V0RW5kTG9jYXRpb24obm9kZSwgZW5kID0gdGhpcy5zdGF0ZS5sYXN0VG9rRW5kLCBlbmRMb2MgPSB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MpIHtcbiAgICBub2RlLmVuZCA9IGVuZDtcbiAgICBub2RlLmxvYy5lbmQgPSBlbmRMb2M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIG5vZGUucmFuZ2VbMV0gPSBlbmQ7XG4gIH1cblxuICByZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShub2RlLCBsb2NhdGlvbk5vZGUpIHtcbiAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbihub2RlLCBsb2NhdGlvbk5vZGUuc3RhcnQsIGxvY2F0aW9uTm9kZS5sb2Muc3RhcnQpO1xuICB9XG5cbn1cblxuY29uc3QgdW53cmFwUGFyZW50aGVzaXplZEV4cHJlc3Npb24gPSBub2RlID0+IHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiID8gdW53cmFwUGFyZW50aGVzaXplZEV4cHJlc3Npb24obm9kZS5leHByZXNzaW9uKSA6IG5vZGU7XG59O1xuXG5jbGFzcyBMVmFsUGFyc2VyIGV4dGVuZHMgTm9kZVV0aWxzIHtcbiAgdG9Bc3NpZ25hYmxlKG5vZGUpIHtcbiAgICB2YXIgX25vZGUkZXh0cmEsIF9ub2RlJGV4dHJhMztcblxuICAgIGxldCBwYXJlbnRoZXNpemVkID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiIHx8ICgoX25vZGUkZXh0cmEgPSBub2RlLmV4dHJhKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkZXh0cmEucGFyZW50aGVzaXplZCkpIHtcbiAgICAgIHBhcmVudGhlc2l6ZWQgPSB1bndyYXBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbihub2RlKTtcblxuICAgICAgaWYgKHBhcmVudGhlc2l6ZWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgcGFyZW50aGVzaXplZC50eXBlICE9PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIEVycm9yTWVzc2FnZXMuSW52YWxpZFBhcmVudGhlc2l6ZWRBc3NpZ25tZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICAgIG5vZGUudHlwZSA9IFwiT2JqZWN0UGF0dGVyblwiO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBub2RlLnByb3BlcnRpZXMubGVuZ3RoLCBsYXN0ID0gbGVuZ3RoIC0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIF9ub2RlJGV4dHJhMjtcblxuICAgICAgICAgIGNvbnN0IHByb3AgPSBub2RlLnByb3BlcnRpZXNbaV07XG4gICAgICAgICAgY29uc3QgaXNMYXN0ID0gaSA9PT0gbGFzdDtcbiAgICAgICAgICB0aGlzLnRvQXNzaWduYWJsZU9iamVjdEV4cHJlc3Npb25Qcm9wKHByb3AsIGlzTGFzdCk7XG5cbiAgICAgICAgICBpZiAoaXNMYXN0ICYmIHByb3AudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmICgoX25vZGUkZXh0cmEyID0gbm9kZS5leHRyYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGV4dHJhMi50cmFpbGluZ0NvbW1hKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZVJlc3ROb3RMYXN0KG5vZGUuZXh0cmEudHJhaWxpbmdDb21tYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJPYmplY3RQcm9wZXJ0eVwiOlxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLnZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzLmNoZWNrVG9SZXN0Q29udmVyc2lvbihub2RlKTtcbiAgICAgICAgICBub2RlLnR5cGUgPSBcIlJlc3RFbGVtZW50XCI7XG4gICAgICAgICAgY29uc3QgYXJnID0gbm9kZS5hcmd1bWVudDtcbiAgICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShhcmcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICAgICAgbm9kZS50eXBlID0gXCJBcnJheVBhdHRlcm5cIjtcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGVMaXN0KG5vZGUuZWxlbWVudHMsIChfbm9kZSRleHRyYTMgPSBub2RlLmV4dHJhKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkZXh0cmEzLnRyYWlsaW5nQ29tbWEpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmIChub2RlLm9wZXJhdG9yICE9PSBcIj1cIikge1xuICAgICAgICAgIHRoaXMucmFpc2Uobm9kZS5sZWZ0LmVuZCwgRXJyb3JNZXNzYWdlcy5NaXNzaW5nRXFJbkFzc2lnbm1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS50eXBlID0gXCJBc3NpZ25tZW50UGF0dGVyblwiO1xuICAgICAgICBkZWxldGUgbm9kZS5vcGVyYXRvcjtcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5sZWZ0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShwYXJlbnRoZXNpemVkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB0b0Fzc2lnbmFibGVPYmplY3RFeHByZXNzaW9uUHJvcChwcm9wLCBpc0xhc3QpIHtcbiAgICBpZiAocHJvcC50eXBlID09PSBcIk9iamVjdE1ldGhvZFwiKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHByb3Aua2luZCA9PT0gXCJnZXRcIiB8fCBwcm9wLmtpbmQgPT09IFwic2V0XCIgPyBFcnJvck1lc3NhZ2VzLlBhdHRlcm5IYXNBY2Nlc3NvciA6IEVycm9yTWVzc2FnZXMuUGF0dGVybkhhc01ldGhvZDtcbiAgICAgIHRoaXMucmFpc2UocHJvcC5rZXkuc3RhcnQsIGVycm9yKTtcbiAgICB9IGVsc2UgaWYgKHByb3AudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIgJiYgIWlzTGFzdCkge1xuICAgICAgdGhpcy5yYWlzZVJlc3ROb3RMYXN0KHByb3Auc3RhcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShwcm9wKTtcbiAgICB9XG4gIH1cblxuICB0b0Fzc2lnbmFibGVMaXN0KGV4cHJMaXN0LCB0cmFpbGluZ0NvbW1hUG9zKSB7XG4gICAgbGV0IGVuZCA9IGV4cHJMaXN0Lmxlbmd0aDtcblxuICAgIGlmIChlbmQpIHtcbiAgICAgIGNvbnN0IGxhc3QgPSBleHByTGlzdFtlbmQgLSAxXTtcblxuICAgICAgaWYgKChsYXN0ID09IG51bGwgPyB2b2lkIDAgOiBsYXN0LnR5cGUpID09PSBcIlJlc3RFbGVtZW50XCIpIHtcbiAgICAgICAgLS1lbmQ7XG4gICAgICB9IGVsc2UgaWYgKChsYXN0ID09IG51bGwgPyB2b2lkIDAgOiBsYXN0LnR5cGUpID09PSBcIlNwcmVhZEVsZW1lbnRcIikge1xuICAgICAgICBsYXN0LnR5cGUgPSBcIlJlc3RFbGVtZW50XCI7XG4gICAgICAgIGNvbnN0IGFyZyA9IGxhc3QuYXJndW1lbnQ7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKGFyZyk7XG5cbiAgICAgICAgaWYgKGFyZy50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiBhcmcudHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgYXJnLnR5cGUgIT09IFwiQXJyYXlQYXR0ZXJuXCIgJiYgYXJnLnR5cGUgIT09IFwiT2JqZWN0UGF0dGVyblwiKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKGFyZy5zdGFydCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhaWxpbmdDb21tYVBvcykge1xuICAgICAgICAgIHRoaXMucmFpc2VUcmFpbGluZ0NvbW1hQWZ0ZXJSZXN0KHRyYWlsaW5nQ29tbWFQb3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLS1lbmQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgY29uc3QgZWx0ID0gZXhwckxpc3RbaV07XG5cbiAgICAgIGlmIChlbHQpIHtcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUoZWx0KTtcblxuICAgICAgICBpZiAoZWx0LnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIikge1xuICAgICAgICAgIHRoaXMucmFpc2VSZXN0Tm90TGFzdChlbHQuc3RhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cHJMaXN0O1xuICB9XG5cbiAgdG9SZWZlcmVuY2VkTGlzdChleHByTGlzdCwgaXNQYXJlbnRoZXNpemVkRXhwcikge1xuICAgIHJldHVybiBleHByTGlzdDtcbiAgfVxuXG4gIHRvUmVmZXJlbmNlZExpc3REZWVwKGV4cHJMaXN0LCBpc1BhcmVudGhlc2l6ZWRFeHByKSB7XG4gICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0KGV4cHJMaXN0LCBpc1BhcmVudGhlc2l6ZWRFeHByKTtcblxuICAgIGZvciAobGV0IF9pID0gMDsgX2kgPCBleHByTGlzdC5sZW5ndGg7IF9pKyspIHtcbiAgICAgIGNvbnN0IGV4cHIgPSBleHByTGlzdFtfaV07XG5cbiAgICAgIGlmICgoZXhwciA9PSBudWxsID8gdm9pZCAwIDogZXhwci50eXBlKSA9PT0gXCJBcnJheUV4cHJlc3Npb25cIikge1xuICAgICAgICB0aGlzLnRvUmVmZXJlbmNlZExpc3REZWVwKGV4cHIuZWxlbWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBhcnNlU3ByZWFkKHJlZkV4cHJlc3Npb25FcnJvcnMsIHJlZk5lZWRzQXJyb3dQb3MpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZFeHByZXNzaW9uRXJyb3JzLCB1bmRlZmluZWQsIHJlZk5lZWRzQXJyb3dQb3MpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTcHJlYWRFbGVtZW50XCIpO1xuICB9XG5cbiAgcGFyc2VSZXN0QmluZGluZygpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJlc3RFbGVtZW50XCIpO1xuICB9XG5cbiAgcGFyc2VCaW5kaW5nQXRvbSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSB0eXBlcy5icmFja2V0TDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMuYnJhY2tldFIsIDkzLCB0cnVlKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlQYXR0ZXJuXCIpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgdHlwZXMuYnJhY2VMOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9iaih0eXBlcy5icmFjZVIsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICB9XG5cbiAgcGFyc2VCaW5kaW5nTGlzdChjbG9zZSwgY2xvc2VDaGFyQ29kZSwgYWxsb3dFbXB0eSwgYWxsb3dNb2RpZmllcnMpIHtcbiAgICBjb25zdCBlbHRzID0gW107XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcblxuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy5tYXRjaCh0eXBlcy5jb21tYSkpIHtcbiAgICAgICAgZWx0cy5wdXNoKG51bGwpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2godHlwZXMuZWxsaXBzaXMpKSB7XG4gICAgICAgIGVsdHMucHVzaCh0aGlzLnBhcnNlQXNzaWduYWJsZUxpc3RJdGVtVHlwZXModGhpcy5wYXJzZVJlc3RCaW5kaW5nKCkpKTtcbiAgICAgICAgdGhpcy5jaGVja0NvbW1hQWZ0ZXJSZXN0KGNsb3NlQ2hhckNvZGUpO1xuICAgICAgICB0aGlzLmV4cGVjdChjbG9zZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGVjb3JhdG9ycyA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmF0KSAmJiB0aGlzLmhhc1BsdWdpbihcImRlY29yYXRvcnNcIikpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIEVycm9yTWVzc2FnZXMuVW5zdXBwb3J0ZWRQYXJhbWV0ZXJEZWNvcmF0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHRoaXMubWF0Y2godHlwZXMuYXQpKSB7XG4gICAgICAgICAgZGVjb3JhdG9ycy5wdXNoKHRoaXMucGFyc2VEZWNvcmF0b3IoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbHRzLnB1c2godGhpcy5wYXJzZUFzc2lnbmFibGVMaXN0SXRlbShhbGxvd01vZGlmaWVycywgZGVjb3JhdG9ycykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbHRzO1xuICB9XG5cbiAgcGFyc2VBc3NpZ25hYmxlTGlzdEl0ZW0oYWxsb3dNb2RpZmllcnMsIGRlY29yYXRvcnMpIHtcbiAgICBjb25zdCBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCgpO1xuICAgIHRoaXMucGFyc2VBc3NpZ25hYmxlTGlzdEl0ZW1UeXBlcyhsZWZ0KTtcbiAgICBjb25zdCBlbHQgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KGxlZnQuc3RhcnQsIGxlZnQubG9jLnN0YXJ0LCBsZWZ0KTtcblxuICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgbGVmdC5kZWNvcmF0b3JzID0gZGVjb3JhdG9ycztcbiAgICB9XG5cbiAgICByZXR1cm4gZWx0O1xuICB9XG5cbiAgcGFyc2VBc3NpZ25hYmxlTGlzdEl0ZW1UeXBlcyhwYXJhbSkge1xuICAgIHJldHVybiBwYXJhbTtcbiAgfVxuXG4gIHBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCkge1xuICAgIHN0YXJ0TG9jID0gc3RhcnRMb2MgfHwgdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBzdGFydFBvcyA9IHN0YXJ0UG9zIHx8IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgbGVmdCA9IGxlZnQgfHwgdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlcy5lcSkpIHJldHVybiBsZWZ0O1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpO1xuICB9XG5cbiAgY2hlY2tMVmFsKGV4cHIsIGJpbmRpbmdUeXBlID0gQklORF9OT05FLCBjaGVja0NsYXNoZXMsIGNvbnRleHREZXNjcmlwdGlvbiwgZGlzYWxsb3dMZXRCaW5kaW5nLCBzdHJpY3RNb2RlQ2hhbmdlZCA9IGZhbHNlKSB7XG4gICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnN0cmljdCAmJiAoc3RyaWN0TW9kZUNoYW5nZWQgPyBpc1N0cmljdEJpbmRSZXNlcnZlZFdvcmQoZXhwci5uYW1lLCB0aGlzLmluTW9kdWxlKSA6IGlzU3RyaWN0QmluZE9ubHlSZXNlcnZlZFdvcmQoZXhwci5uYW1lKSkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIGJpbmRpbmdUeXBlID09PSBCSU5EX05PTkUgPyBFcnJvck1lc3NhZ2VzLlN0cmljdEV2YWxBcmd1bWVudHMgOiBFcnJvck1lc3NhZ2VzLlN0cmljdEV2YWxBcmd1bWVudHNCaW5kaW5nLCBleHByLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoZWNrQ2xhc2hlcykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGBfJHtleHByLm5hbWV9YDtcblxuICAgICAgICAgIGlmIChjaGVja0NsYXNoZXNba2V5XSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShleHByLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLlBhcmFtRHVwZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrQ2xhc2hlc1trZXldID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGlzYWxsb3dMZXRCaW5kaW5nICYmIGV4cHIubmFtZSA9PT0gXCJsZXRcIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoZXhwci5zdGFydCwgRXJyb3JNZXNzYWdlcy5MZXRJbkxleGljYWxCaW5kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKGJpbmRpbmdUeXBlICYgQklORF9OT05FKSkge1xuICAgICAgICAgIHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUoZXhwci5uYW1lLCBiaW5kaW5nVHlwZSwgZXhwci5zdGFydCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKGJpbmRpbmdUeXBlICE9PSBCSU5EX05PTkUpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIEVycm9yTWVzc2FnZXMuSW52YWxpZFByb3BlcnR5QmluZGluZ1BhdHRlcm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICAgIGZvciAobGV0IF9pMiA9IDAsIF9leHByJHByb3BlcnRpZXMgPSBleHByLnByb3BlcnRpZXM7IF9pMiA8IF9leHByJHByb3BlcnRpZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIGxldCBwcm9wID0gX2V4cHIkcHJvcGVydGllc1tfaTJdO1xuICAgICAgICAgIGlmIChwcm9wLnR5cGUgPT09IFwiT2JqZWN0UHJvcGVydHlcIikgcHJvcCA9IHByb3AudmFsdWU7ZWxzZSBpZiAocHJvcC50eXBlID09PSBcIk9iamVjdE1ldGhvZFwiKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLmNoZWNrTFZhbChwcm9wLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzLCBcIm9iamVjdCBkZXN0cnVjdHVyaW5nIHBhdHRlcm5cIiwgZGlzYWxsb3dMZXRCaW5kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICAgIGZvciAobGV0IF9pMyA9IDAsIF9leHByJGVsZW1lbnRzID0gZXhwci5lbGVtZW50czsgX2kzIDwgX2V4cHIkZWxlbWVudHMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgIGNvbnN0IGVsZW0gPSBfZXhwciRlbGVtZW50c1tfaTNdO1xuXG4gICAgICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tMVmFsKGVsZW0sIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMsIFwiYXJyYXkgZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuXCIsIGRpc2FsbG93TGV0QmluZGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgICB0aGlzLmNoZWNrTFZhbChleHByLmxlZnQsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMsIFwiYXNzaWdubWVudCBwYXR0ZXJuXCIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIuYXJndW1lbnQsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMsIFwicmVzdCBlbGVtZW50XCIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIuZXhwcmVzc2lvbiwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcywgXCJwYXJlbnRoZXNpemVkIGV4cHJlc3Npb25cIik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5yYWlzZShleHByLnN0YXJ0LCBiaW5kaW5nVHlwZSA9PT0gQklORF9OT05FID8gRXJyb3JNZXNzYWdlcy5JbnZhbGlkTGhzIDogRXJyb3JNZXNzYWdlcy5JbnZhbGlkTGhzQmluZGluZywgY29udGV4dERlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNoZWNrVG9SZXN0Q29udmVyc2lvbihub2RlKSB7XG4gICAgaWYgKG5vZGUuYXJndW1lbnQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgbm9kZS5hcmd1bWVudC50eXBlICE9PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgdGhpcy5yYWlzZShub2RlLmFyZ3VtZW50LnN0YXJ0LCBFcnJvck1lc3NhZ2VzLkludmFsaWRSZXN0QXNzaWdubWVudFBhdHRlcm4pO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrQ29tbWFBZnRlclJlc3QoY2xvc2UpIHtcbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5jb21tYSkpIHtcbiAgICAgIGlmICh0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IGNsb3NlKSB7XG4gICAgICAgIHRoaXMucmFpc2VUcmFpbGluZ0NvbW1hQWZ0ZXJSZXN0KHRoaXMuc3RhdGUuc3RhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yYWlzZVJlc3ROb3RMYXN0KHRoaXMuc3RhdGUuc3RhcnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJhaXNlUmVzdE5vdExhc3QocG9zKSB7XG4gICAgdGhyb3cgdGhpcy5yYWlzZShwb3MsIEVycm9yTWVzc2FnZXMuRWxlbWVudEFmdGVyUmVzdCk7XG4gIH1cblxuICByYWlzZVRyYWlsaW5nQ29tbWFBZnRlclJlc3QocG9zKSB7XG4gICAgdGhpcy5yYWlzZShwb3MsIEVycm9yTWVzc2FnZXMuUmVzdFRyYWlsaW5nQ29tbWEpO1xuICB9XG5cbn1cblxuY2xhc3MgRXhwcmVzc2lvblBhcnNlciBleHRlbmRzIExWYWxQYXJzZXIge1xuICBjaGVja1Byb3RvKHByb3AsIGlzUmVjb3JkLCBwcm90b1JlZiwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGlmIChwcm9wLnR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiIHx8IHByb3AudHlwZSA9PT0gXCJPYmplY3RNZXRob2RcIiB8fCBwcm9wLmNvbXB1dGVkIHx8IHByb3Auc2hvcnRoYW5kKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qga2V5ID0gcHJvcC5rZXk7XG4gICAgY29uc3QgbmFtZSA9IGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiA/IGtleS5uYW1lIDoga2V5LnZhbHVlO1xuXG4gICAgaWYgKG5hbWUgPT09IFwiX19wcm90b19fXCIpIHtcbiAgICAgIGlmIChpc1JlY29yZCkge1xuICAgICAgICB0aGlzLnJhaXNlKGtleS5zdGFydCwgRXJyb3JNZXNzYWdlcy5SZWNvcmROb1Byb3RvKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvdG9SZWYudXNlZCkge1xuICAgICAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzLmRvdWJsZVByb3RvID09PSAtMSkge1xuICAgICAgICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycy5kb3VibGVQcm90byA9IGtleS5zdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShrZXkuc3RhcnQsIEVycm9yTWVzc2FnZXMuRHVwbGljYXRlUHJvdG8pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByb3RvUmVmLnVzZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGdldEV4cHJlc3Npb24oKSB7XG4gICAgbGV0IHBhcmFtRmxhZ3MgPSBQQVJBTTtcblxuICAgIGlmICh0aGlzLmhhc1BsdWdpbihcInRvcExldmVsQXdhaXRcIikgJiYgdGhpcy5pbk1vZHVsZSkge1xuICAgICAgcGFyYW1GbGFncyB8PSBQQVJBTV9BV0FJVDtcbiAgICB9XG5cbiAgICB0aGlzLnNjb3BlLmVudGVyKFNDT1BFX1BST0dSQU0pO1xuICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKHBhcmFtRmxhZ3MpO1xuICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgY29uc3QgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICBpZiAoIXRoaXMubWF0Y2godHlwZXMuZW9mKSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgZXhwci5jb21tZW50cyA9IHRoaXMuc3RhdGUuY29tbWVudHM7XG4gICAgZXhwci5lcnJvcnMgPSB0aGlzLnN0YXRlLmVycm9ycztcbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIHBhcnNlRXhwcmVzc2lvbihub0luLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgY29uc3Qgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBleHByID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29tbWEpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZS5leHByZXNzaW9ucyA9IFtleHByXTtcblxuICAgICAgd2hpbGUgKHRoaXMuZWF0KHR5cGVzLmNvbW1hKSkge1xuICAgICAgICBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHJlZkV4cHJlc3Npb25FcnJvcnMpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0KG5vZGUuZXhwcmVzc2lvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIHBhcnNlTWF5YmVBc3NpZ24obm9JbiwgcmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UsIHJlZk5lZWRzQXJyb3dQb3MpIHtcbiAgICBjb25zdCBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuXG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwieWllbGRcIikpIHtcbiAgICAgIGlmICh0aGlzLnByb2RQYXJhbS5oYXNZaWVsZCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMucGFyc2VZaWVsZChub0luKTtcblxuICAgICAgICBpZiAoYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgICAgICAgICBsZWZ0ID0gYWZ0ZXJMZWZ0UGFyc2UuY2FsbCh0aGlzLCBsZWZ0LCBzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG93bkV4cHJlc3Npb25FcnJvcnM7XG5cbiAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgICAgb3duRXhwcmVzc2lvbkVycm9ycyA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWZFeHByZXNzaW9uRXJyb3JzID0gbmV3IEV4cHJlc3Npb25FcnJvcnMoKTtcbiAgICAgIG93bkV4cHJlc3Npb25FcnJvcnMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLnBhcmVuTCkgfHwgdGhpcy5tYXRjaCh0eXBlcy5uYW1lKSkge1xuICAgICAgdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICB9XG5cbiAgICBsZXQgbGVmdCA9IHRoaXMucGFyc2VNYXliZUNvbmRpdGlvbmFsKG5vSW4sIHJlZkV4cHJlc3Npb25FcnJvcnMsIHJlZk5lZWRzQXJyb3dQb3MpO1xuXG4gICAgaWYgKGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgICBsZWZ0ID0gYWZ0ZXJMZWZ0UGFyc2UuY2FsbCh0aGlzLCBsZWZ0LCBzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXRlLnR5cGUuaXNBc3NpZ24pIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBjb25zdCBvcGVyYXRvciA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICBub2RlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG5cbiAgICAgIGlmIChvcGVyYXRvciA9PT0gXCI/Pz1cIikge1xuICAgICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImxvZ2ljYWxBc3NpZ25tZW50XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3BlcmF0b3IgPT09IFwifHw9XCIgfHwgb3BlcmF0b3IgPT09IFwiJiY9XCIpIHtcbiAgICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJsb2dpY2FsQXNzaWdubWVudFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuZXEpKSB7XG4gICAgICAgIG5vZGUubGVmdCA9IHRoaXMudG9Bc3NpZ25hYmxlKGxlZnQpO1xuICAgICAgICByZWZFeHByZXNzaW9uRXJyb3JzLmRvdWJsZVByb3RvID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycy5zaG9ydGhhbmRBc3NpZ24gPj0gbm9kZS5sZWZ0LnN0YXJ0KSB7XG4gICAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gLTE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2hlY2tMVmFsKGxlZnQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcImFzc2lnbm1lbnQgZXhwcmVzc2lvblwiKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKG93bkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBsZWZ0O1xuICB9XG5cbiAgcGFyc2VNYXliZUNvbmRpdGlvbmFsKG5vSW4sIHJlZkV4cHJlc3Npb25FcnJvcnMsIHJlZk5lZWRzQXJyb3dQb3MpIHtcbiAgICBjb25zdCBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IHBvdGVudGlhbEFycm93QXQgPSB0aGlzLnN0YXRlLnBvdGVudGlhbEFycm93QXQ7XG4gICAgY29uc3QgZXhwciA9IHRoaXMucGFyc2VFeHByT3BzKG5vSW4sIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuXG4gICAgaWYgKGV4cHIudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiICYmIGV4cHIuc3RhcnQgPT09IHBvdGVudGlhbEFycm93QXQpIHtcbiAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCBmYWxzZSkpIHJldHVybiBleHByO1xuICAgIHJldHVybiB0aGlzLnBhcnNlQ29uZGl0aW9uYWwoZXhwciwgbm9Jbiwgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZOZWVkc0Fycm93UG9zKTtcbiAgfVxuXG4gIHBhcnNlQ29uZGl0aW9uYWwoZXhwciwgbm9Jbiwgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZOZWVkc0Fycm93UG9zKSB7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnF1ZXN0aW9uKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUudGVzdCA9IGV4cHI7XG4gICAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbG9uKTtcbiAgICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIHBhcnNlRXhwck9wcyhub0luLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgY29uc3Qgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBwb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0O1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShyZWZFeHByZXNzaW9uRXJyb3JzKTtcblxuICAgIGlmIChleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiBleHByLnN0YXJ0ID09PSBwb3RlbnRpYWxBcnJvd0F0KSB7XG4gICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRXhwcmVzc2lvbkVycm9ycywgZmFsc2UpKSB7XG4gICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcChleHByLCBzdGFydFBvcywgc3RhcnRMb2MsIC0xLCBub0luKTtcbiAgfVxuXG4gIHBhcnNlRXhwck9wKGxlZnQsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBub0luKSB7XG4gICAgbGV0IHByZWMgPSB0aGlzLnN0YXRlLnR5cGUuYmlub3A7XG5cbiAgICBpZiAocHJlYyAhPSBudWxsICYmICghbm9JbiB8fCAhdGhpcy5tYXRjaCh0eXBlcy5faW4pKSkge1xuICAgICAgaWYgKHByZWMgPiBtaW5QcmVjKSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdG9yID0gdGhpcy5zdGF0ZS52YWx1ZTtcblxuICAgICAgICBpZiAob3BlcmF0b3IgPT09IFwifD5cIiAmJiB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5KSB7XG4gICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYyk7XG4gICAgICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgICAgIG5vZGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcblxuICAgICAgICBpZiAob3BlcmF0b3IgPT09IFwiKipcIiAmJiBsZWZ0LnR5cGUgPT09IFwiVW5hcnlFeHByZXNzaW9uXCIgJiYgKHRoaXMub3B0aW9ucy5jcmVhdGVQYXJlbnRoZXNpemVkRXhwcmVzc2lvbnMgfHwgIShsZWZ0LmV4dHJhICYmIGxlZnQuZXh0cmEucGFyZW50aGVzaXplZCkpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShsZWZ0LmFyZ3VtZW50LnN0YXJ0LCBFcnJvck1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlblVuYXJ5RXhwb25lbnRpYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3AgPSB0aGlzLnN0YXRlLnR5cGU7XG4gICAgICAgIGNvbnN0IGxvZ2ljYWwgPSBvcCA9PT0gdHlwZXMubG9naWNhbE9SIHx8IG9wID09PSB0eXBlcy5sb2dpY2FsQU5EO1xuICAgICAgICBjb25zdCBjb2FsZXNjZSA9IG9wID09PSB0eXBlcy5udWxsaXNoQ29hbGVzY2luZztcblxuICAgICAgICBpZiAob3AgPT09IHR5cGVzLnBpcGVsaW5lKSB7XG4gICAgICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJwaXBlbGluZU9wZXJhdG9yXCIpO1xuICAgICAgICAgIHRoaXMuc3RhdGUuaW5QaXBlbGluZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5jaGVja1BpcGVsaW5lQXRJbmZpeE9wZXJhdG9yKGxlZnQsIGxlZnRTdGFydFBvcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29hbGVzY2UpIHtcbiAgICAgICAgICBwcmVjID0gdHlwZXMubG9naWNhbEFORC5iaW5vcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICAgIGlmIChvcCA9PT0gdHlwZXMucGlwZWxpbmUgJiYgdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJwaXBlbGluZU9wZXJhdG9yXCIsIFwicHJvcG9zYWxcIikgPT09IFwibWluaW1hbFwiKSB7XG4gICAgICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMubmFtZSkgJiYgdGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCJhd2FpdFwiICYmIHRoaXMucHJvZFBhcmFtLmhhc0F3YWl0KSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIEVycm9yTWVzc2FnZXMuVW5leHBlY3RlZEF3YWl0QWZ0ZXJQaXBlbGluZUJvZHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlRXhwck9wUmlnaHRFeHByKG9wLCBwcmVjLCBub0luKTtcbiAgICAgICAgdGhpcy5maW5pc2hOb2RlKG5vZGUsIGxvZ2ljYWwgfHwgY29hbGVzY2UgPyBcIkxvZ2ljYWxFeHByZXNzaW9uXCIgOiBcIkJpbmFyeUV4cHJlc3Npb25cIik7XG4gICAgICAgIGNvbnN0IG5leHRPcCA9IHRoaXMuc3RhdGUudHlwZTtcblxuICAgICAgICBpZiAoY29hbGVzY2UgJiYgKG5leHRPcCA9PT0gdHlwZXMubG9naWNhbE9SIHx8IG5leHRPcCA9PT0gdHlwZXMubG9naWNhbEFORCkgfHwgbG9naWNhbCAmJiBuZXh0T3AgPT09IHR5cGVzLm51bGxpc2hDb2FsZXNjaW5nKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLk1peGluZ0NvYWxlc2NlV2l0aExvZ2ljYWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3Aobm9kZSwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIG5vSW4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsZWZ0O1xuICB9XG5cbiAgcGFyc2VFeHByT3BSaWdodEV4cHIob3AsIHByZWMsIG5vSW4pIHtcbiAgICBjb25zdCBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuXG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSB0eXBlcy5waXBlbGluZTpcbiAgICAgICAgc3dpdGNoICh0aGlzLmdldFBsdWdpbk9wdGlvbihcInBpcGVsaW5lT3BlcmF0b3JcIiwgXCJwcm9wb3NhbFwiKSkge1xuICAgICAgICAgIGNhc2UgXCJzbWFydFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2l0aFRvcGljUGVybWl0dGluZ0NvbnRleHQoKCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNtYXJ0UGlwZWxpbmVCb2R5KHRoaXMucGFyc2VFeHByT3BCYXNlUmlnaHRFeHByKG9wLCBwcmVjLCBub0luKSwgc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSBcImZzaGFycFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2l0aFNvbG9Bd2FpdFBlcm1pdHRpbmdDb250ZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGU2hhcnBQaXBlbGluZUJvZHkocHJlYywgbm9Jbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcEJhc2VSaWdodEV4cHIob3AsIHByZWMsIG5vSW4pO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlRXhwck9wQmFzZVJpZ2h0RXhwcihvcCwgcHJlYywgbm9Jbikge1xuICAgIGNvbnN0IHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3AodGhpcy5wYXJzZU1heWJlVW5hcnkoKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBvcC5yaWdodEFzc29jaWF0aXZlID8gcHJlYyAtIDEgOiBwcmVjLCBub0luKTtcbiAgfVxuXG4gIHBhcnNlTWF5YmVVbmFyeShyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwiYXdhaXRcIikgJiYgdGhpcy5pc0F3YWl0QWxsb3dlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUF3YWl0KCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLnR5cGUucHJlZml4KSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIGNvbnN0IHVwZGF0ZSA9IHRoaXMubWF0Y2godHlwZXMuaW5jRGVjKTtcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuXG4gICAgICBpZiAobm9kZS5vcGVyYXRvciA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwidGhyb3dFeHByZXNzaW9uc1wiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkoKTtcbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIHRydWUpO1xuXG4gICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUuYXJndW1lbnQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcInByZWZpeCBvcGVyYXRpb25cIik7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuc3RyaWN0ICYmIG5vZGUub3BlcmF0b3IgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgY29uc3QgYXJnID0gbm9kZS5hcmd1bWVudDtcblxuICAgICAgICBpZiAoYXJnLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLlN0cmljdERlbGV0ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGFyZy50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiB8fCBhcmcudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIikgJiYgYXJnLnByb3BlcnR5LnR5cGUgPT09IFwiUHJpdmF0ZU5hbWVcIikge1xuICAgICAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgRXJyb3JNZXNzYWdlcy5EZWxldGVQcml2YXRlRmllbGQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdXBkYXRlID8gXCJVcGRhdGVFeHByZXNzaW9uXCIgOiBcIlVuYXJ5RXhwcmVzc2lvblwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGxldCBleHByID0gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCBmYWxzZSkpIHJldHVybiBleHByO1xuXG4gICAgd2hpbGUgKHRoaXMuc3RhdGUudHlwZS5wb3N0Zml4ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZS5vcGVyYXRvciA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICBub2RlLnByZWZpeCA9IGZhbHNlO1xuICAgICAgbm9kZS5hcmd1bWVudCA9IGV4cHI7XG4gICAgICB0aGlzLmNoZWNrTFZhbChleHByLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJwb3N0Zml4IG9wZXJhdGlvblwiKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlVwZGF0ZUV4cHJlc3Npb25cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICBwYXJzZUV4cHJTdWJzY3JpcHRzKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IHBvdGVudGlhbEFycm93QXQgPSB0aGlzLnN0YXRlLnBvdGVudGlhbEFycm93QXQ7XG4gICAgY29uc3QgZXhwciA9IHRoaXMucGFyc2VFeHByQXRvbShyZWZFeHByZXNzaW9uRXJyb3JzKTtcblxuICAgIGlmIChleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiBleHByLnN0YXJ0ID09PSBwb3RlbnRpYWxBcnJvd0F0KSB7XG4gICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXJzZVN1YnNjcmlwdHMoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgfVxuXG4gIHBhcnNlU3Vic2NyaXB0cyhiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgIG9wdGlvbmFsQ2hhaW5NZW1iZXI6IGZhbHNlLFxuICAgICAgbWF5YmVBc3luY0Fycm93OiB0aGlzLmF0UG9zc2libGVBc3luY0Fycm93KGJhc2UpLFxuICAgICAgc3RvcDogZmFsc2VcbiAgICB9O1xuXG4gICAgZG8ge1xuICAgICAgY29uc3Qgb2xkTWF5YmVJbkFzeW5jQXJyb3dIZWFkID0gdGhpcy5zdGF0ZS5tYXliZUluQXN5bmNBcnJvd0hlYWQ7XG5cbiAgICAgIGlmIChzdGF0ZS5tYXliZUFzeW5jQXJyb3cpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5tYXliZUluQXN5bmNBcnJvd0hlYWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBiYXNlID0gdGhpcy5wYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKTtcbiAgICAgIHN0YXRlLm1heWJlQXN5bmNBcnJvdyA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGF0ZS5tYXliZUluQXN5bmNBcnJvd0hlYWQgPSBvbGRNYXliZUluQXN5bmNBcnJvd0hlYWQ7XG4gICAgfSB3aGlsZSAoIXN0YXRlLnN0b3ApO1xuXG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuICBwYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKSB7XG4gICAgaWYgKCFub0NhbGxzICYmIHRoaXMuZWF0KHR5cGVzLmRvdWJsZUNvbG9uKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUub2JqZWN0ID0gYmFzZTtcbiAgICAgIG5vZGUuY2FsbGVlID0gdGhpcy5wYXJzZU5vQ2FsbEV4cHIoKTtcbiAgICAgIHN0YXRlLnN0b3AgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VTdWJzY3JpcHRzKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJpbmRFeHByZXNzaW9uXCIpLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMpO1xuICAgIH1cblxuICAgIGxldCBvcHRpb25hbCA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMucXVlc3Rpb25Eb3QpKSB7XG4gICAgICBzdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyID0gb3B0aW9uYWwgPSB0cnVlO1xuXG4gICAgICBpZiAobm9DYWxscyAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDQwKSB7XG4gICAgICAgIHN0YXRlLnN0b3AgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuXG4gICAgY29uc3QgY29tcHV0ZWQgPSB0aGlzLmVhdCh0eXBlcy5icmFja2V0TCk7XG5cbiAgICBpZiAob3B0aW9uYWwgJiYgIXRoaXMubWF0Y2godHlwZXMucGFyZW5MKSAmJiAhdGhpcy5tYXRjaCh0eXBlcy5iYWNrUXVvdGUpIHx8IGNvbXB1dGVkIHx8IHRoaXMuZWF0KHR5cGVzLmRvdCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgICBub2RlLnByb3BlcnR5ID0gY29tcHV0ZWQgPyB0aGlzLnBhcnNlRXhwcmVzc2lvbigpIDogdGhpcy5wYXJzZU1heWJlUHJpdmF0ZU5hbWUodHJ1ZSk7XG4gICAgICBub2RlLmNvbXB1dGVkID0gY29tcHV0ZWQ7XG5cbiAgICAgIGlmIChub2RlLnByb3BlcnR5LnR5cGUgPT09IFwiUHJpdmF0ZU5hbWVcIikge1xuICAgICAgICBpZiAobm9kZS5vYmplY3QudHlwZSA9PT0gXCJTdXBlclwiKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShzdGFydFBvcywgRXJyb3JNZXNzYWdlcy5TdXBlclByaXZhdGVGaWVsZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsYXNzU2NvcGUudXNlUHJpdmF0ZU5hbWUobm9kZS5wcm9wZXJ0eS5pZC5uYW1lLCBub2RlLnByb3BlcnR5LnN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRSKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIpIHtcbiAgICAgICAgbm9kZS5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghbm9DYWxscyAmJiB0aGlzLm1hdGNoKHR5cGVzLnBhcmVuTCkpIHtcbiAgICAgIGNvbnN0IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgICBjb25zdCBvbGRZaWVsZFBvcyA9IHRoaXMuc3RhdGUueWllbGRQb3M7XG4gICAgICBjb25zdCBvbGRBd2FpdFBvcyA9IHRoaXMuc3RhdGUuYXdhaXRQb3M7XG4gICAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0cnVlO1xuICAgICAgdGhpcy5zdGF0ZS55aWVsZFBvcyA9IC0xO1xuICAgICAgdGhpcy5zdGF0ZS5hd2FpdFBvcyA9IC0xO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBsZXQgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUuY2FsbGVlID0gYmFzZTtcblxuICAgICAgaWYgKHN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIpIHtcbiAgICAgICAgbm9kZS5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHModHlwZXMucGFyZW5SLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cyh0eXBlcy5wYXJlblIsIHN0YXRlLm1heWJlQXN5bmNBcnJvdywgYmFzZS50eXBlID09PSBcIkltcG9ydFwiLCBiYXNlLnR5cGUgIT09IFwiU3VwZXJcIiwgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmluaXNoQ2FsbEV4cHJlc3Npb24obm9kZSwgc3RhdGUub3B0aW9uYWxDaGFpbk1lbWJlcik7XG5cbiAgICAgIGlmIChzdGF0ZS5tYXliZUFzeW5jQXJyb3cgJiYgdGhpcy5zaG91bGRQYXJzZUFzeW5jQXJyb3coKSAmJiAhb3B0aW9uYWwpIHtcbiAgICAgICAgc3RhdGUuc3RvcCA9IHRydWU7XG4gICAgICAgIG5vZGUgPSB0aGlzLnBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIG5vZGUpO1xuICAgICAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICAgICAgICB0aGlzLnN0YXRlLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgICAgIHRoaXMuc3RhdGUuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdERlZXAobm9kZS5hcmd1bWVudHMpO1xuICAgICAgICBpZiAob2xkWWllbGRQb3MgIT09IC0xKSB0aGlzLnN0YXRlLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzQXdhaXRBbGxvd2VkKCkgJiYgIW9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnMgfHwgb2xkQXdhaXRQb3MgIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2godHlwZXMuYmFja1F1b3RlKSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBiYXNlLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnN0b3AgPSB0cnVlO1xuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBiYXNlLCBzdGF0ZSwgdHlwZUFyZ3VtZW50cykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS50YWcgPSBiYXNlO1xuICAgIG5vZGUucXVhc2kgPSB0aGlzLnBhcnNlVGVtcGxhdGUodHJ1ZSk7XG4gICAgaWYgKHR5cGVBcmd1bWVudHMpIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0eXBlQXJndW1lbnRzO1xuXG4gICAgaWYgKHN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIpIHtcbiAgICAgIHRoaXMucmFpc2Uoc3RhcnRQb3MsIEVycm9yTWVzc2FnZXMuT3B0aW9uYWxDaGFpbmluZ05vVGVtcGxhdGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIik7XG4gIH1cblxuICBhdFBvc3NpYmxlQXN5bmNBcnJvdyhiYXNlKSB7XG4gICAgcmV0dXJuIGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kID09PSBiYXNlLmVuZCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiBiYXNlLmVuZCAtIGJhc2Uuc3RhcnQgPT09IDUgJiYgYmFzZS5zdGFydCA9PT0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0O1xuICB9XG5cbiAgZmluaXNoQ2FsbEV4cHJlc3Npb24obm9kZSwgb3B0aW9uYWwpIHtcbiAgICBpZiAobm9kZS5jYWxsZWUudHlwZSA9PT0gXCJJbXBvcnRcIikge1xuICAgICAgaWYgKG5vZGUuYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLmV4cGVjdFBsdWdpbihcIm1vZHVsZUF0dHJpYnV0ZXNcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLmFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgbm9kZS5hcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIEVycm9yTWVzc2FnZXMuSW1wb3J0Q2FsbEFyaXR5LCB0aGlzLmhhc1BsdWdpbihcIm1vZHVsZUF0dHJpYnV0ZXNcIikgPyBcIm9uZSBvciB0d28gYXJndW1lbnRzXCIgOiBcIm9uZSBhcmd1bWVudFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IF9pID0gMCwgX25vZGUkYXJndW1lbnRzID0gbm9kZS5hcmd1bWVudHM7IF9pIDwgX25vZGUkYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGNvbnN0IGFyZyA9IF9ub2RlJGFyZ3VtZW50c1tfaV07XG5cbiAgICAgICAgICBpZiAoYXJnLnR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKGFyZy5zdGFydCwgRXJyb3JNZXNzYWdlcy5JbXBvcnRDYWxsU3ByZWFkQXJndW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgb3B0aW9uYWwgPyBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiA6IFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gIH1cblxuICBwYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKGNsb3NlLCBwb3NzaWJsZUFzeW5jQXJyb3csIGR5bmFtaWNJbXBvcnQsIGFsbG93UGxhY2Vob2xkZXIsIG5vZGVGb3JFeHRyYSkge1xuICAgIGNvbnN0IGVsdHMgPSBbXTtcbiAgICBsZXQgaW5uZXJQYXJlblN0YXJ0O1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgY29uc3Qgb2xkSW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBmYWxzZTtcblxuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcblxuICAgICAgICBpZiAodGhpcy5tYXRjaChjbG9zZSkpIHtcbiAgICAgICAgICBpZiAoZHluYW1pY0ltcG9ydCAmJiAhdGhpcy5oYXNQbHVnaW4oXCJtb2R1bGVBdHRyaWJ1dGVzXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0LCBFcnJvck1lc3NhZ2VzLkltcG9ydENhbGxBcmd1bWVudFRyYWlsaW5nQ29tbWEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChub2RlRm9yRXh0cmEpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRXh0cmEobm9kZUZvckV4dHJhLCBcInRyYWlsaW5nQ29tbWFcIiwgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLnBhcmVuTCkgJiYgIWlubmVyUGFyZW5TdGFydCkge1xuICAgICAgICBpbm5lclBhcmVuU3RhcnQgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgICAgfVxuXG4gICAgICBlbHRzLnB1c2godGhpcy5wYXJzZUV4cHJMaXN0SXRlbShmYWxzZSwgcG9zc2libGVBc3luY0Fycm93ID8gbmV3IEV4cHJlc3Npb25FcnJvcnMoKSA6IHVuZGVmaW5lZCwgcG9zc2libGVBc3luY0Fycm93ID8ge1xuICAgICAgICBzdGFydDogMFxuICAgICAgfSA6IHVuZGVmaW5lZCwgYWxsb3dQbGFjZWhvbGRlcikpO1xuICAgIH1cblxuICAgIGlmIChwb3NzaWJsZUFzeW5jQXJyb3cgJiYgaW5uZXJQYXJlblN0YXJ0ICYmIHRoaXMuc2hvdWxkUGFyc2VBc3luY0Fycm93KCkpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keTtcbiAgICByZXR1cm4gZWx0cztcbiAgfVxuXG4gIHNob3VsZFBhcnNlQXN5bmNBcnJvdygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCh0eXBlcy5hcnJvdykgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCk7XG4gIH1cblxuICBwYXJzZUFzeW5jQXJyb3dGcm9tQ2FsbEV4cHJlc3Npb24obm9kZSwgY2FsbCkge1xuICAgIHZhciBfY2FsbCRleHRyYTtcblxuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmFycm93KTtcbiAgICB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKG5vZGUsIGNhbGwuYXJndW1lbnRzLCB0cnVlLCAoX2NhbGwkZXh0cmEgPSBjYWxsLmV4dHJhKSA9PSBudWxsID8gdm9pZCAwIDogX2NhbGwkZXh0cmEudHJhaWxpbmdDb21tYSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBwYXJzZU5vQ2FsbEV4cHIoKSB7XG4gICAgY29uc3Qgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICByZXR1cm4gdGhpcy5wYXJzZVN1YnNjcmlwdHModGhpcy5wYXJzZUV4cHJBdG9tKCksIHN0YXJ0UG9zLCBzdGFydExvYywgdHJ1ZSk7XG4gIH1cblxuICBwYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS50eXBlID09PSB0eXBlcy5zbGFzaCkgdGhpcy5yZWFkUmVnZXhwKCk7XG4gICAgY29uc3QgY2FuQmVBcnJvdyA9IHRoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdCA9PT0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICBsZXQgbm9kZTtcblxuICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIHR5cGVzLl9zdXBlcjpcbiAgICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLnBhcmVuTCkgJiYgIXRoaXMuc2NvcGUuYWxsb3dEaXJlY3RTdXBlciAmJiAhdGhpcy5vcHRpb25zLmFsbG93U3VwZXJPdXRzaWRlTWV0aG9kKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLlN1cGVyTm90QWxsb3dlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuc2NvcGUuYWxsb3dTdXBlciAmJiAhdGhpcy5vcHRpb25zLmFsbG93U3VwZXJPdXRzaWRlTWV0aG9kKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLlVuZXhwZWN0ZWRTdXBlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMubWF0Y2godHlwZXMucGFyZW5MKSAmJiAhdGhpcy5tYXRjaCh0eXBlcy5icmFja2V0TCkgJiYgIXRoaXMubWF0Y2godHlwZXMuZG90KSkge1xuICAgICAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgRXJyb3JNZXNzYWdlcy5VbnN1cHBvcnRlZFN1cGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTdXBlclwiKTtcblxuICAgICAgY2FzZSB0eXBlcy5faW1wb3J0OlxuICAgICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuZG90KSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSW1wb3J0TWV0YVByb3BlcnR5KG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLm1hdGNoKHR5cGVzLnBhcmVuTCkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0LCBFcnJvck1lc3NhZ2VzLlVuc3VwcG9ydGVkSW1wb3J0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRcIik7XG5cbiAgICAgIGNhc2UgdHlwZXMuX3RoaXM6XG4gICAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRoaXNFeHByZXNzaW9uXCIpO1xuXG4gICAgICBjYXNlIHR5cGVzLm5hbWU6XG4gICAgICAgIHtcbiAgICAgICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICBjb25zdCBjb250YWluc0VzYyA9IHRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gICAgICAgICAgY29uc3QgaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuXG4gICAgICAgICAgaWYgKCFjb250YWluc0VzYyAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy5tYXRjaCh0eXBlcy5fZnVuY3Rpb24pICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5zdGF0ZS5jb250ZXh0Lmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmNvbnRleHRbbGFzdF0gIT09IHR5cGVzJDEuZnVuY3Rpb25TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgZXJyb3JcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY29udGV4dFtsYXN0XSA9IHR5cGVzJDEuZnVuY3Rpb25FeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjYW5CZUFycm93ICYmICFjb250YWluc0VzYyAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy5tYXRjaCh0eXBlcy5uYW1lKSAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICAgICAgY29uc3Qgb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICAgICAgICAgIGNvbnN0IG9sZE1heWJlSW5Bc3luY0Fycm93SGVhZCA9IHRoaXMuc3RhdGUubWF5YmVJbkFzeW5jQXJyb3dIZWFkO1xuICAgICAgICAgICAgY29uc3Qgb2xkWWllbGRQb3MgPSB0aGlzLnN0YXRlLnlpZWxkUG9zO1xuICAgICAgICAgICAgY29uc3Qgb2xkQXdhaXRQb3MgPSB0aGlzLnN0YXRlLmF3YWl0UG9zO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUubWF5YmVJbkFzeW5jQXJyb3dIZWFkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUueWllbGRQb3MgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuYXdhaXRQb3MgPSAtMTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IFt0aGlzLnBhcnNlSWRlbnRpZmllcigpXTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmFycm93KTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSBvbGRNYXliZUluQXJyb3dQYXJhbWV0ZXJzO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5tYXliZUluQXN5bmNBcnJvd0hlYWQgPSBvbGRNYXliZUluQXN5bmNBcnJvd0hlYWQ7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgICAgICAgICB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKG5vZGUsIHBhcmFtcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2FuQmVBcnJvdyAmJiB0aGlzLm1hdGNoKHR5cGVzLmFycm93KSAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKG5vZGUsIFtpZF0sIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIHR5cGVzLl9kbzpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZG9FeHByZXNzaW9uc1wiKTtcbiAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBjb25zdCBvbGRMYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVscztcbiAgICAgICAgICB0aGlzLnN0YXRlLmxhYmVscyA9IFtdO1xuICAgICAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VCbG9jaygpO1xuICAgICAgICAgIHRoaXMuc3RhdGUubGFiZWxzID0gb2xkTGFiZWxzO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEb0V4cHJlc3Npb25cIik7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSB0eXBlcy5yZWdleHA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICAgICAgbm9kZSA9IHRoaXMucGFyc2VMaXRlcmFsKHZhbHVlLnZhbHVlLCBcIlJlZ0V4cExpdGVyYWxcIik7XG4gICAgICAgICAgbm9kZS5wYXR0ZXJuID0gdmFsdWUucGF0dGVybjtcbiAgICAgICAgICBub2RlLmZsYWdzID0gdmFsdWUuZmxhZ3M7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSB0eXBlcy5udW06XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlLCBcIk51bWVyaWNMaXRlcmFsXCIpO1xuXG4gICAgICBjYXNlIHR5cGVzLmJpZ2ludDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUsIFwiQmlnSW50TGl0ZXJhbFwiKTtcblxuICAgICAgY2FzZSB0eXBlcy5zdHJpbmc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlLCBcIlN0cmluZ0xpdGVyYWxcIik7XG5cbiAgICAgIGNhc2UgdHlwZXMuX251bGw6XG4gICAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk51bGxMaXRlcmFsXCIpO1xuXG4gICAgICBjYXNlIHR5cGVzLl90cnVlOlxuICAgICAgY2FzZSB0eXBlcy5fZmFsc2U6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQm9vbGVhbkxpdGVyYWwoKTtcblxuICAgICAgY2FzZSB0eXBlcy5wYXJlbkw6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24oY2FuQmVBcnJvdyk7XG5cbiAgICAgIGNhc2UgdHlwZXMuYnJhY2tldEJhckw6XG4gICAgICBjYXNlIHR5cGVzLmJyYWNrZXRIYXNoTDpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwicmVjb3JkQW5kVHVwbGVcIik7XG4gICAgICAgICAgY29uc3Qgb2xkSW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgICAgICAgIGNvbnN0IGNsb3NlID0gdGhpcy5zdGF0ZS50eXBlID09PSB0eXBlcy5icmFja2V0QmFyTCA/IHR5cGVzLmJyYWNrZXRCYXJSIDogdHlwZXMuYnJhY2tldFI7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IGZhbHNlO1xuICAgICAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QoY2xvc2UsIGZhbHNlLCByZWZFeHByZXNzaW9uRXJyb3JzLCBub2RlKTtcbiAgICAgICAgICB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gb2xkSW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR1cGxlRXhwcmVzc2lvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIHR5cGVzLmJyYWNrZXRMOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qgb2xkSW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgICAgICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBmYWxzZTtcbiAgICAgICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzLmJyYWNrZXRSLCB0cnVlLCByZWZFeHByZXNzaW9uRXJyb3JzLCBub2RlKTtcblxuICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnRvUmVmZXJlbmNlZExpc3Qobm9kZS5lbGVtZW50cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheUV4cHJlc3Npb25cIik7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSB0eXBlcy5icmFjZUJhckw6XG4gICAgICBjYXNlIHR5cGVzLmJyYWNlSGFzaEw6XG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzLmV4cGVjdFBsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpO1xuICAgICAgICAgIGNvbnN0IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keTtcbiAgICAgICAgICBjb25zdCBjbG9zZSA9IHRoaXMuc3RhdGUudHlwZSA9PT0gdHlwZXMuYnJhY2VCYXJMID8gdHlwZXMuYnJhY2VCYXJSIDogdHlwZXMuYnJhY2VSO1xuICAgICAgICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCByZXQgPSB0aGlzLnBhcnNlT2JqKGNsb3NlLCBmYWxzZSwgdHJ1ZSwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSB0eXBlcy5icmFjZUw6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHJldCA9IHRoaXMucGFyc2VPYmoodHlwZXMuYnJhY2VSLCBmYWxzZSwgZmFsc2UsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keTtcbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgdHlwZXMuX2Z1bmN0aW9uOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbigpO1xuXG4gICAgICBjYXNlIHR5cGVzLmF0OlxuICAgICAgICB0aGlzLnBhcnNlRGVjb3JhdG9ycygpO1xuXG4gICAgICBjYXNlIHR5cGVzLl9jbGFzczpcbiAgICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMudGFrZURlY29yYXRvcnMobm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3Mobm9kZSwgZmFsc2UpO1xuXG4gICAgICBjYXNlIHR5cGVzLl9uZXc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTmV3KCk7XG5cbiAgICAgIGNhc2UgdHlwZXMuYmFja1F1b3RlOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRlbXBsYXRlKGZhbHNlKTtcblxuICAgICAgY2FzZSB0eXBlcy5kb3VibGVDb2xvbjpcbiAgICAgICAge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIG5vZGUub2JqZWN0ID0gbnVsbDtcbiAgICAgICAgICBjb25zdCBjYWxsZWUgPSBub2RlLmNhbGxlZSA9IHRoaXMucGFyc2VOb0NhbGxFeHByKCk7XG5cbiAgICAgICAgICBpZiAoY2FsbGVlLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQmluZEV4cHJlc3Npb25cIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoY2FsbGVlLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLlVuc3VwcG9ydGVkQmluZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgdHlwZXMuaGFzaDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmluUGlwZWxpbmUpIHtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRQbHVnaW5PcHRpb24oXCJwaXBlbGluZU9wZXJhdG9yXCIsIFwicHJvcG9zYWxcIikgIT09IFwic21hcnRcIikge1xuICAgICAgICAgICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIEVycm9yTWVzc2FnZXMuUHJpbWFyeVRvcGljUmVxdWlyZXNTbWFydFBpcGVsaW5lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5wcmltYXJ5VG9waWNSZWZlcmVuY2VJc0FsbG93ZWRJbkN1cnJlbnRUb3BpY0NvbnRleHQoKSkge1xuICAgICAgICAgICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIEVycm9yTWVzc2FnZXMuUHJpbWFyeVRvcGljTm90QWxsb3dlZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJUb3BpY1JlZmVyZW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG5leHRDaCA9IHRoaXMuaW5wdXQuY29kZVBvaW50QXQodGhpcy5zdGF0ZS5lbmQpO1xuXG4gICAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KG5leHRDaCkgfHwgbmV4dENoID09PSA5Mikge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMucGFyc2VNYXliZVByaXZhdGVOYW1lKHRydWUpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5faW4pKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwicHJpdmF0ZUluXCIpO1xuICAgICAgICAgICAgICB0aGlzLmNsYXNzU2NvcGUudXNlUHJpdmF0ZU5hbWUobm9kZS5pZC5uYW1lLCBub2RlLnN0YXJ0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNQbHVnaW4oXCJwcml2YXRlSW5cIikpIHtcbiAgICAgICAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLlByaXZhdGVJbkV4cGVjdGVkSW4sIG5vZGUuaWQubmFtZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoc3RhcnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgY2FzZSB0eXBlcy5yZWxhdGlvbmFsOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUudmFsdWUgPT09IFwiPFwiKSB7XG4gICAgICAgICAgICBjb25zdCBsb29rYWhlYWRDaCA9IHRoaXMuaW5wdXQuY29kZVBvaW50QXQodGhpcy5uZXh0VG9rZW5TdGFydCgpKTtcblxuICAgICAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGxvb2thaGVhZENoKSB8fCBsb29rYWhlYWRDaCA9PT0gNjIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdE9uZVBsdWdpbihbXCJqc3hcIiwgXCJmbG93XCIsIFwidHlwZXNjcmlwdFwiXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VCb29sZWFuTGl0ZXJhbCgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnZhbHVlID0gdGhpcy5tYXRjaCh0eXBlcy5fdHJ1ZSk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJvb2xlYW5MaXRlcmFsXCIpO1xuICB9XG5cbiAgcGFyc2VNYXliZVByaXZhdGVOYW1lKGlzUHJpdmF0ZU5hbWVBbGxvd2VkKSB7XG4gICAgY29uc3QgaXNQcml2YXRlID0gdGhpcy5tYXRjaCh0eXBlcy5oYXNoKTtcblxuICAgIGlmIChpc1ByaXZhdGUpIHtcbiAgICAgIHRoaXMuZXhwZWN0T25lUGx1Z2luKFtcImNsYXNzUHJpdmF0ZVByb3BlcnRpZXNcIiwgXCJjbGFzc1ByaXZhdGVNZXRob2RzXCJdKTtcblxuICAgICAgaWYgKCFpc1ByaXZhdGVOYW1lQWxsb3dlZCkge1xuICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUucG9zLCBFcnJvck1lc3NhZ2VzLlVuZXhwZWN0ZWRQcml2YXRlRmllbGQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5hc3NlcnROb1NwYWNlKFwiVW5leHBlY3RlZCBzcGFjZSBiZXR3ZWVuICMgYW5kIGlkZW50aWZpZXJcIik7XG4gICAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJpdmF0ZU5hbWVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbigpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBsZXQgbWV0YSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbWV0YSA9IHRoaXMuY3JlYXRlSWRlbnRpZmllcihtZXRhLCBcImZ1bmN0aW9uXCIpO1xuXG4gICAgaWYgKHRoaXMucHJvZFBhcmFtLmhhc1lpZWxkICYmIHRoaXMuZWF0KHR5cGVzLmRvdCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlTWV0YVByb3BlcnR5KG5vZGUsIG1ldGEsIFwic2VudFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUpO1xuICB9XG5cbiAgcGFyc2VNZXRhUHJvcGVydHkobm9kZSwgbWV0YSwgcHJvcGVydHlOYW1lKSB7XG4gICAgbm9kZS5tZXRhID0gbWV0YTtcblxuICAgIGlmIChtZXRhLm5hbWUgPT09IFwiZnVuY3Rpb25cIiAmJiBwcm9wZXJ0eU5hbWUgPT09IFwic2VudFwiKSB7XG4gICAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwocHJvcGVydHlOYW1lKSkge1xuICAgICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImZ1bmN0aW9uU2VudFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaGFzUGx1Z2luKFwiZnVuY3Rpb25TZW50XCIpKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNvbnRhaW5zRXNjID0gdGhpcy5zdGF0ZS5jb250YWluc0VzYztcbiAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG5cbiAgICBpZiAobm9kZS5wcm9wZXJ0eS5uYW1lICE9PSBwcm9wZXJ0eU5hbWUgfHwgY29udGFpbnNFc2MpIHtcbiAgICAgIHRoaXMucmFpc2Uobm9kZS5wcm9wZXJ0eS5zdGFydCwgRXJyb3JNZXNzYWdlcy5VbnN1cHBvcnRlZE1ldGFQcm9wZXJ0eSwgbWV0YS5uYW1lLCBwcm9wZXJ0eU5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZXRhUHJvcGVydHlcIik7XG4gIH1cblxuICBwYXJzZUltcG9ydE1ldGFQcm9wZXJ0eShub2RlKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmNyZWF0ZUlkZW50aWZpZXIodGhpcy5zdGFydE5vZGVBdE5vZGUobm9kZSksIFwiaW1wb3J0XCIpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmRvdCk7XG5cbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJtZXRhXCIpKSB7XG4gICAgICBpZiAoIXRoaXMuaW5Nb2R1bGUpIHtcbiAgICAgICAgdGhpcy5yYWlzZVdpdGhEYXRhKGlkLnN0YXJ0LCB7XG4gICAgICAgICAgY29kZTogXCJCQUJFTF9QQVJTRVJfU09VUkNFVFlQRV9NT0RVTEVfUkVRVUlSRURcIlxuICAgICAgICB9LCBFcnJvck1lc3NhZ2VzLkltcG9ydE1ldGFPdXRzaWRlTW9kdWxlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zYXdVbmFtYmlndW91c0VTTSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFyc2VNZXRhUHJvcGVydHkobm9kZSwgaWQsIFwibWV0YVwiKTtcbiAgfVxuXG4gIHBhcnNlTGl0ZXJhbCh2YWx1ZSwgdHlwZSwgc3RhcnRQb3MsIHN0YXJ0TG9jKSB7XG4gICAgc3RhcnRQb3MgPSBzdGFydFBvcyB8fCB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIHN0YXJ0TG9jID0gc3RhcnRMb2MgfHwgdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIHRoaXMuYWRkRXh0cmEobm9kZSwgXCJyYXdWYWx1ZVwiLCB2YWx1ZSk7XG4gICAgdGhpcy5hZGRFeHRyYShub2RlLCBcInJhd1wiLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0UG9zLCB0aGlzLnN0YXRlLmVuZCkpO1xuICAgIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHR5cGUpO1xuICB9XG5cbiAgcGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93KSB7XG4gICAgY29uc3Qgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBsZXQgdmFsO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gICAgY29uc3Qgb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICBjb25zdCBvbGRZaWVsZFBvcyA9IHRoaXMuc3RhdGUueWllbGRQb3M7XG4gICAgY29uc3Qgb2xkQXdhaXRQb3MgPSB0aGlzLnN0YXRlLmF3YWl0UG9zO1xuICAgIGNvbnN0IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keTtcbiAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0cnVlO1xuICAgIHRoaXMuc3RhdGUueWllbGRQb3MgPSAtMTtcbiAgICB0aGlzLnN0YXRlLmF3YWl0UG9zID0gLTE7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IGZhbHNlO1xuICAgIGNvbnN0IGlubmVyU3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIGNvbnN0IGlubmVyU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IGV4cHJMaXN0ID0gW107XG4gICAgY29uc3QgcmVmRXhwcmVzc2lvbkVycm9ycyA9IG5ldyBFeHByZXNzaW9uRXJyb3JzKCk7XG4gICAgY29uc3QgcmVmTmVlZHNBcnJvd1BvcyA9IHtcbiAgICAgIHN0YXJ0OiAwXG4gICAgfTtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIGxldCBzcHJlYWRTdGFydDtcbiAgICBsZXQgb3B0aW9uYWxDb21tYVN0YXJ0O1xuXG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKHR5cGVzLnBhcmVuUikpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEsIHJlZk5lZWRzQXJyb3dQb3Muc3RhcnQgfHwgbnVsbCk7XG5cbiAgICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMucGFyZW5SKSkge1xuICAgICAgICAgIG9wdGlvbmFsQ29tbWFTdGFydCA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuZWxsaXBzaXMpKSB7XG4gICAgICAgIGNvbnN0IHNwcmVhZE5vZGVTdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgICAgIGNvbnN0IHNwcmVhZE5vZGVTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICAgIHNwcmVhZFN0YXJ0ID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlUGFyZW5JdGVtKHRoaXMucGFyc2VSZXN0QmluZGluZygpLCBzcHJlYWROb2RlU3RhcnRQb3MsIHNwcmVhZE5vZGVTdGFydExvYykpO1xuICAgICAgICB0aGlzLmNoZWNrQ29tbWFBZnRlclJlc3QoNDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cHJMaXN0LnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZFeHByZXNzaW9uRXJyb3JzLCB0aGlzLnBhcnNlUGFyZW5JdGVtLCByZWZOZWVkc0Fycm93UG9zKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW5uZXJFbmRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIGNvbnN0IGlubmVyRW5kTG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIGxldCBhcnJvd05vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG5cbiAgICBpZiAoY2FuQmVBcnJvdyAmJiB0aGlzLnNob3VsZFBhcnNlQXJyb3coKSAmJiAoYXJyb3dOb2RlID0gdGhpcy5wYXJzZUFycm93KGFycm93Tm9kZSkpKSB7XG4gICAgICBpZiAoIXRoaXMuaXNBd2FpdEFsbG93ZWQoKSAmJiAhdGhpcy5zdGF0ZS5tYXliZUluQXN5bmNBcnJvd0hlYWQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICAgICAgdGhpcy5zdGF0ZS55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgICAgdGhpcy5zdGF0ZS5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuXG4gICAgICBmb3IgKGxldCBfaTIgPSAwOyBfaTIgPCBleHByTGlzdC5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtID0gZXhwckxpc3RbX2kyXTtcblxuICAgICAgICBpZiAocGFyYW0uZXh0cmEgJiYgcGFyYW0uZXh0cmEucGFyZW50aGVzaXplZCkge1xuICAgICAgICAgIHRoaXMudW5leHBlY3RlZChwYXJhbS5leHRyYS5wYXJlblN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKGFycm93Tm9kZSwgZXhwckxpc3QsIGZhbHNlKTtcbiAgICAgIHJldHVybiBhcnJvd05vZGU7XG4gICAgfVxuXG4gICAgaWYgKG9sZFlpZWxkUG9zICE9PSAtMSkgdGhpcy5zdGF0ZS55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgIGlmIChvbGRBd2FpdFBvcyAhPT0gLTEpIHRoaXMuc3RhdGUuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcblxuICAgIGlmICghZXhwckxpc3QubGVuZ3RoKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQodGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25hbENvbW1hU3RhcnQpIHRoaXMudW5leHBlY3RlZChvcHRpb25hbENvbW1hU3RhcnQpO1xuICAgIGlmIChzcHJlYWRTdGFydCkgdGhpcy51bmV4cGVjdGVkKHNwcmVhZFN0YXJ0KTtcbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCB0cnVlKTtcbiAgICBpZiAocmVmTmVlZHNBcnJvd1Bvcy5zdGFydCkgdGhpcy51bmV4cGVjdGVkKHJlZk5lZWRzQXJyb3dQb3Muc3RhcnQpO1xuICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdERlZXAoZXhwckxpc3QsIHRydWUpO1xuXG4gICAgaWYgKGV4cHJMaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhbCA9IHRoaXMuc3RhcnROb2RlQXQoaW5uZXJTdGFydFBvcywgaW5uZXJTdGFydExvYyk7XG4gICAgICB2YWwuZXhwcmVzc2lvbnMgPSBleHByTGlzdDtcbiAgICAgIHRoaXMuZmluaXNoTm9kZUF0KHZhbCwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIiwgaW5uZXJFbmRQb3MsIGlubmVyRW5kTG9jKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gZXhwckxpc3RbMF07XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuY3JlYXRlUGFyZW50aGVzaXplZEV4cHJlc3Npb25zKSB7XG4gICAgICB0aGlzLmFkZEV4dHJhKHZhbCwgXCJwYXJlbnRoZXNpemVkXCIsIHRydWUpO1xuICAgICAgdGhpcy5hZGRFeHRyYSh2YWwsIFwicGFyZW5TdGFydFwiLCBzdGFydFBvcyk7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVuRXhwcmVzc2lvbiA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBwYXJlbkV4cHJlc3Npb24uZXhwcmVzc2lvbiA9IHZhbDtcbiAgICB0aGlzLmZpbmlzaE5vZGUocGFyZW5FeHByZXNzaW9uLCBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpO1xuICAgIHJldHVybiBwYXJlbkV4cHJlc3Npb247XG4gIH1cblxuICBzaG91bGRQYXJzZUFycm93KCkge1xuICAgIHJldHVybiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKTtcbiAgfVxuXG4gIHBhcnNlQXJyb3cobm9kZSkge1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5hcnJvdykpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlUGFyZW5JdGVtKG5vZGUsIHN0YXJ0UG9zLCBzdGFydExvYykge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcGFyc2VOZXcoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbGV0IG1ldGEgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG1ldGEgPSB0aGlzLmNyZWF0ZUlkZW50aWZpZXIobWV0YSwgXCJuZXdcIik7XG5cbiAgICBpZiAodGhpcy5lYXQodHlwZXMuZG90KSkge1xuICAgICAgY29uc3QgbWV0YVByb3AgPSB0aGlzLnBhcnNlTWV0YVByb3BlcnR5KG5vZGUsIG1ldGEsIFwidGFyZ2V0XCIpO1xuXG4gICAgICBpZiAoIXRoaXMuc2NvcGUuaW5Ob25BcnJvd0Z1bmN0aW9uICYmICF0aGlzLnNjb3BlLmluQ2xhc3MpIHtcbiAgICAgICAgbGV0IGVycm9yID0gRXJyb3JNZXNzYWdlcy5VbmV4cGVjdGVkTmV3VGFyZ2V0O1xuXG4gICAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImNsYXNzUHJvcGVydGllc1wiKSkge1xuICAgICAgICAgIGVycm9yICs9IFwiIG9yIGNsYXNzIHByb3BlcnRpZXNcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmFpc2UobWV0YVByb3Auc3RhcnQsIGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1ldGFQcm9wO1xuICAgIH1cblxuICAgIG5vZGUuY2FsbGVlID0gdGhpcy5wYXJzZU5vQ2FsbEV4cHIoKTtcblxuICAgIGlmIChub2RlLmNhbGxlZS50eXBlID09PSBcIkltcG9ydFwiKSB7XG4gICAgICB0aGlzLnJhaXNlKG5vZGUuY2FsbGVlLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLkltcG9ydENhbGxOb3ROZXdFeHByZXNzaW9uKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIgfHwgbm9kZS5jYWxsZWUudHlwZSA9PT0gXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIpIHtcbiAgICAgIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5sYXN0VG9rRW5kLCBFcnJvck1lc3NhZ2VzLk9wdGlvbmFsQ2hhaW5pbmdOb05ldyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVhdCh0eXBlcy5xdWVzdGlvbkRvdCkpIHtcbiAgICAgIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCwgRXJyb3JNZXNzYWdlcy5PcHRpb25hbENoYWluaW5nTm9OZXcpO1xuICAgIH1cblxuICAgIHRoaXMucGFyc2VOZXdBcmd1bWVudHMobm9kZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk5ld0V4cHJlc3Npb25cIik7XG4gIH1cblxuICBwYXJzZU5ld0FyZ3VtZW50cyhub2RlKSB7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnBhcmVuTCkpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMucGFyZW5SKTtcbiAgICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdChhcmdzKTtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gYXJncztcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5hcmd1bWVudHMgPSBbXTtcbiAgICB9XG4gIH1cblxuICBwYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCkge1xuICAgIGNvbnN0IGVsZW0gPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgaWYgKHRoaXMuc3RhdGUudmFsdWUgPT09IG51bGwpIHtcbiAgICAgIGlmICghaXNUYWdnZWQpIHtcbiAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0ICsgMSwgRXJyb3JNZXNzYWdlcy5JbnZhbGlkRXNjYXBlU2VxdWVuY2VUZW1wbGF0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgIHJhdzogdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXRlLnN0YXJ0LCB0aGlzLnN0YXRlLmVuZCkucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSxcbiAgICAgIGNvb2tlZDogdGhpcy5zdGF0ZS52YWx1ZVxuICAgIH07XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgZWxlbS50YWlsID0gdGhpcy5tYXRjaCh0eXBlcy5iYWNrUXVvdGUpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZWxlbSwgXCJUZW1wbGF0ZUVsZW1lbnRcIik7XG4gIH1cblxuICBwYXJzZVRlbXBsYXRlKGlzVGFnZ2VkKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5leHByZXNzaW9ucyA9IFtdO1xuICAgIGxldCBjdXJFbHQgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KGlzVGFnZ2VkKTtcbiAgICBub2RlLnF1YXNpcyA9IFtjdXJFbHRdO1xuXG4gICAgd2hpbGUgKCFjdXJFbHQudGFpbCkge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuZG9sbGFyQnJhY2VMKTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlUik7XG4gICAgICBub2RlLnF1YXNpcy5wdXNoKGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoaXNUYWdnZWQpKTtcbiAgICB9XG5cbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGVtcGxhdGVMaXRlcmFsXCIpO1xuICB9XG5cbiAgcGFyc2VPYmooY2xvc2UsIGlzUGF0dGVybiwgaXNSZWNvcmQsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBwcm9wSGFzaCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnByb3BlcnRpZXMgPSBbXTtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcblxuICAgICAgICBpZiAodGhpcy5tYXRjaChjbG9zZSkpIHtcbiAgICAgICAgICB0aGlzLmFkZEV4dHJhKG5vZGUsIFwidHJhaWxpbmdDb21tYVwiLCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydCk7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvcCA9IHRoaXMucGFyc2VPYmplY3RNZW1iZXIoaXNQYXR0ZXJuLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcblxuICAgICAgaWYgKCFpc1BhdHRlcm4pIHtcbiAgICAgICAgdGhpcy5jaGVja1Byb3RvKHByb3AsIGlzUmVjb3JkLCBwcm9wSGFzaCwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1JlY29yZCAmJiBwcm9wLnR5cGUgIT09IFwiT2JqZWN0UHJvcGVydHlcIiAmJiBwcm9wLnR5cGUgIT09IFwiU3ByZWFkRWxlbWVudFwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UocHJvcC5zdGFydCwgRXJyb3JNZXNzYWdlcy5JbnZhbGlkUmVjb3JkUHJvcGVydHkpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcC5zaG9ydGhhbmQpIHtcbiAgICAgICAgdGhpcy5hZGRFeHRyYShwcm9wLCBcInNob3J0aGFuZFwiLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgbm9kZS5wcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gICAgfVxuXG4gICAgbGV0IHR5cGUgPSBcIk9iamVjdEV4cHJlc3Npb25cIjtcblxuICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgIHR5cGUgPSBcIk9iamVjdFBhdHRlcm5cIjtcbiAgICB9IGVsc2UgaWYgKGlzUmVjb3JkKSB7XG4gICAgICB0eXBlID0gXCJSZWNvcmRFeHByZXNzaW9uXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbiAgfVxuXG4gIGlzQXN5bmNQcm9wKHByb3ApIHtcbiAgICByZXR1cm4gIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgcHJvcC5rZXkubmFtZSA9PT0gXCJhc3luY1wiICYmICh0aGlzLmlzTGl0ZXJhbFByb3BlcnR5TmFtZSgpIHx8IHRoaXMubWF0Y2godHlwZXMuYnJhY2tldEwpIHx8IHRoaXMubWF0Y2godHlwZXMuc3RhcikpICYmICF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpO1xuICB9XG5cbiAgcGFyc2VPYmplY3RNZW1iZXIoaXNQYXR0ZXJuLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgbGV0IGRlY29yYXRvcnMgPSBbXTtcblxuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmF0KSkge1xuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSkge1xuICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIEVycm9yTWVzc2FnZXMuVW5zdXBwb3J0ZWRQcm9wZXJ0eURlY29yYXRvcik7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0aGlzLm1hdGNoKHR5cGVzLmF0KSkge1xuICAgICAgICBkZWNvcmF0b3JzLnB1c2godGhpcy5wYXJzZURlY29yYXRvcigpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwcm9wID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBsZXQgaXNHZW5lcmF0b3IgPSBmYWxzZTtcbiAgICBsZXQgaXNBc3luYyA9IGZhbHNlO1xuICAgIGxldCBzdGFydFBvcztcbiAgICBsZXQgc3RhcnRMb2M7XG5cbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5lbGxpcHNpcykpIHtcbiAgICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkgdGhpcy51bmV4cGVjdGVkKCk7XG5cbiAgICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICB0aGlzLmNoZWNrQ29tbWFBZnRlclJlc3QoMTI1KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlJlc3RFbGVtZW50XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVNwcmVhZCgpO1xuICAgIH1cblxuICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgcHJvcC5kZWNvcmF0b3JzID0gZGVjb3JhdG9ycztcbiAgICAgIGRlY29yYXRvcnMgPSBbXTtcbiAgICB9XG5cbiAgICBwcm9wLm1ldGhvZCA9IGZhbHNlO1xuXG4gICAgaWYgKGlzUGF0dGVybiB8fCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgICBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgICBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgfVxuXG4gICAgaWYgKCFpc1BhdHRlcm4pIHtcbiAgICAgIGlzR2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgfVxuXG4gICAgY29uc3QgY29udGFpbnNFc2MgPSB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCwgZmFsc2UpO1xuXG4gICAgaWYgKCFpc1BhdHRlcm4gJiYgIWNvbnRhaW5zRXNjICYmICFpc0dlbmVyYXRvciAmJiB0aGlzLmlzQXN5bmNQcm9wKHByb3ApKSB7XG4gICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgIGlzR2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3AsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNBc3luYyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMucGFyc2VPYmpQcm9wVmFsdWUocHJvcCwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuLCByZWZFeHByZXNzaW9uRXJyb3JzLCBjb250YWluc0VzYyk7XG4gICAgcmV0dXJuIHByb3A7XG4gIH1cblxuICBpc0dldHRlck9yU2V0dGVyTWV0aG9kKHByb3AsIGlzUGF0dGVybikge1xuICAgIHJldHVybiAhaXNQYXR0ZXJuICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChwcm9wLmtleS5uYW1lID09PSBcImdldFwiIHx8IHByb3Aua2V5Lm5hbWUgPT09IFwic2V0XCIpICYmICh0aGlzLmlzTGl0ZXJhbFByb3BlcnR5TmFtZSgpIHx8IHRoaXMubWF0Y2godHlwZXMuYnJhY2tldEwpKTtcbiAgfVxuXG4gIGdldEdldHRlclNldHRlckV4cGVjdGVkUGFyYW1Db3VudChtZXRob2QpIHtcbiAgICByZXR1cm4gbWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIgPyAwIDogMTtcbiAgfVxuXG4gIGNoZWNrR2V0dGVyU2V0dGVyUGFyYW1zKG1ldGhvZCkge1xuICAgIGNvbnN0IHBhcmFtQ291bnQgPSB0aGlzLmdldEdldHRlclNldHRlckV4cGVjdGVkUGFyYW1Db3VudChtZXRob2QpO1xuICAgIGNvbnN0IHN0YXJ0ID0gbWV0aG9kLnN0YXJ0O1xuXG4gICAgaWYgKG1ldGhvZC5wYXJhbXMubGVuZ3RoICE9PSBwYXJhbUNvdW50KSB7XG4gICAgICBpZiAobWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShzdGFydCwgRXJyb3JNZXNzYWdlcy5CYWRHZXR0ZXJBcml0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJhaXNlKHN0YXJ0LCBFcnJvck1lc3NhZ2VzLkJhZFNldHRlckFyaXR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWV0aG9kLmtpbmQgPT09IFwic2V0XCIgJiYgbWV0aG9kLnBhcmFtc1ttZXRob2QucGFyYW1zLmxlbmd0aCAtIDFdLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIikge1xuICAgICAgdGhpcy5yYWlzZShzdGFydCwgRXJyb3JNZXNzYWdlcy5CYWRTZXR0ZXJSZXN0UGFyYW1ldGVyKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZU9iamVjdE1ldGhvZChwcm9wLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuLCBjb250YWluc0VzYykge1xuICAgIGlmIChpc0FzeW5jIHx8IGlzR2VuZXJhdG9yIHx8IHRoaXMubWF0Y2godHlwZXMucGFyZW5MKSkge1xuICAgICAgaWYgKGlzUGF0dGVybikgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICBwcm9wLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgICAgcHJvcC5tZXRob2QgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VNZXRob2QocHJvcCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGZhbHNlLCBmYWxzZSwgXCJPYmplY3RNZXRob2RcIik7XG4gICAgfVxuXG4gICAgaWYgKCFjb250YWluc0VzYyAmJiB0aGlzLmlzR2V0dGVyT3JTZXR0ZXJNZXRob2QocHJvcCwgaXNQYXR0ZXJuKSkge1xuICAgICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgcHJvcC5raW5kID0gcHJvcC5rZXkubmFtZTtcbiAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCwgZmFsc2UpO1xuICAgICAgdGhpcy5wYXJzZU1ldGhvZChwcm9wLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgXCJPYmplY3RNZXRob2RcIik7XG4gICAgICB0aGlzLmNoZWNrR2V0dGVyU2V0dGVyUGFyYW1zKHByb3ApO1xuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VPYmplY3RQcm9wZXJ0eShwcm9wLCBzdGFydFBvcywgc3RhcnRMb2MsIGlzUGF0dGVybiwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIHByb3Auc2hvcnRoYW5kID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5lYXQodHlwZXMuY29sb24pKSB7XG4gICAgICBwcm9wLnZhbHVlID0gaXNQYXR0ZXJuID8gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCh0aGlzLnN0YXRlLnN0YXJ0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiT2JqZWN0UHJvcGVydHlcIik7XG4gICAgfVxuXG4gICAgaWYgKCFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKHByb3Aua2V5Lm5hbWUsIHByb3Aua2V5LnN0YXJ0LCB0cnVlLCB0cnVlKTtcblxuICAgICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHByb3Aua2V5Ll9fY2xvbmUoKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2godHlwZXMuZXEpICYmIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMuc2hvcnRoYW5kQXNzaWduID09PSAtMSkge1xuICAgICAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgcHJvcC5rZXkuX19jbG9uZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AudmFsdWUgPSBwcm9wLmtleS5fX2Nsb25lKCk7XG4gICAgICB9XG5cbiAgICAgIHByb3Auc2hvcnRoYW5kID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJPYmplY3RQcm9wZXJ0eVwiKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZU9ialByb3BWYWx1ZShwcm9wLCBzdGFydFBvcywgc3RhcnRMb2MsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIHJlZkV4cHJlc3Npb25FcnJvcnMsIGNvbnRhaW5zRXNjKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMucGFyc2VPYmplY3RNZXRob2QocHJvcCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzUGF0dGVybiwgY29udGFpbnNFc2MpIHx8IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eShwcm9wLCBzdGFydFBvcywgc3RhcnRMb2MsIGlzUGF0dGVybiwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKCFub2RlKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHBhcnNlUHJvcGVydHlOYW1lKHByb3AsIGlzUHJpdmF0ZU5hbWVBbGxvd2VkKSB7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLmJyYWNrZXRMKSkge1xuICAgICAgcHJvcC5jb21wdXRlZCA9IHRydWU7XG4gICAgICBwcm9wLmtleSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2tldFIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvbGRJblByb3BlcnR5TmFtZSA9IHRoaXMuc3RhdGUuaW5Qcm9wZXJ0eU5hbWU7XG4gICAgICB0aGlzLnN0YXRlLmluUHJvcGVydHlOYW1lID0gdHJ1ZTtcbiAgICAgIHByb3Aua2V5ID0gdGhpcy5tYXRjaCh0eXBlcy5udW0pIHx8IHRoaXMubWF0Y2godHlwZXMuc3RyaW5nKSB8fCB0aGlzLm1hdGNoKHR5cGVzLmJpZ2ludCkgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMucGFyc2VNYXliZVByaXZhdGVOYW1lKGlzUHJpdmF0ZU5hbWVBbGxvd2VkKTtcblxuICAgICAgaWYgKHByb3Aua2V5LnR5cGUgIT09IFwiUHJpdmF0ZU5hbWVcIikge1xuICAgICAgICBwcm9wLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhdGUuaW5Qcm9wZXJ0eU5hbWUgPSBvbGRJblByb3BlcnR5TmFtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcC5rZXk7XG4gIH1cblxuICBpbml0RnVuY3Rpb24obm9kZSwgaXNBc3luYykge1xuICAgIG5vZGUuaWQgPSBudWxsO1xuICAgIG5vZGUuZ2VuZXJhdG9yID0gZmFsc2U7XG4gICAgbm9kZS5hc3luYyA9ICEhaXNBc3luYztcbiAgfVxuXG4gIHBhcnNlTWV0aG9kKG5vZGUsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd0RpcmVjdFN1cGVyLCB0eXBlLCBpbkNsYXNzU2NvcGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IG9sZFlpZWxkUG9zID0gdGhpcy5zdGF0ZS55aWVsZFBvcztcbiAgICBjb25zdCBvbGRBd2FpdFBvcyA9IHRoaXMuc3RhdGUuYXdhaXRQb3M7XG4gICAgdGhpcy5zdGF0ZS55aWVsZFBvcyA9IC0xO1xuICAgIHRoaXMuc3RhdGUuYXdhaXRQb3MgPSAtMTtcbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlLCBpc0FzeW5jKTtcbiAgICBub2RlLmdlbmVyYXRvciA9ICEhaXNHZW5lcmF0b3I7XG4gICAgY29uc3QgYWxsb3dNb2RpZmllcnMgPSBpc0NvbnN0cnVjdG9yO1xuICAgIHRoaXMuc2NvcGUuZW50ZXIoU0NPUEVfRlVOQ1RJT04gfCBTQ09QRV9TVVBFUiB8IChpbkNsYXNzU2NvcGUgPyBTQ09QRV9DTEFTUyA6IDApIHwgKGFsbG93RGlyZWN0U3VwZXIgPyBTQ09QRV9ESVJFQ1RfU1VQRVIgOiAwKSk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBub2RlLmdlbmVyYXRvcikpO1xuICAgIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlLCBhbGxvd01vZGlmaWVycyk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keUFuZEZpbmlzaChub2RlLCB0eXBlLCB0cnVlKTtcbiAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgdGhpcy5zdGF0ZS55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgIHRoaXMuc3RhdGUuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHBhcnNlQXJyb3dFeHByZXNzaW9uKG5vZGUsIHBhcmFtcywgaXNBc3luYywgdHJhaWxpbmdDb21tYVBvcykge1xuICAgIHRoaXMuc2NvcGUuZW50ZXIoU0NPUEVfRlVOQ1RJT04gfCBTQ09QRV9BUlJPVyk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBmYWxzZSkpO1xuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMpO1xuICAgIGNvbnN0IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgY29uc3Qgb2xkWWllbGRQb3MgPSB0aGlzLnN0YXRlLnlpZWxkUG9zO1xuICAgIGNvbnN0IG9sZEF3YWl0UG9zID0gdGhpcy5zdGF0ZS5hd2FpdFBvcztcblxuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRydWU7XG4gICAgICB0aGlzLnNldEFycm93RnVuY3Rpb25QYXJhbWV0ZXJzKG5vZGUsIHBhcmFtcywgdHJhaWxpbmdDb21tYVBvcyk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZS55aWVsZFBvcyA9IC0xO1xuICAgIHRoaXMuc3RhdGUuYXdhaXRQb3MgPSAtMTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIHRydWUpO1xuICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSBvbGRNYXliZUluQXJyb3dQYXJhbWV0ZXJzO1xuICAgIHRoaXMuc3RhdGUueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICB0aGlzLnN0YXRlLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpO1xuICB9XG5cbiAgc2V0QXJyb3dGdW5jdGlvblBhcmFtZXRlcnMobm9kZSwgcGFyYW1zLCB0cmFpbGluZ0NvbW1hUG9zKSB7XG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnRvQXNzaWduYWJsZUxpc3QocGFyYW1zLCB0cmFpbGluZ0NvbW1hUG9zKTtcbiAgfVxuXG4gIHBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIHR5cGUsIGlzTWV0aG9kID0gZmFsc2UpIHtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGZhbHNlLCBpc01ldGhvZCk7XG4gICAgdGhpcy5maW5pc2hOb2RlKG5vZGUsIHR5cGUpO1xuICB9XG5cbiAgcGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgYWxsb3dFeHByZXNzaW9uLCBpc01ldGhvZCA9IGZhbHNlKSB7XG4gICAgY29uc3QgaXNFeHByZXNzaW9uID0gYWxsb3dFeHByZXNzaW9uICYmICF0aGlzLm1hdGNoKHR5cGVzLmJyYWNlTCk7XG4gICAgY29uc3Qgb2xkSW5QYXJhbWV0ZXJzID0gdGhpcy5zdGF0ZS5pblBhcmFtZXRlcnM7XG4gICAgdGhpcy5zdGF0ZS5pblBhcmFtZXRlcnMgPSBmYWxzZTtcblxuICAgIGlmIChpc0V4cHJlc3Npb24pIHtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCBmYWxzZSwgYWxsb3dFeHByZXNzaW9uLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9sZFN0cmljdCA9IHRoaXMuc3RhdGUuc3RyaWN0O1xuICAgICAgY29uc3Qgb2xkTGFiZWxzID0gdGhpcy5zdGF0ZS5sYWJlbHM7XG4gICAgICB0aGlzLnN0YXRlLmxhYmVscyA9IFtdO1xuICAgICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIodGhpcy5wcm9kUGFyYW0uY3VycmVudEZsYWdzKCkgfCBQQVJBTV9SRVRVUk4pO1xuICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKHRydWUsIGZhbHNlLCBoYXNTdHJpY3RNb2RlRGlyZWN0aXZlID0+IHtcbiAgICAgICAgY29uc3Qgbm9uU2ltcGxlID0gIXRoaXMuaXNTaW1wbGVQYXJhbUxpc3Qobm9kZS5wYXJhbXMpO1xuXG4gICAgICAgIGlmIChoYXNTdHJpY3RNb2RlRGlyZWN0aXZlICYmIG5vblNpbXBsZSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yUG9zID0gKG5vZGUua2luZCA9PT0gXCJtZXRob2RcIiB8fCBub2RlLmtpbmQgPT09IFwiY29uc3RydWN0b3JcIikgJiYgISFub2RlLmtleSA/IG5vZGUua2V5LmVuZCA6IG5vZGUuc3RhcnQ7XG4gICAgICAgICAgdGhpcy5yYWlzZShlcnJvclBvcywgRXJyb3JNZXNzYWdlcy5JbGxlZ2FsTGFuZ3VhZ2VNb2RlRGlyZWN0aXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0cmljdE1vZGVDaGFuZ2VkID0gIW9sZFN0cmljdCAmJiB0aGlzLnN0YXRlLnN0cmljdDtcbiAgICAgICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCAhdGhpcy5zdGF0ZS5zdHJpY3QgJiYgIWFsbG93RXhwcmVzc2lvbiAmJiAhaXNNZXRob2QgJiYgIW5vblNpbXBsZSwgYWxsb3dFeHByZXNzaW9uLCBzdHJpY3RNb2RlQ2hhbmdlZCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RyaWN0ICYmIG5vZGUuaWQpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCBCSU5EX09VVFNJREUsIHVuZGVmaW5lZCwgXCJmdW5jdGlvbiBuYW1lXCIsIHVuZGVmaW5lZCwgc3RyaWN0TW9kZUNoYW5nZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICAgIHRoaXMuc3RhdGUubGFiZWxzID0gb2xkTGFiZWxzO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuaW5QYXJhbWV0ZXJzID0gb2xkSW5QYXJhbWV0ZXJzO1xuICB9XG5cbiAgaXNTaW1wbGVQYXJhbUxpc3QocGFyYW1zKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhcmFtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKHBhcmFtc1tpXS50eXBlICE9PSBcIklkZW50aWZpZXJcIikgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY2hlY2tQYXJhbXMobm9kZSwgYWxsb3dEdXBsaWNhdGVzLCBpc0Fycm93RnVuY3Rpb24sIHN0cmljdE1vZGVDaGFuZ2VkID0gdHJ1ZSkge1xuICAgIGNvbnN0IG5hbWVIYXNoID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUucGFyYW1zW2ldLCBCSU5EX1ZBUiwgYWxsb3dEdXBsaWNhdGVzID8gbnVsbCA6IG5hbWVIYXNoLCBcImZ1bmN0aW9uIHBhcmFtZXRlciBsaXN0XCIsIHVuZGVmaW5lZCwgc3RyaWN0TW9kZUNoYW5nZWQpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlRXhwckxpc3QoY2xvc2UsIGFsbG93RW1wdHksIHJlZkV4cHJlc3Npb25FcnJvcnMsIG5vZGVGb3JFeHRyYSkge1xuICAgIGNvbnN0IGVsdHMgPSBbXTtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuXG4gICAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuXG4gICAgICAgIGlmICh0aGlzLm1hdGNoKGNsb3NlKSkge1xuICAgICAgICAgIGlmIChub2RlRm9yRXh0cmEpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRXh0cmEobm9kZUZvckV4dHJhLCBcInRyYWlsaW5nQ29tbWFcIiwgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsdHMucHVzaCh0aGlzLnBhcnNlRXhwckxpc3RJdGVtKGFsbG93RW1wdHksIHJlZkV4cHJlc3Npb25FcnJvcnMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWx0cztcbiAgfVxuXG4gIHBhcnNlRXhwckxpc3RJdGVtKGFsbG93RW1wdHksIHJlZkV4cHJlc3Npb25FcnJvcnMsIHJlZk5lZWRzQXJyb3dQb3MsIGFsbG93UGxhY2Vob2xkZXIpIHtcbiAgICBsZXQgZWx0O1xuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29tbWEpKSB7XG4gICAgICBpZiAoIWFsbG93RW1wdHkpIHtcbiAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnBvcywgRXJyb3JNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sIFwiLFwiKTtcbiAgICAgIH1cblxuICAgICAgZWx0ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2godHlwZXMuZWxsaXBzaXMpKSB7XG4gICAgICBjb25zdCBzcHJlYWROb2RlU3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgICAgY29uc3Qgc3ByZWFkTm9kZVN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgIGVsdCA9IHRoaXMucGFyc2VQYXJlbkl0ZW0odGhpcy5wYXJzZVNwcmVhZChyZWZFeHByZXNzaW9uRXJyb3JzLCByZWZOZWVkc0Fycm93UG9zKSwgc3ByZWFkTm9kZVN0YXJ0UG9zLCBzcHJlYWROb2RlU3RhcnRMb2MpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCh0eXBlcy5xdWVzdGlvbikpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwicGFydGlhbEFwcGxpY2F0aW9uXCIpO1xuXG4gICAgICBpZiAoIWFsbG93UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLlVuZXhwZWN0ZWRBcmd1bWVudFBsYWNlaG9sZGVyKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGVsdCA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFyZ3VtZW50UGxhY2Vob2xkZXJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRXhwcmVzc2lvbkVycm9ycywgdGhpcy5wYXJzZVBhcmVuSXRlbSwgcmVmTmVlZHNBcnJvd1Bvcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsdDtcbiAgfVxuXG4gIHBhcnNlSWRlbnRpZmllcihsaWJlcmFsKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZShub2RlLnN0YXJ0LCBsaWJlcmFsKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVJZGVudGlmaWVyKG5vZGUsIG5hbWUpO1xuICB9XG5cbiAgY3JlYXRlSWRlbnRpZmllcihub2RlLCBuYW1lKSB7XG4gICAgbm9kZS5uYW1lID0gbmFtZTtcbiAgICBub2RlLmxvYy5pZGVudGlmaWVyTmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklkZW50aWZpZXJcIik7XG4gIH1cblxuICBwYXJzZUlkZW50aWZpZXJOYW1lKHBvcywgbGliZXJhbCkge1xuICAgIGxldCBuYW1lO1xuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMubmFtZSkpIHtcbiAgICAgIG5hbWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS50eXBlLmtleXdvcmQpIHtcbiAgICAgIG5hbWUgPSB0aGlzLnN0YXRlLnR5cGUua2V5d29yZDtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLnN0YXRlLmNvbnRleHQ7XG5cbiAgICAgIGlmICgobmFtZSA9PT0gXCJjbGFzc1wiIHx8IG5hbWUgPT09IFwiZnVuY3Rpb25cIikgJiYgY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdLnRva2VuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29udGV4dC5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgaWYgKGxpYmVyYWwpIHtcbiAgICAgIHRoaXMuc3RhdGUudHlwZSA9IHR5cGVzLm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tSZXNlcnZlZFdvcmQobmFtZSwgdGhpcy5zdGF0ZS5zdGFydCwgISF0aGlzLnN0YXRlLnR5cGUua2V5d29yZCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiBuYW1lO1xuICB9XG5cbiAgY2hlY2tSZXNlcnZlZFdvcmQod29yZCwgc3RhcnRMb2MsIGNoZWNrS2V5d29yZHMsIGlzQmluZGluZykge1xuICAgIGlmICh0aGlzLnByb2RQYXJhbS5oYXNZaWVsZCAmJiB3b3JkID09PSBcInlpZWxkXCIpIHtcbiAgICAgIHRoaXMucmFpc2Uoc3RhcnRMb2MsIEVycm9yTWVzc2FnZXMuWWllbGRCaW5kaW5nSWRlbnRpZmllcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHdvcmQgPT09IFwiYXdhaXRcIikge1xuICAgICAgaWYgKHRoaXMucHJvZFBhcmFtLmhhc0F3YWl0KSB7XG4gICAgICAgIHRoaXMucmFpc2Uoc3RhcnRMb2MsIEVycm9yTWVzc2FnZXMuQXdhaXRCaW5kaW5nSWRlbnRpZmllcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3RhdGUuYXdhaXRQb3MgPT09IC0xICYmICh0aGlzLnN0YXRlLm1heWJlSW5Bc3luY0Fycm93SGVhZCB8fCB0aGlzLmlzQXdhaXRBbGxvd2VkKCkpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuYXdhaXRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnNjb3BlLmluQ2xhc3MgJiYgIXRoaXMuc2NvcGUuaW5Ob25BcnJvd0Z1bmN0aW9uICYmIHdvcmQgPT09IFwiYXJndW1lbnRzXCIpIHtcbiAgICAgIHRoaXMucmFpc2Uoc3RhcnRMb2MsIEVycm9yTWVzc2FnZXMuQXJndW1lbnRzRGlzYWxsb3dlZEluSW5pdGlhbGl6ZXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjaGVja0tleXdvcmRzICYmIGlzS2V5d29yZCh3b3JkKSkge1xuICAgICAgdGhpcy5yYWlzZShzdGFydExvYywgRXJyb3JNZXNzYWdlcy5VbmV4cGVjdGVkS2V5d29yZCwgd29yZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVzZXJ2ZWRUZXN0ID0gIXRoaXMuc3RhdGUuc3RyaWN0ID8gaXNSZXNlcnZlZFdvcmQgOiBpc0JpbmRpbmcgPyBpc1N0cmljdEJpbmRSZXNlcnZlZFdvcmQgOiBpc1N0cmljdFJlc2VydmVkV29yZDtcblxuICAgIGlmIChyZXNlcnZlZFRlc3Qod29yZCwgdGhpcy5pbk1vZHVsZSkpIHtcbiAgICAgIGlmICghdGhpcy5wcm9kUGFyYW0uaGFzQXdhaXQgJiYgd29yZCA9PT0gXCJhd2FpdFwiKSB7XG4gICAgICAgIHRoaXMucmFpc2Uoc3RhcnRMb2MsIEVycm9yTWVzc2FnZXMuQXdhaXROb3RJbkFzeW5jRnVuY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yYWlzZShzdGFydExvYywgRXJyb3JNZXNzYWdlcy5VbmV4cGVjdGVkUmVzZXJ2ZWRXb3JkLCB3b3JkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc0F3YWl0QWxsb3dlZCgpIHtcbiAgICBpZiAodGhpcy5zY29wZS5pbkZ1bmN0aW9uKSByZXR1cm4gdGhpcy5wcm9kUGFyYW0uaGFzQXdhaXQ7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uKSByZXR1cm4gdHJ1ZTtcblxuICAgIGlmICh0aGlzLmhhc1BsdWdpbihcInRvcExldmVsQXdhaXRcIikpIHtcbiAgICAgIHJldHVybiB0aGlzLmluTW9kdWxlICYmIHRoaXMucHJvZFBhcmFtLmhhc0F3YWl0O1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHBhcnNlQXdhaXQoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5pblBhcmFtZXRlcnMpIHtcbiAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgRXJyb3JNZXNzYWdlcy5Bd2FpdEV4cHJlc3Npb25Gb3JtYWxQYXJhbWV0ZXIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5hd2FpdFBvcyA9PT0gLTEpIHtcbiAgICAgIHRoaXMuc3RhdGUuYXdhaXRQb3MgPSBub2RlLnN0YXJ0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5zdGFyKSkge1xuICAgICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLk9ic29sZXRlQXdhaXRTdGFyKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc2NvcGUuaW5GdW5jdGlvbiAmJiAhdGhpcy5vcHRpb25zLmFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb24pIHtcbiAgICAgIGlmICh0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpIHx8IHRoaXMubWF0Y2godHlwZXMucGx1c01pbikgfHwgdGhpcy5tYXRjaCh0eXBlcy5wYXJlbkwpIHx8IHRoaXMubWF0Y2godHlwZXMuYnJhY2tldEwpIHx8IHRoaXMubWF0Y2godHlwZXMuYmFja1F1b3RlKSB8fCB0aGlzLm1hdGNoKHR5cGVzLnJlZ2V4cCkgfHwgdGhpcy5tYXRjaCh0eXBlcy5zbGFzaCkgfHwgdGhpcy5oYXNQbHVnaW4oXCJ2OGludHJpbnNpY1wiKSAmJiB0aGlzLm1hdGNoKHR5cGVzLm1vZHVsbykpIHtcbiAgICAgICAgdGhpcy5hbWJpZ3VvdXNTY3JpcHREaWZmZXJlbnRBc3QgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zYXdVbmFtYmlndW91c0VTTSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnN0YXRlLnNvbG9Bd2FpdCkge1xuICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkF3YWl0RXhwcmVzc2lvblwiKTtcbiAgfVxuXG4gIHBhcnNlWWllbGQobm9Jbikge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgaWYgKHRoaXMuc3RhdGUuaW5QYXJhbWV0ZXJzKSB7XG4gICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIEVycm9yTWVzc2FnZXMuWWllbGRJblBhcmFtZXRlcik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLnlpZWxkUG9zID09PSAtMSkge1xuICAgICAgdGhpcy5zdGF0ZS55aWVsZFBvcyA9IG5vZGUuc3RhcnQ7XG4gICAgfVxuXG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5zZW1pKSB8fCAhdGhpcy5tYXRjaCh0eXBlcy5zdGFyKSAmJiAhdGhpcy5zdGF0ZS50eXBlLnN0YXJ0c0V4cHIgfHwgdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgbm9kZS5kZWxlZ2F0ZSA9IGZhbHNlO1xuICAgICAgbm9kZS5hcmd1bWVudCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuZGVsZWdhdGUgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIllpZWxkRXhwcmVzc2lvblwiKTtcbiAgfVxuXG4gIGNoZWNrUGlwZWxpbmVBdEluZml4T3BlcmF0b3IobGVmdCwgbGVmdFN0YXJ0UG9zKSB7XG4gICAgaWYgKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicGlwZWxpbmVPcGVyYXRvclwiLCBcInByb3Bvc2FsXCIpID09PSBcInNtYXJ0XCIpIHtcbiAgICAgIGlmIChsZWZ0LnR5cGUgPT09IFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShsZWZ0U3RhcnRQb3MsIEVycm9yTWVzc2FnZXMuUGlwZWxpbmVIZWFkU2VxdWVuY2VFeHByZXNzaW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwYXJzZVNtYXJ0UGlwZWxpbmVCb2R5KGNoaWxkRXhwcmVzc2lvbiwgc3RhcnRQb3MsIHN0YXJ0TG9jKSB7XG4gICAgY29uc3QgcGlwZWxpbmVTdHlsZSA9IHRoaXMuY2hlY2tTbWFydFBpcGVsaW5lQm9keVN0eWxlKGNoaWxkRXhwcmVzc2lvbik7XG4gICAgdGhpcy5jaGVja1NtYXJ0UGlwZWxpbmVCb2R5RWFybHlFcnJvcnMoY2hpbGRFeHByZXNzaW9uLCBwaXBlbGluZVN0eWxlLCBzdGFydFBvcyk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTbWFydFBpcGVsaW5lQm9keUluU3R5bGUoY2hpbGRFeHByZXNzaW9uLCBwaXBlbGluZVN0eWxlLCBzdGFydFBvcywgc3RhcnRMb2MpO1xuICB9XG5cbiAgY2hlY2tTbWFydFBpcGVsaW5lQm9keUVhcmx5RXJyb3JzKGNoaWxkRXhwcmVzc2lvbiwgcGlwZWxpbmVTdHlsZSwgc3RhcnRQb3MpIHtcbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5hcnJvdykpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCwgRXJyb3JNZXNzYWdlcy5QaXBlbGluZUJvZHlOb0Fycm93KTtcbiAgICB9IGVsc2UgaWYgKHBpcGVsaW5lU3R5bGUgPT09IFwiUGlwZWxpbmVUb3BpY0V4cHJlc3Npb25cIiAmJiBjaGlsZEV4cHJlc3Npb24udHlwZSA9PT0gXCJTZXF1ZW5jZUV4cHJlc3Npb25cIikge1xuICAgICAgdGhpcy5yYWlzZShzdGFydFBvcywgRXJyb3JNZXNzYWdlcy5QaXBlbGluZUJvZHlTZXF1ZW5jZUV4cHJlc3Npb24pO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlU21hcnRQaXBlbGluZUJvZHlJblN0eWxlKGNoaWxkRXhwcmVzc2lvbiwgcGlwZWxpbmVTdHlsZSwgc3RhcnRQb3MsIHN0YXJ0TG9jKSB7XG4gICAgY29uc3QgYm9keU5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG5cbiAgICBzd2l0Y2ggKHBpcGVsaW5lU3R5bGUpIHtcbiAgICAgIGNhc2UgXCJQaXBlbGluZUJhcmVGdW5jdGlvblwiOlxuICAgICAgICBib2R5Tm9kZS5jYWxsZWUgPSBjaGlsZEV4cHJlc3Npb247XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiUGlwZWxpbmVCYXJlQ29uc3RydWN0b3JcIjpcbiAgICAgICAgYm9keU5vZGUuY2FsbGVlID0gY2hpbGRFeHByZXNzaW9uLmNhbGxlZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJQaXBlbGluZUJhcmVBd2FpdGVkRnVuY3Rpb25cIjpcbiAgICAgICAgYm9keU5vZGUuY2FsbGVlID0gY2hpbGRFeHByZXNzaW9uLmFyZ3VtZW50O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlBpcGVsaW5lVG9waWNFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmICghdGhpcy50b3BpY1JlZmVyZW5jZVdhc1VzZWRJbkN1cnJlbnRUb3BpY0NvbnRleHQoKSkge1xuICAgICAgICAgIHRoaXMucmFpc2Uoc3RhcnRQb3MsIEVycm9yTWVzc2FnZXMuUGlwZWxpbmVUb3BpY1VudXNlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBib2R5Tm9kZS5leHByZXNzaW9uID0gY2hpbGRFeHByZXNzaW9uO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBAYmFiZWwvcGFyc2VyIGVycm9yOiBVbmtub3duIHBpcGVsaW5lIHN0eWxlICgke3BpcGVsaW5lU3R5bGV9KWApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoYm9keU5vZGUsIHBpcGVsaW5lU3R5bGUpO1xuICB9XG5cbiAgY2hlY2tTbWFydFBpcGVsaW5lQm9keVN0eWxlKGV4cHJlc3Npb24pIHtcbiAgICBzd2l0Y2ggKGV4cHJlc3Npb24udHlwZSkge1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTaW1wbGVSZWZlcmVuY2UoZXhwcmVzc2lvbikgPyBcIlBpcGVsaW5lQmFyZUZ1bmN0aW9uXCIgOiBcIlBpcGVsaW5lVG9waWNFeHByZXNzaW9uXCI7XG4gICAgfVxuICB9XG5cbiAgaXNTaW1wbGVSZWZlcmVuY2UoZXhwcmVzc2lvbikge1xuICAgIHN3aXRjaCAoZXhwcmVzc2lvbi50eXBlKSB7XG4gICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gIWV4cHJlc3Npb24uY29tcHV0ZWQgJiYgdGhpcy5pc1NpbXBsZVJlZmVyZW5jZShleHByZXNzaW9uLm9iamVjdCk7XG5cbiAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgd2l0aFRvcGljUGVybWl0dGluZ0NvbnRleHQoY2FsbGJhY2spIHtcbiAgICBjb25zdCBvdXRlckNvbnRleHRUb3BpY1N0YXRlID0gdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQ7XG4gICAgdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQgPSB7XG4gICAgICBtYXhOdW1PZlJlc29sdmFibGVUb3BpY3M6IDEsXG4gICAgICBtYXhUb3BpY0luZGV4OiBudWxsXG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQgPSBvdXRlckNvbnRleHRUb3BpY1N0YXRlO1xuICAgIH1cbiAgfVxuXG4gIHdpdGhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgb3V0ZXJDb250ZXh0VG9waWNTdGF0ZSA9IHRoaXMuc3RhdGUudG9waWNDb250ZXh0O1xuICAgIHRoaXMuc3RhdGUudG9waWNDb250ZXh0ID0ge1xuICAgICAgbWF4TnVtT2ZSZXNvbHZhYmxlVG9waWNzOiAwLFxuICAgICAgbWF4VG9waWNJbmRleDogbnVsbFxuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUudG9waWNDb250ZXh0ID0gb3V0ZXJDb250ZXh0VG9waWNTdGF0ZTtcbiAgICB9XG4gIH1cblxuICB3aXRoU29sb0F3YWl0UGVybWl0dGluZ0NvbnRleHQoY2FsbGJhY2spIHtcbiAgICBjb25zdCBvdXRlckNvbnRleHRTb2xvQXdhaXRTdGF0ZSA9IHRoaXMuc3RhdGUuc29sb0F3YWl0O1xuICAgIHRoaXMuc3RhdGUuc29sb0F3YWl0ID0gdHJ1ZTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5zdGF0ZS5zb2xvQXdhaXQgPSBvdXRlckNvbnRleHRTb2xvQXdhaXRTdGF0ZTtcbiAgICB9XG4gIH1cblxuICByZWdpc3RlclRvcGljUmVmZXJlbmNlKCkge1xuICAgIHRoaXMuc3RhdGUudG9waWNDb250ZXh0Lm1heFRvcGljSW5kZXggPSAwO1xuICB9XG5cbiAgcHJpbWFyeVRvcGljUmVmZXJlbmNlSXNBbGxvd2VkSW5DdXJyZW50VG9waWNDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnRvcGljQ29udGV4dC5tYXhOdW1PZlJlc29sdmFibGVUb3BpY3MgPj0gMTtcbiAgfVxuXG4gIHRvcGljUmVmZXJlbmNlV2FzVXNlZEluQ3VycmVudFRvcGljQ29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQubWF4VG9waWNJbmRleCAhPSBudWxsICYmIHRoaXMuc3RhdGUudG9waWNDb250ZXh0Lm1heFRvcGljSW5kZXggPj0gMDtcbiAgfVxuXG4gIHBhcnNlRlNoYXJwUGlwZWxpbmVCb2R5KHByZWMsIG5vSW4pIHtcbiAgICBjb25zdCBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHRoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3Qgb2xkSW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSB0cnVlO1xuICAgIGNvbnN0IHJldCA9IHRoaXMucGFyc2VFeHByT3AodGhpcy5wYXJzZU1heWJlVW5hcnkoKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcmVjLCBub0luKTtcbiAgICB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gb2xkSW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG59XG5cbmNvbnN0IGxvb3BMYWJlbCA9IHtcbiAga2luZDogXCJsb29wXCJcbn0sXG4gICAgICBzd2l0Y2hMYWJlbCA9IHtcbiAga2luZDogXCJzd2l0Y2hcIlxufTtcbmNvbnN0IEZVTkNfTk9fRkxBR1MgPSAwYjAwMCxcbiAgICAgIEZVTkNfU1RBVEVNRU5UID0gMGIwMDEsXG4gICAgICBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UID0gMGIwMTAsXG4gICAgICBGVU5DX05VTExBQkxFX0lEID0gMGIxMDA7XG5jbGFzcyBTdGF0ZW1lbnRQYXJzZXIgZXh0ZW5kcyBFeHByZXNzaW9uUGFyc2VyIHtcbiAgcGFyc2VUb3BMZXZlbChmaWxlLCBwcm9ncmFtKSB7XG4gICAgcHJvZ3JhbS5zb3VyY2VUeXBlID0gdGhpcy5vcHRpb25zLnNvdXJjZVR5cGU7XG4gICAgcHJvZ3JhbS5pbnRlcnByZXRlciA9IHRoaXMucGFyc2VJbnRlcnByZXRlckRpcmVjdGl2ZSgpO1xuICAgIHRoaXMucGFyc2VCbG9ja0JvZHkocHJvZ3JhbSwgdHJ1ZSwgdHJ1ZSwgdHlwZXMuZW9mKTtcblxuICAgIGlmICh0aGlzLmluTW9kdWxlICYmICF0aGlzLm9wdGlvbnMuYWxsb3dVbmRlY2xhcmVkRXhwb3J0cyAmJiB0aGlzLnNjb3BlLnVuZGVmaW5lZEV4cG9ydHMuc2l6ZSA+IDApIHtcbiAgICAgIGZvciAobGV0IF9pID0gMCwgX0FycmF5JGZyb20gPSBBcnJheS5mcm9tKHRoaXMuc2NvcGUudW5kZWZpbmVkRXhwb3J0cyk7IF9pIDwgX0FycmF5JGZyb20ubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGNvbnN0IFtuYW1lXSA9IF9BcnJheSRmcm9tW19pXTtcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5zY29wZS51bmRlZmluZWRFeHBvcnRzLmdldChuYW1lKTtcbiAgICAgICAgdGhpcy5yYWlzZShwb3MsIEVycm9yTWVzc2FnZXMuTW9kdWxlRXhwb3J0VW5kZWZpbmVkLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaWxlLnByb2dyYW0gPSB0aGlzLmZpbmlzaE5vZGUocHJvZ3JhbSwgXCJQcm9ncmFtXCIpO1xuICAgIGZpbGUuY29tbWVudHMgPSB0aGlzLnN0YXRlLmNvbW1lbnRzO1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG9rZW5zKSBmaWxlLnRva2VucyA9IHRoaXMudG9rZW5zO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZmlsZSwgXCJGaWxlXCIpO1xuICB9XG5cbiAgc3RtdFRvRGlyZWN0aXZlKHN0bXQpIHtcbiAgICBjb25zdCBleHByID0gc3RtdC5leHByZXNzaW9uO1xuICAgIGNvbnN0IGRpcmVjdGl2ZUxpdGVyYWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGV4cHIuc3RhcnQsIGV4cHIubG9jLnN0YXJ0KTtcbiAgICBjb25zdCBkaXJlY3RpdmUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0bXQuc3RhcnQsIHN0bXQubG9jLnN0YXJ0KTtcbiAgICBjb25zdCByYXcgPSB0aGlzLmlucHV0LnNsaWNlKGV4cHIuc3RhcnQsIGV4cHIuZW5kKTtcbiAgICBjb25zdCB2YWwgPSBkaXJlY3RpdmVMaXRlcmFsLnZhbHVlID0gcmF3LnNsaWNlKDEsIC0xKTtcbiAgICB0aGlzLmFkZEV4dHJhKGRpcmVjdGl2ZUxpdGVyYWwsIFwicmF3XCIsIHJhdyk7XG4gICAgdGhpcy5hZGRFeHRyYShkaXJlY3RpdmVMaXRlcmFsLCBcInJhd1ZhbHVlXCIsIHZhbCk7XG4gICAgZGlyZWN0aXZlLnZhbHVlID0gdGhpcy5maW5pc2hOb2RlQXQoZGlyZWN0aXZlTGl0ZXJhbCwgXCJEaXJlY3RpdmVMaXRlcmFsXCIsIGV4cHIuZW5kLCBleHByLmxvYy5lbmQpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGVBdChkaXJlY3RpdmUsIFwiRGlyZWN0aXZlXCIsIHN0bXQuZW5kLCBzdG10LmxvYy5lbmQpO1xuICB9XG5cbiAgcGFyc2VJbnRlcnByZXRlckRpcmVjdGl2ZSgpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2godHlwZXMuaW50ZXJwcmV0ZXJEaXJlY3RpdmUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW50ZXJwcmV0ZXJEaXJlY3RpdmVcIik7XG4gIH1cblxuICBpc0xldChjb250ZXh0KSB7XG4gICAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbChcImxldFwiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlblN0YXJ0KCk7XG4gICAgY29uc3QgbmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpO1xuICAgIGlmIChuZXh0Q2ggPT09IDkxKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoY29udGV4dCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChuZXh0Q2ggPT09IDEyMykgcmV0dXJuIHRydWU7XG5cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQobmV4dENoKSkge1xuICAgICAgbGV0IHBvcyA9IG5leHQgKyAxO1xuXG4gICAgICB3aGlsZSAoaXNJZGVudGlmaWVyQ2hhcih0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlkZW50ID0gdGhpcy5pbnB1dC5zbGljZShuZXh0LCBwb3MpO1xuICAgICAgaWYgKCFrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yLnRlc3QoaWRlbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwYXJzZVN0YXRlbWVudChjb250ZXh0LCB0b3BMZXZlbCkge1xuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmF0KSkge1xuICAgICAgdGhpcy5wYXJzZURlY29yYXRvcnModHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnRDb250ZW50KGNvbnRleHQsIHRvcExldmVsKTtcbiAgfVxuXG4gIHBhcnNlU3RhdGVtZW50Q29udGVudChjb250ZXh0LCB0b3BMZXZlbCkge1xuICAgIGxldCBzdGFydHR5cGUgPSB0aGlzLnN0YXRlLnR5cGU7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbGV0IGtpbmQ7XG5cbiAgICBpZiAodGhpcy5pc0xldChjb250ZXh0KSkge1xuICAgICAgc3RhcnR0eXBlID0gdHlwZXMuX3ZhcjtcbiAgICAgIGtpbmQgPSBcImxldFwiO1xuICAgIH1cblxuICAgIHN3aXRjaCAoc3RhcnR0eXBlKSB7XG4gICAgICBjYXNlIHR5cGVzLl9icmVhazpcbiAgICAgIGNhc2UgdHlwZXMuX2NvbnRpbnVlOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQobm9kZSwgc3RhcnR0eXBlLmtleXdvcmQpO1xuXG4gICAgICBjYXNlIHR5cGVzLl9kZWJ1Z2dlcjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKTtcblxuICAgICAgY2FzZSB0eXBlcy5fZG86XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRG9TdGF0ZW1lbnQobm9kZSk7XG5cbiAgICAgIGNhc2UgdHlwZXMuX2ZvcjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JTdGF0ZW1lbnQobm9kZSk7XG5cbiAgICAgIGNhc2UgdHlwZXMuX2Z1bmN0aW9uOlxuICAgICAgICBpZiAodGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSA0NikgYnJlYWs7XG5cbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdHJpY3QpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCwgRXJyb3JNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0ICE9PSBcImlmXCIgJiYgY29udGV4dCAhPT0gXCJsYWJlbFwiKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIEVycm9yTWVzc2FnZXMuU2xvcHB5RnVuY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobm9kZSwgZmFsc2UsICFjb250ZXh0KTtcblxuICAgICAgY2FzZSB0eXBlcy5fY2xhc3M6XG4gICAgICAgIGlmIChjb250ZXh0KSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyhub2RlLCB0cnVlKTtcblxuICAgICAgY2FzZSB0eXBlcy5faWY6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlSWZTdGF0ZW1lbnQobm9kZSk7XG5cbiAgICAgIGNhc2UgdHlwZXMuX3JldHVybjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSZXR1cm5TdGF0ZW1lbnQobm9kZSk7XG5cbiAgICAgIGNhc2UgdHlwZXMuX3N3aXRjaDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTd2l0Y2hTdGF0ZW1lbnQobm9kZSk7XG5cbiAgICAgIGNhc2UgdHlwZXMuX3Rocm93OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRocm93U3RhdGVtZW50KG5vZGUpO1xuXG4gICAgICBjYXNlIHR5cGVzLl90cnk6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpO1xuXG4gICAgICBjYXNlIHR5cGVzLl9jb25zdDpcbiAgICAgIGNhc2UgdHlwZXMuX3ZhcjpcbiAgICAgICAga2luZCA9IGtpbmQgfHwgdGhpcy5zdGF0ZS52YWx1ZTtcblxuICAgICAgICBpZiAoY29udGV4dCAmJiBraW5kICE9PSBcInZhclwiKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLlVuZXhwZWN0ZWRMZXhpY2FsRGVjbGFyYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwga2luZCk7XG5cbiAgICAgIGNhc2UgdHlwZXMuX3doaWxlOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVdoaWxlU3RhdGVtZW50KG5vZGUpO1xuXG4gICAgICBjYXNlIHR5cGVzLl93aXRoOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSk7XG5cbiAgICAgIGNhc2UgdHlwZXMuYnJhY2VMOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJsb2NrKCk7XG5cbiAgICAgIGNhc2UgdHlwZXMuc2VtaTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFbXB0eVN0YXRlbWVudChub2RlKTtcblxuICAgICAgY2FzZSB0eXBlcy5fZXhwb3J0OlxuICAgICAgY2FzZSB0eXBlcy5faW1wb3J0OlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbmV4dFRva2VuQ2hhckNvZGUgPSB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCk7XG5cbiAgICAgICAgICBpZiAobmV4dFRva2VuQ2hhckNvZGUgPT09IDQwIHx8IG5leHRUb2tlbkNoYXJDb2RlID09PSA0Nikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlICYmICF0b3BMZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLlVuZXhwZWN0ZWRJbXBvcnRFeHBvcnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgICBpZiAoc3RhcnR0eXBlID09PSB0eXBlcy5faW1wb3J0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlSW1wb3J0KG5vZGUpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiSW1wb3J0RGVjbGFyYXRpb25cIiAmJiAoIXJlc3VsdC5pbXBvcnRLaW5kIHx8IHJlc3VsdC5pbXBvcnRLaW5kID09PSBcInZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlRXhwb3J0KG5vZGUpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiICYmICghcmVzdWx0LmV4cG9ydEtpbmQgfHwgcmVzdWx0LmV4cG9ydEtpbmQgPT09IFwidmFsdWVcIikgfHwgcmVzdWx0LnR5cGUgPT09IFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIiAmJiAoIXJlc3VsdC5leHBvcnRLaW5kIHx8IHJlc3VsdC5leHBvcnRLaW5kID09PSBcInZhbHVlXCIpIHx8IHJlc3VsdC50eXBlID09PSBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYXNzZXJ0TW9kdWxlTm9kZUFsbG93ZWQobm9kZSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNBc3luY0Z1bmN0aW9uKCkpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCwgRXJyb3JNZXNzYWdlcy5Bc3luY0Z1bmN0aW9uSW5TaW5nbGVTdGF0ZW1lbnRDb250ZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIHRydWUsICFjb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtYXliZU5hbWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgaWYgKHN0YXJ0dHlwZSA9PT0gdHlwZXMubmFtZSAmJiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHRoaXMuZWF0KHR5cGVzLmNvbG9uKSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwciwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByKTtcbiAgICB9XG4gIH1cblxuICBhc3NlcnRNb2R1bGVOb2RlQWxsb3dlZChub2RlKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlICYmICF0aGlzLmluTW9kdWxlKSB7XG4gICAgICB0aGlzLnJhaXNlV2l0aERhdGEobm9kZS5zdGFydCwge1xuICAgICAgICBjb2RlOiBcIkJBQkVMX1BBUlNFUl9TT1VSQ0VUWVBFX01PRFVMRV9SRVFVSVJFRFwiXG4gICAgICB9LCBFcnJvck1lc3NhZ2VzLkltcG9ydE91dHNpZGVNb2R1bGUpO1xuICAgIH1cbiAgfVxuXG4gIHRha2VEZWNvcmF0b3JzKG5vZGUpIHtcbiAgICBjb25zdCBkZWNvcmF0b3JzID0gdGhpcy5zdGF0ZS5kZWNvcmF0b3JTdGFja1t0aGlzLnN0YXRlLmRlY29yYXRvclN0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgICBub2RlLmRlY29yYXRvcnMgPSBkZWNvcmF0b3JzO1xuICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShub2RlLCBkZWNvcmF0b3JzWzBdKTtcbiAgICAgIHRoaXMuc3RhdGUuZGVjb3JhdG9yU3RhY2tbdGhpcy5zdGF0ZS5kZWNvcmF0b3JTdGFjay5sZW5ndGggLSAxXSA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIGNhbkhhdmVMZWFkaW5nRGVjb3JhdG9yKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKHR5cGVzLl9jbGFzcyk7XG4gIH1cblxuICBwYXJzZURlY29yYXRvcnMoYWxsb3dFeHBvcnQpIHtcbiAgICBjb25zdCBjdXJyZW50Q29udGV4dERlY29yYXRvcnMgPSB0aGlzLnN0YXRlLmRlY29yYXRvclN0YWNrW3RoaXMuc3RhdGUuZGVjb3JhdG9yU3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICB3aGlsZSAodGhpcy5tYXRjaCh0eXBlcy5hdCkpIHtcbiAgICAgIGNvbnN0IGRlY29yYXRvciA9IHRoaXMucGFyc2VEZWNvcmF0b3IoKTtcbiAgICAgIGN1cnJlbnRDb250ZXh0RGVjb3JhdG9ycy5wdXNoKGRlY29yYXRvcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2V4cG9ydCkpIHtcbiAgICAgIGlmICghYWxsb3dFeHBvcnQpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImRlY29yYXRvcnNcIikgJiYgIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZGVjb3JhdG9yc1wiLCBcImRlY29yYXRvcnNCZWZvcmVFeHBvcnRcIikpIHtcbiAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLkRlY29yYXRvckV4cG9ydENsYXNzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCF0aGlzLmNhbkhhdmVMZWFkaW5nRGVjb3JhdG9yKCkpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCwgRXJyb3JNZXNzYWdlcy5VbmV4cGVjdGVkTGVhZGluZ0RlY29yYXRvcik7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VEZWNvcmF0b3IoKSB7XG4gICAgdGhpcy5leHBlY3RPbmVQbHVnaW4oW1wiZGVjb3JhdG9ycy1sZWdhY3lcIiwgXCJkZWNvcmF0b3JzXCJdKTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImRlY29yYXRvcnNcIikpIHtcbiAgICAgIHRoaXMuc3RhdGUuZGVjb3JhdG9yU3RhY2sucHVzaChbXSk7XG4gICAgICBjb25zdCBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICBsZXQgZXhwcjtcblxuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLnBhcmVuTCkpIHtcbiAgICAgICAgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHByID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoZmFsc2UpO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLmVhdCh0eXBlcy5kb3QpKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgICBub2RlLm9iamVjdCA9IGV4cHI7XG4gICAgICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgICAgIG5vZGUuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnBhcnNlTWF5YmVEZWNvcmF0b3JBcmd1bWVudHMoZXhwcik7XG4gICAgICB0aGlzLnN0YXRlLmRlY29yYXRvclN0YWNrLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjb3JhdG9yXCIpO1xuICB9XG5cbiAgcGFyc2VNYXliZURlY29yYXRvckFyZ3VtZW50cyhleHByKSB7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnBhcmVuTCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShleHByKTtcbiAgICAgIG5vZGUuY2FsbGVlID0gZXhwcjtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKHR5cGVzLnBhcmVuUiwgZmFsc2UpO1xuICAgICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0KG5vZGUuYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIHBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudChub2RlLCBrZXl3b3JkKSB7XG4gICAgY29uc3QgaXNCcmVhayA9IGtleXdvcmQgPT09IFwiYnJlYWtcIjtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIGlmICh0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgbm9kZS5sYWJlbCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUubGFiZWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG5cbiAgICB0aGlzLnZlcmlmeUJyZWFrQ29udGludWUobm9kZSwga2V5d29yZCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0JyZWFrID8gXCJCcmVha1N0YXRlbWVudFwiIDogXCJDb250aW51ZVN0YXRlbWVudFwiKTtcbiAgfVxuXG4gIHZlcmlmeUJyZWFrQ29udGludWUobm9kZSwga2V5d29yZCkge1xuICAgIGNvbnN0IGlzQnJlYWsgPSBrZXl3b3JkID09PSBcImJyZWFrXCI7XG4gICAgbGV0IGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zdGF0ZS5sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGxhYiA9IHRoaXMuc3RhdGUubGFiZWxzW2ldO1xuXG4gICAgICBpZiAobm9kZS5sYWJlbCA9PSBudWxsIHx8IGxhYi5uYW1lID09PSBub2RlLmxhYmVsLm5hbWUpIHtcbiAgICAgICAgaWYgKGxhYi5raW5kICE9IG51bGwgJiYgKGlzQnJlYWsgfHwgbGFiLmtpbmQgPT09IFwibG9vcFwiKSkgYnJlYWs7XG4gICAgICAgIGlmIChub2RlLmxhYmVsICYmIGlzQnJlYWspIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpID09PSB0aGlzLnN0YXRlLmxhYmVscy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgRXJyb3JNZXNzYWdlcy5JbGxlZ2FsQnJlYWtDb250aW51ZSwga2V5d29yZCk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVidWdnZXJTdGF0ZW1lbnRcIik7XG4gIH1cblxuICBwYXJzZUhlYWRlckV4cHJlc3Npb24oKSB7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgICBjb25zdCB2YWwgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIHBhcnNlRG9TdGF0ZW1lbnQobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLndpdGhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpID0+IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJkb1wiKSk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucG9wKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuX3doaWxlKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlSGVhZGVyRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZWF0KHR5cGVzLnNlbWkpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEb1doaWxlU3RhdGVtZW50XCIpO1xuICB9XG5cbiAgcGFyc2VGb3JTdGF0ZW1lbnQobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICBsZXQgYXdhaXRBdCA9IC0xO1xuXG4gICAgaWYgKHRoaXMuaXNBd2FpdEFsbG93ZWQoKSAmJiB0aGlzLmVhdENvbnRleHR1YWwoXCJhd2FpdFwiKSkge1xuICAgICAgYXdhaXRBdCA9IHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0O1xuICAgIH1cblxuICAgIHRoaXMuc2NvcGUuZW50ZXIoU0NPUEVfT1RIRVIpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5zZW1pKSkge1xuICAgICAgaWYgKGF3YWl0QXQgPiAtMSkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIG51bGwpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzTGV0ID0gdGhpcy5pc0xldCgpO1xuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuX3ZhcikgfHwgdGhpcy5tYXRjaCh0eXBlcy5fY29uc3QpIHx8IGlzTGV0KSB7XG4gICAgICBjb25zdCBpbml0ID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIGNvbnN0IGtpbmQgPSBpc0xldCA/IFwibGV0XCIgOiB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLnBhcnNlVmFyKGluaXQsIHRydWUsIGtpbmQpO1xuICAgICAgdGhpcy5maW5pc2hOb2RlKGluaXQsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcblxuICAgICAgaWYgKCh0aGlzLm1hdGNoKHR5cGVzLl9pbikgfHwgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkgJiYgaW5pdC5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdCwgYXdhaXRBdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhd2FpdEF0ID4gLTEpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0KTtcbiAgICB9XG5cbiAgICBjb25zdCByZWZFeHByZXNzaW9uRXJyb3JzID0gbmV3IEV4cHJlc3Npb25FcnJvcnMoKTtcbiAgICBjb25zdCBpbml0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5faW4pIHx8IHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpIHtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKGluaXQpO1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpID8gXCJmb3Itb2Ygc3RhdGVtZW50XCIgOiBcImZvci1pbiBzdGF0ZW1lbnRcIjtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGluaXQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZXNjcmlwdGlvbik7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQsIGF3YWl0QXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCB0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAoYXdhaXRBdCA+IC0xKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdCk7XG4gIH1cblxuICBwYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIGlzQXN5bmMsIGRlY2xhcmF0aW9uUG9zaXRpb24pIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIEZVTkNfU1RBVEVNRU5UIHwgKGRlY2xhcmF0aW9uUG9zaXRpb24gPyAwIDogRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCksIGlzQXN5bmMpO1xuICB9XG5cbiAgcGFyc2VJZlN0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZUhlYWRlckV4cHJlc3Npb24oKTtcbiAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiaWZcIik7XG4gICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLmVhdCh0eXBlcy5fZWxzZSkgPyB0aGlzLnBhcnNlU3RhdGVtZW50KFwiaWZcIikgOiBudWxsO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKTtcbiAgfVxuXG4gIHBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpIHtcbiAgICBpZiAoIXRoaXMucHJvZFBhcmFtLmhhc1JldHVybiAmJiAhdGhpcy5vcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIEVycm9yTWVzc2FnZXMuSWxsZWdhbFJldHVybik7XG4gICAgfVxuXG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAodGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJldHVyblN0YXRlbWVudFwiKTtcbiAgfVxuXG4gIHBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmRpc2NyaW1pbmFudCA9IHRoaXMucGFyc2VIZWFkZXJFeHByZXNzaW9uKCk7XG4gICAgY29uc3QgY2FzZXMgPSBub2RlLmNhc2VzID0gW107XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wdXNoKHN3aXRjaExhYmVsKTtcbiAgICB0aGlzLnNjb3BlLmVudGVyKFNDT1BFX09USEVSKTtcbiAgICBsZXQgY3VyO1xuXG4gICAgZm9yIChsZXQgc2F3RGVmYXVsdDsgIXRoaXMubWF0Y2godHlwZXMuYnJhY2VSKTspIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLl9jYXNlKSB8fCB0aGlzLm1hdGNoKHR5cGVzLl9kZWZhdWx0KSkge1xuICAgICAgICBjb25zdCBpc0Nhc2UgPSB0aGlzLm1hdGNoKHR5cGVzLl9jYXNlKTtcbiAgICAgICAgaWYgKGN1cikgdGhpcy5maW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpO1xuICAgICAgICBjYXNlcy5wdXNoKGN1ciA9IHRoaXMuc3RhcnROb2RlKCkpO1xuICAgICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgICBpZiAoaXNDYXNlKSB7XG4gICAgICAgICAgY3VyLnRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzYXdEZWZhdWx0KSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0LCBFcnJvck1lc3NhZ2VzLk11bHRpcGxlRGVmYXVsdHNJblN3aXRjaCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgY3VyLnRlc3QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29sb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN1cikge1xuICAgICAgICAgIGN1ci5jb25zZXF1ZW50LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudChudWxsKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICBpZiAoY3VyKSB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN3aXRjaFN0YXRlbWVudFwiKTtcbiAgfVxuXG4gIHBhcnNlVGhyb3dTdGF0ZW1lbnQobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgaWYgKGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGF0ZS5sYXN0VG9rRW5kLCB0aGlzLnN0YXRlLnN0YXJ0KSkpIHtcbiAgICAgIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5sYXN0VG9rRW5kLCBFcnJvck1lc3NhZ2VzLk5ld2xpbmVBZnRlclRocm93KTtcbiAgICB9XG5cbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaHJvd1N0YXRlbWVudFwiKTtcbiAgfVxuXG4gIHBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgbm9kZS5oYW5kbGVyID0gbnVsbDtcblxuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLl9jYXRjaCkpIHtcbiAgICAgIGNvbnN0IGNsYXVzZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMucGFyZW5MKSkge1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICAgICAgICBjbGF1c2UucGFyYW0gPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICAgICAgY29uc3Qgc2ltcGxlID0gY2xhdXNlLnBhcmFtLnR5cGUgPT09IFwiSWRlbnRpZmllclwiO1xuICAgICAgICB0aGlzLnNjb3BlLmVudGVyKHNpbXBsZSA/IFNDT1BFX1NJTVBMRV9DQVRDSCA6IDApO1xuICAgICAgICB0aGlzLmNoZWNrTFZhbChjbGF1c2UucGFyYW0sIEJJTkRfTEVYSUNBTCwgbnVsbCwgXCJjYXRjaCBjbGF1c2VcIik7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGF1c2UucGFyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLnNjb3BlLmVudGVyKFNDT1BFX09USEVSKTtcbiAgICAgIH1cblxuICAgICAgY2xhdXNlLmJvZHkgPSB0aGlzLndpdGhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpID0+IHRoaXMucGFyc2VCbG9jayhmYWxzZSwgZmFsc2UpKTtcbiAgICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgICAgbm9kZS5oYW5kbGVyID0gdGhpcy5maW5pc2hOb2RlKGNsYXVzZSwgXCJDYXRjaENsYXVzZVwiKTtcbiAgICB9XG5cbiAgICBub2RlLmZpbmFsaXplciA9IHRoaXMuZWF0KHR5cGVzLl9maW5hbGx5KSA/IHRoaXMucGFyc2VCbG9jaygpIDogbnVsbDtcblxuICAgIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcikge1xuICAgICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLk5vQ2F0Y2hPckZpbmFsbHkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUcnlTdGF0ZW1lbnRcIik7XG4gIH1cblxuICBwYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5wYXJzZVZhcihub2RlLCBmYWxzZSwga2luZCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcbiAgfVxuXG4gIHBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMucGFyc2VIZWFkZXJFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMud2l0aFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCkgPT4gdGhpcy5wYXJzZVN0YXRlbWVudChcIndoaWxlXCIpKTtcbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2hpbGVTdGF0ZW1lbnRcIik7XG4gIH1cblxuICBwYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSkge1xuICAgIGlmICh0aGlzLnN0YXRlLnN0cmljdCkge1xuICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLlN0cmljdFdpdGgpO1xuICAgIH1cblxuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUub2JqZWN0ID0gdGhpcy5wYXJzZUhlYWRlckV4cHJlc3Npb24oKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLndpdGhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpID0+IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJ3aXRoXCIpKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKTtcbiAgfVxuXG4gIHBhcnNlRW1wdHlTdGF0ZW1lbnQobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbXB0eVN0YXRlbWVudFwiKTtcbiAgfVxuXG4gIHBhcnNlTGFiZWxlZFN0YXRlbWVudChub2RlLCBtYXliZU5hbWUsIGV4cHIsIGNvbnRleHQpIHtcbiAgICBmb3IgKGxldCBfaTIgPSAwLCBfdGhpcyRzdGF0ZSRsYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVsczsgX2kyIDwgX3RoaXMkc3RhdGUkbGFiZWxzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIGNvbnN0IGxhYmVsID0gX3RoaXMkc3RhdGUkbGFiZWxzW19pMl07XG5cbiAgICAgIGlmIChsYWJlbC5uYW1lID09PSBtYXliZU5hbWUpIHtcbiAgICAgICAgdGhpcy5yYWlzZShleHByLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLkxhYmVsUmVkZWNsYXJhdGlvbiwgbWF5YmVOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBraW5kID0gdGhpcy5zdGF0ZS50eXBlLmlzTG9vcCA/IFwibG9vcFwiIDogdGhpcy5tYXRjaCh0eXBlcy5fc3dpdGNoKSA/IFwic3dpdGNoXCIgOiBudWxsO1xuXG4gICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGUubGFiZWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBsYWJlbCA9IHRoaXMuc3RhdGUubGFiZWxzW2ldO1xuXG4gICAgICBpZiAobGFiZWwuc3RhdGVtZW50U3RhcnQgPT09IG5vZGUuc3RhcnQpIHtcbiAgICAgICAgbGFiZWwuc3RhdGVtZW50U3RhcnQgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgICAgICBsYWJlbC5raW5kID0ga2luZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RhdGUubGFiZWxzLnB1c2goe1xuICAgICAgbmFtZTogbWF5YmVOYW1lLFxuICAgICAga2luZDoga2luZCxcbiAgICAgIHN0YXRlbWVudFN0YXJ0OiB0aGlzLnN0YXRlLnN0YXJ0XG4gICAgfSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChjb250ZXh0ID8gY29udGV4dC5pbmRleE9mKFwibGFiZWxcIikgPT09IC0xID8gY29udGV4dCArIFwibGFiZWxcIiA6IGNvbnRleHQgOiBcImxhYmVsXCIpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpO1xuICAgIG5vZGUubGFiZWwgPSBleHByO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMYWJlbGVkU3RhdGVtZW50XCIpO1xuICB9XG5cbiAgcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpIHtcbiAgICBub2RlLmV4cHJlc3Npb24gPSBleHByO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIik7XG4gIH1cblxuICBwYXJzZUJsb2NrKGFsbG93RGlyZWN0aXZlcyA9IGZhbHNlLCBjcmVhdGVOZXdMZXhpY2FsU2NvcGUgPSB0cnVlLCBhZnRlckJsb2NrUGFyc2UpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuXG4gICAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkge1xuICAgICAgdGhpcy5zY29wZS5lbnRlcihTQ09QRV9PVEhFUik7XG4gICAgfVxuXG4gICAgdGhpcy5wYXJzZUJsb2NrQm9keShub2RlLCBhbGxvd0RpcmVjdGl2ZXMsIGZhbHNlLCB0eXBlcy5icmFjZVIsIGFmdGVyQmxvY2tQYXJzZSk7XG5cbiAgICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7XG4gICAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQmxvY2tTdGF0ZW1lbnRcIik7XG4gIH1cblxuICBpc1ZhbGlkRGlyZWN0aXZlKHN0bXQpIHtcbiAgICByZXR1cm4gc3RtdC50eXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiAmJiBzdG10LmV4cHJlc3Npb24udHlwZSA9PT0gXCJTdHJpbmdMaXRlcmFsXCIgJiYgIXN0bXQuZXhwcmVzc2lvbi5leHRyYS5wYXJlbnRoZXNpemVkO1xuICB9XG5cbiAgcGFyc2VCbG9ja0JvZHkobm9kZSwgYWxsb3dEaXJlY3RpdmVzLCB0b3BMZXZlbCwgZW5kLCBhZnRlckJsb2NrUGFyc2UpIHtcbiAgICBjb25zdCBib2R5ID0gbm9kZS5ib2R5ID0gW107XG4gICAgY29uc3QgZGlyZWN0aXZlcyA9IG5vZGUuZGlyZWN0aXZlcyA9IFtdO1xuICAgIHRoaXMucGFyc2VCbG9ja09yTW9kdWxlQmxvY2tCb2R5KGJvZHksIGFsbG93RGlyZWN0aXZlcyA/IGRpcmVjdGl2ZXMgOiB1bmRlZmluZWQsIHRvcExldmVsLCBlbmQsIGFmdGVyQmxvY2tQYXJzZSk7XG4gIH1cblxuICBwYXJzZUJsb2NrT3JNb2R1bGVCbG9ja0JvZHkoYm9keSwgZGlyZWN0aXZlcywgdG9wTGV2ZWwsIGVuZCwgYWZ0ZXJCbG9ja1BhcnNlKSB7XG4gICAgY29uc3Qgb2N0YWxQb3NpdGlvbnMgPSBbXTtcbiAgICBjb25zdCBvbGRTdHJpY3QgPSB0aGlzLnN0YXRlLnN0cmljdDtcbiAgICBsZXQgaGFzU3RyaWN0TW9kZURpcmVjdGl2ZSA9IGZhbHNlO1xuICAgIGxldCBwYXJzZWROb25EaXJlY3RpdmUgPSBmYWxzZTtcblxuICAgIHdoaWxlICghdGhpcy5tYXRjaChlbmQpKSB7XG4gICAgICBpZiAoIXBhcnNlZE5vbkRpcmVjdGl2ZSAmJiB0aGlzLnN0YXRlLm9jdGFsUG9zaXRpb25zLmxlbmd0aCkge1xuICAgICAgICBvY3RhbFBvc2l0aW9ucy5wdXNoKC4uLnRoaXMuc3RhdGUub2N0YWxQb3NpdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsLCB0b3BMZXZlbCk7XG5cbiAgICAgIGlmIChkaXJlY3RpdmVzICYmICFwYXJzZWROb25EaXJlY3RpdmUgJiYgdGhpcy5pc1ZhbGlkRGlyZWN0aXZlKHN0bXQpKSB7XG4gICAgICAgIGNvbnN0IGRpcmVjdGl2ZSA9IHRoaXMuc3RtdFRvRGlyZWN0aXZlKHN0bXQpO1xuICAgICAgICBkaXJlY3RpdmVzLnB1c2goZGlyZWN0aXZlKTtcblxuICAgICAgICBpZiAoIWhhc1N0cmljdE1vZGVEaXJlY3RpdmUgJiYgZGlyZWN0aXZlLnZhbHVlLnZhbHVlID09PSBcInVzZSBzdHJpY3RcIikge1xuICAgICAgICAgIGhhc1N0cmljdE1vZGVEaXJlY3RpdmUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuc2V0U3RyaWN0KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHBhcnNlZE5vbkRpcmVjdGl2ZSA9IHRydWU7XG4gICAgICBib2R5LnB1c2goc3RtdCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhdGUuc3RyaWN0ICYmIG9jdGFsUG9zaXRpb25zLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgX2kzID0gMDsgX2kzIDwgb2N0YWxQb3NpdGlvbnMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICBjb25zdCBwb3MgPSBvY3RhbFBvc2l0aW9uc1tfaTNdO1xuICAgICAgICB0aGlzLnJhaXNlKHBvcywgRXJyb3JNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhZnRlckJsb2NrUGFyc2UpIHtcbiAgICAgIGFmdGVyQmxvY2tQYXJzZS5jYWxsKHRoaXMsIGhhc1N0cmljdE1vZGVEaXJlY3RpdmUpO1xuICAgIH1cblxuICAgIGlmICghb2xkU3RyaWN0KSB7XG4gICAgICB0aGlzLnNldFN0cmljdChmYWxzZSk7XG4gICAgfVxuXG4gICAgdGhpcy5uZXh0KCk7XG4gIH1cblxuICBwYXJzZUZvcihub2RlLCBpbml0KSB7XG4gICAgbm9kZS5pbml0ID0gaW5pdDtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5zZW1pKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLm1hdGNoKHR5cGVzLnNlbWkpID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuc2VtaSk7XG4gICAgbm9kZS51cGRhdGUgPSB0aGlzLm1hdGNoKHR5cGVzLnBhcmVuUikgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMud2l0aFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCkgPT4gdGhpcy5wYXJzZVN0YXRlbWVudChcImZvclwiKSk7XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZvclN0YXRlbWVudFwiKTtcbiAgfVxuXG4gIHBhcnNlRm9ySW4obm9kZSwgaW5pdCwgYXdhaXRBdCkge1xuICAgIGNvbnN0IGlzRm9ySW4gPSB0aGlzLm1hdGNoKHR5cGVzLl9pbik7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAoaXNGb3JJbikge1xuICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmF3YWl0ID0gYXdhaXRBdCA+IC0xO1xuICAgIH1cblxuICAgIGlmIChpbml0LnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiICYmIGluaXQuZGVjbGFyYXRpb25zWzBdLmluaXQgIT0gbnVsbCAmJiAoIWlzRm9ySW4gfHwgdGhpcy5zdGF0ZS5zdHJpY3QgfHwgaW5pdC5raW5kICE9PSBcInZhclwiIHx8IGluaXQuZGVjbGFyYXRpb25zWzBdLmlkLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSkge1xuICAgICAgdGhpcy5yYWlzZShpbml0LnN0YXJ0LCBFcnJvck1lc3NhZ2VzLkZvckluT2ZMb29wSW5pdGlhbGl6ZXIsIGlzRm9ySW4gPyBcImZvci1pblwiIDogXCJmb3Itb2ZcIik7XG4gICAgfSBlbHNlIGlmIChpbml0LnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIikge1xuICAgICAgdGhpcy5yYWlzZShpbml0LnN0YXJ0LCBFcnJvck1lc3NhZ2VzLkludmFsaWRMaHMsIFwiZm9yLWxvb3BcIik7XG4gICAgfVxuXG4gICAgbm9kZS5sZWZ0ID0gaW5pdDtcbiAgICBub2RlLnJpZ2h0ID0gaXNGb3JJbiA/IHRoaXMucGFyc2VFeHByZXNzaW9uKCkgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMud2l0aFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCkgPT4gdGhpcy5wYXJzZVN0YXRlbWVudChcImZvclwiKSk7XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0ZvckluID8gXCJGb3JJblN0YXRlbWVudFwiIDogXCJGb3JPZlN0YXRlbWVudFwiKTtcbiAgfVxuXG4gIHBhcnNlVmFyKG5vZGUsIGlzRm9yLCBraW5kKSB7XG4gICAgY29uc3QgZGVjbGFyYXRpb25zID0gbm9kZS5kZWNsYXJhdGlvbnMgPSBbXTtcbiAgICBjb25zdCBpc1R5cGVzY3JpcHQgPSB0aGlzLmhhc1BsdWdpbihcInR5cGVzY3JpcHRcIik7XG4gICAgbm9kZS5raW5kID0ga2luZDtcblxuICAgIGZvciAoOzspIHtcbiAgICAgIGNvbnN0IGRlY2wgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5wYXJzZVZhcklkKGRlY2wsIGtpbmQpO1xuXG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMuZXEpKSB7XG4gICAgICAgIGRlY2wuaW5pdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihpc0Zvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJjb25zdFwiICYmICEodGhpcy5tYXRjaCh0eXBlcy5faW4pIHx8IHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSB7XG4gICAgICAgICAgaWYgKCFpc1R5cGVzY3JpcHQpIHtcbiAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkZWNsLmlkLnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmICEoaXNGb3IgJiYgKHRoaXMubWF0Y2godHlwZXMuX2luKSB8fCB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUubGFzdFRva0VuZCwgRXJyb3JNZXNzYWdlcy5EZWNsYXJhdGlvbk1pc3NpbmdJbml0aWFsaXplciwgXCJDb21wbGV4IGJpbmRpbmcgcGF0dGVybnNcIik7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNsLmluaXQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBkZWNsYXJhdGlvbnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoZGVjbCwgXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpO1xuICAgICAgaWYgKCF0aGlzLmVhdCh0eXBlcy5jb21tYSkpIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcGFyc2VWYXJJZChkZWNsLCBraW5kKSB7XG4gICAgZGVjbC5pZCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIHRoaXMuY2hlY2tMVmFsKGRlY2wuaWQsIGtpbmQgPT09IFwidmFyXCIgPyBCSU5EX1ZBUiA6IEJJTkRfTEVYSUNBTCwgdW5kZWZpbmVkLCBcInZhcmlhYmxlIGRlY2xhcmF0aW9uXCIsIGtpbmQgIT09IFwidmFyXCIpO1xuICB9XG5cbiAgcGFyc2VGdW5jdGlvbihub2RlLCBzdGF0ZW1lbnQgPSBGVU5DX05PX0ZMQUdTLCBpc0FzeW5jID0gZmFsc2UpIHtcbiAgICBjb25zdCBpc1N0YXRlbWVudCA9IHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UO1xuICAgIGNvbnN0IGlzSGFuZ2luZ1N0YXRlbWVudCA9IHN0YXRlbWVudCAmIEZVTkNfSEFOR0lOR19TVEFURU1FTlQ7XG4gICAgY29uc3QgcmVxdWlyZUlkID0gISFpc1N0YXRlbWVudCAmJiAhKHN0YXRlbWVudCAmIEZVTkNfTlVMTEFCTEVfSUQpO1xuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMpO1xuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuc3RhcikgJiYgaXNIYW5naW5nU3RhdGVtZW50KSB7XG4gICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIEVycm9yTWVzc2FnZXMuR2VuZXJhdG9ySW5TaW5nbGVTdGF0ZW1lbnRDb250ZXh0KTtcbiAgICB9XG5cbiAgICBub2RlLmdlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuXG4gICAgaWYgKGlzU3RhdGVtZW50KSB7XG4gICAgICBub2RlLmlkID0gdGhpcy5wYXJzZUZ1bmN0aW9uSWQocmVxdWlyZUlkKTtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRNYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzO1xuICAgIGNvbnN0IG9sZFlpZWxkUG9zID0gdGhpcy5zdGF0ZS55aWVsZFBvcztcbiAgICBjb25zdCBvbGRBd2FpdFBvcyA9IHRoaXMuc3RhdGUuYXdhaXRQb3M7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZS55aWVsZFBvcyA9IC0xO1xuICAgIHRoaXMuc3RhdGUuYXdhaXRQb3MgPSAtMTtcbiAgICB0aGlzLnNjb3BlLmVudGVyKFNDT1BFX0ZVTkNUSU9OKTtcbiAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihmdW5jdGlvbkZsYWdzKGlzQXN5bmMsIG5vZGUuZ2VuZXJhdG9yKSk7XG5cbiAgICBpZiAoIWlzU3RhdGVtZW50KSB7XG4gICAgICBub2RlLmlkID0gdGhpcy5wYXJzZUZ1bmN0aW9uSWQoKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG4gICAgdGhpcy53aXRoVG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKSA9PiB7XG4gICAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIGlzU3RhdGVtZW50ID8gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgOiBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKTtcbiAgICB9KTtcbiAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG5cbiAgICBpZiAoaXNTdGF0ZW1lbnQgJiYgIWlzSGFuZ2luZ1N0YXRlbWVudCkge1xuICAgICAgdGhpcy5yZWdpc3RlckZ1bmN0aW9uU3RhdGVtZW50SWQobm9kZSk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICB0aGlzLnN0YXRlLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgdGhpcy5zdGF0ZS5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcGFyc2VGdW5jdGlvbklkKHJlcXVpcmVJZCkge1xuICAgIHJldHVybiByZXF1aXJlSWQgfHwgdGhpcy5tYXRjaCh0eXBlcy5uYW1lKSA/IHRoaXMucGFyc2VJZGVudGlmaWVyKCkgOiBudWxsO1xuICB9XG5cbiAgcGFyc2VGdW5jdGlvblBhcmFtcyhub2RlLCBhbGxvd01vZGlmaWVycykge1xuICAgIGNvbnN0IG9sZEluUGFyYW1ldGVycyA9IHRoaXMuc3RhdGUuaW5QYXJhbWV0ZXJzO1xuICAgIHRoaXMuc3RhdGUuaW5QYXJhbWV0ZXJzID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICAgIG5vZGUucGFyYW1zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzLnBhcmVuUiwgNDEsIGZhbHNlLCBhbGxvd01vZGlmaWVycyk7XG4gICAgdGhpcy5zdGF0ZS5pblBhcmFtZXRlcnMgPSBvbGRJblBhcmFtZXRlcnM7XG4gICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgfVxuXG4gIHJlZ2lzdGVyRnVuY3Rpb25TdGF0ZW1lbnRJZChub2RlKSB7XG4gICAgaWYgKCFub2RlLmlkKSByZXR1cm47XG4gICAgdGhpcy5zY29wZS5kZWNsYXJlTmFtZShub2RlLmlkLm5hbWUsIHRoaXMuc3RhdGUuc3RyaWN0IHx8IG5vZGUuZ2VuZXJhdG9yIHx8IG5vZGUuYXN5bmMgPyB0aGlzLnNjb3BlLnRyZWF0RnVuY3Rpb25zQXNWYXIgPyBCSU5EX1ZBUiA6IEJJTkRfTEVYSUNBTCA6IEJJTkRfRlVOQ1RJT04sIG5vZGUuaWQuc3RhcnQpO1xuICB9XG5cbiAgcGFyc2VDbGFzcyhub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMudGFrZURlY29yYXRvcnMobm9kZSk7XG4gICAgY29uc3Qgb2xkU3RyaWN0ID0gdGhpcy5zdGF0ZS5zdHJpY3Q7XG4gICAgdGhpcy5zdGF0ZS5zdHJpY3QgPSB0cnVlO1xuICAgIHRoaXMucGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkKTtcbiAgICB0aGlzLnBhcnNlQ2xhc3NTdXBlcihub2RlKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlQ2xhc3NCb2R5KCEhbm9kZS5zdXBlckNsYXNzLCBvbGRTdHJpY3QpO1xuICAgIHRoaXMuc3RhdGUuc3RyaWN0ID0gb2xkU3RyaWN0O1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNTdGF0ZW1lbnQgPyBcIkNsYXNzRGVjbGFyYXRpb25cIiA6IFwiQ2xhc3NFeHByZXNzaW9uXCIpO1xuICB9XG5cbiAgaXNDbGFzc1Byb3BlcnR5KCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKHR5cGVzLmVxKSB8fCB0aGlzLm1hdGNoKHR5cGVzLnNlbWkpIHx8IHRoaXMubWF0Y2godHlwZXMuYnJhY2VSKTtcbiAgfVxuXG4gIGlzQ2xhc3NNZXRob2QoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2godHlwZXMucGFyZW5MKTtcbiAgfVxuXG4gIGlzTm9uc3RhdGljQ29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgcmV0dXJuICFtZXRob2QuY29tcHV0ZWQgJiYgIW1ldGhvZC5zdGF0aWMgJiYgKG1ldGhvZC5rZXkubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8IG1ldGhvZC5rZXkudmFsdWUgPT09IFwiY29uc3RydWN0b3JcIik7XG4gIH1cblxuICBwYXJzZUNsYXNzQm9keShjb25zdHJ1Y3RvckFsbG93c1N1cGVyLCBvbGRTdHJpY3QpIHtcbiAgICB0aGlzLmNsYXNzU2NvcGUuZW50ZXIoKTtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgIGhhZENvbnN0cnVjdG9yOiBmYWxzZVxuICAgIH07XG4gICAgbGV0IGRlY29yYXRvcnMgPSBbXTtcbiAgICBjb25zdCBjbGFzc0JvZHkgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNsYXNzQm9keS5ib2R5ID0gW107XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgICB0aGlzLndpdGhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpID0+IHtcbiAgICAgIHdoaWxlICghdGhpcy5tYXRjaCh0eXBlcy5icmFjZVIpKSB7XG4gICAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5zZW1pKSkge1xuICAgICAgICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucmFpc2UodGhpcy5zdGF0ZS5sYXN0VG9rRW5kLCBFcnJvck1lc3NhZ2VzLkRlY29yYXRvclNlbWljb2xvbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5hdCkpIHtcbiAgICAgICAgICBkZWNvcmF0b3JzLnB1c2godGhpcy5wYXJzZURlY29yYXRvcigpKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1lbWJlciA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgICAgICAgaWYgKGRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgbWVtYmVyLmRlY29yYXRvcnMgPSBkZWNvcmF0b3JzO1xuICAgICAgICAgIHRoaXMucmVzZXRTdGFydExvY2F0aW9uRnJvbU5vZGUobWVtYmVyLCBkZWNvcmF0b3JzWzBdKTtcbiAgICAgICAgICBkZWNvcmF0b3JzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhcnNlQ2xhc3NNZW1iZXIoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlLCBjb25zdHJ1Y3RvckFsbG93c1N1cGVyKTtcblxuICAgICAgICBpZiAobWVtYmVyLmtpbmQgPT09IFwiY29uc3RydWN0b3JcIiAmJiBtZW1iZXIuZGVjb3JhdG9ycyAmJiBtZW1iZXIuZGVjb3JhdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShtZW1iZXIuc3RhcnQsIEVycm9yTWVzc2FnZXMuRGVjb3JhdG9yQ29uc3RydWN0b3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIW9sZFN0cmljdCkge1xuICAgICAgdGhpcy5zdGF0ZS5zdHJpY3QgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLm5leHQoKTtcblxuICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLlRyYWlsaW5nRGVjb3JhdG9yKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsYXNzU2NvcGUuZXhpdCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoY2xhc3NCb2R5LCBcIkNsYXNzQm9keVwiKTtcbiAgfVxuXG4gIHBhcnNlQ2xhc3NNZW1iZXJGcm9tTW9kaWZpZXIoY2xhc3NCb2R5LCBtZW1iZXIpIHtcbiAgICBjb25zdCBjb250YWluc0VzYyA9IHRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG5cbiAgICBpZiAodGhpcy5pc0NsYXNzTWV0aG9kKCkpIHtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IG1lbWJlcjtcbiAgICAgIG1ldGhvZC5raW5kID0gXCJtZXRob2RcIjtcbiAgICAgIG1ldGhvZC5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgbWV0aG9kLmtleSA9IGtleTtcbiAgICAgIG1ldGhvZC5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIHRoaXMucHVzaENsYXNzTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDbGFzc1Byb3BlcnR5KCkpIHtcbiAgICAgIGNvbnN0IHByb3AgPSBtZW1iZXI7XG4gICAgICBwcm9wLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICBwcm9wLmtleSA9IGtleTtcbiAgICAgIHByb3Auc3RhdGljID0gZmFsc2U7XG4gICAgICBjbGFzc0JvZHkuYm9keS5wdXNoKHRoaXMucGFyc2VDbGFzc1Byb3BlcnR5KHByb3ApKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoY29udGFpbnNFc2MpIHtcbiAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHBhcnNlQ2xhc3NNZW1iZXIoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlLCBjb25zdHJ1Y3RvckFsbG93c1N1cGVyKSB7XG4gICAgY29uc3QgaXNTdGF0aWMgPSB0aGlzLmlzQ29udGV4dHVhbChcInN0YXRpY1wiKTtcblxuICAgIGlmIChpc1N0YXRpYyAmJiB0aGlzLnBhcnNlQ2xhc3NNZW1iZXJGcm9tTW9kaWZpZXIoY2xhc3NCb2R5LCBtZW1iZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wYXJzZUNsYXNzTWVtYmVyV2l0aElzU3RhdGljKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSwgaXNTdGF0aWMsIGNvbnN0cnVjdG9yQWxsb3dzU3VwZXIpO1xuICB9XG5cbiAgcGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYyhjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUsIGlzU3RhdGljLCBjb25zdHJ1Y3RvckFsbG93c1N1cGVyKSB7XG4gICAgY29uc3QgcHVibGljTWV0aG9kID0gbWVtYmVyO1xuICAgIGNvbnN0IHByaXZhdGVNZXRob2QgPSBtZW1iZXI7XG4gICAgY29uc3QgcHVibGljUHJvcCA9IG1lbWJlcjtcbiAgICBjb25zdCBwcml2YXRlUHJvcCA9IG1lbWJlcjtcbiAgICBjb25zdCBtZXRob2QgPSBwdWJsaWNNZXRob2Q7XG4gICAgY29uc3QgcHVibGljTWVtYmVyID0gcHVibGljTWV0aG9kO1xuICAgIG1lbWJlci5zdGF0aWMgPSBpc1N0YXRpYztcblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5zdGFyKSkge1xuICAgICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgICAgdGhpcy5wYXJzZUNsYXNzUHJvcGVydHlOYW1lKG1ldGhvZCk7XG5cbiAgICAgIGlmIChtZXRob2Qua2V5LnR5cGUgPT09IFwiUHJpdmF0ZU5hbWVcIikge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBwcml2YXRlTWV0aG9kLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihwdWJsaWNNZXRob2QpKSB7XG4gICAgICAgIHRoaXMucmFpc2UocHVibGljTWV0aG9kLmtleS5zdGFydCwgRXJyb3JNZXNzYWdlcy5Db25zdHJ1Y3RvcklzR2VuZXJhdG9yKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBwdWJsaWNNZXRob2QsIHRydWUsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRhaW5zRXNjID0gdGhpcy5zdGF0ZS5jb250YWluc0VzYztcbiAgICBjb25zdCBrZXkgPSB0aGlzLnBhcnNlQ2xhc3NQcm9wZXJ0eU5hbWUobWVtYmVyKTtcbiAgICBjb25zdCBpc1ByaXZhdGUgPSBrZXkudHlwZSA9PT0gXCJQcml2YXRlTmFtZVwiO1xuICAgIGNvbnN0IGlzU2ltcGxlID0ga2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiO1xuICAgIGNvbnN0IG1heWJlUXVlc3Rpb25Ub2tlblN0YXJ0ID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICB0aGlzLnBhcnNlUG9zdE1lbWJlck5hbWVNb2RpZmllcnMocHVibGljTWVtYmVyKTtcblxuICAgIGlmICh0aGlzLmlzQ2xhc3NNZXRob2QoKSkge1xuICAgICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuXG4gICAgICBpZiAoaXNQcml2YXRlKSB7XG4gICAgICAgIHRoaXMucHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIHByaXZhdGVNZXRob2QsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNDb25zdHJ1Y3RvciA9IHRoaXMuaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihwdWJsaWNNZXRob2QpO1xuICAgICAgbGV0IGFsbG93c0RpcmVjdFN1cGVyID0gZmFsc2U7XG5cbiAgICAgIGlmIChpc0NvbnN0cnVjdG9yKSB7XG4gICAgICAgIHB1YmxpY01ldGhvZC5raW5kID0gXCJjb25zdHJ1Y3RvclwiO1xuXG4gICAgICAgIGlmIChzdGF0ZS5oYWRDb25zdHJ1Y3RvciAmJiAhdGhpcy5oYXNQbHVnaW4oXCJ0eXBlc2NyaXB0XCIpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShrZXkuc3RhcnQsIEVycm9yTWVzc2FnZXMuRHVwbGljYXRlQ29uc3RydWN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuaGFkQ29uc3RydWN0b3IgPSB0cnVlO1xuICAgICAgICBhbGxvd3NEaXJlY3RTdXBlciA9IGNvbnN0cnVjdG9yQWxsb3dzU3VwZXI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHVzaENsYXNzTWV0aG9kKGNsYXNzQm9keSwgcHVibGljTWV0aG9kLCBmYWxzZSwgZmFsc2UsIGlzQ29uc3RydWN0b3IsIGFsbG93c0RpcmVjdFN1cGVyKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDbGFzc1Byb3BlcnR5KCkpIHtcbiAgICAgIGlmIChpc1ByaXZhdGUpIHtcbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NQcml2YXRlUHJvcGVydHkoY2xhc3NCb2R5LCBwcml2YXRlUHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1Byb3BlcnR5KGNsYXNzQm9keSwgcHVibGljUHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1NpbXBsZSAmJiBrZXkubmFtZSA9PT0gXCJhc3luY1wiICYmICFjb250YWluc0VzYyAmJiAhdGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIGNvbnN0IGlzR2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7XG5cbiAgICAgIGlmIChwdWJsaWNNZW1iZXIub3B0aW9uYWwpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKG1heWJlUXVlc3Rpb25Ub2tlblN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgICAgdGhpcy5wYXJzZUNsYXNzUHJvcGVydHlOYW1lKG1ldGhvZCk7XG4gICAgICB0aGlzLnBhcnNlUG9zdE1lbWJlck5hbWVNb2RpZmllcnMocHVibGljTWVtYmVyKTtcblxuICAgICAgaWYgKG1ldGhvZC5rZXkudHlwZSA9PT0gXCJQcml2YXRlTmFtZVwiKSB7XG4gICAgICAgIHRoaXMucHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIHByaXZhdGVNZXRob2QsIGlzR2VuZXJhdG9yLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmlzTm9uc3RhdGljQ29uc3RydWN0b3IocHVibGljTWV0aG9kKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UocHVibGljTWV0aG9kLmtleS5zdGFydCwgRXJyb3JNZXNzYWdlcy5Db25zdHJ1Y3RvcklzQXN5bmMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBwdWJsaWNNZXRob2QsIGlzR2VuZXJhdG9yLCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNTaW1wbGUgJiYgKGtleS5uYW1lID09PSBcImdldFwiIHx8IGtleS5uYW1lID09PSBcInNldFwiKSAmJiAhY29udGFpbnNFc2MgJiYgISh0aGlzLm1hdGNoKHR5cGVzLnN0YXIpICYmIHRoaXMuaXNMaW5lVGVybWluYXRvcigpKSkge1xuICAgICAgbWV0aG9kLmtpbmQgPSBrZXkubmFtZTtcbiAgICAgIHRoaXMucGFyc2VDbGFzc1Byb3BlcnR5TmFtZShwdWJsaWNNZXRob2QpO1xuXG4gICAgICBpZiAobWV0aG9kLmtleS50eXBlID09PSBcIlByaXZhdGVOYW1lXCIpIHtcbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgcHJpdmF0ZU1ldGhvZCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmlzTm9uc3RhdGljQ29uc3RydWN0b3IocHVibGljTWV0aG9kKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UocHVibGljTWV0aG9kLmtleS5zdGFydCwgRXJyb3JNZXNzYWdlcy5Db25zdHJ1Y3RvcklzQWNjZXNzb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBwdWJsaWNNZXRob2QsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jaGVja0dldHRlclNldHRlclBhcmFtcyhwdWJsaWNNZXRob2QpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIGlmIChpc1ByaXZhdGUpIHtcbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NQcml2YXRlUHJvcGVydHkoY2xhc3NCb2R5LCBwcml2YXRlUHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1Byb3BlcnR5KGNsYXNzQm9keSwgcHVibGljUHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlQ2xhc3NQcm9wZXJ0eU5hbWUobWVtYmVyKSB7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5wYXJzZVByb3BlcnR5TmFtZShtZW1iZXIsIHRydWUpO1xuXG4gICAgaWYgKCFtZW1iZXIuY29tcHV0ZWQgJiYgbWVtYmVyLnN0YXRpYyAmJiAoa2V5Lm5hbWUgPT09IFwicHJvdG90eXBlXCIgfHwga2V5LnZhbHVlID09PSBcInByb3RvdHlwZVwiKSkge1xuICAgICAgdGhpcy5yYWlzZShrZXkuc3RhcnQsIEVycm9yTWVzc2FnZXMuU3RhdGljUHJvdG90eXBlKTtcbiAgICB9XG5cbiAgICBpZiAoa2V5LnR5cGUgPT09IFwiUHJpdmF0ZU5hbWVcIiAmJiBrZXkuaWQubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICB0aGlzLnJhaXNlKGtleS5zdGFydCwgRXJyb3JNZXNzYWdlcy5Db25zdHJ1Y3RvckNsYXNzUHJpdmF0ZUZpZWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5O1xuICB9XG5cbiAgcHVzaENsYXNzUHJvcGVydHkoY2xhc3NCb2R5LCBwcm9wKSB7XG4gICAgaWYgKCFwcm9wLmNvbXB1dGVkICYmIChwcm9wLmtleS5uYW1lID09PSBcImNvbnN0cnVjdG9yXCIgfHwgcHJvcC5rZXkudmFsdWUgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgIHRoaXMucmFpc2UocHJvcC5rZXkuc3RhcnQsIEVycm9yTWVzc2FnZXMuQ29uc3RydWN0b3JDbGFzc0ZpZWxkKTtcbiAgICB9XG5cbiAgICBjbGFzc0JvZHkuYm9keS5wdXNoKHRoaXMucGFyc2VDbGFzc1Byb3BlcnR5KHByb3ApKTtcbiAgfVxuXG4gIHB1c2hDbGFzc1ByaXZhdGVQcm9wZXJ0eShjbGFzc0JvZHksIHByb3ApIHtcbiAgICB0aGlzLmV4cGVjdFBsdWdpbihcImNsYXNzUHJpdmF0ZVByb3BlcnRpZXNcIiwgcHJvcC5rZXkuc3RhcnQpO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlQ2xhc3NQcml2YXRlUHJvcGVydHkocHJvcCk7XG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaChub2RlKTtcbiAgICB0aGlzLmNsYXNzU2NvcGUuZGVjbGFyZVByaXZhdGVOYW1lKG5vZGUua2V5LmlkLm5hbWUsIENMQVNTX0VMRU1FTlRfT1RIRVIsIG5vZGUua2V5LnN0YXJ0KTtcbiAgfVxuXG4gIHB1c2hDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93c0RpcmVjdFN1cGVyKSB7XG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaCh0aGlzLnBhcnNlTWV0aG9kKG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93c0RpcmVjdFN1cGVyLCBcIkNsYXNzTWV0aG9kXCIsIHRydWUpKTtcbiAgfVxuXG4gIHB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jKSB7XG4gICAgdGhpcy5leHBlY3RQbHVnaW4oXCJjbGFzc1ByaXZhdGVNZXRob2RzXCIsIG1ldGhvZC5rZXkuc3RhcnQpO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlTWV0aG9kKG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGZhbHNlLCBmYWxzZSwgXCJDbGFzc1ByaXZhdGVNZXRob2RcIiwgdHJ1ZSk7XG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaChub2RlKTtcbiAgICBjb25zdCBraW5kID0gbm9kZS5raW5kID09PSBcImdldFwiID8gbm9kZS5zdGF0aWMgPyBDTEFTU19FTEVNRU5UX1NUQVRJQ19HRVRURVIgOiBDTEFTU19FTEVNRU5UX0lOU1RBTkNFX0dFVFRFUiA6IG5vZGUua2luZCA9PT0gXCJzZXRcIiA/IG5vZGUuc3RhdGljID8gQ0xBU1NfRUxFTUVOVF9TVEFUSUNfU0VUVEVSIDogQ0xBU1NfRUxFTUVOVF9JTlNUQU5DRV9TRVRURVIgOiBDTEFTU19FTEVNRU5UX09USEVSO1xuICAgIHRoaXMuY2xhc3NTY29wZS5kZWNsYXJlUHJpdmF0ZU5hbWUobm9kZS5rZXkuaWQubmFtZSwga2luZCwgbm9kZS5rZXkuc3RhcnQpO1xuICB9XG5cbiAgcGFyc2VQb3N0TWVtYmVyTmFtZU1vZGlmaWVycyhtZXRob2RPclByb3ApIHt9XG5cbiAgcGFyc2VBY2Nlc3NNb2RpZmllcigpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcGFyc2VDbGFzc1ByaXZhdGVQcm9wZXJ0eShub2RlKSB7XG4gICAgdGhpcy5zY29wZS5lbnRlcihTQ09QRV9DTEFTUyB8IFNDT1BFX1NVUEVSKTtcbiAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihQQVJBTSk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMuZWF0KHR5cGVzLmVxKSA/IHRoaXMucGFyc2VNYXliZUFzc2lnbigpIDogbnVsbDtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIik7XG4gIH1cblxuICBwYXJzZUNsYXNzUHJvcGVydHkobm9kZSkge1xuICAgIGlmICghbm9kZS50eXBlQW5ub3RhdGlvbikge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJjbGFzc1Byb3BlcnRpZXNcIik7XG4gICAgfVxuXG4gICAgdGhpcy5zY29wZS5lbnRlcihTQ09QRV9DTEFTUyB8IFNDT1BFX1NVUEVSKTtcbiAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihQQVJBTSk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5lcSkpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiY2xhc3NQcm9wZXJ0aWVzXCIpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudmFsdWUgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDbGFzc1Byb3BlcnR5XCIpO1xuICB9XG5cbiAgcGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkLCBiaW5kaW5nVHlwZSA9IEJJTkRfQ0xBU1MpIHtcbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5uYW1lKSkge1xuICAgICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG5cbiAgICAgIGlmIChpc1N0YXRlbWVudCkge1xuICAgICAgICB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCBiaW5kaW5nVHlwZSwgdW5kZWZpbmVkLCBcImNsYXNzIG5hbWVcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25hbElkIHx8ICFpc1N0YXRlbWVudCkge1xuICAgICAgICBub2RlLmlkID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCBFcnJvck1lc3NhZ2VzLk1pc3NpbmdDbGFzc05hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBhcnNlQ2xhc3NTdXBlcihub2RlKSB7XG4gICAgbm9kZS5zdXBlckNsYXNzID0gdGhpcy5lYXQodHlwZXMuX2V4dGVuZHMpID8gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKCkgOiBudWxsO1xuICB9XG5cbiAgcGFyc2VFeHBvcnQobm9kZSkge1xuICAgIGNvbnN0IGhhc0RlZmF1bHQgPSB0aGlzLm1heWJlUGFyc2VFeHBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUpO1xuICAgIGNvbnN0IHBhcnNlQWZ0ZXJEZWZhdWx0ID0gIWhhc0RlZmF1bHQgfHwgdGhpcy5lYXQodHlwZXMuY29tbWEpO1xuICAgIGNvbnN0IGhhc1N0YXIgPSBwYXJzZUFmdGVyRGVmYXVsdCAmJiB0aGlzLmVhdEV4cG9ydFN0YXIobm9kZSk7XG4gICAgY29uc3QgaGFzTmFtZXNwYWNlID0gaGFzU3RhciAmJiB0aGlzLm1heWJlUGFyc2VFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXIobm9kZSk7XG4gICAgY29uc3QgcGFyc2VBZnRlck5hbWVzcGFjZSA9IHBhcnNlQWZ0ZXJEZWZhdWx0ICYmICghaGFzTmFtZXNwYWNlIHx8IHRoaXMuZWF0KHR5cGVzLmNvbW1hKSk7XG4gICAgY29uc3QgaXNGcm9tUmVxdWlyZWQgPSBoYXNEZWZhdWx0IHx8IGhhc1N0YXI7XG5cbiAgICBpZiAoaGFzU3RhciAmJiAhaGFzTmFtZXNwYWNlKSB7XG4gICAgICBpZiAoaGFzRGVmYXVsdCkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICB0aGlzLnBhcnNlRXhwb3J0RnJvbShub2RlLCB0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBoYXNTcGVjaWZpZXJzID0gdGhpcy5tYXliZVBhcnNlRXhwb3J0TmFtZWRTcGVjaWZpZXJzKG5vZGUpO1xuXG4gICAgaWYgKGhhc0RlZmF1bHQgJiYgcGFyc2VBZnRlckRlZmF1bHQgJiYgIWhhc1N0YXIgJiYgIWhhc1NwZWNpZmllcnMgfHwgaGFzTmFtZXNwYWNlICYmIHBhcnNlQWZ0ZXJOYW1lc3BhY2UgJiYgIWhhc1NwZWNpZmllcnMpIHtcbiAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZChudWxsLCB0eXBlcy5icmFjZUwpO1xuICAgIH1cblxuICAgIGxldCBoYXNEZWNsYXJhdGlvbjtcblxuICAgIGlmIChpc0Zyb21SZXF1aXJlZCB8fCBoYXNTcGVjaWZpZXJzKSB7XG4gICAgICBoYXNEZWNsYXJhdGlvbiA9IGZhbHNlO1xuICAgICAgdGhpcy5wYXJzZUV4cG9ydEZyb20obm9kZSwgaXNGcm9tUmVxdWlyZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYXNEZWNsYXJhdGlvbiA9IHRoaXMubWF5YmVQYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpO1xuICAgIH1cblxuICAgIGlmIChpc0Zyb21SZXF1aXJlZCB8fCBoYXNTcGVjaWZpZXJzIHx8IGhhc0RlY2xhcmF0aW9uKSB7XG4gICAgICB0aGlzLmNoZWNrRXhwb3J0KG5vZGUsIHRydWUsIGZhbHNlLCAhIW5vZGUuc291cmNlKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5fZGVmYXVsdCkpIHtcbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKTtcbiAgICAgIHRoaXMuY2hlY2tFeHBvcnQobm9kZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpO1xuICAgIH1cblxuICAgIHRocm93IHRoaXMudW5leHBlY3RlZChudWxsLCB0eXBlcy5icmFjZUwpO1xuICB9XG5cbiAgZWF0RXhwb3J0U3Rhcihub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICB9XG5cbiAgbWF5YmVQYXJzZUV4cG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSkge1xuICAgIGlmICh0aGlzLmlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImV4cG9ydERlZmF1bHRGcm9tXCIpO1xuICAgICAgY29uc3Qgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHNwZWNpZmllci5leHBvcnRlZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gW3RoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiKV07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtYXliZVBhcnNlRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUpIHtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJhc1wiKSkge1xuICAgICAgaWYgKCFub2RlLnNwZWNpZmllcnMpIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgICAgY29uc3Qgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGVBdCh0aGlzLnN0YXRlLmxhc3RUb2tTdGFydCwgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBzcGVjaWZpZXIuZXhwb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgIG5vZGUuc3BlY2lmaWVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG1heWJlUGFyc2VFeHBvcnROYW1lZFNwZWNpZmllcnMobm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmJyYWNlTCkpIHtcbiAgICAgIGlmICghbm9kZS5zcGVjaWZpZXJzKSBub2RlLnNwZWNpZmllcnMgPSBbXTtcbiAgICAgIG5vZGUuc3BlY2lmaWVycy5wdXNoKC4uLnRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzKCkpO1xuICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtYXliZVBhcnNlRXhwb3J0RGVjbGFyYXRpb24obm9kZSkge1xuICAgIGlmICh0aGlzLnNob3VsZFBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKSkge1xuICAgICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwiYXN5bmNcIikpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNVbnBhcnNlZENvbnRleHR1YWwobmV4dCwgXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgIHRoaXMudW5leHBlY3RlZChuZXh0LCB0eXBlcy5fZnVuY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlzQXN5bmNGdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKFwiYXN5bmNcIikpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5uZXh0VG9rZW5TdGFydCgpO1xuICAgIHJldHVybiAhbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXRlLnBvcywgbmV4dCkpICYmIHRoaXMuaXNVbnBhcnNlZENvbnRleHR1YWwobmV4dCwgXCJmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKSB7XG4gICAgY29uc3QgZXhwciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgaXNBc3luYyA9IHRoaXMuaXNBc3luY0Z1bmN0aW9uKCk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5fZnVuY3Rpb24pIHx8IGlzQXN5bmMpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICBpZiAoaXNBc3luYykge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihleHByLCBGVU5DX1NUQVRFTUVOVCB8IEZVTkNfTlVMTEFCTEVfSUQsIGlzQXN5bmMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCh0eXBlcy5fY2xhc3MpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKGV4cHIsIHRydWUsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCh0eXBlcy5hdCkpIHtcbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImRlY29yYXRvcnNcIikgJiYgdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJkZWNvcmF0b3JzXCIsIFwiZGVjb3JhdG9yc0JlZm9yZUV4cG9ydFwiKSkge1xuICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIEVycm9yTWVzc2FnZXMuRGVjb3JhdG9yQmVmb3JlRXhwb3J0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYXJzZURlY29yYXRvcnMoZmFsc2UpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyhleHByLCB0cnVlLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2godHlwZXMuX2NvbnN0KSB8fCB0aGlzLm1hdGNoKHR5cGVzLl92YXIpIHx8IHRoaXMuaXNMZXQoKSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLlVuc3VwcG9ydGVkRGVmYXVsdEV4cG9ydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlcyA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCk7XG4gIH1cblxuICBpc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIoKSB7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMubmFtZSkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZTtcblxuICAgICAgaWYgKHZhbHVlID09PSBcImFzeW5jXCIgfHwgdmFsdWUgPT09IFwibGV0XCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHZhbHVlID09PSBcInR5cGVcIiB8fCB2YWx1ZSA9PT0gXCJpbnRlcmZhY2VcIikgJiYgIXRoaXMuc3RhdGUuY29udGFpbnNFc2MpIHtcbiAgICAgICAgY29uc3QgbCA9IHRoaXMubG9va2FoZWFkKCk7XG5cbiAgICAgICAgaWYgKGwudHlwZSA9PT0gdHlwZXMubmFtZSAmJiBsLnZhbHVlICE9PSBcImZyb21cIiB8fCBsLnR5cGUgPT09IHR5cGVzLmJyYWNlTCkge1xuICAgICAgICAgIHRoaXMuZXhwZWN0T25lUGx1Z2luKFtcImZsb3dcIiwgXCJ0eXBlc2NyaXB0XCJdKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCF0aGlzLm1hdGNoKHR5cGVzLl9kZWZhdWx0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlblN0YXJ0KCk7XG4gICAgY29uc3QgaGFzRnJvbSA9IHRoaXMuaXNVbnBhcnNlZENvbnRleHR1YWwobmV4dCwgXCJmcm9tXCIpO1xuXG4gICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KSA9PT0gNDQgfHwgdGhpcy5tYXRjaCh0eXBlcy5uYW1lKSAmJiBoYXNGcm9tKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5fZGVmYXVsdCkgJiYgaGFzRnJvbSkge1xuICAgICAgY29uc3QgbmV4dEFmdGVyRnJvbSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLm5leHRUb2tlblN0YXJ0U2luY2UobmV4dCArIDQpKTtcbiAgICAgIHJldHVybiBuZXh0QWZ0ZXJGcm9tID09PSAzNCB8fCBuZXh0QWZ0ZXJGcm9tID09PSAzOTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwYXJzZUV4cG9ydEZyb20obm9kZSwgZXhwZWN0KSB7XG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImZyb21cIikpIHtcbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUltcG9ydFNvdXJjZSgpO1xuICAgICAgdGhpcy5jaGVja0V4cG9ydChub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGV4cGVjdCkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICB9XG5cbiAgc2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpIHtcbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5hdCkpIHtcbiAgICAgIHRoaXMuZXhwZWN0T25lUGx1Z2luKFtcImRlY29yYXRvcnNcIiwgXCJkZWNvcmF0b3JzLWxlZ2FjeVwiXSk7XG5cbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImRlY29yYXRvcnNcIikpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZGVjb3JhdG9yc1wiLCBcImRlY29yYXRvcnNCZWZvcmVFeHBvcnRcIikpIHtcbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQodGhpcy5zdGF0ZS5zdGFydCwgRXJyb3JNZXNzYWdlcy5EZWNvcmF0b3JCZWZvcmVFeHBvcnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUudHlwZS5rZXl3b3JkID09PSBcInZhclwiIHx8IHRoaXMuc3RhdGUudHlwZS5rZXl3b3JkID09PSBcImNvbnN0XCIgfHwgdGhpcy5zdGF0ZS50eXBlLmtleXdvcmQgPT09IFwiZnVuY3Rpb25cIiB8fCB0aGlzLnN0YXRlLnR5cGUua2V5d29yZCA9PT0gXCJjbGFzc1wiIHx8IHRoaXMuaXNMZXQoKSB8fCB0aGlzLmlzQXN5bmNGdW5jdGlvbigpO1xuICB9XG5cbiAgY2hlY2tFeHBvcnQobm9kZSwgY2hlY2tOYW1lcywgaXNEZWZhdWx0LCBpc0Zyb20pIHtcbiAgICBpZiAoY2hlY2tOYW1lcykge1xuICAgICAgaWYgKGlzRGVmYXVsdCkge1xuICAgICAgICB0aGlzLmNoZWNrRHVwbGljYXRlRXhwb3J0cyhub2RlLCBcImRlZmF1bHRcIik7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZXhwb3J0RGVmYXVsdEZyb21cIikpIHtcbiAgICAgICAgICB2YXIgX2RlY2xhcmF0aW9uJGV4dHJhO1xuXG4gICAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSBub2RlLmRlY2xhcmF0aW9uO1xuXG4gICAgICAgICAgaWYgKGRlY2xhcmF0aW9uLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGRlY2xhcmF0aW9uLm5hbWUgPT09IFwiZnJvbVwiICYmIGRlY2xhcmF0aW9uLmVuZCAtIGRlY2xhcmF0aW9uLnN0YXJ0ID09PSA0ICYmICEoKF9kZWNsYXJhdGlvbiRleHRyYSA9IGRlY2xhcmF0aW9uLmV4dHJhKSA9PSBudWxsID8gdm9pZCAwIDogX2RlY2xhcmF0aW9uJGV4dHJhLnBhcmVudGhlc2l6ZWQpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKGRlY2xhcmF0aW9uLnN0YXJ0LCBFcnJvck1lc3NhZ2VzLkV4cG9ydERlZmF1bHRGcm9tQXNJZGVudGlmaWVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5zcGVjaWZpZXJzICYmIG5vZGUuc3BlY2lmaWVycy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgX2k0ID0gMCwgX25vZGUkc3BlY2lmaWVycyA9IG5vZGUuc3BlY2lmaWVyczsgX2k0IDwgX25vZGUkc3BlY2lmaWVycy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgICAgY29uc3Qgc3BlY2lmaWVyID0gX25vZGUkc3BlY2lmaWVyc1tfaTRdO1xuICAgICAgICAgIHRoaXMuY2hlY2tEdXBsaWNhdGVFeHBvcnRzKHNwZWNpZmllciwgc3BlY2lmaWVyLmV4cG9ydGVkLm5hbWUpO1xuXG4gICAgICAgICAgaWYgKCFpc0Zyb20gJiYgc3BlY2lmaWVyLmxvY2FsKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKHNwZWNpZmllci5sb2NhbC5uYW1lLCBzcGVjaWZpZXIubG9jYWwuc3RhcnQsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuc2NvcGUuY2hlY2tMb2NhbEV4cG9ydChzcGVjaWZpZXIubG9jYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmRlY2xhcmF0aW9uKSB7XG4gICAgICAgIGlmIChub2RlLmRlY2xhcmF0aW9uLnR5cGUgPT09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIHx8IG5vZGUuZGVjbGFyYXRpb24udHlwZSA9PT0gXCJDbGFzc0RlY2xhcmF0aW9uXCIpIHtcbiAgICAgICAgICBjb25zdCBpZCA9IG5vZGUuZGVjbGFyYXRpb24uaWQ7XG4gICAgICAgICAgaWYgKCFpZCkgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0aW9uIGZhaWx1cmVcIik7XG4gICAgICAgICAgdGhpcy5jaGVja0R1cGxpY2F0ZUV4cG9ydHMobm9kZSwgaWQubmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5kZWNsYXJhdGlvbi50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIikge1xuICAgICAgICAgIGZvciAobGV0IF9pNSA9IDAsIF9ub2RlJGRlY2xhcmF0aW9uJGRlYyA9IG5vZGUuZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zOyBfaTUgPCBfbm9kZSRkZWNsYXJhdGlvbiRkZWMubGVuZ3RoOyBfaTUrKykge1xuICAgICAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSBfbm9kZSRkZWNsYXJhdGlvbiRkZWNbX2k1XTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihkZWNsYXJhdGlvbi5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudENvbnRleHREZWNvcmF0b3JzID0gdGhpcy5zdGF0ZS5kZWNvcmF0b3JTdGFja1t0aGlzLnN0YXRlLmRlY29yYXRvclN0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGN1cnJlbnRDb250ZXh0RGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGlzQ2xhc3MgPSBub2RlLmRlY2xhcmF0aW9uICYmIChub2RlLmRlY2xhcmF0aW9uLnR5cGUgPT09IFwiQ2xhc3NEZWNsYXJhdGlvblwiIHx8IG5vZGUuZGVjbGFyYXRpb24udHlwZSA9PT0gXCJDbGFzc0V4cHJlc3Npb25cIik7XG5cbiAgICAgIGlmICghbm9kZS5kZWNsYXJhdGlvbiB8fCAhaXNDbGFzcykge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIEVycm9yTWVzc2FnZXMuVW5zdXBwb3J0ZWREZWNvcmF0b3JFeHBvcnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRha2VEZWNvcmF0b3JzKG5vZGUuZGVjbGFyYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrRGVjbGFyYXRpb24obm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICB0aGlzLmNoZWNrRHVwbGljYXRlRXhwb3J0cyhub2RlLCBub2RlLm5hbWUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIikge1xuICAgICAgZm9yIChsZXQgX2k2ID0gMCwgX25vZGUkcHJvcGVydGllcyA9IG5vZGUucHJvcGVydGllczsgX2k2IDwgX25vZGUkcHJvcGVydGllcy5sZW5ndGg7IF9pNisrKSB7XG4gICAgICAgIGNvbnN0IHByb3AgPSBfbm9kZSRwcm9wZXJ0aWVzW19pNl07XG4gICAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihwcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIikge1xuICAgICAgZm9yIChsZXQgX2k3ID0gMCwgX25vZGUkZWxlbWVudHMgPSBub2RlLmVsZW1lbnRzOyBfaTcgPCBfbm9kZSRlbGVtZW50cy5sZW5ndGg7IF9pNysrKSB7XG4gICAgICAgIGNvbnN0IGVsZW0gPSBfbm9kZSRlbGVtZW50c1tfaTddO1xuXG4gICAgICAgIGlmIChlbGVtKSB7XG4gICAgICAgICAgdGhpcy5jaGVja0RlY2xhcmF0aW9uKGVsZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiT2JqZWN0UHJvcGVydHlcIikge1xuICAgICAgdGhpcy5jaGVja0RlY2xhcmF0aW9uKG5vZGUudmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpIHtcbiAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihub2RlLmFyZ3VtZW50KTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKSB7XG4gICAgICB0aGlzLmNoZWNrRGVjbGFyYXRpb24obm9kZS5sZWZ0KTtcbiAgICB9XG4gIH1cblxuICBjaGVja0R1cGxpY2F0ZUV4cG9ydHMobm9kZSwgbmFtZSkge1xuICAgIGlmICh0aGlzLnN0YXRlLmV4cG9ydGVkSWRlbnRpZmllcnMuaW5kZXhPZihuYW1lKSA+IC0xKSB7XG4gICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIG5hbWUgPT09IFwiZGVmYXVsdFwiID8gRXJyb3JNZXNzYWdlcy5EdXBsaWNhdGVEZWZhdWx0RXhwb3J0IDogRXJyb3JNZXNzYWdlcy5EdXBsaWNhdGVFeHBvcnQsIG5hbWUpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuZXhwb3J0ZWRJZGVudGlmaWVycy5wdXNoKG5hbWUpO1xuICB9XG5cbiAgcGFyc2VFeHBvcnRTcGVjaWZpZXJzKCkge1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuXG4gICAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgIG5vZGUuZXhwb3J0ZWQgPSB0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSA/IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpIDogbm9kZS5sb2NhbC5fX2Nsb25lKCk7XG4gICAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydFNwZWNpZmllclwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgcGFyc2VJbXBvcnQobm9kZSkge1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuXG4gICAgaWYgKCF0aGlzLm1hdGNoKHR5cGVzLnN0cmluZykpIHtcbiAgICAgIGNvbnN0IGhhc0RlZmF1bHQgPSB0aGlzLm1heWJlUGFyc2VEZWZhdWx0SW1wb3J0U3BlY2lmaWVyKG5vZGUpO1xuICAgICAgY29uc3QgcGFyc2VOZXh0ID0gIWhhc0RlZmF1bHQgfHwgdGhpcy5lYXQodHlwZXMuY29tbWEpO1xuICAgICAgY29uc3QgaGFzU3RhciA9IHBhcnNlTmV4dCAmJiB0aGlzLm1heWJlUGFyc2VTdGFySW1wb3J0U3BlY2lmaWVyKG5vZGUpO1xuICAgICAgaWYgKHBhcnNlTmV4dCAmJiAhaGFzU3RhcikgdGhpcy5wYXJzZU5hbWVkSW1wb3J0U3BlY2lmaWVycyhub2RlKTtcbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgfVxuXG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlSW1wb3J0U291cmNlKCk7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHRoaXMubWF5YmVQYXJzZU1vZHVsZUF0dHJpYnV0ZXMoKTtcblxuICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICBub2RlLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgIH1cblxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydERlY2xhcmF0aW9uXCIpO1xuICB9XG5cbiAgcGFyc2VJbXBvcnRTb3VyY2UoKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKHR5cGVzLnN0cmluZykpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgfVxuXG4gIHNob3VsZFBhcnNlRGVmYXVsdEltcG9ydChub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2godHlwZXMubmFtZSk7XG4gIH1cblxuICBwYXJzZUltcG9ydFNwZWNpZmllckxvY2FsKG5vZGUsIHNwZWNpZmllciwgdHlwZSwgY29udGV4dERlc2NyaXB0aW9uKSB7XG4gICAgc3BlY2lmaWVyLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICB0aGlzLmNoZWNrTFZhbChzcGVjaWZpZXIubG9jYWwsIEJJTkRfTEVYSUNBTCwgdW5kZWZpbmVkLCBjb250ZXh0RGVzY3JpcHRpb24pO1xuICAgIG5vZGUuc3BlY2lmaWVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIHR5cGUpKTtcbiAgfVxuXG4gIG1heWJlUGFyc2VNb2R1bGVBdHRyaWJ1dGVzKCkge1xuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLl93aXRoKSAmJiAhdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJtb2R1bGVBdHRyaWJ1dGVzXCIpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcIm1vZHVsZUF0dHJpYnV0ZXNcIikpIHJldHVybiBbXTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGF0dHJzID0gW107XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IG5ldyBTZXQoKTtcblxuICAgIGRvIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS5rZXkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcblxuICAgICAgaWYgKG5vZGUua2V5Lm5hbWUgIT09IFwidHlwZVwiKSB7XG4gICAgICAgIHRoaXMucmFpc2Uobm9kZS5rZXkuc3RhcnQsIEVycm9yTWVzc2FnZXMuTW9kdWxlQXR0cmlidXRlRGlmZmVyZW50RnJvbVR5cGUsIG5vZGUua2V5Lm5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cmlidXRlcy5oYXMobm9kZS5rZXkubmFtZSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShub2RlLmtleS5zdGFydCwgRXJyb3JNZXNzYWdlcy5Nb2R1bGVBdHRyaWJ1dGVzV2l0aER1cGxpY2F0ZUtleXMsIG5vZGUua2V5Lm5hbWUpO1xuICAgICAgfVxuXG4gICAgICBhdHRyaWJ1dGVzLmFkZChub2RlLmtleS5uYW1lKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbG9uKTtcblxuICAgICAgaWYgKCF0aGlzLm1hdGNoKHR5cGVzLnN0cmluZykpIHtcbiAgICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKHRoaXMuc3RhdGUuc3RhcnQsIEVycm9yTWVzc2FnZXMuTW9kdWxlQXR0cmlidXRlSW52YWxpZFZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgbm9kZS52YWx1ZSA9IHRoaXMucGFyc2VMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUsIFwiU3RyaW5nTGl0ZXJhbFwiKTtcbiAgICAgIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydEF0dHJpYnV0ZVwiKTtcbiAgICAgIGF0dHJzLnB1c2gobm9kZSk7XG4gICAgfSB3aGlsZSAodGhpcy5lYXQodHlwZXMuY29tbWEpKTtcblxuICAgIHJldHVybiBhdHRycztcbiAgfVxuXG4gIG1heWJlUGFyc2VEZWZhdWx0SW1wb3J0U3BlY2lmaWVyKG5vZGUpIHtcbiAgICBpZiAodGhpcy5zaG91bGRQYXJzZURlZmF1bHRJbXBvcnQobm9kZSkpIHtcbiAgICAgIHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJMb2NhbChub2RlLCB0aGlzLnN0YXJ0Tm9kZSgpLCBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIiwgXCJkZWZhdWx0IGltcG9ydCBzcGVjaWZpZXJcIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtYXliZVBhcnNlU3RhckltcG9ydFNwZWNpZmllcihub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuc3RhcikpIHtcbiAgICAgIGNvbnN0IHNwZWNpZmllciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImFzXCIpO1xuICAgICAgdGhpcy5wYXJzZUltcG9ydFNwZWNpZmllckxvY2FsKG5vZGUsIHNwZWNpZmllciwgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIiwgXCJpbXBvcnQgbmFtZXNwYWNlIHNwZWNpZmllclwiKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHBhcnNlTmFtZWRJbXBvcnRTcGVjaWZpZXJzKG5vZGUpIHtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG5cbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmNvbG9uKSkge1xuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCwgRXJyb3JNZXNzYWdlcy5EZXN0cnVjdHVyZU5hbWVkSW1wb3J0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSW1wb3J0U3BlY2lmaWVyKG5vZGUpIHtcbiAgICBjb25zdCBzcGVjaWZpZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHNwZWNpZmllci5pbXBvcnRlZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuXG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICBzcGVjaWZpZXIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKHNwZWNpZmllci5pbXBvcnRlZC5uYW1lLCBzcGVjaWZpZXIuc3RhcnQsIHRydWUsIHRydWUpO1xuICAgICAgc3BlY2lmaWVyLmxvY2FsID0gc3BlY2lmaWVyLmltcG9ydGVkLl9fY2xvbmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLmNoZWNrTFZhbChzcGVjaWZpZXIubG9jYWwsIEJJTkRfTEVYSUNBTCwgdW5kZWZpbmVkLCBcImltcG9ydCBzcGVjaWZpZXJcIik7XG4gICAgbm9kZS5zcGVjaWZpZXJzLnB1c2godGhpcy5maW5pc2hOb2RlKHNwZWNpZmllciwgXCJJbXBvcnRTcGVjaWZpZXJcIikpO1xuICB9XG5cbn1cblxuY2xhc3MgQ2xhc3NTY29wZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJpdmF0ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgIHRoaXMubG9uZUFjY2Vzc29ycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnVuZGVmaW5lZFByaXZhdGVOYW1lcyA9IG5ldyBNYXAoKTtcbiAgfVxuXG59XG5jbGFzcyBDbGFzc1Njb3BlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKHJhaXNlKSB7XG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICAgIHRoaXMudW5kZWZpbmVkUHJpdmF0ZU5hbWVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucmFpc2UgPSByYWlzZTtcbiAgfVxuXG4gIGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIGVudGVyKCkge1xuICAgIHRoaXMuc3RhY2sucHVzaChuZXcgQ2xhc3NTY29wZSgpKTtcbiAgfVxuXG4gIGV4aXQoKSB7XG4gICAgY29uc3Qgb2xkQ2xhc3NTY29wZSA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudCgpO1xuXG4gICAgZm9yIChsZXQgX2kgPSAwLCBfQXJyYXkkZnJvbSA9IEFycmF5LmZyb20ob2xkQ2xhc3NTY29wZS51bmRlZmluZWRQcml2YXRlTmFtZXMpOyBfaSA8IF9BcnJheSRmcm9tLmxlbmd0aDsgX2krKykge1xuICAgICAgY29uc3QgW25hbWUsIHBvc10gPSBfQXJyYXkkZnJvbVtfaV07XG5cbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIGlmICghY3VycmVudC51bmRlZmluZWRQcml2YXRlTmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgY3VycmVudC51bmRlZmluZWRQcml2YXRlTmFtZXMuc2V0KG5hbWUsIHBvcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmFpc2UocG9zLCBFcnJvck1lc3NhZ2VzLkludmFsaWRQcml2YXRlRmllbGRSZXNvbHV0aW9uLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWNsYXJlUHJpdmF0ZU5hbWUobmFtZSwgZWxlbWVudFR5cGUsIHBvcykge1xuICAgIGNvbnN0IGNsYXNzU2NvcGUgPSB0aGlzLmN1cnJlbnQoKTtcbiAgICBsZXQgcmVkZWZpbmVkID0gY2xhc3NTY29wZS5wcml2YXRlTmFtZXMuaGFzKG5hbWUpO1xuXG4gICAgaWYgKGVsZW1lbnRUeXBlICYgQ0xBU1NfRUxFTUVOVF9LSU5EX0FDQ0VTU09SKSB7XG4gICAgICBjb25zdCBhY2Nlc3NvciA9IHJlZGVmaW5lZCAmJiBjbGFzc1Njb3BlLmxvbmVBY2Nlc3NvcnMuZ2V0KG5hbWUpO1xuXG4gICAgICBpZiAoYWNjZXNzb3IpIHtcbiAgICAgICAgY29uc3Qgb2xkU3RhdGljID0gYWNjZXNzb3IgJiBDTEFTU19FTEVNRU5UX0ZMQUdfU1RBVElDO1xuICAgICAgICBjb25zdCBuZXdTdGF0aWMgPSBlbGVtZW50VHlwZSAmIENMQVNTX0VMRU1FTlRfRkxBR19TVEFUSUM7XG4gICAgICAgIGNvbnN0IG9sZEtpbmQgPSBhY2Nlc3NvciAmIENMQVNTX0VMRU1FTlRfS0lORF9BQ0NFU1NPUjtcbiAgICAgICAgY29uc3QgbmV3S2luZCA9IGVsZW1lbnRUeXBlICYgQ0xBU1NfRUxFTUVOVF9LSU5EX0FDQ0VTU09SO1xuICAgICAgICByZWRlZmluZWQgPSBvbGRLaW5kID09PSBuZXdLaW5kIHx8IG9sZFN0YXRpYyAhPT0gbmV3U3RhdGljO1xuICAgICAgICBpZiAoIXJlZGVmaW5lZCkgY2xhc3NTY29wZS5sb25lQWNjZXNzb3JzLmRlbGV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoIXJlZGVmaW5lZCkge1xuICAgICAgICBjbGFzc1Njb3BlLmxvbmVBY2Nlc3NvcnMuc2V0KG5hbWUsIGVsZW1lbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVkZWZpbmVkKSB7XG4gICAgICB0aGlzLnJhaXNlKHBvcywgRXJyb3JNZXNzYWdlcy5Qcml2YXRlTmFtZVJlZGVjbGFyYXRpb24sIG5hbWUpO1xuICAgIH1cblxuICAgIGNsYXNzU2NvcGUucHJpdmF0ZU5hbWVzLmFkZChuYW1lKTtcbiAgICBjbGFzc1Njb3BlLnVuZGVmaW5lZFByaXZhdGVOYW1lcy5kZWxldGUobmFtZSk7XG4gIH1cblxuICB1c2VQcml2YXRlTmFtZShuYW1lLCBwb3MpIHtcbiAgICBsZXQgY2xhc3NTY29wZTtcblxuICAgIGZvciAobGV0IF9pMiA9IDAsIF90aGlzJHN0YWNrID0gdGhpcy5zdGFjazsgX2kyIDwgX3RoaXMkc3RhY2subGVuZ3RoOyBfaTIrKykge1xuICAgICAgY2xhc3NTY29wZSA9IF90aGlzJHN0YWNrW19pMl07XG4gICAgICBpZiAoY2xhc3NTY29wZS5wcml2YXRlTmFtZXMuaGFzKG5hbWUpKSByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNsYXNzU2NvcGUpIHtcbiAgICAgIGNsYXNzU2NvcGUudW5kZWZpbmVkUHJpdmF0ZU5hbWVzLnNldChuYW1lLCBwb3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJhaXNlKHBvcywgRXJyb3JNZXNzYWdlcy5JbnZhbGlkUHJpdmF0ZUZpZWxkUmVzb2x1dGlvbiwgbmFtZSk7XG4gICAgfVxuICB9XG5cbn1cblxuY2xhc3MgUGFyc2VyIGV4dGVuZHMgU3RhdGVtZW50UGFyc2VyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgaW5wdXQpIHtcbiAgICBvcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICBzdXBlcihvcHRpb25zLCBpbnB1dCk7XG4gICAgY29uc3QgU2NvcGVIYW5kbGVyID0gdGhpcy5nZXRTY29wZUhhbmRsZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuaW5Nb2R1bGUgPSB0aGlzLm9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIjtcbiAgICB0aGlzLnNjb3BlID0gbmV3IFNjb3BlSGFuZGxlcih0aGlzLnJhaXNlLmJpbmQodGhpcyksIHRoaXMuaW5Nb2R1bGUpO1xuICAgIHRoaXMucHJvZFBhcmFtID0gbmV3IFByb2R1Y3Rpb25QYXJhbWV0ZXJIYW5kbGVyKCk7XG4gICAgdGhpcy5jbGFzc1Njb3BlID0gbmV3IENsYXNzU2NvcGVIYW5kbGVyKHRoaXMucmFpc2UuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5wbHVnaW5zID0gcGx1Z2luc01hcCh0aGlzLm9wdGlvbnMucGx1Z2lucyk7XG4gICAgdGhpcy5maWxlbmFtZSA9IG9wdGlvbnMuc291cmNlRmlsZW5hbWU7XG4gIH1cblxuICBnZXRTY29wZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIFNjb3BlSGFuZGxlcjtcbiAgfVxuXG4gIHBhcnNlKCkge1xuICAgIGxldCBwYXJhbUZsYWdzID0gUEFSQU07XG5cbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJ0b3BMZXZlbEF3YWl0XCIpICYmIHRoaXMuaW5Nb2R1bGUpIHtcbiAgICAgIHBhcmFtRmxhZ3MgfD0gUEFSQU1fQVdBSVQ7XG4gICAgfVxuXG4gICAgdGhpcy5zY29wZS5lbnRlcihTQ09QRV9QUk9HUkFNKTtcbiAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihwYXJhbUZsYWdzKTtcbiAgICBjb25zdCBmaWxlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgIGZpbGUuZXJyb3JzID0gbnVsbDtcbiAgICB0aGlzLnBhcnNlVG9wTGV2ZWwoZmlsZSwgcHJvZ3JhbSk7XG4gICAgZmlsZS5lcnJvcnMgPSB0aGlzLnN0YXRlLmVycm9ycztcbiAgICByZXR1cm4gZmlsZTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHBsdWdpbnNNYXAocGx1Z2lucykge1xuICBjb25zdCBwbHVnaW5NYXAgPSBuZXcgTWFwKCk7XG5cbiAgZm9yIChsZXQgX2kgPSAwOyBfaSA8IHBsdWdpbnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgY29uc3QgcGx1Z2luID0gcGx1Z2luc1tfaV07XG4gICAgY29uc3QgW25hbWUsIG9wdGlvbnNdID0gQXJyYXkuaXNBcnJheShwbHVnaW4pID8gcGx1Z2luIDogW3BsdWdpbiwge31dO1xuICAgIGlmICghcGx1Z2luTWFwLmhhcyhuYW1lKSkgcGx1Z2luTWFwLnNldChuYW1lLCBvcHRpb25zIHx8IHt9KTtcbiAgfVxuXG4gIHJldHVybiBwbHVnaW5NYXA7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucztcblxuICBpZiAoKChfb3B0aW9ucyA9IG9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfb3B0aW9ucy5zb3VyY2VUeXBlKSA9PT0gXCJ1bmFtYmlndW91c1wiKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuXG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMuc291cmNlVHlwZSA9IFwibW9kdWxlXCI7XG4gICAgICBjb25zdCBwYXJzZXIgPSBnZXRQYXJzZXIob3B0aW9ucywgaW5wdXQpO1xuICAgICAgY29uc3QgYXN0ID0gcGFyc2VyLnBhcnNlKCk7XG5cbiAgICAgIGlmIChwYXJzZXIuc2F3VW5hbWJpZ3VvdXNFU00pIHtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcnNlci5hbWJpZ3VvdXNTY3JpcHREaWZmZXJlbnRBc3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvcHRpb25zLnNvdXJjZVR5cGUgPSBcInNjcmlwdFwiO1xuICAgICAgICAgIHJldHVybiBnZXRQYXJzZXIob3B0aW9ucywgaW5wdXQpLnBhcnNlKCk7XG4gICAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHt9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3QucHJvZ3JhbS5zb3VyY2VUeXBlID0gXCJzY3JpcHRcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFzdDtcbiAgICB9IGNhdGNoIChtb2R1bGVFcnJvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb3B0aW9ucy5zb3VyY2VUeXBlID0gXCJzY3JpcHRcIjtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNlcihvcHRpb25zLCBpbnB1dCkucGFyc2UoKTtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQyKSB7fVxuXG4gICAgICB0aHJvdyBtb2R1bGVFcnJvcjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldFBhcnNlcihvcHRpb25zLCBpbnB1dCkucGFyc2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKGlucHV0LCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhcnNlciA9IGdldFBhcnNlcihvcHRpb25zLCBpbnB1dCk7XG5cbiAgaWYgKHBhcnNlci5vcHRpb25zLnN0cmljdE1vZGUpIHtcbiAgICBwYXJzZXIuc3RhdGUuc3RyaWN0ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZXIuZ2V0RXhwcmVzc2lvbigpO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJzZXIob3B0aW9ucywgaW5wdXQpIHtcbiAgbGV0IGNscyA9IFBhcnNlcjtcblxuICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wbHVnaW5zKSB7XG4gICAgdmFsaWRhdGVQbHVnaW5zKG9wdGlvbnMucGx1Z2lucyk7XG4gICAgY2xzID0gZ2V0UGFyc2VyQ2xhc3Mob3B0aW9ucy5wbHVnaW5zKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgY2xzKG9wdGlvbnMsIGlucHV0KTtcbn1cblxuY29uc3QgcGFyc2VyQ2xhc3NDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBnZXRQYXJzZXJDbGFzcyhwbHVnaW5zRnJvbU9wdGlvbnMpIHtcbiAgY29uc3QgcGx1Z2luTGlzdCA9IG1peGluUGx1Z2luTmFtZXMuZmlsdGVyKG5hbWUgPT4gaGFzUGx1Z2luKHBsdWdpbnNGcm9tT3B0aW9ucywgbmFtZSkpO1xuICBjb25zdCBrZXkgPSBwbHVnaW5MaXN0LmpvaW4oXCIvXCIpO1xuICBsZXQgY2xzID0gcGFyc2VyQ2xhc3NDYWNoZVtrZXldO1xuXG4gIGlmICghY2xzKSB7XG4gICAgY2xzID0gUGFyc2VyO1xuXG4gICAgZm9yIChsZXQgX2kgPSAwOyBfaSA8IHBsdWdpbkxpc3QubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBwbHVnaW5MaXN0W19pXTtcbiAgICAgIGNscyA9IG1peGluUGx1Z2luc1twbHVnaW5dKGNscyk7XG4gICAgfVxuXG4gICAgcGFyc2VyQ2xhc3NDYWNoZVtrZXldID0gY2xzO1xuICB9XG5cbiAgcmV0dXJuIGNscztcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5wYXJzZUV4cHJlc3Npb24gPSBwYXJzZUV4cHJlc3Npb247XG5leHBvcnRzLnRva1R5cGVzID0gdHlwZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYXNzZXJ0Tm9kZTtcblxudmFyIF9pc05vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2lzTm9kZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGFzc2VydE5vZGUobm9kZSkge1xuICBpZiAoISgwLCBfaXNOb2RlLmRlZmF1bHQpKG5vZGUpKSB7XG4gICAgdmFyIF9ub2RlJHR5cGU7XG5cbiAgICBjb25zdCB0eXBlID0gKF9ub2RlJHR5cGUgPSBub2RlID09IG51bGwgPyB2b2lkIDAgOiBub2RlLnR5cGUpICE9IG51bGwgPyBfbm9kZSR0eXBlIDogSlNPTi5zdHJpbmdpZnkobm9kZSk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm90IGEgdmFsaWQgbm9kZSBvZiB0eXBlIFwiJHt0eXBlfVwiYCk7XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYXNzZXJ0QXJyYXlFeHByZXNzaW9uID0gYXNzZXJ0QXJyYXlFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRBc3NpZ25tZW50RXhwcmVzc2lvbiA9IGFzc2VydEFzc2lnbm1lbnRFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRCaW5hcnlFeHByZXNzaW9uID0gYXNzZXJ0QmluYXJ5RXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0SW50ZXJwcmV0ZXJEaXJlY3RpdmUgPSBhc3NlcnRJbnRlcnByZXRlckRpcmVjdGl2ZTtcbmV4cG9ydHMuYXNzZXJ0RGlyZWN0aXZlID0gYXNzZXJ0RGlyZWN0aXZlO1xuZXhwb3J0cy5hc3NlcnREaXJlY3RpdmVMaXRlcmFsID0gYXNzZXJ0RGlyZWN0aXZlTGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0QmxvY2tTdGF0ZW1lbnQgPSBhc3NlcnRCbG9ja1N0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0QnJlYWtTdGF0ZW1lbnQgPSBhc3NlcnRCcmVha1N0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0Q2FsbEV4cHJlc3Npb24gPSBhc3NlcnRDYWxsRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0Q2F0Y2hDbGF1c2UgPSBhc3NlcnRDYXRjaENsYXVzZTtcbmV4cG9ydHMuYXNzZXJ0Q29uZGl0aW9uYWxFeHByZXNzaW9uID0gYXNzZXJ0Q29uZGl0aW9uYWxFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRDb250aW51ZVN0YXRlbWVudCA9IGFzc2VydENvbnRpbnVlU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnREZWJ1Z2dlclN0YXRlbWVudCA9IGFzc2VydERlYnVnZ2VyU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnREb1doaWxlU3RhdGVtZW50ID0gYXNzZXJ0RG9XaGlsZVN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0RW1wdHlTdGF0ZW1lbnQgPSBhc3NlcnRFbXB0eVN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0RXhwcmVzc2lvblN0YXRlbWVudCA9IGFzc2VydEV4cHJlc3Npb25TdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydEZpbGUgPSBhc3NlcnRGaWxlO1xuZXhwb3J0cy5hc3NlcnRGb3JJblN0YXRlbWVudCA9IGFzc2VydEZvckluU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRGb3JTdGF0ZW1lbnQgPSBhc3NlcnRGb3JTdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydEZ1bmN0aW9uRGVjbGFyYXRpb24gPSBhc3NlcnRGdW5jdGlvbkRlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRGdW5jdGlvbkV4cHJlc3Npb24gPSBhc3NlcnRGdW5jdGlvbkV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydElkZW50aWZpZXIgPSBhc3NlcnRJZGVudGlmaWVyO1xuZXhwb3J0cy5hc3NlcnRJZlN0YXRlbWVudCA9IGFzc2VydElmU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRMYWJlbGVkU3RhdGVtZW50ID0gYXNzZXJ0TGFiZWxlZFN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0U3RyaW5nTGl0ZXJhbCA9IGFzc2VydFN0cmluZ0xpdGVyYWw7XG5leHBvcnRzLmFzc2VydE51bWVyaWNMaXRlcmFsID0gYXNzZXJ0TnVtZXJpY0xpdGVyYWw7XG5leHBvcnRzLmFzc2VydE51bGxMaXRlcmFsID0gYXNzZXJ0TnVsbExpdGVyYWw7XG5leHBvcnRzLmFzc2VydEJvb2xlYW5MaXRlcmFsID0gYXNzZXJ0Qm9vbGVhbkxpdGVyYWw7XG5leHBvcnRzLmFzc2VydFJlZ0V4cExpdGVyYWwgPSBhc3NlcnRSZWdFeHBMaXRlcmFsO1xuZXhwb3J0cy5hc3NlcnRMb2dpY2FsRXhwcmVzc2lvbiA9IGFzc2VydExvZ2ljYWxFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRNZW1iZXJFeHByZXNzaW9uID0gYXNzZXJ0TWVtYmVyRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0TmV3RXhwcmVzc2lvbiA9IGFzc2VydE5ld0V4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydFByb2dyYW0gPSBhc3NlcnRQcm9ncmFtO1xuZXhwb3J0cy5hc3NlcnRPYmplY3RFeHByZXNzaW9uID0gYXNzZXJ0T2JqZWN0RXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0T2JqZWN0TWV0aG9kID0gYXNzZXJ0T2JqZWN0TWV0aG9kO1xuZXhwb3J0cy5hc3NlcnRPYmplY3RQcm9wZXJ0eSA9IGFzc2VydE9iamVjdFByb3BlcnR5O1xuZXhwb3J0cy5hc3NlcnRSZXN0RWxlbWVudCA9IGFzc2VydFJlc3RFbGVtZW50O1xuZXhwb3J0cy5hc3NlcnRSZXR1cm5TdGF0ZW1lbnQgPSBhc3NlcnRSZXR1cm5TdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydFNlcXVlbmNlRXhwcmVzc2lvbiA9IGFzc2VydFNlcXVlbmNlRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0UGFyZW50aGVzaXplZEV4cHJlc3Npb24gPSBhc3NlcnRQYXJlbnRoZXNpemVkRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0U3dpdGNoQ2FzZSA9IGFzc2VydFN3aXRjaENhc2U7XG5leHBvcnRzLmFzc2VydFN3aXRjaFN0YXRlbWVudCA9IGFzc2VydFN3aXRjaFN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0VGhpc0V4cHJlc3Npb24gPSBhc3NlcnRUaGlzRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0VGhyb3dTdGF0ZW1lbnQgPSBhc3NlcnRUaHJvd1N0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0VHJ5U3RhdGVtZW50ID0gYXNzZXJ0VHJ5U3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRVbmFyeUV4cHJlc3Npb24gPSBhc3NlcnRVbmFyeUV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydFVwZGF0ZUV4cHJlc3Npb24gPSBhc3NlcnRVcGRhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRWYXJpYWJsZURlY2xhcmF0aW9uID0gYXNzZXJ0VmFyaWFibGVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VmFyaWFibGVEZWNsYXJhdG9yID0gYXNzZXJ0VmFyaWFibGVEZWNsYXJhdG9yO1xuZXhwb3J0cy5hc3NlcnRXaGlsZVN0YXRlbWVudCA9IGFzc2VydFdoaWxlU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRXaXRoU3RhdGVtZW50ID0gYXNzZXJ0V2l0aFN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0QXNzaWdubWVudFBhdHRlcm4gPSBhc3NlcnRBc3NpZ25tZW50UGF0dGVybjtcbmV4cG9ydHMuYXNzZXJ0QXJyYXlQYXR0ZXJuID0gYXNzZXJ0QXJyYXlQYXR0ZXJuO1xuZXhwb3J0cy5hc3NlcnRBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGFzc2VydEFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRDbGFzc0JvZHkgPSBhc3NlcnRDbGFzc0JvZHk7XG5leHBvcnRzLmFzc2VydENsYXNzRXhwcmVzc2lvbiA9IGFzc2VydENsYXNzRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0Q2xhc3NEZWNsYXJhdGlvbiA9IGFzc2VydENsYXNzRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydEV4cG9ydEFsbERlY2xhcmF0aW9uID0gYXNzZXJ0RXhwb3J0QWxsRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IGFzc2VydEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RXhwb3J0TmFtZWREZWNsYXJhdGlvbiA9IGFzc2VydEV4cG9ydE5hbWVkRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydEV4cG9ydFNwZWNpZmllciA9IGFzc2VydEV4cG9ydFNwZWNpZmllcjtcbmV4cG9ydHMuYXNzZXJ0Rm9yT2ZTdGF0ZW1lbnQgPSBhc3NlcnRGb3JPZlN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0SW1wb3J0RGVjbGFyYXRpb24gPSBhc3NlcnRJbXBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0SW1wb3J0RGVmYXVsdFNwZWNpZmllciA9IGFzc2VydEltcG9ydERlZmF1bHRTcGVjaWZpZXI7XG5leHBvcnRzLmFzc2VydEltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGFzc2VydEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbmV4cG9ydHMuYXNzZXJ0SW1wb3J0U3BlY2lmaWVyID0gYXNzZXJ0SW1wb3J0U3BlY2lmaWVyO1xuZXhwb3J0cy5hc3NlcnRNZXRhUHJvcGVydHkgPSBhc3NlcnRNZXRhUHJvcGVydHk7XG5leHBvcnRzLmFzc2VydENsYXNzTWV0aG9kID0gYXNzZXJ0Q2xhc3NNZXRob2Q7XG5leHBvcnRzLmFzc2VydE9iamVjdFBhdHRlcm4gPSBhc3NlcnRPYmplY3RQYXR0ZXJuO1xuZXhwb3J0cy5hc3NlcnRTcHJlYWRFbGVtZW50ID0gYXNzZXJ0U3ByZWFkRWxlbWVudDtcbmV4cG9ydHMuYXNzZXJ0U3VwZXIgPSBhc3NlcnRTdXBlcjtcbmV4cG9ydHMuYXNzZXJ0VGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uID0gYXNzZXJ0VGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRUZW1wbGF0ZUVsZW1lbnQgPSBhc3NlcnRUZW1wbGF0ZUVsZW1lbnQ7XG5leHBvcnRzLmFzc2VydFRlbXBsYXRlTGl0ZXJhbCA9IGFzc2VydFRlbXBsYXRlTGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0WWllbGRFeHByZXNzaW9uID0gYXNzZXJ0WWllbGRFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRBbnlUeXBlQW5ub3RhdGlvbiA9IGFzc2VydEFueVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRBcnJheVR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0QXJyYXlUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0Qm9vbGVhblR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0Qm9vbGVhblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0Qm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0TnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGFzc2VydE51bGxMaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydENsYXNzSW1wbGVtZW50cyA9IGFzc2VydENsYXNzSW1wbGVtZW50cztcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyZUNsYXNzID0gYXNzZXJ0RGVjbGFyZUNsYXNzO1xuZXhwb3J0cy5hc3NlcnREZWNsYXJlRnVuY3Rpb24gPSBhc3NlcnREZWNsYXJlRnVuY3Rpb247XG5leHBvcnRzLmFzc2VydERlY2xhcmVJbnRlcmZhY2UgPSBhc3NlcnREZWNsYXJlSW50ZXJmYWNlO1xuZXhwb3J0cy5hc3NlcnREZWNsYXJlTW9kdWxlID0gYXNzZXJ0RGVjbGFyZU1vZHVsZTtcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyZU1vZHVsZUV4cG9ydHMgPSBhc3NlcnREZWNsYXJlTW9kdWxlRXhwb3J0cztcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyZVR5cGVBbGlhcyA9IGFzc2VydERlY2xhcmVUeXBlQWxpYXM7XG5leHBvcnRzLmFzc2VydERlY2xhcmVPcGFxdWVUeXBlID0gYXNzZXJ0RGVjbGFyZU9wYXF1ZVR5cGU7XG5leHBvcnRzLmFzc2VydERlY2xhcmVWYXJpYWJsZSA9IGFzc2VydERlY2xhcmVWYXJpYWJsZTtcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uID0gYXNzZXJ0RGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnREZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBhc3NlcnREZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydERlY2xhcmVkUHJlZGljYXRlID0gYXNzZXJ0RGVjbGFyZWRQcmVkaWNhdGU7XG5leHBvcnRzLmFzc2VydEV4aXN0c1R5cGVBbm5vdGF0aW9uID0gYXNzZXJ0RXhpc3RzVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydEZ1bmN0aW9uVHlwZUFubm90YXRpb24gPSBhc3NlcnRGdW5jdGlvblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRGdW5jdGlvblR5cGVQYXJhbSA9IGFzc2VydEZ1bmN0aW9uVHlwZVBhcmFtO1xuZXhwb3J0cy5hc3NlcnRHZW5lcmljVHlwZUFubm90YXRpb24gPSBhc3NlcnRHZW5lcmljVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydEluZmVycmVkUHJlZGljYXRlID0gYXNzZXJ0SW5mZXJyZWRQcmVkaWNhdGU7XG5leHBvcnRzLmFzc2VydEludGVyZmFjZUV4dGVuZHMgPSBhc3NlcnRJbnRlcmZhY2VFeHRlbmRzO1xuZXhwb3J0cy5hc3NlcnRJbnRlcmZhY2VEZWNsYXJhdGlvbiA9IGFzc2VydEludGVyZmFjZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRJbnRlcmZhY2VUeXBlQW5ub3RhdGlvbiA9IGFzc2VydEludGVyZmFjZVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvbiA9IGFzc2VydEludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRNaXhlZFR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0TWl4ZWRUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RW1wdHlUeXBlQW5ub3RhdGlvbiA9IGFzc2VydEVtcHR5VHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydE51bGxhYmxlVHlwZUFubm90YXRpb24gPSBhc3NlcnROdWxsYWJsZVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnROdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb24gPSBhc3NlcnROdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydE51bWJlclR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0TnVtYmVyVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydE9iamVjdFR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0T2JqZWN0VHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydE9iamVjdFR5cGVJbnRlcm5hbFNsb3QgPSBhc3NlcnRPYmplY3RUeXBlSW50ZXJuYWxTbG90O1xuZXhwb3J0cy5hc3NlcnRPYmplY3RUeXBlQ2FsbFByb3BlcnR5ID0gYXNzZXJ0T2JqZWN0VHlwZUNhbGxQcm9wZXJ0eTtcbmV4cG9ydHMuYXNzZXJ0T2JqZWN0VHlwZUluZGV4ZXIgPSBhc3NlcnRPYmplY3RUeXBlSW5kZXhlcjtcbmV4cG9ydHMuYXNzZXJ0T2JqZWN0VHlwZVByb3BlcnR5ID0gYXNzZXJ0T2JqZWN0VHlwZVByb3BlcnR5O1xuZXhwb3J0cy5hc3NlcnRPYmplY3RUeXBlU3ByZWFkUHJvcGVydHkgPSBhc3NlcnRPYmplY3RUeXBlU3ByZWFkUHJvcGVydHk7XG5leHBvcnRzLmFzc2VydE9wYXF1ZVR5cGUgPSBhc3NlcnRPcGFxdWVUeXBlO1xuZXhwb3J0cy5hc3NlcnRRdWFsaWZpZWRUeXBlSWRlbnRpZmllciA9IGFzc2VydFF1YWxpZmllZFR5cGVJZGVudGlmaWVyO1xuZXhwb3J0cy5hc3NlcnRTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb24gPSBhc3NlcnRTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydFN0cmluZ1R5cGVBbm5vdGF0aW9uID0gYXNzZXJ0U3RyaW5nVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydFN5bWJvbFR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0U3ltYm9sVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydFRoaXNUeXBlQW5ub3RhdGlvbiA9IGFzc2VydFRoaXNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VHVwbGVUeXBlQW5ub3RhdGlvbiA9IGFzc2VydFR1cGxlVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydFR5cGVvZlR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0VHlwZW9mVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydFR5cGVBbGlhcyA9IGFzc2VydFR5cGVBbGlhcztcbmV4cG9ydHMuYXNzZXJ0VHlwZUFubm90YXRpb24gPSBhc3NlcnRUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VHlwZUNhc3RFeHByZXNzaW9uID0gYXNzZXJ0VHlwZUNhc3RFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRUeXBlUGFyYW1ldGVyID0gYXNzZXJ0VHlwZVBhcmFtZXRlcjtcbmV4cG9ydHMuYXNzZXJ0VHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uID0gYXNzZXJ0VHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IGFzc2VydFR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uO1xuZXhwb3J0cy5hc3NlcnRVbmlvblR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0VW5pb25UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VmFyaWFuY2UgPSBhc3NlcnRWYXJpYW5jZTtcbmV4cG9ydHMuYXNzZXJ0Vm9pZFR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0Vm9pZFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRFbnVtRGVjbGFyYXRpb24gPSBhc3NlcnRFbnVtRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydEVudW1Cb29sZWFuQm9keSA9IGFzc2VydEVudW1Cb29sZWFuQm9keTtcbmV4cG9ydHMuYXNzZXJ0RW51bU51bWJlckJvZHkgPSBhc3NlcnRFbnVtTnVtYmVyQm9keTtcbmV4cG9ydHMuYXNzZXJ0RW51bVN0cmluZ0JvZHkgPSBhc3NlcnRFbnVtU3RyaW5nQm9keTtcbmV4cG9ydHMuYXNzZXJ0RW51bVN5bWJvbEJvZHkgPSBhc3NlcnRFbnVtU3ltYm9sQm9keTtcbmV4cG9ydHMuYXNzZXJ0RW51bUJvb2xlYW5NZW1iZXIgPSBhc3NlcnRFbnVtQm9vbGVhbk1lbWJlcjtcbmV4cG9ydHMuYXNzZXJ0RW51bU51bWJlck1lbWJlciA9IGFzc2VydEVudW1OdW1iZXJNZW1iZXI7XG5leHBvcnRzLmFzc2VydEVudW1TdHJpbmdNZW1iZXIgPSBhc3NlcnRFbnVtU3RyaW5nTWVtYmVyO1xuZXhwb3J0cy5hc3NlcnRFbnVtRGVmYXVsdGVkTWVtYmVyID0gYXNzZXJ0RW51bURlZmF1bHRlZE1lbWJlcjtcbmV4cG9ydHMuYXNzZXJ0SlNYQXR0cmlidXRlID0gYXNzZXJ0SlNYQXR0cmlidXRlO1xuZXhwb3J0cy5hc3NlcnRKU1hDbG9zaW5nRWxlbWVudCA9IGFzc2VydEpTWENsb3NpbmdFbGVtZW50O1xuZXhwb3J0cy5hc3NlcnRKU1hFbGVtZW50ID0gYXNzZXJ0SlNYRWxlbWVudDtcbmV4cG9ydHMuYXNzZXJ0SlNYRW1wdHlFeHByZXNzaW9uID0gYXNzZXJ0SlNYRW1wdHlFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRKU1hFeHByZXNzaW9uQ29udGFpbmVyID0gYXNzZXJ0SlNYRXhwcmVzc2lvbkNvbnRhaW5lcjtcbmV4cG9ydHMuYXNzZXJ0SlNYU3ByZWFkQ2hpbGQgPSBhc3NlcnRKU1hTcHJlYWRDaGlsZDtcbmV4cG9ydHMuYXNzZXJ0SlNYSWRlbnRpZmllciA9IGFzc2VydEpTWElkZW50aWZpZXI7XG5leHBvcnRzLmFzc2VydEpTWE1lbWJlckV4cHJlc3Npb24gPSBhc3NlcnRKU1hNZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRKU1hOYW1lc3BhY2VkTmFtZSA9IGFzc2VydEpTWE5hbWVzcGFjZWROYW1lO1xuZXhwb3J0cy5hc3NlcnRKU1hPcGVuaW5nRWxlbWVudCA9IGFzc2VydEpTWE9wZW5pbmdFbGVtZW50O1xuZXhwb3J0cy5hc3NlcnRKU1hTcHJlYWRBdHRyaWJ1dGUgPSBhc3NlcnRKU1hTcHJlYWRBdHRyaWJ1dGU7XG5leHBvcnRzLmFzc2VydEpTWFRleHQgPSBhc3NlcnRKU1hUZXh0O1xuZXhwb3J0cy5hc3NlcnRKU1hGcmFnbWVudCA9IGFzc2VydEpTWEZyYWdtZW50O1xuZXhwb3J0cy5hc3NlcnRKU1hPcGVuaW5nRnJhZ21lbnQgPSBhc3NlcnRKU1hPcGVuaW5nRnJhZ21lbnQ7XG5leHBvcnRzLmFzc2VydEpTWENsb3NpbmdGcmFnbWVudCA9IGFzc2VydEpTWENsb3NpbmdGcmFnbWVudDtcbmV4cG9ydHMuYXNzZXJ0Tm9vcCA9IGFzc2VydE5vb3A7XG5leHBvcnRzLmFzc2VydFBsYWNlaG9sZGVyID0gYXNzZXJ0UGxhY2Vob2xkZXI7XG5leHBvcnRzLmFzc2VydFY4SW50cmluc2ljSWRlbnRpZmllciA9IGFzc2VydFY4SW50cmluc2ljSWRlbnRpZmllcjtcbmV4cG9ydHMuYXNzZXJ0QXJndW1lbnRQbGFjZWhvbGRlciA9IGFzc2VydEFyZ3VtZW50UGxhY2Vob2xkZXI7XG5leHBvcnRzLmFzc2VydEF3YWl0RXhwcmVzc2lvbiA9IGFzc2VydEF3YWl0RXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0QmluZEV4cHJlc3Npb24gPSBhc3NlcnRCaW5kRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0Q2xhc3NQcm9wZXJ0eSA9IGFzc2VydENsYXNzUHJvcGVydHk7XG5leHBvcnRzLmFzc2VydE9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbiA9IGFzc2VydE9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0UGlwZWxpbmVUb3BpY0V4cHJlc3Npb24gPSBhc3NlcnRQaXBlbGluZVRvcGljRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0UGlwZWxpbmVCYXJlRnVuY3Rpb24gPSBhc3NlcnRQaXBlbGluZUJhcmVGdW5jdGlvbjtcbmV4cG9ydHMuYXNzZXJ0UGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2UgPSBhc3NlcnRQaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZTtcbmV4cG9ydHMuYXNzZXJ0T3B0aW9uYWxDYWxsRXhwcmVzc2lvbiA9IGFzc2VydE9wdGlvbmFsQ2FsbEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydENsYXNzUHJpdmF0ZVByb3BlcnR5ID0gYXNzZXJ0Q2xhc3NQcml2YXRlUHJvcGVydHk7XG5leHBvcnRzLmFzc2VydENsYXNzUHJpdmF0ZU1ldGhvZCA9IGFzc2VydENsYXNzUHJpdmF0ZU1ldGhvZDtcbmV4cG9ydHMuYXNzZXJ0SW1wb3J0ID0gYXNzZXJ0SW1wb3J0O1xuZXhwb3J0cy5hc3NlcnRJbXBvcnRBdHRyaWJ1dGUgPSBhc3NlcnRJbXBvcnRBdHRyaWJ1dGU7XG5leHBvcnRzLmFzc2VydERlY29yYXRvciA9IGFzc2VydERlY29yYXRvcjtcbmV4cG9ydHMuYXNzZXJ0RG9FeHByZXNzaW9uID0gYXNzZXJ0RG9FeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRFeHBvcnREZWZhdWx0U3BlY2lmaWVyID0gYXNzZXJ0RXhwb3J0RGVmYXVsdFNwZWNpZmllcjtcbmV4cG9ydHMuYXNzZXJ0RXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gYXNzZXJ0RXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xuZXhwb3J0cy5hc3NlcnRQcml2YXRlTmFtZSA9IGFzc2VydFByaXZhdGVOYW1lO1xuZXhwb3J0cy5hc3NlcnRCaWdJbnRMaXRlcmFsID0gYXNzZXJ0QmlnSW50TGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0UmVjb3JkRXhwcmVzc2lvbiA9IGFzc2VydFJlY29yZEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydFR1cGxlRXhwcmVzc2lvbiA9IGFzc2VydFR1cGxlRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0VFNQYXJhbWV0ZXJQcm9wZXJ0eSA9IGFzc2VydFRTUGFyYW1ldGVyUHJvcGVydHk7XG5leHBvcnRzLmFzc2VydFRTRGVjbGFyZUZ1bmN0aW9uID0gYXNzZXJ0VFNEZWNsYXJlRnVuY3Rpb247XG5leHBvcnRzLmFzc2VydFRTRGVjbGFyZU1ldGhvZCA9IGFzc2VydFRTRGVjbGFyZU1ldGhvZDtcbmV4cG9ydHMuYXNzZXJ0VFNRdWFsaWZpZWROYW1lID0gYXNzZXJ0VFNRdWFsaWZpZWROYW1lO1xuZXhwb3J0cy5hc3NlcnRUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbiA9IGFzc2VydFRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uID0gYXNzZXJ0VFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNQcm9wZXJ0eVNpZ25hdHVyZSA9IGFzc2VydFRTUHJvcGVydHlTaWduYXR1cmU7XG5leHBvcnRzLmFzc2VydFRTTWV0aG9kU2lnbmF0dXJlID0gYXNzZXJ0VFNNZXRob2RTaWduYXR1cmU7XG5leHBvcnRzLmFzc2VydFRTSW5kZXhTaWduYXR1cmUgPSBhc3NlcnRUU0luZGV4U2lnbmF0dXJlO1xuZXhwb3J0cy5hc3NlcnRUU0FueUtleXdvcmQgPSBhc3NlcnRUU0FueUtleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTQm9vbGVhbktleXdvcmQgPSBhc3NlcnRUU0Jvb2xlYW5LZXl3b3JkO1xuZXhwb3J0cy5hc3NlcnRUU0JpZ0ludEtleXdvcmQgPSBhc3NlcnRUU0JpZ0ludEtleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTTmV2ZXJLZXl3b3JkID0gYXNzZXJ0VFNOZXZlcktleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTTnVsbEtleXdvcmQgPSBhc3NlcnRUU051bGxLZXl3b3JkO1xuZXhwb3J0cy5hc3NlcnRUU051bWJlcktleXdvcmQgPSBhc3NlcnRUU051bWJlcktleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTT2JqZWN0S2V5d29yZCA9IGFzc2VydFRTT2JqZWN0S2V5d29yZDtcbmV4cG9ydHMuYXNzZXJ0VFNTdHJpbmdLZXl3b3JkID0gYXNzZXJ0VFNTdHJpbmdLZXl3b3JkO1xuZXhwb3J0cy5hc3NlcnRUU1N5bWJvbEtleXdvcmQgPSBhc3NlcnRUU1N5bWJvbEtleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTVW5kZWZpbmVkS2V5d29yZCA9IGFzc2VydFRTVW5kZWZpbmVkS2V5d29yZDtcbmV4cG9ydHMuYXNzZXJ0VFNVbmtub3duS2V5d29yZCA9IGFzc2VydFRTVW5rbm93bktleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTVm9pZEtleXdvcmQgPSBhc3NlcnRUU1ZvaWRLZXl3b3JkO1xuZXhwb3J0cy5hc3NlcnRUU1RoaXNUeXBlID0gYXNzZXJ0VFNUaGlzVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNGdW5jdGlvblR5cGUgPSBhc3NlcnRUU0Z1bmN0aW9uVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNDb25zdHJ1Y3RvclR5cGUgPSBhc3NlcnRUU0NvbnN0cnVjdG9yVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlUmVmZXJlbmNlID0gYXNzZXJ0VFNUeXBlUmVmZXJlbmNlO1xuZXhwb3J0cy5hc3NlcnRUU1R5cGVQcmVkaWNhdGUgPSBhc3NlcnRUU1R5cGVQcmVkaWNhdGU7XG5leHBvcnRzLmFzc2VydFRTVHlwZVF1ZXJ5ID0gYXNzZXJ0VFNUeXBlUXVlcnk7XG5leHBvcnRzLmFzc2VydFRTVHlwZUxpdGVyYWwgPSBhc3NlcnRUU1R5cGVMaXRlcmFsO1xuZXhwb3J0cy5hc3NlcnRUU0FycmF5VHlwZSA9IGFzc2VydFRTQXJyYXlUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU1R1cGxlVHlwZSA9IGFzc2VydFRTVHVwbGVUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU09wdGlvbmFsVHlwZSA9IGFzc2VydFRTT3B0aW9uYWxUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU1Jlc3RUeXBlID0gYXNzZXJ0VFNSZXN0VHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNVbmlvblR5cGUgPSBhc3NlcnRUU1VuaW9uVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNJbnRlcnNlY3Rpb25UeXBlID0gYXNzZXJ0VFNJbnRlcnNlY3Rpb25UeXBlO1xuZXhwb3J0cy5hc3NlcnRUU0NvbmRpdGlvbmFsVHlwZSA9IGFzc2VydFRTQ29uZGl0aW9uYWxUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU0luZmVyVHlwZSA9IGFzc2VydFRTSW5mZXJUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU1BhcmVudGhlc2l6ZWRUeXBlID0gYXNzZXJ0VFNQYXJlbnRoZXNpemVkVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlT3BlcmF0b3IgPSBhc3NlcnRUU1R5cGVPcGVyYXRvcjtcbmV4cG9ydHMuYXNzZXJ0VFNJbmRleGVkQWNjZXNzVHlwZSA9IGFzc2VydFRTSW5kZXhlZEFjY2Vzc1R5cGU7XG5leHBvcnRzLmFzc2VydFRTTWFwcGVkVHlwZSA9IGFzc2VydFRTTWFwcGVkVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNMaXRlcmFsVHlwZSA9IGFzc2VydFRTTGl0ZXJhbFR5cGU7XG5leHBvcnRzLmFzc2VydFRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzID0gYXNzZXJ0VFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHM7XG5leHBvcnRzLmFzc2VydFRTSW50ZXJmYWNlRGVjbGFyYXRpb24gPSBhc3NlcnRUU0ludGVyZmFjZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU0ludGVyZmFjZUJvZHkgPSBhc3NlcnRUU0ludGVyZmFjZUJvZHk7XG5leHBvcnRzLmFzc2VydFRTVHlwZUFsaWFzRGVjbGFyYXRpb24gPSBhc3NlcnRUU1R5cGVBbGlhc0RlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU0FzRXhwcmVzc2lvbiA9IGFzc2VydFRTQXNFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRUU1R5cGVBc3NlcnRpb24gPSBhc3NlcnRUU1R5cGVBc3NlcnRpb247XG5leHBvcnRzLmFzc2VydFRTRW51bURlY2xhcmF0aW9uID0gYXNzZXJ0VFNFbnVtRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydFRTRW51bU1lbWJlciA9IGFzc2VydFRTRW51bU1lbWJlcjtcbmV4cG9ydHMuYXNzZXJ0VFNNb2R1bGVEZWNsYXJhdGlvbiA9IGFzc2VydFRTTW9kdWxlRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydFRTTW9kdWxlQmxvY2sgPSBhc3NlcnRUU01vZHVsZUJsb2NrO1xuZXhwb3J0cy5hc3NlcnRUU0ltcG9ydFR5cGUgPSBhc3NlcnRUU0ltcG9ydFR5cGU7XG5leHBvcnRzLmFzc2VydFRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24gPSBhc3NlcnRUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlID0gYXNzZXJ0VFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZTtcbmV4cG9ydHMuYXNzZXJ0VFNOb25OdWxsRXhwcmVzc2lvbiA9IGFzc2VydFRTTm9uTnVsbEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydFRTRXhwb3J0QXNzaWdubWVudCA9IGFzc2VydFRTRXhwb3J0QXNzaWdubWVudDtcbmV4cG9ydHMuYXNzZXJ0VFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbiA9IGFzc2VydFRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydFRTVHlwZUFubm90YXRpb24gPSBhc3NlcnRUU1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uID0gYXNzZXJ0VFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24gPSBhc3NlcnRUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlUGFyYW1ldGVyID0gYXNzZXJ0VFNUeXBlUGFyYW1ldGVyO1xuZXhwb3J0cy5hc3NlcnRFeHByZXNzaW9uID0gYXNzZXJ0RXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0QmluYXJ5ID0gYXNzZXJ0QmluYXJ5O1xuZXhwb3J0cy5hc3NlcnRTY29wYWJsZSA9IGFzc2VydFNjb3BhYmxlO1xuZXhwb3J0cy5hc3NlcnRCbG9ja1BhcmVudCA9IGFzc2VydEJsb2NrUGFyZW50O1xuZXhwb3J0cy5hc3NlcnRCbG9jayA9IGFzc2VydEJsb2NrO1xuZXhwb3J0cy5hc3NlcnRTdGF0ZW1lbnQgPSBhc3NlcnRTdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydFRlcm1pbmF0b3JsZXNzID0gYXNzZXJ0VGVybWluYXRvcmxlc3M7XG5leHBvcnRzLmFzc2VydENvbXBsZXRpb25TdGF0ZW1lbnQgPSBhc3NlcnRDb21wbGV0aW9uU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRDb25kaXRpb25hbCA9IGFzc2VydENvbmRpdGlvbmFsO1xuZXhwb3J0cy5hc3NlcnRMb29wID0gYXNzZXJ0TG9vcDtcbmV4cG9ydHMuYXNzZXJ0V2hpbGUgPSBhc3NlcnRXaGlsZTtcbmV4cG9ydHMuYXNzZXJ0RXhwcmVzc2lvbldyYXBwZXIgPSBhc3NlcnRFeHByZXNzaW9uV3JhcHBlcjtcbmV4cG9ydHMuYXNzZXJ0Rm9yID0gYXNzZXJ0Rm9yO1xuZXhwb3J0cy5hc3NlcnRGb3JYU3RhdGVtZW50ID0gYXNzZXJ0Rm9yWFN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0RnVuY3Rpb24gPSBhc3NlcnRGdW5jdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RnVuY3Rpb25QYXJlbnQgPSBhc3NlcnRGdW5jdGlvblBhcmVudDtcbmV4cG9ydHMuYXNzZXJ0UHVyZWlzaCA9IGFzc2VydFB1cmVpc2g7XG5leHBvcnRzLmFzc2VydERlY2xhcmF0aW9uID0gYXNzZXJ0RGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydFBhdHRlcm5MaWtlID0gYXNzZXJ0UGF0dGVybkxpa2U7XG5leHBvcnRzLmFzc2VydExWYWwgPSBhc3NlcnRMVmFsO1xuZXhwb3J0cy5hc3NlcnRUU0VudGl0eU5hbWUgPSBhc3NlcnRUU0VudGl0eU5hbWU7XG5leHBvcnRzLmFzc2VydExpdGVyYWwgPSBhc3NlcnRMaXRlcmFsO1xuZXhwb3J0cy5hc3NlcnRJbW11dGFibGUgPSBhc3NlcnRJbW11dGFibGU7XG5leHBvcnRzLmFzc2VydFVzZXJXaGl0ZXNwYWNhYmxlID0gYXNzZXJ0VXNlcldoaXRlc3BhY2FibGU7XG5leHBvcnRzLmFzc2VydE1ldGhvZCA9IGFzc2VydE1ldGhvZDtcbmV4cG9ydHMuYXNzZXJ0T2JqZWN0TWVtYmVyID0gYXNzZXJ0T2JqZWN0TWVtYmVyO1xuZXhwb3J0cy5hc3NlcnRQcm9wZXJ0eSA9IGFzc2VydFByb3BlcnR5O1xuZXhwb3J0cy5hc3NlcnRVbmFyeUxpa2UgPSBhc3NlcnRVbmFyeUxpa2U7XG5leHBvcnRzLmFzc2VydFBhdHRlcm4gPSBhc3NlcnRQYXR0ZXJuO1xuZXhwb3J0cy5hc3NlcnRDbGFzcyA9IGFzc2VydENsYXNzO1xuZXhwb3J0cy5hc3NlcnRNb2R1bGVEZWNsYXJhdGlvbiA9IGFzc2VydE1vZHVsZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRFeHBvcnREZWNsYXJhdGlvbiA9IGFzc2VydEV4cG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRNb2R1bGVTcGVjaWZpZXIgPSBhc3NlcnRNb2R1bGVTcGVjaWZpZXI7XG5leHBvcnRzLmFzc2VydEZsb3cgPSBhc3NlcnRGbG93O1xuZXhwb3J0cy5hc3NlcnRGbG93VHlwZSA9IGFzc2VydEZsb3dUeXBlO1xuZXhwb3J0cy5hc3NlcnRGbG93QmFzZUFubm90YXRpb24gPSBhc3NlcnRGbG93QmFzZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydEZsb3dEZWNsYXJhdGlvbiA9IGFzc2VydEZsb3dEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0Rmxvd1ByZWRpY2F0ZSA9IGFzc2VydEZsb3dQcmVkaWNhdGU7XG5leHBvcnRzLmFzc2VydEVudW1Cb2R5ID0gYXNzZXJ0RW51bUJvZHk7XG5leHBvcnRzLmFzc2VydEVudW1NZW1iZXIgPSBhc3NlcnRFbnVtTWVtYmVyO1xuZXhwb3J0cy5hc3NlcnRKU1ggPSBhc3NlcnRKU1g7XG5leHBvcnRzLmFzc2VydFByaXZhdGUgPSBhc3NlcnRQcml2YXRlO1xuZXhwb3J0cy5hc3NlcnRUU1R5cGVFbGVtZW50ID0gYXNzZXJ0VFNUeXBlRWxlbWVudDtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlID0gYXNzZXJ0VFNUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU0Jhc2VUeXBlID0gYXNzZXJ0VFNCYXNlVHlwZTtcbmV4cG9ydHMuYXNzZXJ0TnVtYmVyTGl0ZXJhbCA9IGFzc2VydE51bWJlckxpdGVyYWw7XG5leHBvcnRzLmFzc2VydFJlZ2V4TGl0ZXJhbCA9IGFzc2VydFJlZ2V4TGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0UmVzdFByb3BlcnR5ID0gYXNzZXJ0UmVzdFByb3BlcnR5O1xuZXhwb3J0cy5hc3NlcnRTcHJlYWRQcm9wZXJ0eSA9IGFzc2VydFNwcmVhZFByb3BlcnR5O1xuXG52YXIgX2lzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vdmFsaWRhdG9ycy9pc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGFzc2VydCh0eXBlLCBub2RlLCBvcHRzKSB7XG4gIGlmICghKDAsIF9pcy5kZWZhdWx0KSh0eXBlLCBub2RlLCBvcHRzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgdHlwZSBcIiR7dHlwZX1cIiB3aXRoIG9wdGlvbiAke0pTT04uc3RyaW5naWZ5KG9wdHMpfSwgYCArIGBidXQgaW5zdGVhZCBnb3QgXCIke25vZGUudHlwZX1cIi5gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRBcnJheUV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkFycmF5RXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QXNzaWdubWVudEV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRCaW5hcnlFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJCaW5hcnlFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJbnRlcnByZXRlckRpcmVjdGl2ZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSW50ZXJwcmV0ZXJEaXJlY3RpdmVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydERpcmVjdGl2ZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRGlyZWN0aXZlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnREaXJlY3RpdmVMaXRlcmFsKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJEaXJlY3RpdmVMaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRCbG9ja1N0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQmxvY2tTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEJyZWFrU3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJCcmVha1N0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q2FsbEV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkNhbGxFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRDYXRjaENsYXVzZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQ2F0Y2hDbGF1c2VcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENvbmRpdGlvbmFsRXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRDb250aW51ZVN0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQ29udGludWVTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydERlYnVnZ2VyU3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJEZWJ1Z2dlclN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RG9XaGlsZVN0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRG9XaGlsZVN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RW1wdHlTdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkVtcHR5U3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRGaWxlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJGaWxlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRGb3JJblN0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRm9ySW5TdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEZvclN0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRm9yU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRGdW5jdGlvbkV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SWRlbnRpZmllcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSWRlbnRpZmllclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SWZTdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIklmU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJMYWJlbGVkU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTdHJpbmdMaXRlcmFsKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJTdHJpbmdMaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROdW1lcmljTGl0ZXJhbChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiTnVtZXJpY0xpdGVyYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE51bGxMaXRlcmFsKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJOdWxsTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Qm9vbGVhbkxpdGVyYWwobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkJvb2xlYW5MaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRSZWdFeHBMaXRlcmFsKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJSZWdFeHBMaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRMb2dpY2FsRXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiTG9naWNhbEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE1lbWJlckV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk1lbWJlckV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE5ld0V4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk5ld0V4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFByb2dyYW0obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlByb2dyYW1cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdEV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk9iamVjdEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdE1ldGhvZChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiT2JqZWN0TWV0aG9kXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RQcm9wZXJ0eShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiT2JqZWN0UHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJlc3RFbGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJSZXN0RWxlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmV0dXJuU3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJSZXR1cm5TdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNlcXVlbmNlRXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiU2VxdWVuY2VFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRQYXJlbnRoZXNpemVkRXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFN3aXRjaENhc2Uobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlN3aXRjaENhc2VcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFN3aXRjaFN0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiU3dpdGNoU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUaGlzRXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVGhpc0V4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRocm93U3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUaHJvd1N0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VHJ5U3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUcnlTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFVuYXJ5RXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVW5hcnlFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRVcGRhdGVFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJVcGRhdGVFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRWYXJpYWJsZURlY2xhcmF0b3Iobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlZhcmlhYmxlRGVjbGFyYXRvclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0V2hpbGVTdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIldoaWxlU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRXaXRoU3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJXaXRoU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRBc3NpZ25tZW50UGF0dGVybihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQXNzaWdubWVudFBhdHRlcm5cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEFycmF5UGF0dGVybihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQXJyYXlQYXR0ZXJuXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENsYXNzQm9keShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQ2xhc3NCb2R5XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRDbGFzc0V4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkNsYXNzRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q2xhc3NEZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQ2xhc3NEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RXhwb3J0QWxsRGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RXhwb3J0TmFtZWREZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RXhwb3J0U3BlY2lmaWVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFeHBvcnRTcGVjaWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEZvck9mU3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJGb3JPZlN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SW1wb3J0RGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkltcG9ydERlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJbXBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SW1wb3J0U3BlY2lmaWVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJJbXBvcnRTcGVjaWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE1ldGFQcm9wZXJ0eShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiTWV0YVByb3BlcnR5XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRDbGFzc01ldGhvZChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQ2xhc3NNZXRob2RcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFBhdHRlcm4obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk9iamVjdFBhdHRlcm5cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNwcmVhZEVsZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlNwcmVhZEVsZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFN1cGVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJTdXBlclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRlbXBsYXRlRWxlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVGVtcGxhdGVFbGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUZW1wbGF0ZUxpdGVyYWwobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRlbXBsYXRlTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0WWllbGRFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJZaWVsZEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEFueVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJBbnlUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QXJyYXlUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQXJyYXlUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Qm9vbGVhblR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJCb29sZWFuVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE51bGxMaXRlcmFsVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk51bGxMaXRlcmFsVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENsYXNzSW1wbGVtZW50cyhub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQ2xhc3NJbXBsZW1lbnRzXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnREZWNsYXJlQ2xhc3Mobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRlY2xhcmVDbGFzc1wiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGVjbGFyZUZ1bmN0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJEZWNsYXJlRnVuY3Rpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmVJbnRlcmZhY2Uobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRlY2xhcmVJbnRlcmZhY2VcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmVNb2R1bGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRlY2xhcmVNb2R1bGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmVNb2R1bGVFeHBvcnRzKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGVjbGFyZVR5cGVBbGlhcyhub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRGVjbGFyZVR5cGVBbGlhc1wiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGVjbGFyZU9wYXF1ZVR5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRlY2xhcmVPcGFxdWVUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnREZWNsYXJlVmFyaWFibGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRlY2xhcmVWYXJpYWJsZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnREZWNsYXJlZFByZWRpY2F0ZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRGVjbGFyZWRQcmVkaWNhdGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEV4aXN0c1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFeGlzdHNUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb25UeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb25UeXBlUGFyYW0obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkZ1bmN0aW9uVHlwZVBhcmFtXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRHZW5lcmljVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SW5mZXJyZWRQcmVkaWNhdGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkluZmVycmVkUHJlZGljYXRlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJbnRlcmZhY2VFeHRlbmRzKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJJbnRlcmZhY2VFeHRlbmRzXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJbnRlcmZhY2VEZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEludGVyZmFjZVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJJbnRlcmZhY2VUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRNaXhlZFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFbXB0eVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFbXB0eVR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROdWxsYWJsZVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk51bWJlclR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiT2JqZWN0VHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGVJbnRlcm5hbFNsb3Qobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGVDYWxsUHJvcGVydHkobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGVJbmRleGVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJPYmplY3RUeXBlSW5kZXhlclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZVByb3BlcnR5KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJPYmplY3RUeXBlUHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRPcGFxdWVUeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJPcGFxdWVUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRRdWFsaWZpZWRUeXBlSWRlbnRpZmllcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTdHJpbmdUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiU3RyaW5nVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFN5bWJvbFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJTeW1ib2xUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VGhpc1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUaGlzVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFR1cGxlVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlR1cGxlVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGVvZlR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUeXBlb2ZUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VHlwZUFsaWFzKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUeXBlQWxpYXNcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VHlwZUNhc3RFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUeXBlQ2FzdEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGVQYXJhbWV0ZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlR5cGVQYXJhbWV0ZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFVuaW9uVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlVuaW9uVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFZhcmlhbmNlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJWYXJpYW5jZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Vm9pZFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJWb2lkVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEVudW1EZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRW51bURlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFbnVtQm9vbGVhbkJvZHkobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkVudW1Cb29sZWFuQm9keVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RW51bU51bWJlckJvZHkobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkVudW1OdW1iZXJCb2R5XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFbnVtU3RyaW5nQm9keShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRW51bVN0cmluZ0JvZHlcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEVudW1TeW1ib2xCb2R5KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFbnVtU3ltYm9sQm9keVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RW51bUJvb2xlYW5NZW1iZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkVudW1Cb29sZWFuTWVtYmVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFbnVtTnVtYmVyTWVtYmVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFbnVtTnVtYmVyTWVtYmVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFbnVtU3RyaW5nTWVtYmVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFbnVtU3RyaW5nTWVtYmVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFbnVtRGVmYXVsdGVkTWVtYmVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFbnVtRGVmYXVsdGVkTWVtYmVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRKU1hBdHRyaWJ1dGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkpTWEF0dHJpYnV0ZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SlNYQ2xvc2luZ0VsZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkpTWENsb3NpbmdFbGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRKU1hFbGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJKU1hFbGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRKU1hFbXB0eUV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkpTWEVtcHR5RXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SlNYRXhwcmVzc2lvbkNvbnRhaW5lcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SlNYU3ByZWFkQ2hpbGQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkpTWFNwcmVhZENoaWxkXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRKU1hJZGVudGlmaWVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJKU1hJZGVudGlmaWVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRKU1hNZW1iZXJFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRKU1hOYW1lc3BhY2VkTmFtZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSlNYTmFtZXNwYWNlZE5hbWVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEpTWE9wZW5pbmdFbGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJKU1hPcGVuaW5nRWxlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SlNYU3ByZWFkQXR0cmlidXRlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEpTWFRleHQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkpTWFRleHRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEpTWEZyYWdtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJKU1hGcmFnbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SlNYT3BlbmluZ0ZyYWdtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJKU1hPcGVuaW5nRnJhZ21lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEpTWENsb3NpbmdGcmFnbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSlNYQ2xvc2luZ0ZyYWdtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROb29wKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJOb29wXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRQbGFjZWhvbGRlcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiUGxhY2Vob2xkZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFY4SW50cmluc2ljSWRlbnRpZmllcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRBcmd1bWVudFBsYWNlaG9sZGVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJBcmd1bWVudFBsYWNlaG9sZGVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRBd2FpdEV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkF3YWl0RXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QmluZEV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkJpbmRFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRDbGFzc1Byb3BlcnR5KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJDbGFzc1Byb3BlcnR5XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25hbE1lbWJlckV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UGlwZWxpbmVUb3BpY0V4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlBpcGVsaW5lVG9waWNFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRQaXBlbGluZUJhcmVGdW5jdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiUGlwZWxpbmVCYXJlRnVuY3Rpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJQaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0T3B0aW9uYWxDYWxsRXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q2xhc3NQcml2YXRlUHJvcGVydHkobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRDbGFzc1ByaXZhdGVNZXRob2Qobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SW1wb3J0KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJJbXBvcnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEltcG9ydEF0dHJpYnV0ZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSW1wb3J0QXR0cmlidXRlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnREZWNvcmF0b3Iobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRlY29yYXRvclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RG9FeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJEb0V4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEV4cG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRQcml2YXRlTmFtZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiUHJpdmF0ZU5hbWVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEJpZ0ludExpdGVyYWwobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkJpZ0ludExpdGVyYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJlY29yZEV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlJlY29yZEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFR1cGxlRXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVHVwbGVFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1BhcmFtZXRlclByb3BlcnR5KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1BhcmFtZXRlclByb3BlcnR5XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0RlY2xhcmVGdW5jdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNEZWNsYXJlRnVuY3Rpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTRGVjbGFyZU1ldGhvZChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNEZWNsYXJlTWV0aG9kXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1F1YWxpZmllZE5hbWUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTUXVhbGlmaWVkTmFtZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1Byb3BlcnR5U2lnbmF0dXJlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1Byb3BlcnR5U2lnbmF0dXJlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU01ldGhvZFNpZ25hdHVyZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNNZXRob2RTaWduYXR1cmVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTSW5kZXhTaWduYXR1cmUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTSW5kZXhTaWduYXR1cmVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTQW55S2V5d29yZChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNBbnlLZXl3b3JkXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0Jvb2xlYW5LZXl3b3JkKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0Jvb2xlYW5LZXl3b3JkXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0JpZ0ludEtleXdvcmQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTQmlnSW50S2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNOZXZlcktleXdvcmQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTTmV2ZXJLZXl3b3JkXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU051bGxLZXl3b3JkKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU051bGxLZXl3b3JkXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU051bWJlcktleXdvcmQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTTnVtYmVyS2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNPYmplY3RLZXl3b3JkKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU09iamVjdEtleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTU3RyaW5nS2V5d29yZChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNTdHJpbmdLZXl3b3JkXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1N5bWJvbEtleXdvcmQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTU3ltYm9sS2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNVbmRlZmluZWRLZXl3b3JkKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1VuZGVmaW5lZEtleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVW5rbm93bktleXdvcmQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTVW5rbm93bktleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVm9pZEtleXdvcmQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTVm9pZEtleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVGhpc1R5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTVGhpc1R5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTRnVuY3Rpb25UeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0Z1bmN0aW9uVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNDb25zdHJ1Y3RvclR5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTQ29uc3RydWN0b3JUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1R5cGVSZWZlcmVuY2Uobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTVHlwZVJlZmVyZW5jZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlUHJlZGljYXRlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1R5cGVQcmVkaWNhdGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZVF1ZXJ5KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1R5cGVRdWVyeVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlTGl0ZXJhbChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNUeXBlTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNBcnJheVR5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTQXJyYXlUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1R1cGxlVHlwZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNUdXBsZVR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTT3B0aW9uYWxUeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU09wdGlvbmFsVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNSZXN0VHlwZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNSZXN0VHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNVbmlvblR5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTVW5pb25UeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0ludGVyc2VjdGlvblR5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTSW50ZXJzZWN0aW9uVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNDb25kaXRpb25hbFR5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTQ29uZGl0aW9uYWxUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0luZmVyVHlwZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNJbmZlclR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTUGFyZW50aGVzaXplZFR5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTUGFyZW50aGVzaXplZFR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZU9wZXJhdG9yKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1R5cGVPcGVyYXRvclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNJbmRleGVkQWNjZXNzVHlwZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNJbmRleGVkQWNjZXNzVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNNYXBwZWRUeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU01hcHBlZFR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTTGl0ZXJhbFR5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTTGl0ZXJhbFR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50c1wiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNJbnRlcmZhY2VEZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNJbnRlcmZhY2VCb2R5KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0ludGVyZmFjZUJvZHlcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZUFsaWFzRGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTQXNFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0FzRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlQXNzZXJ0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1R5cGVBc3NlcnRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTRW51bURlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0VudW1EZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNFbnVtTWVtYmVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0VudW1NZW1iZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTTW9kdWxlRGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTTW9kdWxlRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTTW9kdWxlQmxvY2sobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTTW9kdWxlQmxvY2tcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTSW1wb3J0VHlwZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNJbXBvcnRUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU05vbk51bGxFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU05vbk51bGxFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0V4cG9ydEFzc2lnbm1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTRXhwb3J0QXNzaWdubWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1R5cGVQYXJhbWV0ZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTVHlwZVBhcmFtZXRlclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QmluYXJ5KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJCaW5hcnlcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNjb3BhYmxlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJTY29wYWJsZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QmxvY2tQYXJlbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkJsb2NrUGFyZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRCbG9jayhub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQmxvY2tcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFN0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUZXJtaW5hdG9ybGVzcyhub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVGVybWluYXRvcmxlc3NcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENvbXBsZXRpb25TdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkNvbXBsZXRpb25TdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENvbmRpdGlvbmFsKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJDb25kaXRpb25hbFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TG9vcChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiTG9vcFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0V2hpbGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIldoaWxlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFeHByZXNzaW9uV3JhcHBlcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRXhwcmVzc2lvbldyYXBwZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEZvcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRm9yXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRGb3JYU3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJGb3JYU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRGdW5jdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRnVuY3Rpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uUGFyZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJGdW5jdGlvblBhcmVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UHVyZWlzaChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiUHVyZWlzaFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRQYXR0ZXJuTGlrZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiUGF0dGVybkxpa2VcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydExWYWwobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkxWYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTRW50aXR5TmFtZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNFbnRpdHlOYW1lXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRMaXRlcmFsKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJMaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJbW11dGFibGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkltbXV0YWJsZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VXNlcldoaXRlc3BhY2FibGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlVzZXJXaGl0ZXNwYWNhYmxlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRNZXRob2Qobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk1ldGhvZFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0TWVtYmVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJPYmplY3RNZW1iZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFByb3BlcnR5KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJQcm9wZXJ0eVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VW5hcnlMaWtlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJVbmFyeUxpa2VcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFBhdHRlcm4obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlBhdHRlcm5cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENsYXNzKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJDbGFzc1wiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TW9kdWxlRGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk1vZHVsZURlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFeHBvcnREZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRXhwb3J0RGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE1vZHVsZVNwZWNpZmllcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiTW9kdWxlU3BlY2lmaWVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRGbG93KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJGbG93XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRGbG93VHlwZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRmxvd1R5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEZsb3dCYXNlQW5ub3RhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRGbG93RGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkZsb3dEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Rmxvd1ByZWRpY2F0ZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRmxvd1ByZWRpY2F0ZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RW51bUJvZHkobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkVudW1Cb2R5XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFbnVtTWVtYmVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFbnVtTWVtYmVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRKU1gobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkpTWFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UHJpdmF0ZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiUHJpdmF0ZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlRWxlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNUeXBlRWxlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1R5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTQmFzZVR5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTQmFzZVR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE51bWJlckxpdGVyYWwobm9kZSwgb3B0cykge1xuICBjb25zb2xlLnRyYWNlKFwiVGhlIG5vZGUgdHlwZSBOdW1iZXJMaXRlcmFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gTnVtZXJpY0xpdGVyYWxcIik7XG4gIGFzc2VydChcIk51bWJlckxpdGVyYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJlZ2V4TGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGNvbnNvbGUudHJhY2UoXCJUaGUgbm9kZSB0eXBlIFJlZ2V4TGl0ZXJhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFJlZ0V4cExpdGVyYWxcIik7XG4gIGFzc2VydChcIlJlZ2V4TGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVzdFByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgY29uc29sZS50cmFjZShcIlRoZSBub2RlIHR5cGUgUmVzdFByb3BlcnR5IGhhcyBiZWVuIHJlbmFtZWQgdG8gUmVzdEVsZW1lbnRcIik7XG4gIGFzc2VydChcIlJlc3RQcm9wZXJ0eVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0U3ByZWFkUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBjb25zb2xlLnRyYWNlKFwiVGhlIG5vZGUgdHlwZSBTcHJlYWRQcm9wZXJ0eSBoYXMgYmVlbiByZW5hbWVkIHRvIFNwcmVhZEVsZW1lbnRcIik7XG4gIGFzc2VydChcIlNwcmVhZFByb3BlcnR5XCIsIG5vZGUsIG9wdHMpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYnVpbGRlcjtcblxudmFyIF9jbG9uZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9jbG9uZVwiKSk7XG5cbnZhciBfZGVmaW5pdGlvbnMgPSByZXF1aXJlKFwiLi4vZGVmaW5pdGlvbnNcIik7XG5cbnZhciBfdmFsaWRhdGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL3ZhbGlkYXRlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gYnVpbGRlcih0eXBlLCAuLi5hcmdzKSB7XG4gIGNvbnN0IGtleXMgPSBfZGVmaW5pdGlvbnMuQlVJTERFUl9LRVlTW3R5cGVdO1xuICBjb25zdCBjb3VudEFyZ3MgPSBhcmdzLmxlbmd0aDtcblxuICBpZiAoY291bnRBcmdzID4ga2V5cy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dHlwZX06IFRvbyBtYW55IGFyZ3VtZW50cyBwYXNzZWQuIFJlY2VpdmVkICR7Y291bnRBcmdzfSBidXQgY2FuIHJlY2VpdmUgbm8gbW9yZSB0aGFuICR7a2V5cy5sZW5ndGh9YCk7XG4gIH1cblxuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGVcbiAgfTtcbiAgbGV0IGkgPSAwO1xuICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICBjb25zdCBmaWVsZCA9IF9kZWZpbml0aW9ucy5OT0RFX0ZJRUxEU1t0eXBlXVtrZXldO1xuICAgIGxldCBhcmc7XG4gICAgaWYgKGkgPCBjb3VudEFyZ3MpIGFyZyA9IGFyZ3NbaV07XG4gICAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkKSBhcmcgPSAoMCwgX2Nsb25lLmRlZmF1bHQpKGZpZWxkLmRlZmF1bHQpO1xuICAgIG5vZGVba2V5XSA9IGFyZztcbiAgICBpKys7XG4gIH0pO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG5vZGUpKSB7XG4gICAgKDAsIF92YWxpZGF0ZS5kZWZhdWx0KShub2RlLCBrZXksIG5vZGVba2V5XSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZUZsb3dVbmlvblR5cGU7XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4uL2dlbmVyYXRlZFwiKTtcblxudmFyIF9yZW1vdmVUeXBlRHVwbGljYXRlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL21vZGlmaWNhdGlvbnMvZmxvdy9yZW1vdmVUeXBlRHVwbGljYXRlc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNyZWF0ZUZsb3dVbmlvblR5cGUodHlwZXMpIHtcbiAgY29uc3QgZmxhdHRlbmVkID0gKDAsIF9yZW1vdmVUeXBlRHVwbGljYXRlcy5kZWZhdWx0KSh0eXBlcyk7XG5cbiAgaWYgKGZsYXR0ZW5lZC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZmxhdHRlbmVkWzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoMCwgX2dlbmVyYXRlZC51bmlvblR5cGVBbm5vdGF0aW9uKShmbGF0dGVuZWQpO1xuICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVUeXBlQW5ub3RhdGlvbkJhc2VkT25UeXBlb2Y7XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4uL2dlbmVyYXRlZFwiKTtcblxuZnVuY3Rpb24gY3JlYXRlVHlwZUFubm90YXRpb25CYXNlZE9uVHlwZW9mKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQuc3RyaW5nVHlwZUFubm90YXRpb24pKCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiAoMCwgX2dlbmVyYXRlZC5udW1iZXJUeXBlQW5ub3RhdGlvbikoKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuICgwLCBfZ2VuZXJhdGVkLnZvaWRUeXBlQW5ub3RhdGlvbikoKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiAoMCwgX2dlbmVyYXRlZC5ib29sZWFuVHlwZUFubm90YXRpb24pKCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuICgwLCBfZ2VuZXJhdGVkLmdlbmVyaWNUeXBlQW5ub3RhdGlvbikoKDAsIF9nZW5lcmF0ZWQuaWRlbnRpZmllcikoXCJGdW5jdGlvblwiKSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiAoMCwgX2dlbmVyYXRlZC5nZW5lcmljVHlwZUFubm90YXRpb24pKCgwLCBfZ2VuZXJhdGVkLmlkZW50aWZpZXIpKFwiT2JqZWN0XCIpKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcInN5bWJvbFwiKSB7XG4gICAgcmV0dXJuICgwLCBfZ2VuZXJhdGVkLmdlbmVyaWNUeXBlQW5ub3RhdGlvbikoKDAsIF9nZW5lcmF0ZWQuaWRlbnRpZmllcikoXCJTeW1ib2xcIikpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdHlwZW9mIHZhbHVlXCIpO1xuICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkFycmF5RXhwcmVzc2lvbiA9IGV4cG9ydHMuYXJyYXlFeHByZXNzaW9uID0gYXJyYXlFeHByZXNzaW9uO1xuZXhwb3J0cy5Bc3NpZ25tZW50RXhwcmVzc2lvbiA9IGV4cG9ydHMuYXNzaWdubWVudEV4cHJlc3Npb24gPSBhc3NpZ25tZW50RXhwcmVzc2lvbjtcbmV4cG9ydHMuQmluYXJ5RXhwcmVzc2lvbiA9IGV4cG9ydHMuYmluYXJ5RXhwcmVzc2lvbiA9IGJpbmFyeUV4cHJlc3Npb247XG5leHBvcnRzLkludGVycHJldGVyRGlyZWN0aXZlID0gZXhwb3J0cy5pbnRlcnByZXRlckRpcmVjdGl2ZSA9IGludGVycHJldGVyRGlyZWN0aXZlO1xuZXhwb3J0cy5EaXJlY3RpdmUgPSBleHBvcnRzLmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcbmV4cG9ydHMuRGlyZWN0aXZlTGl0ZXJhbCA9IGV4cG9ydHMuZGlyZWN0aXZlTGl0ZXJhbCA9IGRpcmVjdGl2ZUxpdGVyYWw7XG5leHBvcnRzLkJsb2NrU3RhdGVtZW50ID0gZXhwb3J0cy5ibG9ja1N0YXRlbWVudCA9IGJsb2NrU3RhdGVtZW50O1xuZXhwb3J0cy5CcmVha1N0YXRlbWVudCA9IGV4cG9ydHMuYnJlYWtTdGF0ZW1lbnQgPSBicmVha1N0YXRlbWVudDtcbmV4cG9ydHMuQ2FsbEV4cHJlc3Npb24gPSBleHBvcnRzLmNhbGxFeHByZXNzaW9uID0gY2FsbEV4cHJlc3Npb247XG5leHBvcnRzLkNhdGNoQ2xhdXNlID0gZXhwb3J0cy5jYXRjaENsYXVzZSA9IGNhdGNoQ2xhdXNlO1xuZXhwb3J0cy5Db25kaXRpb25hbEV4cHJlc3Npb24gPSBleHBvcnRzLmNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGNvbmRpdGlvbmFsRXhwcmVzc2lvbjtcbmV4cG9ydHMuQ29udGludWVTdGF0ZW1lbnQgPSBleHBvcnRzLmNvbnRpbnVlU3RhdGVtZW50ID0gY29udGludWVTdGF0ZW1lbnQ7XG5leHBvcnRzLkRlYnVnZ2VyU3RhdGVtZW50ID0gZXhwb3J0cy5kZWJ1Z2dlclN0YXRlbWVudCA9IGRlYnVnZ2VyU3RhdGVtZW50O1xuZXhwb3J0cy5Eb1doaWxlU3RhdGVtZW50ID0gZXhwb3J0cy5kb1doaWxlU3RhdGVtZW50ID0gZG9XaGlsZVN0YXRlbWVudDtcbmV4cG9ydHMuRW1wdHlTdGF0ZW1lbnQgPSBleHBvcnRzLmVtcHR5U3RhdGVtZW50ID0gZW1wdHlTdGF0ZW1lbnQ7XG5leHBvcnRzLkV4cHJlc3Npb25TdGF0ZW1lbnQgPSBleHBvcnRzLmV4cHJlc3Npb25TdGF0ZW1lbnQgPSBleHByZXNzaW9uU3RhdGVtZW50O1xuZXhwb3J0cy5GaWxlID0gZXhwb3J0cy5maWxlID0gZmlsZTtcbmV4cG9ydHMuRm9ySW5TdGF0ZW1lbnQgPSBleHBvcnRzLmZvckluU3RhdGVtZW50ID0gZm9ySW5TdGF0ZW1lbnQ7XG5leHBvcnRzLkZvclN0YXRlbWVudCA9IGV4cG9ydHMuZm9yU3RhdGVtZW50ID0gZm9yU3RhdGVtZW50O1xuZXhwb3J0cy5GdW5jdGlvbkRlY2xhcmF0aW9uID0gZXhwb3J0cy5mdW5jdGlvbkRlY2xhcmF0aW9uID0gZnVuY3Rpb25EZWNsYXJhdGlvbjtcbmV4cG9ydHMuRnVuY3Rpb25FeHByZXNzaW9uID0gZXhwb3J0cy5mdW5jdGlvbkV4cHJlc3Npb24gPSBmdW5jdGlvbkV4cHJlc3Npb247XG5leHBvcnRzLklkZW50aWZpZXIgPSBleHBvcnRzLmlkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xuZXhwb3J0cy5JZlN0YXRlbWVudCA9IGV4cG9ydHMuaWZTdGF0ZW1lbnQgPSBpZlN0YXRlbWVudDtcbmV4cG9ydHMuTGFiZWxlZFN0YXRlbWVudCA9IGV4cG9ydHMubGFiZWxlZFN0YXRlbWVudCA9IGxhYmVsZWRTdGF0ZW1lbnQ7XG5leHBvcnRzLlN0cmluZ0xpdGVyYWwgPSBleHBvcnRzLnN0cmluZ0xpdGVyYWwgPSBzdHJpbmdMaXRlcmFsO1xuZXhwb3J0cy5OdW1lcmljTGl0ZXJhbCA9IGV4cG9ydHMubnVtZXJpY0xpdGVyYWwgPSBudW1lcmljTGl0ZXJhbDtcbmV4cG9ydHMuTnVsbExpdGVyYWwgPSBleHBvcnRzLm51bGxMaXRlcmFsID0gbnVsbExpdGVyYWw7XG5leHBvcnRzLkJvb2xlYW5MaXRlcmFsID0gZXhwb3J0cy5ib29sZWFuTGl0ZXJhbCA9IGJvb2xlYW5MaXRlcmFsO1xuZXhwb3J0cy5SZWdFeHBMaXRlcmFsID0gZXhwb3J0cy5yZWdFeHBMaXRlcmFsID0gcmVnRXhwTGl0ZXJhbDtcbmV4cG9ydHMuTG9naWNhbEV4cHJlc3Npb24gPSBleHBvcnRzLmxvZ2ljYWxFeHByZXNzaW9uID0gbG9naWNhbEV4cHJlc3Npb247XG5leHBvcnRzLk1lbWJlckV4cHJlc3Npb24gPSBleHBvcnRzLm1lbWJlckV4cHJlc3Npb24gPSBtZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5OZXdFeHByZXNzaW9uID0gZXhwb3J0cy5uZXdFeHByZXNzaW9uID0gbmV3RXhwcmVzc2lvbjtcbmV4cG9ydHMuUHJvZ3JhbSA9IGV4cG9ydHMucHJvZ3JhbSA9IHByb2dyYW07XG5leHBvcnRzLk9iamVjdEV4cHJlc3Npb24gPSBleHBvcnRzLm9iamVjdEV4cHJlc3Npb24gPSBvYmplY3RFeHByZXNzaW9uO1xuZXhwb3J0cy5PYmplY3RNZXRob2QgPSBleHBvcnRzLm9iamVjdE1ldGhvZCA9IG9iamVjdE1ldGhvZDtcbmV4cG9ydHMuT2JqZWN0UHJvcGVydHkgPSBleHBvcnRzLm9iamVjdFByb3BlcnR5ID0gb2JqZWN0UHJvcGVydHk7XG5leHBvcnRzLlJlc3RFbGVtZW50ID0gZXhwb3J0cy5yZXN0RWxlbWVudCA9IHJlc3RFbGVtZW50O1xuZXhwb3J0cy5SZXR1cm5TdGF0ZW1lbnQgPSBleHBvcnRzLnJldHVyblN0YXRlbWVudCA9IHJldHVyblN0YXRlbWVudDtcbmV4cG9ydHMuU2VxdWVuY2VFeHByZXNzaW9uID0gZXhwb3J0cy5zZXF1ZW5jZUV4cHJlc3Npb24gPSBzZXF1ZW5jZUV4cHJlc3Npb247XG5leHBvcnRzLlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uID0gZXhwb3J0cy5wYXJlbnRoZXNpemVkRXhwcmVzc2lvbiA9IHBhcmVudGhlc2l6ZWRFeHByZXNzaW9uO1xuZXhwb3J0cy5Td2l0Y2hDYXNlID0gZXhwb3J0cy5zd2l0Y2hDYXNlID0gc3dpdGNoQ2FzZTtcbmV4cG9ydHMuU3dpdGNoU3RhdGVtZW50ID0gZXhwb3J0cy5zd2l0Y2hTdGF0ZW1lbnQgPSBzd2l0Y2hTdGF0ZW1lbnQ7XG5leHBvcnRzLlRoaXNFeHByZXNzaW9uID0gZXhwb3J0cy50aGlzRXhwcmVzc2lvbiA9IHRoaXNFeHByZXNzaW9uO1xuZXhwb3J0cy5UaHJvd1N0YXRlbWVudCA9IGV4cG9ydHMudGhyb3dTdGF0ZW1lbnQgPSB0aHJvd1N0YXRlbWVudDtcbmV4cG9ydHMuVHJ5U3RhdGVtZW50ID0gZXhwb3J0cy50cnlTdGF0ZW1lbnQgPSB0cnlTdGF0ZW1lbnQ7XG5leHBvcnRzLlVuYXJ5RXhwcmVzc2lvbiA9IGV4cG9ydHMudW5hcnlFeHByZXNzaW9uID0gdW5hcnlFeHByZXNzaW9uO1xuZXhwb3J0cy5VcGRhdGVFeHByZXNzaW9uID0gZXhwb3J0cy51cGRhdGVFeHByZXNzaW9uID0gdXBkYXRlRXhwcmVzc2lvbjtcbmV4cG9ydHMuVmFyaWFibGVEZWNsYXJhdGlvbiA9IGV4cG9ydHMudmFyaWFibGVEZWNsYXJhdGlvbiA9IHZhcmlhYmxlRGVjbGFyYXRpb247XG5leHBvcnRzLlZhcmlhYmxlRGVjbGFyYXRvciA9IGV4cG9ydHMudmFyaWFibGVEZWNsYXJhdG9yID0gdmFyaWFibGVEZWNsYXJhdG9yO1xuZXhwb3J0cy5XaGlsZVN0YXRlbWVudCA9IGV4cG9ydHMud2hpbGVTdGF0ZW1lbnQgPSB3aGlsZVN0YXRlbWVudDtcbmV4cG9ydHMuV2l0aFN0YXRlbWVudCA9IGV4cG9ydHMud2l0aFN0YXRlbWVudCA9IHdpdGhTdGF0ZW1lbnQ7XG5leHBvcnRzLkFzc2lnbm1lbnRQYXR0ZXJuID0gZXhwb3J0cy5hc3NpZ25tZW50UGF0dGVybiA9IGFzc2lnbm1lbnRQYXR0ZXJuO1xuZXhwb3J0cy5BcnJheVBhdHRlcm4gPSBleHBvcnRzLmFycmF5UGF0dGVybiA9IGFycmF5UGF0dGVybjtcbmV4cG9ydHMuQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSBleHBvcnRzLmFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gYXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XG5leHBvcnRzLkNsYXNzQm9keSA9IGV4cG9ydHMuY2xhc3NCb2R5ID0gY2xhc3NCb2R5O1xuZXhwb3J0cy5DbGFzc0V4cHJlc3Npb24gPSBleHBvcnRzLmNsYXNzRXhwcmVzc2lvbiA9IGNsYXNzRXhwcmVzc2lvbjtcbmV4cG9ydHMuQ2xhc3NEZWNsYXJhdGlvbiA9IGV4cG9ydHMuY2xhc3NEZWNsYXJhdGlvbiA9IGNsYXNzRGVjbGFyYXRpb247XG5leHBvcnRzLkV4cG9ydEFsbERlY2xhcmF0aW9uID0gZXhwb3J0cy5leHBvcnRBbGxEZWNsYXJhdGlvbiA9IGV4cG9ydEFsbERlY2xhcmF0aW9uO1xuZXhwb3J0cy5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24gPSBleHBvcnRzLmV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IGV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcbmV4cG9ydHMuRXhwb3J0TmFtZWREZWNsYXJhdGlvbiA9IGV4cG9ydHMuZXhwb3J0TmFtZWREZWNsYXJhdGlvbiA9IGV4cG9ydE5hbWVkRGVjbGFyYXRpb247XG5leHBvcnRzLkV4cG9ydFNwZWNpZmllciA9IGV4cG9ydHMuZXhwb3J0U3BlY2lmaWVyID0gZXhwb3J0U3BlY2lmaWVyO1xuZXhwb3J0cy5Gb3JPZlN0YXRlbWVudCA9IGV4cG9ydHMuZm9yT2ZTdGF0ZW1lbnQgPSBmb3JPZlN0YXRlbWVudDtcbmV4cG9ydHMuSW1wb3J0RGVjbGFyYXRpb24gPSBleHBvcnRzLmltcG9ydERlY2xhcmF0aW9uID0gaW1wb3J0RGVjbGFyYXRpb247XG5leHBvcnRzLkltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBleHBvcnRzLmltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBpbXBvcnREZWZhdWx0U3BlY2lmaWVyO1xuZXhwb3J0cy5JbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSBleHBvcnRzLmltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbmV4cG9ydHMuSW1wb3J0U3BlY2lmaWVyID0gZXhwb3J0cy5pbXBvcnRTcGVjaWZpZXIgPSBpbXBvcnRTcGVjaWZpZXI7XG5leHBvcnRzLk1ldGFQcm9wZXJ0eSA9IGV4cG9ydHMubWV0YVByb3BlcnR5ID0gbWV0YVByb3BlcnR5O1xuZXhwb3J0cy5DbGFzc01ldGhvZCA9IGV4cG9ydHMuY2xhc3NNZXRob2QgPSBjbGFzc01ldGhvZDtcbmV4cG9ydHMuT2JqZWN0UGF0dGVybiA9IGV4cG9ydHMub2JqZWN0UGF0dGVybiA9IG9iamVjdFBhdHRlcm47XG5leHBvcnRzLlNwcmVhZEVsZW1lbnQgPSBleHBvcnRzLnNwcmVhZEVsZW1lbnQgPSBzcHJlYWRFbGVtZW50O1xuZXhwb3J0cy5zdXBlciA9IGV4cG9ydHMuU3VwZXIgPSBfc3VwZXI7XG5leHBvcnRzLlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiA9IGV4cG9ydHMudGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uID0gdGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy5UZW1wbGF0ZUVsZW1lbnQgPSBleHBvcnRzLnRlbXBsYXRlRWxlbWVudCA9IHRlbXBsYXRlRWxlbWVudDtcbmV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsID0gZXhwb3J0cy50ZW1wbGF0ZUxpdGVyYWwgPSB0ZW1wbGF0ZUxpdGVyYWw7XG5leHBvcnRzLllpZWxkRXhwcmVzc2lvbiA9IGV4cG9ydHMueWllbGRFeHByZXNzaW9uID0geWllbGRFeHByZXNzaW9uO1xuZXhwb3J0cy5BbnlUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuYW55VHlwZUFubm90YXRpb24gPSBhbnlUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuQXJyYXlUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuYXJyYXlUeXBlQW5ub3RhdGlvbiA9IGFycmF5VHlwZUFubm90YXRpb247XG5leHBvcnRzLkJvb2xlYW5UeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuYm9vbGVhblR5cGVBbm5vdGF0aW9uID0gYm9vbGVhblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5Cb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5ib29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gYm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMubnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IG51bGxMaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLkNsYXNzSW1wbGVtZW50cyA9IGV4cG9ydHMuY2xhc3NJbXBsZW1lbnRzID0gY2xhc3NJbXBsZW1lbnRzO1xuZXhwb3J0cy5EZWNsYXJlQ2xhc3MgPSBleHBvcnRzLmRlY2xhcmVDbGFzcyA9IGRlY2xhcmVDbGFzcztcbmV4cG9ydHMuRGVjbGFyZUZ1bmN0aW9uID0gZXhwb3J0cy5kZWNsYXJlRnVuY3Rpb24gPSBkZWNsYXJlRnVuY3Rpb247XG5leHBvcnRzLkRlY2xhcmVJbnRlcmZhY2UgPSBleHBvcnRzLmRlY2xhcmVJbnRlcmZhY2UgPSBkZWNsYXJlSW50ZXJmYWNlO1xuZXhwb3J0cy5EZWNsYXJlTW9kdWxlID0gZXhwb3J0cy5kZWNsYXJlTW9kdWxlID0gZGVjbGFyZU1vZHVsZTtcbmV4cG9ydHMuRGVjbGFyZU1vZHVsZUV4cG9ydHMgPSBleHBvcnRzLmRlY2xhcmVNb2R1bGVFeHBvcnRzID0gZGVjbGFyZU1vZHVsZUV4cG9ydHM7XG5leHBvcnRzLkRlY2xhcmVUeXBlQWxpYXMgPSBleHBvcnRzLmRlY2xhcmVUeXBlQWxpYXMgPSBkZWNsYXJlVHlwZUFsaWFzO1xuZXhwb3J0cy5EZWNsYXJlT3BhcXVlVHlwZSA9IGV4cG9ydHMuZGVjbGFyZU9wYXF1ZVR5cGUgPSBkZWNsYXJlT3BhcXVlVHlwZTtcbmV4cG9ydHMuRGVjbGFyZVZhcmlhYmxlID0gZXhwb3J0cy5kZWNsYXJlVmFyaWFibGUgPSBkZWNsYXJlVmFyaWFibGU7XG5leHBvcnRzLkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvbiA9IGV4cG9ydHMuZGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uID0gZGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5EZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBleHBvcnRzLmRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvbiA9IGRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvbjtcbmV4cG9ydHMuRGVjbGFyZWRQcmVkaWNhdGUgPSBleHBvcnRzLmRlY2xhcmVkUHJlZGljYXRlID0gZGVjbGFyZWRQcmVkaWNhdGU7XG5leHBvcnRzLkV4aXN0c1R5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5leGlzdHNUeXBlQW5ub3RhdGlvbiA9IGV4aXN0c1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5GdW5jdGlvblR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5mdW5jdGlvblR5cGVBbm5vdGF0aW9uID0gZnVuY3Rpb25UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuRnVuY3Rpb25UeXBlUGFyYW0gPSBleHBvcnRzLmZ1bmN0aW9uVHlwZVBhcmFtID0gZnVuY3Rpb25UeXBlUGFyYW07XG5leHBvcnRzLkdlbmVyaWNUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuZ2VuZXJpY1R5cGVBbm5vdGF0aW9uID0gZ2VuZXJpY1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5JbmZlcnJlZFByZWRpY2F0ZSA9IGV4cG9ydHMuaW5mZXJyZWRQcmVkaWNhdGUgPSBpbmZlcnJlZFByZWRpY2F0ZTtcbmV4cG9ydHMuSW50ZXJmYWNlRXh0ZW5kcyA9IGV4cG9ydHMuaW50ZXJmYWNlRXh0ZW5kcyA9IGludGVyZmFjZUV4dGVuZHM7XG5leHBvcnRzLkludGVyZmFjZURlY2xhcmF0aW9uID0gZXhwb3J0cy5pbnRlcmZhY2VEZWNsYXJhdGlvbiA9IGludGVyZmFjZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5JbnRlcmZhY2VUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuaW50ZXJmYWNlVHlwZUFubm90YXRpb24gPSBpbnRlcmZhY2VUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24gPSBleHBvcnRzLmludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uID0gaW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLk1peGVkVHlwZUFubm90YXRpb24gPSBleHBvcnRzLm1peGVkVHlwZUFubm90YXRpb24gPSBtaXhlZFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5FbXB0eVR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5lbXB0eVR5cGVBbm5vdGF0aW9uID0gZW1wdHlUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuTnVsbGFibGVUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMubnVsbGFibGVUeXBlQW5ub3RhdGlvbiA9IG51bGxhYmxlVHlwZUFubm90YXRpb247XG5leHBvcnRzLk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMubnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gbnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5OdW1iZXJUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMubnVtYmVyVHlwZUFubm90YXRpb24gPSBudW1iZXJUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuT2JqZWN0VHlwZUFubm90YXRpb24gPSBleHBvcnRzLm9iamVjdFR5cGVBbm5vdGF0aW9uID0gb2JqZWN0VHlwZUFubm90YXRpb247XG5leHBvcnRzLk9iamVjdFR5cGVJbnRlcm5hbFNsb3QgPSBleHBvcnRzLm9iamVjdFR5cGVJbnRlcm5hbFNsb3QgPSBvYmplY3RUeXBlSW50ZXJuYWxTbG90O1xuZXhwb3J0cy5PYmplY3RUeXBlQ2FsbFByb3BlcnR5ID0gZXhwb3J0cy5vYmplY3RUeXBlQ2FsbFByb3BlcnR5ID0gb2JqZWN0VHlwZUNhbGxQcm9wZXJ0eTtcbmV4cG9ydHMuT2JqZWN0VHlwZUluZGV4ZXIgPSBleHBvcnRzLm9iamVjdFR5cGVJbmRleGVyID0gb2JqZWN0VHlwZUluZGV4ZXI7XG5leHBvcnRzLk9iamVjdFR5cGVQcm9wZXJ0eSA9IGV4cG9ydHMub2JqZWN0VHlwZVByb3BlcnR5ID0gb2JqZWN0VHlwZVByb3BlcnR5O1xuZXhwb3J0cy5PYmplY3RUeXBlU3ByZWFkUHJvcGVydHkgPSBleHBvcnRzLm9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eSA9IG9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eTtcbmV4cG9ydHMuT3BhcXVlVHlwZSA9IGV4cG9ydHMub3BhcXVlVHlwZSA9IG9wYXF1ZVR5cGU7XG5leHBvcnRzLlF1YWxpZmllZFR5cGVJZGVudGlmaWVyID0gZXhwb3J0cy5xdWFsaWZpZWRUeXBlSWRlbnRpZmllciA9IHF1YWxpZmllZFR5cGVJZGVudGlmaWVyO1xuZXhwb3J0cy5TdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb24gPSBleHBvcnRzLnN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IHN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuU3RyaW5nVHlwZUFubm90YXRpb24gPSBleHBvcnRzLnN0cmluZ1R5cGVBbm5vdGF0aW9uID0gc3RyaW5nVHlwZUFubm90YXRpb247XG5leHBvcnRzLlN5bWJvbFR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5zeW1ib2xUeXBlQW5ub3RhdGlvbiA9IHN5bWJvbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5UaGlzVHlwZUFubm90YXRpb24gPSBleHBvcnRzLnRoaXNUeXBlQW5ub3RhdGlvbiA9IHRoaXNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuVHVwbGVUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMudHVwbGVUeXBlQW5ub3RhdGlvbiA9IHR1cGxlVHlwZUFubm90YXRpb247XG5leHBvcnRzLlR5cGVvZlR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy50eXBlb2ZUeXBlQW5ub3RhdGlvbiA9IHR5cGVvZlR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5UeXBlQWxpYXMgPSBleHBvcnRzLnR5cGVBbGlhcyA9IHR5cGVBbGlhcztcbmV4cG9ydHMuVHlwZUFubm90YXRpb24gPSBleHBvcnRzLnR5cGVBbm5vdGF0aW9uID0gdHlwZUFubm90YXRpb247XG5leHBvcnRzLlR5cGVDYXN0RXhwcmVzc2lvbiA9IGV4cG9ydHMudHlwZUNhc3RFeHByZXNzaW9uID0gdHlwZUNhc3RFeHByZXNzaW9uO1xuZXhwb3J0cy5UeXBlUGFyYW1ldGVyID0gZXhwb3J0cy50eXBlUGFyYW1ldGVyID0gdHlwZVBhcmFtZXRlcjtcbmV4cG9ydHMuVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uID0gZXhwb3J0cy50eXBlUGFyYW1ldGVyRGVjbGFyYXRpb24gPSB0eXBlUGFyYW1ldGVyRGVjbGFyYXRpb247XG5leHBvcnRzLlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uID0gZXhwb3J0cy50eXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IHR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uO1xuZXhwb3J0cy5VbmlvblR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy51bmlvblR5cGVBbm5vdGF0aW9uID0gdW5pb25UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuVmFyaWFuY2UgPSBleHBvcnRzLnZhcmlhbmNlID0gdmFyaWFuY2U7XG5leHBvcnRzLlZvaWRUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMudm9pZFR5cGVBbm5vdGF0aW9uID0gdm9pZFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5FbnVtRGVjbGFyYXRpb24gPSBleHBvcnRzLmVudW1EZWNsYXJhdGlvbiA9IGVudW1EZWNsYXJhdGlvbjtcbmV4cG9ydHMuRW51bUJvb2xlYW5Cb2R5ID0gZXhwb3J0cy5lbnVtQm9vbGVhbkJvZHkgPSBlbnVtQm9vbGVhbkJvZHk7XG5leHBvcnRzLkVudW1OdW1iZXJCb2R5ID0gZXhwb3J0cy5lbnVtTnVtYmVyQm9keSA9IGVudW1OdW1iZXJCb2R5O1xuZXhwb3J0cy5FbnVtU3RyaW5nQm9keSA9IGV4cG9ydHMuZW51bVN0cmluZ0JvZHkgPSBlbnVtU3RyaW5nQm9keTtcbmV4cG9ydHMuRW51bVN5bWJvbEJvZHkgPSBleHBvcnRzLmVudW1TeW1ib2xCb2R5ID0gZW51bVN5bWJvbEJvZHk7XG5leHBvcnRzLkVudW1Cb29sZWFuTWVtYmVyID0gZXhwb3J0cy5lbnVtQm9vbGVhbk1lbWJlciA9IGVudW1Cb29sZWFuTWVtYmVyO1xuZXhwb3J0cy5FbnVtTnVtYmVyTWVtYmVyID0gZXhwb3J0cy5lbnVtTnVtYmVyTWVtYmVyID0gZW51bU51bWJlck1lbWJlcjtcbmV4cG9ydHMuRW51bVN0cmluZ01lbWJlciA9IGV4cG9ydHMuZW51bVN0cmluZ01lbWJlciA9IGVudW1TdHJpbmdNZW1iZXI7XG5leHBvcnRzLkVudW1EZWZhdWx0ZWRNZW1iZXIgPSBleHBvcnRzLmVudW1EZWZhdWx0ZWRNZW1iZXIgPSBlbnVtRGVmYXVsdGVkTWVtYmVyO1xuZXhwb3J0cy5qU1hBdHRyaWJ1dGUgPSBleHBvcnRzLkpTWEF0dHJpYnV0ZSA9IGV4cG9ydHMuanN4QXR0cmlidXRlID0ganN4QXR0cmlidXRlO1xuZXhwb3J0cy5qU1hDbG9zaW5nRWxlbWVudCA9IGV4cG9ydHMuSlNYQ2xvc2luZ0VsZW1lbnQgPSBleHBvcnRzLmpzeENsb3NpbmdFbGVtZW50ID0ganN4Q2xvc2luZ0VsZW1lbnQ7XG5leHBvcnRzLmpTWEVsZW1lbnQgPSBleHBvcnRzLkpTWEVsZW1lbnQgPSBleHBvcnRzLmpzeEVsZW1lbnQgPSBqc3hFbGVtZW50O1xuZXhwb3J0cy5qU1hFbXB0eUV4cHJlc3Npb24gPSBleHBvcnRzLkpTWEVtcHR5RXhwcmVzc2lvbiA9IGV4cG9ydHMuanN4RW1wdHlFeHByZXNzaW9uID0ganN4RW1wdHlFeHByZXNzaW9uO1xuZXhwb3J0cy5qU1hFeHByZXNzaW9uQ29udGFpbmVyID0gZXhwb3J0cy5KU1hFeHByZXNzaW9uQ29udGFpbmVyID0gZXhwb3J0cy5qc3hFeHByZXNzaW9uQ29udGFpbmVyID0ganN4RXhwcmVzc2lvbkNvbnRhaW5lcjtcbmV4cG9ydHMualNYU3ByZWFkQ2hpbGQgPSBleHBvcnRzLkpTWFNwcmVhZENoaWxkID0gZXhwb3J0cy5qc3hTcHJlYWRDaGlsZCA9IGpzeFNwcmVhZENoaWxkO1xuZXhwb3J0cy5qU1hJZGVudGlmaWVyID0gZXhwb3J0cy5KU1hJZGVudGlmaWVyID0gZXhwb3J0cy5qc3hJZGVudGlmaWVyID0ganN4SWRlbnRpZmllcjtcbmV4cG9ydHMualNYTWVtYmVyRXhwcmVzc2lvbiA9IGV4cG9ydHMuSlNYTWVtYmVyRXhwcmVzc2lvbiA9IGV4cG9ydHMuanN4TWVtYmVyRXhwcmVzc2lvbiA9IGpzeE1lbWJlckV4cHJlc3Npb247XG5leHBvcnRzLmpTWE5hbWVzcGFjZWROYW1lID0gZXhwb3J0cy5KU1hOYW1lc3BhY2VkTmFtZSA9IGV4cG9ydHMuanN4TmFtZXNwYWNlZE5hbWUgPSBqc3hOYW1lc3BhY2VkTmFtZTtcbmV4cG9ydHMualNYT3BlbmluZ0VsZW1lbnQgPSBleHBvcnRzLkpTWE9wZW5pbmdFbGVtZW50ID0gZXhwb3J0cy5qc3hPcGVuaW5nRWxlbWVudCA9IGpzeE9wZW5pbmdFbGVtZW50O1xuZXhwb3J0cy5qU1hTcHJlYWRBdHRyaWJ1dGUgPSBleHBvcnRzLkpTWFNwcmVhZEF0dHJpYnV0ZSA9IGV4cG9ydHMuanN4U3ByZWFkQXR0cmlidXRlID0ganN4U3ByZWFkQXR0cmlidXRlO1xuZXhwb3J0cy5qU1hUZXh0ID0gZXhwb3J0cy5KU1hUZXh0ID0gZXhwb3J0cy5qc3hUZXh0ID0ganN4VGV4dDtcbmV4cG9ydHMualNYRnJhZ21lbnQgPSBleHBvcnRzLkpTWEZyYWdtZW50ID0gZXhwb3J0cy5qc3hGcmFnbWVudCA9IGpzeEZyYWdtZW50O1xuZXhwb3J0cy5qU1hPcGVuaW5nRnJhZ21lbnQgPSBleHBvcnRzLkpTWE9wZW5pbmdGcmFnbWVudCA9IGV4cG9ydHMuanN4T3BlbmluZ0ZyYWdtZW50ID0ganN4T3BlbmluZ0ZyYWdtZW50O1xuZXhwb3J0cy5qU1hDbG9zaW5nRnJhZ21lbnQgPSBleHBvcnRzLkpTWENsb3NpbmdGcmFnbWVudCA9IGV4cG9ydHMuanN4Q2xvc2luZ0ZyYWdtZW50ID0ganN4Q2xvc2luZ0ZyYWdtZW50O1xuZXhwb3J0cy5Ob29wID0gZXhwb3J0cy5ub29wID0gbm9vcDtcbmV4cG9ydHMuUGxhY2Vob2xkZXIgPSBleHBvcnRzLnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG5leHBvcnRzLlY4SW50cmluc2ljSWRlbnRpZmllciA9IGV4cG9ydHMudjhJbnRyaW5zaWNJZGVudGlmaWVyID0gdjhJbnRyaW5zaWNJZGVudGlmaWVyO1xuZXhwb3J0cy5Bcmd1bWVudFBsYWNlaG9sZGVyID0gZXhwb3J0cy5hcmd1bWVudFBsYWNlaG9sZGVyID0gYXJndW1lbnRQbGFjZWhvbGRlcjtcbmV4cG9ydHMuQXdhaXRFeHByZXNzaW9uID0gZXhwb3J0cy5hd2FpdEV4cHJlc3Npb24gPSBhd2FpdEV4cHJlc3Npb247XG5leHBvcnRzLkJpbmRFeHByZXNzaW9uID0gZXhwb3J0cy5iaW5kRXhwcmVzc2lvbiA9IGJpbmRFeHByZXNzaW9uO1xuZXhwb3J0cy5DbGFzc1Byb3BlcnR5ID0gZXhwb3J0cy5jbGFzc1Byb3BlcnR5ID0gY2xhc3NQcm9wZXJ0eTtcbmV4cG9ydHMuT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uID0gZXhwb3J0cy5vcHRpb25hbE1lbWJlckV4cHJlc3Npb24gPSBvcHRpb25hbE1lbWJlckV4cHJlc3Npb247XG5leHBvcnRzLlBpcGVsaW5lVG9waWNFeHByZXNzaW9uID0gZXhwb3J0cy5waXBlbGluZVRvcGljRXhwcmVzc2lvbiA9IHBpcGVsaW5lVG9waWNFeHByZXNzaW9uO1xuZXhwb3J0cy5QaXBlbGluZUJhcmVGdW5jdGlvbiA9IGV4cG9ydHMucGlwZWxpbmVCYXJlRnVuY3Rpb24gPSBwaXBlbGluZUJhcmVGdW5jdGlvbjtcbmV4cG9ydHMuUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2UgPSBleHBvcnRzLnBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlID0gcGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2U7XG5leHBvcnRzLk9wdGlvbmFsQ2FsbEV4cHJlc3Npb24gPSBleHBvcnRzLm9wdGlvbmFsQ2FsbEV4cHJlc3Npb24gPSBvcHRpb25hbENhbGxFeHByZXNzaW9uO1xuZXhwb3J0cy5DbGFzc1ByaXZhdGVQcm9wZXJ0eSA9IGV4cG9ydHMuY2xhc3NQcml2YXRlUHJvcGVydHkgPSBjbGFzc1ByaXZhdGVQcm9wZXJ0eTtcbmV4cG9ydHMuQ2xhc3NQcml2YXRlTWV0aG9kID0gZXhwb3J0cy5jbGFzc1ByaXZhdGVNZXRob2QgPSBjbGFzc1ByaXZhdGVNZXRob2Q7XG5leHBvcnRzLmltcG9ydCA9IGV4cG9ydHMuSW1wb3J0ID0gX2ltcG9ydDtcbmV4cG9ydHMuSW1wb3J0QXR0cmlidXRlID0gZXhwb3J0cy5pbXBvcnRBdHRyaWJ1dGUgPSBpbXBvcnRBdHRyaWJ1dGU7XG5leHBvcnRzLkRlY29yYXRvciA9IGV4cG9ydHMuZGVjb3JhdG9yID0gZGVjb3JhdG9yO1xuZXhwb3J0cy5Eb0V4cHJlc3Npb24gPSBleHBvcnRzLmRvRXhwcmVzc2lvbiA9IGRvRXhwcmVzc2lvbjtcbmV4cG9ydHMuRXhwb3J0RGVmYXVsdFNwZWNpZmllciA9IGV4cG9ydHMuZXhwb3J0RGVmYXVsdFNwZWNpZmllciA9IGV4cG9ydERlZmF1bHRTcGVjaWZpZXI7XG5leHBvcnRzLkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGV4cG9ydHMuZXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gZXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xuZXhwb3J0cy5Qcml2YXRlTmFtZSA9IGV4cG9ydHMucHJpdmF0ZU5hbWUgPSBwcml2YXRlTmFtZTtcbmV4cG9ydHMuQmlnSW50TGl0ZXJhbCA9IGV4cG9ydHMuYmlnSW50TGl0ZXJhbCA9IGJpZ0ludExpdGVyYWw7XG5leHBvcnRzLlJlY29yZEV4cHJlc3Npb24gPSBleHBvcnRzLnJlY29yZEV4cHJlc3Npb24gPSByZWNvcmRFeHByZXNzaW9uO1xuZXhwb3J0cy5UdXBsZUV4cHJlc3Npb24gPSBleHBvcnRzLnR1cGxlRXhwcmVzc2lvbiA9IHR1cGxlRXhwcmVzc2lvbjtcbmV4cG9ydHMudFNQYXJhbWV0ZXJQcm9wZXJ0eSA9IGV4cG9ydHMuVFNQYXJhbWV0ZXJQcm9wZXJ0eSA9IGV4cG9ydHMudHNQYXJhbWV0ZXJQcm9wZXJ0eSA9IHRzUGFyYW1ldGVyUHJvcGVydHk7XG5leHBvcnRzLnRTRGVjbGFyZUZ1bmN0aW9uID0gZXhwb3J0cy5UU0RlY2xhcmVGdW5jdGlvbiA9IGV4cG9ydHMudHNEZWNsYXJlRnVuY3Rpb24gPSB0c0RlY2xhcmVGdW5jdGlvbjtcbmV4cG9ydHMudFNEZWNsYXJlTWV0aG9kID0gZXhwb3J0cy5UU0RlY2xhcmVNZXRob2QgPSBleHBvcnRzLnRzRGVjbGFyZU1ldGhvZCA9IHRzRGVjbGFyZU1ldGhvZDtcbmV4cG9ydHMudFNRdWFsaWZpZWROYW1lID0gZXhwb3J0cy5UU1F1YWxpZmllZE5hbWUgPSBleHBvcnRzLnRzUXVhbGlmaWVkTmFtZSA9IHRzUXVhbGlmaWVkTmFtZTtcbmV4cG9ydHMudFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb24gPSBleHBvcnRzLlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uID0gZXhwb3J0cy50c0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbiA9IHRzQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uO1xuZXhwb3J0cy50U0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uID0gZXhwb3J0cy5UU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uID0gZXhwb3J0cy50c0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uID0gdHNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbjtcbmV4cG9ydHMudFNQcm9wZXJ0eVNpZ25hdHVyZSA9IGV4cG9ydHMuVFNQcm9wZXJ0eVNpZ25hdHVyZSA9IGV4cG9ydHMudHNQcm9wZXJ0eVNpZ25hdHVyZSA9IHRzUHJvcGVydHlTaWduYXR1cmU7XG5leHBvcnRzLnRTTWV0aG9kU2lnbmF0dXJlID0gZXhwb3J0cy5UU01ldGhvZFNpZ25hdHVyZSA9IGV4cG9ydHMudHNNZXRob2RTaWduYXR1cmUgPSB0c01ldGhvZFNpZ25hdHVyZTtcbmV4cG9ydHMudFNJbmRleFNpZ25hdHVyZSA9IGV4cG9ydHMuVFNJbmRleFNpZ25hdHVyZSA9IGV4cG9ydHMudHNJbmRleFNpZ25hdHVyZSA9IHRzSW5kZXhTaWduYXR1cmU7XG5leHBvcnRzLnRTQW55S2V5d29yZCA9IGV4cG9ydHMuVFNBbnlLZXl3b3JkID0gZXhwb3J0cy50c0FueUtleXdvcmQgPSB0c0FueUtleXdvcmQ7XG5leHBvcnRzLnRTQm9vbGVhbktleXdvcmQgPSBleHBvcnRzLlRTQm9vbGVhbktleXdvcmQgPSBleHBvcnRzLnRzQm9vbGVhbktleXdvcmQgPSB0c0Jvb2xlYW5LZXl3b3JkO1xuZXhwb3J0cy50U0JpZ0ludEtleXdvcmQgPSBleHBvcnRzLlRTQmlnSW50S2V5d29yZCA9IGV4cG9ydHMudHNCaWdJbnRLZXl3b3JkID0gdHNCaWdJbnRLZXl3b3JkO1xuZXhwb3J0cy50U05ldmVyS2V5d29yZCA9IGV4cG9ydHMuVFNOZXZlcktleXdvcmQgPSBleHBvcnRzLnRzTmV2ZXJLZXl3b3JkID0gdHNOZXZlcktleXdvcmQ7XG5leHBvcnRzLnRTTnVsbEtleXdvcmQgPSBleHBvcnRzLlRTTnVsbEtleXdvcmQgPSBleHBvcnRzLnRzTnVsbEtleXdvcmQgPSB0c051bGxLZXl3b3JkO1xuZXhwb3J0cy50U051bWJlcktleXdvcmQgPSBleHBvcnRzLlRTTnVtYmVyS2V5d29yZCA9IGV4cG9ydHMudHNOdW1iZXJLZXl3b3JkID0gdHNOdW1iZXJLZXl3b3JkO1xuZXhwb3J0cy50U09iamVjdEtleXdvcmQgPSBleHBvcnRzLlRTT2JqZWN0S2V5d29yZCA9IGV4cG9ydHMudHNPYmplY3RLZXl3b3JkID0gdHNPYmplY3RLZXl3b3JkO1xuZXhwb3J0cy50U1N0cmluZ0tleXdvcmQgPSBleHBvcnRzLlRTU3RyaW5nS2V5d29yZCA9IGV4cG9ydHMudHNTdHJpbmdLZXl3b3JkID0gdHNTdHJpbmdLZXl3b3JkO1xuZXhwb3J0cy50U1N5bWJvbEtleXdvcmQgPSBleHBvcnRzLlRTU3ltYm9sS2V5d29yZCA9IGV4cG9ydHMudHNTeW1ib2xLZXl3b3JkID0gdHNTeW1ib2xLZXl3b3JkO1xuZXhwb3J0cy50U1VuZGVmaW5lZEtleXdvcmQgPSBleHBvcnRzLlRTVW5kZWZpbmVkS2V5d29yZCA9IGV4cG9ydHMudHNVbmRlZmluZWRLZXl3b3JkID0gdHNVbmRlZmluZWRLZXl3b3JkO1xuZXhwb3J0cy50U1Vua25vd25LZXl3b3JkID0gZXhwb3J0cy5UU1Vua25vd25LZXl3b3JkID0gZXhwb3J0cy50c1Vua25vd25LZXl3b3JkID0gdHNVbmtub3duS2V5d29yZDtcbmV4cG9ydHMudFNWb2lkS2V5d29yZCA9IGV4cG9ydHMuVFNWb2lkS2V5d29yZCA9IGV4cG9ydHMudHNWb2lkS2V5d29yZCA9IHRzVm9pZEtleXdvcmQ7XG5leHBvcnRzLnRTVGhpc1R5cGUgPSBleHBvcnRzLlRTVGhpc1R5cGUgPSBleHBvcnRzLnRzVGhpc1R5cGUgPSB0c1RoaXNUeXBlO1xuZXhwb3J0cy50U0Z1bmN0aW9uVHlwZSA9IGV4cG9ydHMuVFNGdW5jdGlvblR5cGUgPSBleHBvcnRzLnRzRnVuY3Rpb25UeXBlID0gdHNGdW5jdGlvblR5cGU7XG5leHBvcnRzLnRTQ29uc3RydWN0b3JUeXBlID0gZXhwb3J0cy5UU0NvbnN0cnVjdG9yVHlwZSA9IGV4cG9ydHMudHNDb25zdHJ1Y3RvclR5cGUgPSB0c0NvbnN0cnVjdG9yVHlwZTtcbmV4cG9ydHMudFNUeXBlUmVmZXJlbmNlID0gZXhwb3J0cy5UU1R5cGVSZWZlcmVuY2UgPSBleHBvcnRzLnRzVHlwZVJlZmVyZW5jZSA9IHRzVHlwZVJlZmVyZW5jZTtcbmV4cG9ydHMudFNUeXBlUHJlZGljYXRlID0gZXhwb3J0cy5UU1R5cGVQcmVkaWNhdGUgPSBleHBvcnRzLnRzVHlwZVByZWRpY2F0ZSA9IHRzVHlwZVByZWRpY2F0ZTtcbmV4cG9ydHMudFNUeXBlUXVlcnkgPSBleHBvcnRzLlRTVHlwZVF1ZXJ5ID0gZXhwb3J0cy50c1R5cGVRdWVyeSA9IHRzVHlwZVF1ZXJ5O1xuZXhwb3J0cy50U1R5cGVMaXRlcmFsID0gZXhwb3J0cy5UU1R5cGVMaXRlcmFsID0gZXhwb3J0cy50c1R5cGVMaXRlcmFsID0gdHNUeXBlTGl0ZXJhbDtcbmV4cG9ydHMudFNBcnJheVR5cGUgPSBleHBvcnRzLlRTQXJyYXlUeXBlID0gZXhwb3J0cy50c0FycmF5VHlwZSA9IHRzQXJyYXlUeXBlO1xuZXhwb3J0cy50U1R1cGxlVHlwZSA9IGV4cG9ydHMuVFNUdXBsZVR5cGUgPSBleHBvcnRzLnRzVHVwbGVUeXBlID0gdHNUdXBsZVR5cGU7XG5leHBvcnRzLnRTT3B0aW9uYWxUeXBlID0gZXhwb3J0cy5UU09wdGlvbmFsVHlwZSA9IGV4cG9ydHMudHNPcHRpb25hbFR5cGUgPSB0c09wdGlvbmFsVHlwZTtcbmV4cG9ydHMudFNSZXN0VHlwZSA9IGV4cG9ydHMuVFNSZXN0VHlwZSA9IGV4cG9ydHMudHNSZXN0VHlwZSA9IHRzUmVzdFR5cGU7XG5leHBvcnRzLnRTVW5pb25UeXBlID0gZXhwb3J0cy5UU1VuaW9uVHlwZSA9IGV4cG9ydHMudHNVbmlvblR5cGUgPSB0c1VuaW9uVHlwZTtcbmV4cG9ydHMudFNJbnRlcnNlY3Rpb25UeXBlID0gZXhwb3J0cy5UU0ludGVyc2VjdGlvblR5cGUgPSBleHBvcnRzLnRzSW50ZXJzZWN0aW9uVHlwZSA9IHRzSW50ZXJzZWN0aW9uVHlwZTtcbmV4cG9ydHMudFNDb25kaXRpb25hbFR5cGUgPSBleHBvcnRzLlRTQ29uZGl0aW9uYWxUeXBlID0gZXhwb3J0cy50c0NvbmRpdGlvbmFsVHlwZSA9IHRzQ29uZGl0aW9uYWxUeXBlO1xuZXhwb3J0cy50U0luZmVyVHlwZSA9IGV4cG9ydHMuVFNJbmZlclR5cGUgPSBleHBvcnRzLnRzSW5mZXJUeXBlID0gdHNJbmZlclR5cGU7XG5leHBvcnRzLnRTUGFyZW50aGVzaXplZFR5cGUgPSBleHBvcnRzLlRTUGFyZW50aGVzaXplZFR5cGUgPSBleHBvcnRzLnRzUGFyZW50aGVzaXplZFR5cGUgPSB0c1BhcmVudGhlc2l6ZWRUeXBlO1xuZXhwb3J0cy50U1R5cGVPcGVyYXRvciA9IGV4cG9ydHMuVFNUeXBlT3BlcmF0b3IgPSBleHBvcnRzLnRzVHlwZU9wZXJhdG9yID0gdHNUeXBlT3BlcmF0b3I7XG5leHBvcnRzLnRTSW5kZXhlZEFjY2Vzc1R5cGUgPSBleHBvcnRzLlRTSW5kZXhlZEFjY2Vzc1R5cGUgPSBleHBvcnRzLnRzSW5kZXhlZEFjY2Vzc1R5cGUgPSB0c0luZGV4ZWRBY2Nlc3NUeXBlO1xuZXhwb3J0cy50U01hcHBlZFR5cGUgPSBleHBvcnRzLlRTTWFwcGVkVHlwZSA9IGV4cG9ydHMudHNNYXBwZWRUeXBlID0gdHNNYXBwZWRUeXBlO1xuZXhwb3J0cy50U0xpdGVyYWxUeXBlID0gZXhwb3J0cy5UU0xpdGVyYWxUeXBlID0gZXhwb3J0cy50c0xpdGVyYWxUeXBlID0gdHNMaXRlcmFsVHlwZTtcbmV4cG9ydHMudFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHMgPSBleHBvcnRzLlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzID0gZXhwb3J0cy50c0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cyA9IHRzRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzO1xuZXhwb3J0cy50U0ludGVyZmFjZURlY2xhcmF0aW9uID0gZXhwb3J0cy5UU0ludGVyZmFjZURlY2xhcmF0aW9uID0gZXhwb3J0cy50c0ludGVyZmFjZURlY2xhcmF0aW9uID0gdHNJbnRlcmZhY2VEZWNsYXJhdGlvbjtcbmV4cG9ydHMudFNJbnRlcmZhY2VCb2R5ID0gZXhwb3J0cy5UU0ludGVyZmFjZUJvZHkgPSBleHBvcnRzLnRzSW50ZXJmYWNlQm9keSA9IHRzSW50ZXJmYWNlQm9keTtcbmV4cG9ydHMudFNUeXBlQWxpYXNEZWNsYXJhdGlvbiA9IGV4cG9ydHMuVFNUeXBlQWxpYXNEZWNsYXJhdGlvbiA9IGV4cG9ydHMudHNUeXBlQWxpYXNEZWNsYXJhdGlvbiA9IHRzVHlwZUFsaWFzRGVjbGFyYXRpb247XG5leHBvcnRzLnRTQXNFeHByZXNzaW9uID0gZXhwb3J0cy5UU0FzRXhwcmVzc2lvbiA9IGV4cG9ydHMudHNBc0V4cHJlc3Npb24gPSB0c0FzRXhwcmVzc2lvbjtcbmV4cG9ydHMudFNUeXBlQXNzZXJ0aW9uID0gZXhwb3J0cy5UU1R5cGVBc3NlcnRpb24gPSBleHBvcnRzLnRzVHlwZUFzc2VydGlvbiA9IHRzVHlwZUFzc2VydGlvbjtcbmV4cG9ydHMudFNFbnVtRGVjbGFyYXRpb24gPSBleHBvcnRzLlRTRW51bURlY2xhcmF0aW9uID0gZXhwb3J0cy50c0VudW1EZWNsYXJhdGlvbiA9IHRzRW51bURlY2xhcmF0aW9uO1xuZXhwb3J0cy50U0VudW1NZW1iZXIgPSBleHBvcnRzLlRTRW51bU1lbWJlciA9IGV4cG9ydHMudHNFbnVtTWVtYmVyID0gdHNFbnVtTWVtYmVyO1xuZXhwb3J0cy50U01vZHVsZURlY2xhcmF0aW9uID0gZXhwb3J0cy5UU01vZHVsZURlY2xhcmF0aW9uID0gZXhwb3J0cy50c01vZHVsZURlY2xhcmF0aW9uID0gdHNNb2R1bGVEZWNsYXJhdGlvbjtcbmV4cG9ydHMudFNNb2R1bGVCbG9jayA9IGV4cG9ydHMuVFNNb2R1bGVCbG9jayA9IGV4cG9ydHMudHNNb2R1bGVCbG9jayA9IHRzTW9kdWxlQmxvY2s7XG5leHBvcnRzLnRTSW1wb3J0VHlwZSA9IGV4cG9ydHMuVFNJbXBvcnRUeXBlID0gZXhwb3J0cy50c0ltcG9ydFR5cGUgPSB0c0ltcG9ydFR5cGU7XG5leHBvcnRzLnRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24gPSBleHBvcnRzLlRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24gPSBleHBvcnRzLnRzSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24gPSB0c0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uO1xuZXhwb3J0cy50U0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlID0gZXhwb3J0cy5UU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlID0gZXhwb3J0cy50c0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlID0gdHNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZTtcbmV4cG9ydHMudFNOb25OdWxsRXhwcmVzc2lvbiA9IGV4cG9ydHMuVFNOb25OdWxsRXhwcmVzc2lvbiA9IGV4cG9ydHMudHNOb25OdWxsRXhwcmVzc2lvbiA9IHRzTm9uTnVsbEV4cHJlc3Npb247XG5leHBvcnRzLnRTRXhwb3J0QXNzaWdubWVudCA9IGV4cG9ydHMuVFNFeHBvcnRBc3NpZ25tZW50ID0gZXhwb3J0cy50c0V4cG9ydEFzc2lnbm1lbnQgPSB0c0V4cG9ydEFzc2lnbm1lbnQ7XG5leHBvcnRzLnRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24gPSBleHBvcnRzLlRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24gPSBleHBvcnRzLnRzTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24gPSB0c05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy50U1R5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5UU1R5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy50c1R5cGVBbm5vdGF0aW9uID0gdHNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMudFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IGV4cG9ydHMuVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IGV4cG9ydHMudHNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IHRzVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb247XG5leHBvcnRzLnRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uID0gZXhwb3J0cy5UU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGV4cG9ydHMudHNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24gPSB0c1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbjtcbmV4cG9ydHMudFNUeXBlUGFyYW1ldGVyID0gZXhwb3J0cy5UU1R5cGVQYXJhbWV0ZXIgPSBleHBvcnRzLnRzVHlwZVBhcmFtZXRlciA9IHRzVHlwZVBhcmFtZXRlcjtcbmV4cG9ydHMubnVtYmVyTGl0ZXJhbCA9IGV4cG9ydHMuTnVtYmVyTGl0ZXJhbCA9IE51bWJlckxpdGVyYWw7XG5leHBvcnRzLnJlZ2V4TGl0ZXJhbCA9IGV4cG9ydHMuUmVnZXhMaXRlcmFsID0gUmVnZXhMaXRlcmFsO1xuZXhwb3J0cy5yZXN0UHJvcGVydHkgPSBleHBvcnRzLlJlc3RQcm9wZXJ0eSA9IFJlc3RQcm9wZXJ0eTtcbmV4cG9ydHMuc3ByZWFkUHJvcGVydHkgPSBleHBvcnRzLlNwcmVhZFByb3BlcnR5ID0gU3ByZWFkUHJvcGVydHk7XG5cbnZhciBfYnVpbGRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2J1aWxkZXJcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBhcnJheUV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQXJyYXlFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25tZW50RXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gYmluYXJ5RXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJCaW5hcnlFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnByZXRlckRpcmVjdGl2ZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJJbnRlcnByZXRlckRpcmVjdGl2ZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZGlyZWN0aXZlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRpcmVjdGl2ZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZGlyZWN0aXZlTGl0ZXJhbCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJEaXJlY3RpdmVMaXRlcmFsXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBibG9ja1N0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJCbG9ja1N0YXRlbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gYnJlYWtTdGF0ZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQnJlYWtTdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNhbGxFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkNhbGxFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBjYXRjaENsYXVzZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJDYXRjaENsYXVzZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gY29uZGl0aW9uYWxFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gY29udGludWVTdGF0ZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQ29udGludWVTdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGRlYnVnZ2VyU3RhdGVtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRlYnVnZ2VyU3RhdGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBkb1doaWxlU3RhdGVtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRvV2hpbGVTdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGVtcHR5U3RhdGVtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkVtcHR5U3RhdGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBleHByZXNzaW9uU3RhdGVtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGZpbGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRmlsZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZm9ySW5TdGF0ZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRm9ySW5TdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGZvclN0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJGb3JTdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVjbGFyYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZnVuY3Rpb25FeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpZmllciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJJZGVudGlmaWVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBpZlN0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJJZlN0YXRlbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gbGFiZWxlZFN0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJMYWJlbGVkU3RhdGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdMaXRlcmFsKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlN0cmluZ0xpdGVyYWxcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG51bWVyaWNMaXRlcmFsKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk51bWVyaWNMaXRlcmFsXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBudWxsTGl0ZXJhbCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJOdWxsTGl0ZXJhbFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gYm9vbGVhbkxpdGVyYWwoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQm9vbGVhbkxpdGVyYWxcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHJlZ0V4cExpdGVyYWwoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiUmVnRXhwTGl0ZXJhbFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gbG9naWNhbEV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiTG9naWNhbEV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG1lbWJlckV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiTWVtYmVyRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gbmV3RXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJOZXdFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBwcm9ncmFtKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlByb2dyYW1cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG9iamVjdEV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiT2JqZWN0RXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0TWV0aG9kKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk9iamVjdE1ldGhvZFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0UHJvcGVydHkoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiT2JqZWN0UHJvcGVydHlcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHJlc3RFbGVtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlJlc3RFbGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiByZXR1cm5TdGF0ZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiUmV0dXJuU3RhdGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBzZXF1ZW5jZUV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiU2VxdWVuY2VFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnRoZXNpemVkRXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gc3dpdGNoQ2FzZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJTd2l0Y2hDYXNlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBzd2l0Y2hTdGF0ZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiU3dpdGNoU3RhdGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0aGlzRXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUaGlzRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dTdGF0ZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVGhyb3dTdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRyeVN0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUcnlTdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHVuYXJ5RXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJVbmFyeUV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVXBkYXRlRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdmFyaWFibGVEZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB2YXJpYWJsZURlY2xhcmF0b3IoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVmFyaWFibGVEZWNsYXJhdG9yXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB3aGlsZVN0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJXaGlsZVN0YXRlbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gd2l0aFN0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJXaXRoU3RhdGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25tZW50UGF0dGVybiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJBc3NpZ25tZW50UGF0dGVyblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlQYXR0ZXJuKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkFycmF5UGF0dGVyblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gYXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzQm9keSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJDbGFzc0JvZHlcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzRXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJDbGFzc0V4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzRGVjbGFyYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQ2xhc3NEZWNsYXJhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZXhwb3J0QWxsRGVjbGFyYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGV4cG9ydE5hbWVkRGVjbGFyYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZXhwb3J0U3BlY2lmaWVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkV4cG9ydFNwZWNpZmllclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZm9yT2ZTdGF0ZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRm9yT2ZTdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGltcG9ydERlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkltcG9ydERlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBpbXBvcnREZWZhdWx0U3BlY2lmaWVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGltcG9ydE5hbWVzcGFjZVNwZWNpZmllciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGltcG9ydFNwZWNpZmllciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJJbXBvcnRTcGVjaWZpZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG1ldGFQcm9wZXJ0eSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJNZXRhUHJvcGVydHlcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzTWV0aG9kKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkNsYXNzTWV0aG9kXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBvYmplY3RQYXR0ZXJuKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk9iamVjdFBhdHRlcm5cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHNwcmVhZEVsZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiU3ByZWFkRWxlbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gX3N1cGVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlN1cGVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0YWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0ZW1wbGF0ZUVsZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVGVtcGxhdGVFbGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0ZW1wbGF0ZUxpdGVyYWwoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVGVtcGxhdGVMaXRlcmFsXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB5aWVsZEV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiWWllbGRFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBhbnlUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJBbnlUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJBcnJheVR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBib29sZWFuVHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQm9vbGVhblR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBib29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG51bGxMaXRlcmFsVHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NJbXBsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkNsYXNzSW1wbGVtZW50c1wiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZGVjbGFyZUNsYXNzKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRlY2xhcmVDbGFzc1wiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZGVjbGFyZUZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRlY2xhcmVGdW5jdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZGVjbGFyZUludGVyZmFjZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJEZWNsYXJlSW50ZXJmYWNlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBkZWNsYXJlTW9kdWxlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRlY2xhcmVNb2R1bGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGRlY2xhcmVNb2R1bGVFeHBvcnRzKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBkZWNsYXJlVHlwZUFsaWFzKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRlY2xhcmVUeXBlQWxpYXNcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGRlY2xhcmVPcGFxdWVUeXBlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRlY2xhcmVPcGFxdWVUeXBlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBkZWNsYXJlVmFyaWFibGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRGVjbGFyZVZhcmlhYmxlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBkZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBkZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBkZWNsYXJlZFByZWRpY2F0ZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJEZWNsYXJlZFByZWRpY2F0ZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZXhpc3RzVHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRXhpc3RzVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uVHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZnVuY3Rpb25UeXBlUGFyYW0oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRnVuY3Rpb25UeXBlUGFyYW1cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyaWNUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJHZW5lcmljVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGluZmVycmVkUHJlZGljYXRlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkluZmVycmVkUHJlZGljYXRlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBpbnRlcmZhY2VFeHRlbmRzKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkludGVyZmFjZUV4dGVuZHNcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGludGVyZmFjZURlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkludGVyZmFjZURlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBpbnRlcmZhY2VUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJJbnRlcmZhY2VUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG1peGVkVHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiTWl4ZWRUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZW1wdHlUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJFbXB0eVR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBudWxsYWJsZVR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG51bWJlclR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk51bWJlclR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBvYmplY3RUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0VHlwZUludGVybmFsU2xvdCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJPYmplY3RUeXBlSW50ZXJuYWxTbG90XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBvYmplY3RUeXBlQ2FsbFByb3BlcnR5KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFR5cGVJbmRleGVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk9iamVjdFR5cGVJbmRleGVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBvYmplY3RUeXBlUHJvcGVydHkoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiT2JqZWN0VHlwZVByb3BlcnR5XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBvYmplY3RUeXBlU3ByZWFkUHJvcGVydHkoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBvcGFxdWVUeXBlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk9wYXF1ZVR5cGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHF1YWxpZmllZFR5cGVJZGVudGlmaWVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJTdHJpbmdUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gc3ltYm9sVHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiU3ltYm9sVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRoaXNUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUaGlzVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHR1cGxlVHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVHVwbGVUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHlwZW9mVHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVHlwZW9mVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHR5cGVBbGlhcyguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUeXBlQWxpYXNcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0eXBlQ2FzdEV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVHlwZUNhc3RFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0eXBlUGFyYW1ldGVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlR5cGVQYXJhbWV0ZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB1bmlvblR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlVuaW9uVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHZhcmlhbmNlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlZhcmlhbmNlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB2b2lkVHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVm9pZFR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBlbnVtRGVjbGFyYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRW51bURlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBlbnVtQm9vbGVhbkJvZHkoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRW51bUJvb2xlYW5Cb2R5XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBlbnVtTnVtYmVyQm9keSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJFbnVtTnVtYmVyQm9keVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZW51bVN0cmluZ0JvZHkoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRW51bVN0cmluZ0JvZHlcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGVudW1TeW1ib2xCb2R5KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkVudW1TeW1ib2xCb2R5XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBlbnVtQm9vbGVhbk1lbWJlciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJFbnVtQm9vbGVhbk1lbWJlclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZW51bU51bWJlck1lbWJlciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJFbnVtTnVtYmVyTWVtYmVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBlbnVtU3RyaW5nTWVtYmVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkVudW1TdHJpbmdNZW1iZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGVudW1EZWZhdWx0ZWRNZW1iZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRW51bURlZmF1bHRlZE1lbWJlclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24ganN4QXR0cmlidXRlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkpTWEF0dHJpYnV0ZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24ganN4Q2xvc2luZ0VsZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSlNYQ2xvc2luZ0VsZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGpzeEVsZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSlNYRWxlbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24ganN4RW1wdHlFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkpTWEVtcHR5RXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24ganN4RXhwcmVzc2lvbkNvbnRhaW5lciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBqc3hTcHJlYWRDaGlsZCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJKU1hTcHJlYWRDaGlsZFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24ganN4SWRlbnRpZmllciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJKU1hJZGVudGlmaWVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBqc3hNZW1iZXJFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkpTWE1lbWJlckV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGpzeE5hbWVzcGFjZWROYW1lKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkpTWE5hbWVzcGFjZWROYW1lXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBqc3hPcGVuaW5nRWxlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJKU1hPcGVuaW5nRWxlbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24ganN4U3ByZWFkQXR0cmlidXRlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkpTWFNwcmVhZEF0dHJpYnV0ZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24ganN4VGV4dCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJKU1hUZXh0XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBqc3hGcmFnbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJKU1hGcmFnbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24ganN4T3BlbmluZ0ZyYWdtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkpTWE9wZW5pbmdGcmFnbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24ganN4Q2xvc2luZ0ZyYWdtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkpTWENsb3NpbmdGcmFnbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gbm9vcCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJOb29wXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJQbGFjZWhvbGRlclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdjhJbnRyaW5zaWNJZGVudGlmaWVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlY4SW50cmluc2ljSWRlbnRpZmllclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gYXJndW1lbnRQbGFjZWhvbGRlciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJBcmd1bWVudFBsYWNlaG9sZGVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBhd2FpdEV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQXdhaXRFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBiaW5kRXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJCaW5kRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NQcm9wZXJ0eSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJDbGFzc1Byb3BlcnR5XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBvcHRpb25hbE1lbWJlckV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBwaXBlbGluZVRvcGljRXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJQaXBlbGluZVRvcGljRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gcGlwZWxpbmVCYXJlRnVuY3Rpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiUGlwZWxpbmVCYXJlRnVuY3Rpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBvcHRpb25hbENhbGxFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzUHJpdmF0ZVByb3BlcnR5KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBjbGFzc1ByaXZhdGVNZXRob2QoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBfaW1wb3J0KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkltcG9ydFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gaW1wb3J0QXR0cmlidXRlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkltcG9ydEF0dHJpYnV0ZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZGVjb3JhdG9yKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRlY29yYXRvclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZG9FeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRvRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZXhwb3J0RGVmYXVsdFNwZWNpZmllciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBleHBvcnROYW1lc3BhY2VTcGVjaWZpZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBwcml2YXRlTmFtZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJQcml2YXRlTmFtZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gYmlnSW50TGl0ZXJhbCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJCaWdJbnRMaXRlcmFsXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiByZWNvcmRFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlJlY29yZEV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHR1cGxlRXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUdXBsZUV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzUGFyYW1ldGVyUHJvcGVydHkoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNEZWNsYXJlRnVuY3Rpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNEZWNsYXJlRnVuY3Rpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzRGVjbGFyZU1ldGhvZCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0RlY2xhcmVNZXRob2RcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzUXVhbGlmaWVkTmFtZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1F1YWxpZmllZE5hbWVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzUHJvcGVydHlTaWduYXR1cmUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNNZXRob2RTaWduYXR1cmUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNNZXRob2RTaWduYXR1cmVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzSW5kZXhTaWduYXR1cmUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNJbmRleFNpZ25hdHVyZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNBbnlLZXl3b3JkKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTQW55S2V5d29yZFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNCb29sZWFuS2V5d29yZCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0Jvb2xlYW5LZXl3b3JkXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0JpZ0ludEtleXdvcmQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNCaWdJbnRLZXl3b3JkXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c05ldmVyS2V5d29yZCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU05ldmVyS2V5d29yZFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNOdWxsS2V5d29yZCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU051bGxLZXl3b3JkXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c051bWJlcktleXdvcmQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNOdW1iZXJLZXl3b3JkXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c09iamVjdEtleXdvcmQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNPYmplY3RLZXl3b3JkXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1N0cmluZ0tleXdvcmQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNTdHJpbmdLZXl3b3JkXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1N5bWJvbEtleXdvcmQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNTeW1ib2xLZXl3b3JkXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1VuZGVmaW5lZEtleXdvcmQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNVbmRlZmluZWRLZXl3b3JkXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1Vua25vd25LZXl3b3JkKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTVW5rbm93bktleXdvcmRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzVm9pZEtleXdvcmQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNWb2lkS2V5d29yZFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNUaGlzVHlwZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1RoaXNUeXBlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0Z1bmN0aW9uVHlwZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0Z1bmN0aW9uVHlwZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNDb25zdHJ1Y3RvclR5cGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNDb25zdHJ1Y3RvclR5cGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzVHlwZVJlZmVyZW5jZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1R5cGVSZWZlcmVuY2VcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzVHlwZVByZWRpY2F0ZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1R5cGVQcmVkaWNhdGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzVHlwZVF1ZXJ5KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTVHlwZVF1ZXJ5XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1R5cGVMaXRlcmFsKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTVHlwZUxpdGVyYWxcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzQXJyYXlUeXBlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTQXJyYXlUeXBlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1R1cGxlVHlwZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1R1cGxlVHlwZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNPcHRpb25hbFR5cGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNPcHRpb25hbFR5cGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzUmVzdFR5cGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNSZXN0VHlwZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNVbmlvblR5cGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNVbmlvblR5cGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzSW50ZXJzZWN0aW9uVHlwZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0ludGVyc2VjdGlvblR5cGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzQ29uZGl0aW9uYWxUeXBlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTQ29uZGl0aW9uYWxUeXBlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0luZmVyVHlwZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0luZmVyVHlwZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNQYXJlbnRoZXNpemVkVHlwZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1BhcmVudGhlc2l6ZWRUeXBlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1R5cGVPcGVyYXRvciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1R5cGVPcGVyYXRvclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNJbmRleGVkQWNjZXNzVHlwZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0luZGV4ZWRBY2Nlc3NUeXBlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c01hcHBlZFR5cGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNNYXBwZWRUeXBlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0xpdGVyYWxUeXBlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTTGl0ZXJhbFR5cGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0ludGVyZmFjZURlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzSW50ZXJmYWNlQm9keSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0ludGVyZmFjZUJvZHlcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzVHlwZUFsaWFzRGVjbGFyYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNBc0V4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNBc0V4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzVHlwZUFzc2VydGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1R5cGVBc3NlcnRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzRW51bURlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTRW51bURlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0VudW1NZW1iZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNFbnVtTWVtYmVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c01vZHVsZURlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTTW9kdWxlRGVjbGFyYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzTW9kdWxlQmxvY2soLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNNb2R1bGVCbG9ja1wiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNJbXBvcnRUeXBlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTSW1wb3J0VHlwZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2VcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzTm9uTnVsbEV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNOb25OdWxsRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNFeHBvcnRBc3NpZ25tZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTRXhwb3J0QXNzaWdubWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1R5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzVHlwZVBhcmFtZXRlciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1R5cGVQYXJhbWV0ZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIE51bWJlckxpdGVyYWwoLi4uYXJncykge1xuICBjb25zb2xlLnRyYWNlKFwiVGhlIG5vZGUgdHlwZSBOdW1iZXJMaXRlcmFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gTnVtZXJpY0xpdGVyYWxcIik7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJOdW1iZXJMaXRlcmFsXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBSZWdleExpdGVyYWwoLi4uYXJncykge1xuICBjb25zb2xlLnRyYWNlKFwiVGhlIG5vZGUgdHlwZSBSZWdleExpdGVyYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBSZWdFeHBMaXRlcmFsXCIpO1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiUmVnZXhMaXRlcmFsXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBSZXN0UHJvcGVydHkoLi4uYXJncykge1xuICBjb25zb2xlLnRyYWNlKFwiVGhlIG5vZGUgdHlwZSBSZXN0UHJvcGVydHkgaGFzIGJlZW4gcmVuYW1lZCB0byBSZXN0RWxlbWVudFwiKTtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlJlc3RQcm9wZXJ0eVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gU3ByZWFkUHJvcGVydHkoLi4uYXJncykge1xuICBjb25zb2xlLnRyYWNlKFwiVGhlIG5vZGUgdHlwZSBTcHJlYWRQcm9wZXJ0eSBoYXMgYmVlbiByZW5hbWVkIHRvIFNwcmVhZEVsZW1lbnRcIik7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJTcHJlYWRQcm9wZXJ0eVwiLCAuLi5hcmdzKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGJ1aWxkQ2hpbGRyZW47XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4uLy4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkXCIpO1xuXG52YXIgX2NsZWFuSlNYRWxlbWVudExpdGVyYWxDaGlsZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3V0aWxzL3JlYWN0L2NsZWFuSlNYRWxlbWVudExpdGVyYWxDaGlsZFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGJ1aWxkQ2hpbGRyZW4obm9kZSkge1xuICBjb25zdCBlbGVtZW50cyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG5cbiAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNKU1hUZXh0KShjaGlsZCkpIHtcbiAgICAgICgwLCBfY2xlYW5KU1hFbGVtZW50TGl0ZXJhbENoaWxkLmRlZmF1bHQpKGNoaWxkLCBlbGVtZW50cyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNKU1hFeHByZXNzaW9uQ29udGFpbmVyKShjaGlsZCkpIGNoaWxkID0gY2hpbGQuZXhwcmVzc2lvbjtcbiAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNKU1hFbXB0eUV4cHJlc3Npb24pKGNoaWxkKSkgY29udGludWU7XG4gICAgZWxlbWVudHMucHVzaChjaGlsZCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudHM7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVUU1VuaW9uVHlwZTtcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi4vZ2VuZXJhdGVkXCIpO1xuXG52YXIgX3JlbW92ZVR5cGVEdXBsaWNhdGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbW9kaWZpY2F0aW9ucy90eXBlc2NyaXB0L3JlbW92ZVR5cGVEdXBsaWNhdGVzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlVFNVbmlvblR5cGUodHlwZUFubm90YXRpb25zKSB7XG4gIGNvbnN0IHR5cGVzID0gdHlwZUFubm90YXRpb25zLm1hcCh0eXBlID0+IHR5cGUudHlwZUFubm90YXRpb25zKTtcbiAgY29uc3QgZmxhdHRlbmVkID0gKDAsIF9yZW1vdmVUeXBlRHVwbGljYXRlcy5kZWZhdWx0KSh0eXBlcyk7XG5cbiAgaWYgKGZsYXR0ZW5lZC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZmxhdHRlbmVkWzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoMCwgX2dlbmVyYXRlZC50c1VuaW9uVHlwZSkoZmxhdHRlbmVkKTtcbiAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY2xvbmU7XG5cbnZhciBfY2xvbmVOb2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jbG9uZU5vZGVcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBjbG9uZShub2RlKSB7XG4gIHJldHVybiAoMCwgX2Nsb25lTm9kZS5kZWZhdWx0KShub2RlLCBmYWxzZSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjbG9uZURlZXA7XG5cbnZhciBfY2xvbmVOb2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jbG9uZU5vZGVcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBjbG9uZURlZXAobm9kZSkge1xuICByZXR1cm4gKDAsIF9jbG9uZU5vZGUuZGVmYXVsdCkobm9kZSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjbG9uZURlZXBXaXRob3V0TG9jO1xuXG52YXIgX2Nsb25lTm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY2xvbmVOb2RlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY2xvbmVEZWVwV2l0aG91dExvYyhub2RlKSB7XG4gIHJldHVybiAoMCwgX2Nsb25lTm9kZS5kZWZhdWx0KShub2RlLCB0cnVlLCB0cnVlKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNsb25lTm9kZTtcblxudmFyIF9kZWZpbml0aW9ucyA9IHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uc1wiKTtcblxuY29uc3QgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBjbG9uZUlmTm9kZShvYmosIGRlZXAsIHdpdGhvdXRMb2MpIHtcbiAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gY2xvbmVOb2RlKG9iaiwgZGVlcCwgd2l0aG91dExvYyk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBjbG9uZUlmTm9kZU9yQXJyYXkob2JqLCBkZWVwLCB3aXRob3V0TG9jKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLm1hcChub2RlID0+IGNsb25lSWZOb2RlKG5vZGUsIGRlZXAsIHdpdGhvdXRMb2MpKTtcbiAgfVxuXG4gIHJldHVybiBjbG9uZUlmTm9kZShvYmosIGRlZXAsIHdpdGhvdXRMb2MpO1xufVxuXG5mdW5jdGlvbiBjbG9uZU5vZGUobm9kZSwgZGVlcCA9IHRydWUsIHdpdGhvdXRMb2MgPSBmYWxzZSkge1xuICBpZiAoIW5vZGUpIHJldHVybiBub2RlO1xuICBjb25zdCB7XG4gICAgdHlwZVxuICB9ID0gbm9kZTtcbiAgY29uc3QgbmV3Tm9kZSA9IHtcbiAgICB0eXBlXG4gIH07XG5cbiAgaWYgKHR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgbmV3Tm9kZS5uYW1lID0gbm9kZS5uYW1lO1xuXG4gICAgaWYgKGhhcyhub2RlLCBcIm9wdGlvbmFsXCIpICYmIHR5cGVvZiBub2RlLm9wdGlvbmFsID09PSBcImJvb2xlYW5cIikge1xuICAgICAgbmV3Tm9kZS5vcHRpb25hbCA9IG5vZGUub3B0aW9uYWw7XG4gICAgfVxuXG4gICAgaWYgKGhhcyhub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIpKSB7XG4gICAgICBuZXdOb2RlLnR5cGVBbm5vdGF0aW9uID0gZGVlcCA/IGNsb25lSWZOb2RlT3JBcnJheShub2RlLnR5cGVBbm5vdGF0aW9uLCB0cnVlLCB3aXRob3V0TG9jKSA6IG5vZGUudHlwZUFubm90YXRpb247XG4gICAgfVxuICB9IGVsc2UgaWYgKCFoYXMoX2RlZmluaXRpb25zLk5PREVfRklFTERTLCB0eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBub2RlIHR5cGU6IFwiJHt0eXBlfVwiYCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBPYmplY3Qua2V5cyhfZGVmaW5pdGlvbnMuTk9ERV9GSUVMRFNbdHlwZV0pKSB7XG4gICAgICBpZiAoaGFzKG5vZGUsIGZpZWxkKSkge1xuICAgICAgICBpZiAoZGVlcCkge1xuICAgICAgICAgIG5ld05vZGVbZmllbGRdID0gdHlwZSA9PT0gXCJGaWxlXCIgJiYgZmllbGQgPT09IFwiY29tbWVudHNcIiA/IG1heWJlQ2xvbmVDb21tZW50cyhub2RlLmNvbW1lbnRzLCBkZWVwLCB3aXRob3V0TG9jKSA6IGNsb25lSWZOb2RlT3JBcnJheShub2RlW2ZpZWxkXSwgdHJ1ZSwgd2l0aG91dExvYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Tm9kZVtmaWVsZF0gPSBub2RlW2ZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChoYXMobm9kZSwgXCJsb2NcIikpIHtcbiAgICBpZiAod2l0aG91dExvYykge1xuICAgICAgbmV3Tm9kZS5sb2MgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdOb2RlLmxvYyA9IG5vZGUubG9jO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoYXMobm9kZSwgXCJsZWFkaW5nQ29tbWVudHNcIikpIHtcbiAgICBuZXdOb2RlLmxlYWRpbmdDb21tZW50cyA9IG1heWJlQ2xvbmVDb21tZW50cyhub2RlLmxlYWRpbmdDb21tZW50cywgZGVlcCwgd2l0aG91dExvYyk7XG4gIH1cblxuICBpZiAoaGFzKG5vZGUsIFwiaW5uZXJDb21tZW50c1wiKSkge1xuICAgIG5ld05vZGUuaW5uZXJDb21tZW50cyA9IG1heWJlQ2xvbmVDb21tZW50cyhub2RlLmlubmVyQ29tbWVudHMsIGRlZXAsIHdpdGhvdXRMb2MpO1xuICB9XG5cbiAgaWYgKGhhcyhub2RlLCBcInRyYWlsaW5nQ29tbWVudHNcIikpIHtcbiAgICBuZXdOb2RlLnRyYWlsaW5nQ29tbWVudHMgPSBtYXliZUNsb25lQ29tbWVudHMobm9kZS50cmFpbGluZ0NvbW1lbnRzLCBkZWVwLCB3aXRob3V0TG9jKTtcbiAgfVxuXG4gIGlmIChoYXMobm9kZSwgXCJleHRyYVwiKSkge1xuICAgIG5ld05vZGUuZXh0cmEgPSBPYmplY3QuYXNzaWduKHt9LCBub2RlLmV4dHJhKTtcbiAgfVxuXG4gIHJldHVybiBuZXdOb2RlO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvbW1lbnRzV2l0aG91dExvYyhjb21tZW50cykge1xuICByZXR1cm4gY29tbWVudHMubWFwKCh7XG4gICAgdHlwZSxcbiAgICB2YWx1ZVxuICB9KSA9PiAoe1xuICAgIHR5cGUsXG4gICAgdmFsdWUsXG4gICAgbG9jOiBudWxsXG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gbWF5YmVDbG9uZUNvbW1lbnRzKGNvbW1lbnRzLCBkZWVwLCB3aXRob3V0TG9jKSB7XG4gIHJldHVybiBkZWVwICYmIHdpdGhvdXRMb2MgPyBjbG9uZUNvbW1lbnRzV2l0aG91dExvYyhjb21tZW50cykgOiBjb21tZW50cztcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNsb25lV2l0aG91dExvYztcblxudmFyIF9jbG9uZU5vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nsb25lTm9kZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNsb25lV2l0aG91dExvYyhub2RlKSB7XG4gIHJldHVybiAoMCwgX2Nsb25lTm9kZS5kZWZhdWx0KShub2RlLCBmYWxzZSwgdHJ1ZSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhZGRDb21tZW50O1xuXG52YXIgX2FkZENvbW1lbnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9hZGRDb21tZW50c1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGFkZENvbW1lbnQobm9kZSwgdHlwZSwgY29udGVudCwgbGluZSkge1xuICByZXR1cm4gKDAsIF9hZGRDb21tZW50cy5kZWZhdWx0KShub2RlLCB0eXBlLCBbe1xuICAgIHR5cGU6IGxpbmUgPyBcIkNvbW1lbnRMaW5lXCIgOiBcIkNvbW1lbnRCbG9ja1wiLFxuICAgIHZhbHVlOiBjb250ZW50XG4gIH1dKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFkZENvbW1lbnRzO1xuXG5mdW5jdGlvbiBhZGRDb21tZW50cyhub2RlLCB0eXBlLCBjb21tZW50cykge1xuICBpZiAoIWNvbW1lbnRzIHx8ICFub2RlKSByZXR1cm4gbm9kZTtcbiAgY29uc3Qga2V5ID0gYCR7dHlwZX1Db21tZW50c2A7XG5cbiAgaWYgKG5vZGVba2V5XSkge1xuICAgIGlmICh0eXBlID09PSBcImxlYWRpbmdcIikge1xuICAgICAgbm9kZVtrZXldID0gY29tbWVudHMuY29uY2F0KG5vZGVba2V5XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVba2V5XSA9IG5vZGVba2V5XS5jb25jYXQoY29tbWVudHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlW2tleV0gPSBjb21tZW50cztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaW5oZXJpdElubmVyQ29tbWVudHM7XG5cbnZhciBfaW5oZXJpdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3V0aWxzL2luaGVyaXRcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpbmhlcml0SW5uZXJDb21tZW50cyhjaGlsZCwgcGFyZW50KSB7XG4gICgwLCBfaW5oZXJpdC5kZWZhdWx0KShcImlubmVyQ29tbWVudHNcIiwgY2hpbGQsIHBhcmVudCk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpbmhlcml0TGVhZGluZ0NvbW1lbnRzO1xuXG52YXIgX2luaGVyaXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy9pbmhlcml0XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaW5oZXJpdExlYWRpbmdDb21tZW50cyhjaGlsZCwgcGFyZW50KSB7XG4gICgwLCBfaW5oZXJpdC5kZWZhdWx0KShcImxlYWRpbmdDb21tZW50c1wiLCBjaGlsZCwgcGFyZW50KTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGluaGVyaXRUcmFpbGluZ0NvbW1lbnRzO1xuXG52YXIgX2luaGVyaXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy9pbmhlcml0XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaW5oZXJpdFRyYWlsaW5nQ29tbWVudHMoY2hpbGQsIHBhcmVudCkge1xuICAoMCwgX2luaGVyaXQuZGVmYXVsdCkoXCJ0cmFpbGluZ0NvbW1lbnRzXCIsIGNoaWxkLCBwYXJlbnQpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaW5oZXJpdHNDb21tZW50cztcblxudmFyIF9pbmhlcml0VHJhaWxpbmdDb21tZW50cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW5oZXJpdFRyYWlsaW5nQ29tbWVudHNcIikpO1xuXG52YXIgX2luaGVyaXRMZWFkaW5nQ29tbWVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2luaGVyaXRMZWFkaW5nQ29tbWVudHNcIikpO1xuXG52YXIgX2luaGVyaXRJbm5lckNvbW1lbnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbmhlcml0SW5uZXJDb21tZW50c1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGluaGVyaXRzQ29tbWVudHMoY2hpbGQsIHBhcmVudCkge1xuICAoMCwgX2luaGVyaXRUcmFpbGluZ0NvbW1lbnRzLmRlZmF1bHQpKGNoaWxkLCBwYXJlbnQpO1xuICAoMCwgX2luaGVyaXRMZWFkaW5nQ29tbWVudHMuZGVmYXVsdCkoY2hpbGQsIHBhcmVudCk7XG4gICgwLCBfaW5oZXJpdElubmVyQ29tbWVudHMuZGVmYXVsdCkoY2hpbGQsIHBhcmVudCk7XG4gIHJldHVybiBjaGlsZDtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlbW92ZUNvbW1lbnRzO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG5cbmZ1bmN0aW9uIHJlbW92ZUNvbW1lbnRzKG5vZGUpIHtcbiAgX2NvbnN0YW50cy5DT01NRU5UX0tFWVMuZm9yRWFjaChrZXkgPT4ge1xuICAgIG5vZGVba2V5XSA9IG51bGw7XG4gIH0pO1xuXG4gIHJldHVybiBub2RlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5UU0JBU0VUWVBFX1RZUEVTID0gZXhwb3J0cy5UU1RZUEVfVFlQRVMgPSBleHBvcnRzLlRTVFlQRUVMRU1FTlRfVFlQRVMgPSBleHBvcnRzLlBSSVZBVEVfVFlQRVMgPSBleHBvcnRzLkpTWF9UWVBFUyA9IGV4cG9ydHMuRU5VTU1FTUJFUl9UWVBFUyA9IGV4cG9ydHMuRU5VTUJPRFlfVFlQRVMgPSBleHBvcnRzLkZMT1dQUkVESUNBVEVfVFlQRVMgPSBleHBvcnRzLkZMT1dERUNMQVJBVElPTl9UWVBFUyA9IGV4cG9ydHMuRkxPV0JBU0VBTk5PVEFUSU9OX1RZUEVTID0gZXhwb3J0cy5GTE9XVFlQRV9UWVBFUyA9IGV4cG9ydHMuRkxPV19UWVBFUyA9IGV4cG9ydHMuTU9EVUxFU1BFQ0lGSUVSX1RZUEVTID0gZXhwb3J0cy5FWFBPUlRERUNMQVJBVElPTl9UWVBFUyA9IGV4cG9ydHMuTU9EVUxFREVDTEFSQVRJT05fVFlQRVMgPSBleHBvcnRzLkNMQVNTX1RZUEVTID0gZXhwb3J0cy5QQVRURVJOX1RZUEVTID0gZXhwb3J0cy5VTkFSWUxJS0VfVFlQRVMgPSBleHBvcnRzLlBST1BFUlRZX1RZUEVTID0gZXhwb3J0cy5PQkpFQ1RNRU1CRVJfVFlQRVMgPSBleHBvcnRzLk1FVEhPRF9UWVBFUyA9IGV4cG9ydHMuVVNFUldISVRFU1BBQ0FCTEVfVFlQRVMgPSBleHBvcnRzLklNTVVUQUJMRV9UWVBFUyA9IGV4cG9ydHMuTElURVJBTF9UWVBFUyA9IGV4cG9ydHMuVFNFTlRJVFlOQU1FX1RZUEVTID0gZXhwb3J0cy5MVkFMX1RZUEVTID0gZXhwb3J0cy5QQVRURVJOTElLRV9UWVBFUyA9IGV4cG9ydHMuREVDTEFSQVRJT05fVFlQRVMgPSBleHBvcnRzLlBVUkVJU0hfVFlQRVMgPSBleHBvcnRzLkZVTkNUSU9OUEFSRU5UX1RZUEVTID0gZXhwb3J0cy5GVU5DVElPTl9UWVBFUyA9IGV4cG9ydHMuRk9SWFNUQVRFTUVOVF9UWVBFUyA9IGV4cG9ydHMuRk9SX1RZUEVTID0gZXhwb3J0cy5FWFBSRVNTSU9OV1JBUFBFUl9UWVBFUyA9IGV4cG9ydHMuV0hJTEVfVFlQRVMgPSBleHBvcnRzLkxPT1BfVFlQRVMgPSBleHBvcnRzLkNPTkRJVElPTkFMX1RZUEVTID0gZXhwb3J0cy5DT01QTEVUSU9OU1RBVEVNRU5UX1RZUEVTID0gZXhwb3J0cy5URVJNSU5BVE9STEVTU19UWVBFUyA9IGV4cG9ydHMuU1RBVEVNRU5UX1RZUEVTID0gZXhwb3J0cy5CTE9DS19UWVBFUyA9IGV4cG9ydHMuQkxPQ0tQQVJFTlRfVFlQRVMgPSBleHBvcnRzLlNDT1BBQkxFX1RZUEVTID0gZXhwb3J0cy5CSU5BUllfVFlQRVMgPSBleHBvcnRzLkVYUFJFU1NJT05fVFlQRVMgPSB2b2lkIDA7XG5cbnZhciBfZGVmaW5pdGlvbnMgPSByZXF1aXJlKFwiLi4vLi4vZGVmaW5pdGlvbnNcIik7XG5cbmNvbnN0IEVYUFJFU1NJT05fVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiRXhwcmVzc2lvblwiXTtcbmV4cG9ydHMuRVhQUkVTU0lPTl9UWVBFUyA9IEVYUFJFU1NJT05fVFlQRVM7XG5jb25zdCBCSU5BUllfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiQmluYXJ5XCJdO1xuZXhwb3J0cy5CSU5BUllfVFlQRVMgPSBCSU5BUllfVFlQRVM7XG5jb25zdCBTQ09QQUJMRV9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJTY29wYWJsZVwiXTtcbmV4cG9ydHMuU0NPUEFCTEVfVFlQRVMgPSBTQ09QQUJMRV9UWVBFUztcbmNvbnN0IEJMT0NLUEFSRU5UX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkJsb2NrUGFyZW50XCJdO1xuZXhwb3J0cy5CTE9DS1BBUkVOVF9UWVBFUyA9IEJMT0NLUEFSRU5UX1RZUEVTO1xuY29uc3QgQkxPQ0tfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiQmxvY2tcIl07XG5leHBvcnRzLkJMT0NLX1RZUEVTID0gQkxPQ0tfVFlQRVM7XG5jb25zdCBTVEFURU1FTlRfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiU3RhdGVtZW50XCJdO1xuZXhwb3J0cy5TVEFURU1FTlRfVFlQRVMgPSBTVEFURU1FTlRfVFlQRVM7XG5jb25zdCBURVJNSU5BVE9STEVTU19UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJUZXJtaW5hdG9ybGVzc1wiXTtcbmV4cG9ydHMuVEVSTUlOQVRPUkxFU1NfVFlQRVMgPSBURVJNSU5BVE9STEVTU19UWVBFUztcbmNvbnN0IENPTVBMRVRJT05TVEFURU1FTlRfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiQ29tcGxldGlvblN0YXRlbWVudFwiXTtcbmV4cG9ydHMuQ09NUExFVElPTlNUQVRFTUVOVF9UWVBFUyA9IENPTVBMRVRJT05TVEFURU1FTlRfVFlQRVM7XG5jb25zdCBDT05ESVRJT05BTF9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJDb25kaXRpb25hbFwiXTtcbmV4cG9ydHMuQ09ORElUSU9OQUxfVFlQRVMgPSBDT05ESVRJT05BTF9UWVBFUztcbmNvbnN0IExPT1BfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiTG9vcFwiXTtcbmV4cG9ydHMuTE9PUF9UWVBFUyA9IExPT1BfVFlQRVM7XG5jb25zdCBXSElMRV9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJXaGlsZVwiXTtcbmV4cG9ydHMuV0hJTEVfVFlQRVMgPSBXSElMRV9UWVBFUztcbmNvbnN0IEVYUFJFU1NJT05XUkFQUEVSX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkV4cHJlc3Npb25XcmFwcGVyXCJdO1xuZXhwb3J0cy5FWFBSRVNTSU9OV1JBUFBFUl9UWVBFUyA9IEVYUFJFU1NJT05XUkFQUEVSX1RZUEVTO1xuY29uc3QgRk9SX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkZvclwiXTtcbmV4cG9ydHMuRk9SX1RZUEVTID0gRk9SX1RZUEVTO1xuY29uc3QgRk9SWFNUQVRFTUVOVF9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJGb3JYU3RhdGVtZW50XCJdO1xuZXhwb3J0cy5GT1JYU1RBVEVNRU5UX1RZUEVTID0gRk9SWFNUQVRFTUVOVF9UWVBFUztcbmNvbnN0IEZVTkNUSU9OX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkZ1bmN0aW9uXCJdO1xuZXhwb3J0cy5GVU5DVElPTl9UWVBFUyA9IEZVTkNUSU9OX1RZUEVTO1xuY29uc3QgRlVOQ1RJT05QQVJFTlRfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiRnVuY3Rpb25QYXJlbnRcIl07XG5leHBvcnRzLkZVTkNUSU9OUEFSRU5UX1RZUEVTID0gRlVOQ1RJT05QQVJFTlRfVFlQRVM7XG5jb25zdCBQVVJFSVNIX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIlB1cmVpc2hcIl07XG5leHBvcnRzLlBVUkVJU0hfVFlQRVMgPSBQVVJFSVNIX1RZUEVTO1xuY29uc3QgREVDTEFSQVRJT05fVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiRGVjbGFyYXRpb25cIl07XG5leHBvcnRzLkRFQ0xBUkFUSU9OX1RZUEVTID0gREVDTEFSQVRJT05fVFlQRVM7XG5jb25zdCBQQVRURVJOTElLRV9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJQYXR0ZXJuTGlrZVwiXTtcbmV4cG9ydHMuUEFUVEVSTkxJS0VfVFlQRVMgPSBQQVRURVJOTElLRV9UWVBFUztcbmNvbnN0IExWQUxfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiTFZhbFwiXTtcbmV4cG9ydHMuTFZBTF9UWVBFUyA9IExWQUxfVFlQRVM7XG5jb25zdCBUU0VOVElUWU5BTUVfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiVFNFbnRpdHlOYW1lXCJdO1xuZXhwb3J0cy5UU0VOVElUWU5BTUVfVFlQRVMgPSBUU0VOVElUWU5BTUVfVFlQRVM7XG5jb25zdCBMSVRFUkFMX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkxpdGVyYWxcIl07XG5leHBvcnRzLkxJVEVSQUxfVFlQRVMgPSBMSVRFUkFMX1RZUEVTO1xuY29uc3QgSU1NVVRBQkxFX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkltbXV0YWJsZVwiXTtcbmV4cG9ydHMuSU1NVVRBQkxFX1RZUEVTID0gSU1NVVRBQkxFX1RZUEVTO1xuY29uc3QgVVNFUldISVRFU1BBQ0FCTEVfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiVXNlcldoaXRlc3BhY2FibGVcIl07XG5leHBvcnRzLlVTRVJXSElURVNQQUNBQkxFX1RZUEVTID0gVVNFUldISVRFU1BBQ0FCTEVfVFlQRVM7XG5jb25zdCBNRVRIT0RfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiTWV0aG9kXCJdO1xuZXhwb3J0cy5NRVRIT0RfVFlQRVMgPSBNRVRIT0RfVFlQRVM7XG5jb25zdCBPQkpFQ1RNRU1CRVJfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiT2JqZWN0TWVtYmVyXCJdO1xuZXhwb3J0cy5PQkpFQ1RNRU1CRVJfVFlQRVMgPSBPQkpFQ1RNRU1CRVJfVFlQRVM7XG5jb25zdCBQUk9QRVJUWV9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJQcm9wZXJ0eVwiXTtcbmV4cG9ydHMuUFJPUEVSVFlfVFlQRVMgPSBQUk9QRVJUWV9UWVBFUztcbmNvbnN0IFVOQVJZTElLRV9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJVbmFyeUxpa2VcIl07XG5leHBvcnRzLlVOQVJZTElLRV9UWVBFUyA9IFVOQVJZTElLRV9UWVBFUztcbmNvbnN0IFBBVFRFUk5fVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiUGF0dGVyblwiXTtcbmV4cG9ydHMuUEFUVEVSTl9UWVBFUyA9IFBBVFRFUk5fVFlQRVM7XG5jb25zdCBDTEFTU19UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJDbGFzc1wiXTtcbmV4cG9ydHMuQ0xBU1NfVFlQRVMgPSBDTEFTU19UWVBFUztcbmNvbnN0IE1PRFVMRURFQ0xBUkFUSU9OX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIk1vZHVsZURlY2xhcmF0aW9uXCJdO1xuZXhwb3J0cy5NT0RVTEVERUNMQVJBVElPTl9UWVBFUyA9IE1PRFVMRURFQ0xBUkFUSU9OX1RZUEVTO1xuY29uc3QgRVhQT1JUREVDTEFSQVRJT05fVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiRXhwb3J0RGVjbGFyYXRpb25cIl07XG5leHBvcnRzLkVYUE9SVERFQ0xBUkFUSU9OX1RZUEVTID0gRVhQT1JUREVDTEFSQVRJT05fVFlQRVM7XG5jb25zdCBNT0RVTEVTUEVDSUZJRVJfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiTW9kdWxlU3BlY2lmaWVyXCJdO1xuZXhwb3J0cy5NT0RVTEVTUEVDSUZJRVJfVFlQRVMgPSBNT0RVTEVTUEVDSUZJRVJfVFlQRVM7XG5jb25zdCBGTE9XX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkZsb3dcIl07XG5leHBvcnRzLkZMT1dfVFlQRVMgPSBGTE9XX1RZUEVTO1xuY29uc3QgRkxPV1RZUEVfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiRmxvd1R5cGVcIl07XG5leHBvcnRzLkZMT1dUWVBFX1RZUEVTID0gRkxPV1RZUEVfVFlQRVM7XG5jb25zdCBGTE9XQkFTRUFOTk9UQVRJT05fVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdO1xuZXhwb3J0cy5GTE9XQkFTRUFOTk9UQVRJT05fVFlQRVMgPSBGTE9XQkFTRUFOTk9UQVRJT05fVFlQRVM7XG5jb25zdCBGTE9XREVDTEFSQVRJT05fVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiRmxvd0RlY2xhcmF0aW9uXCJdO1xuZXhwb3J0cy5GTE9XREVDTEFSQVRJT05fVFlQRVMgPSBGTE9XREVDTEFSQVRJT05fVFlQRVM7XG5jb25zdCBGTE9XUFJFRElDQVRFX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkZsb3dQcmVkaWNhdGVcIl07XG5leHBvcnRzLkZMT1dQUkVESUNBVEVfVFlQRVMgPSBGTE9XUFJFRElDQVRFX1RZUEVTO1xuY29uc3QgRU5VTUJPRFlfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiRW51bUJvZHlcIl07XG5leHBvcnRzLkVOVU1CT0RZX1RZUEVTID0gRU5VTUJPRFlfVFlQRVM7XG5jb25zdCBFTlVNTUVNQkVSX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkVudW1NZW1iZXJcIl07XG5leHBvcnRzLkVOVU1NRU1CRVJfVFlQRVMgPSBFTlVNTUVNQkVSX1RZUEVTO1xuY29uc3QgSlNYX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkpTWFwiXTtcbmV4cG9ydHMuSlNYX1RZUEVTID0gSlNYX1RZUEVTO1xuY29uc3QgUFJJVkFURV9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJQcml2YXRlXCJdO1xuZXhwb3J0cy5QUklWQVRFX1RZUEVTID0gUFJJVkFURV9UWVBFUztcbmNvbnN0IFRTVFlQRUVMRU1FTlRfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiVFNUeXBlRWxlbWVudFwiXTtcbmV4cG9ydHMuVFNUWVBFRUxFTUVOVF9UWVBFUyA9IFRTVFlQRUVMRU1FTlRfVFlQRVM7XG5jb25zdCBUU1RZUEVfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiVFNUeXBlXCJdO1xuZXhwb3J0cy5UU1RZUEVfVFlQRVMgPSBUU1RZUEVfVFlQRVM7XG5jb25zdCBUU0JBU0VUWVBFX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIlRTQmFzZVR5cGVcIl07XG5leHBvcnRzLlRTQkFTRVRZUEVfVFlQRVMgPSBUU0JBU0VUWVBFX1RZUEVTOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5OT1RfTE9DQUxfQklORElORyA9IGV4cG9ydHMuQkxPQ0tfU0NPUEVEX1NZTUJPTCA9IGV4cG9ydHMuSU5IRVJJVF9LRVlTID0gZXhwb3J0cy5VTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLlNUUklOR19VTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLk5VTUJFUl9VTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLkJPT0xFQU5fVU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5BU1NJR05NRU5UX09QRVJBVE9SUyA9IGV4cG9ydHMuQklOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuTlVNQkVSX0JJTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLkJPT0xFQU5fQklOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuQ09NUEFSSVNPTl9CSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5FUVVBTElUWV9CSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5CT09MRUFOX05VTUJFUl9CSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5VUERBVEVfT1BFUkFUT1JTID0gZXhwb3J0cy5MT0dJQ0FMX09QRVJBVE9SUyA9IGV4cG9ydHMuQ09NTUVOVF9LRVlTID0gZXhwb3J0cy5GT1JfSU5JVF9LRVlTID0gZXhwb3J0cy5GTEFUVEVOQUJMRV9LRVlTID0gZXhwb3J0cy5TVEFURU1FTlRfT1JfQkxPQ0tfS0VZUyA9IHZvaWQgMDtcbmNvbnN0IFNUQVRFTUVOVF9PUl9CTE9DS19LRVlTID0gW1wiY29uc2VxdWVudFwiLCBcImJvZHlcIiwgXCJhbHRlcm5hdGVcIl07XG5leHBvcnRzLlNUQVRFTUVOVF9PUl9CTE9DS19LRVlTID0gU1RBVEVNRU5UX09SX0JMT0NLX0tFWVM7XG5jb25zdCBGTEFUVEVOQUJMRV9LRVlTID0gW1wiYm9keVwiLCBcImV4cHJlc3Npb25zXCJdO1xuZXhwb3J0cy5GTEFUVEVOQUJMRV9LRVlTID0gRkxBVFRFTkFCTEVfS0VZUztcbmNvbnN0IEZPUl9JTklUX0tFWVMgPSBbXCJsZWZ0XCIsIFwiaW5pdFwiXTtcbmV4cG9ydHMuRk9SX0lOSVRfS0VZUyA9IEZPUl9JTklUX0tFWVM7XG5jb25zdCBDT01NRU5UX0tFWVMgPSBbXCJsZWFkaW5nQ29tbWVudHNcIiwgXCJ0cmFpbGluZ0NvbW1lbnRzXCIsIFwiaW5uZXJDb21tZW50c1wiXTtcbmV4cG9ydHMuQ09NTUVOVF9LRVlTID0gQ09NTUVOVF9LRVlTO1xuY29uc3QgTE9HSUNBTF9PUEVSQVRPUlMgPSBbXCJ8fFwiLCBcIiYmXCIsIFwiPz9cIl07XG5leHBvcnRzLkxPR0lDQUxfT1BFUkFUT1JTID0gTE9HSUNBTF9PUEVSQVRPUlM7XG5jb25zdCBVUERBVEVfT1BFUkFUT1JTID0gW1wiKytcIiwgXCItLVwiXTtcbmV4cG9ydHMuVVBEQVRFX09QRVJBVE9SUyA9IFVQREFURV9PUEVSQVRPUlM7XG5jb25zdCBCT09MRUFOX05VTUJFUl9CSU5BUllfT1BFUkFUT1JTID0gW1wiPlwiLCBcIjxcIiwgXCI+PVwiLCBcIjw9XCJdO1xuZXhwb3J0cy5CT09MRUFOX05VTUJFUl9CSU5BUllfT1BFUkFUT1JTID0gQk9PTEVBTl9OVU1CRVJfQklOQVJZX09QRVJBVE9SUztcbmNvbnN0IEVRVUFMSVRZX0JJTkFSWV9PUEVSQVRPUlMgPSBbXCI9PVwiLCBcIj09PVwiLCBcIiE9XCIsIFwiIT09XCJdO1xuZXhwb3J0cy5FUVVBTElUWV9CSU5BUllfT1BFUkFUT1JTID0gRVFVQUxJVFlfQklOQVJZX09QRVJBVE9SUztcbmNvbnN0IENPTVBBUklTT05fQklOQVJZX09QRVJBVE9SUyA9IFsuLi5FUVVBTElUWV9CSU5BUllfT1BFUkFUT1JTLCBcImluXCIsIFwiaW5zdGFuY2VvZlwiXTtcbmV4cG9ydHMuQ09NUEFSSVNPTl9CSU5BUllfT1BFUkFUT1JTID0gQ09NUEFSSVNPTl9CSU5BUllfT1BFUkFUT1JTO1xuY29uc3QgQk9PTEVBTl9CSU5BUllfT1BFUkFUT1JTID0gWy4uLkNPTVBBUklTT05fQklOQVJZX09QRVJBVE9SUywgLi4uQk9PTEVBTl9OVU1CRVJfQklOQVJZX09QRVJBVE9SU107XG5leHBvcnRzLkJPT0xFQU5fQklOQVJZX09QRVJBVE9SUyA9IEJPT0xFQU5fQklOQVJZX09QRVJBVE9SUztcbmNvbnN0IE5VTUJFUl9CSU5BUllfT1BFUkFUT1JTID0gW1wiLVwiLCBcIi9cIiwgXCIlXCIsIFwiKlwiLCBcIioqXCIsIFwiJlwiLCBcInxcIiwgXCI+PlwiLCBcIj4+PlwiLCBcIjw8XCIsIFwiXlwiXTtcbmV4cG9ydHMuTlVNQkVSX0JJTkFSWV9PUEVSQVRPUlMgPSBOVU1CRVJfQklOQVJZX09QRVJBVE9SUztcbmNvbnN0IEJJTkFSWV9PUEVSQVRPUlMgPSBbXCIrXCIsIC4uLk5VTUJFUl9CSU5BUllfT1BFUkFUT1JTLCAuLi5CT09MRUFOX0JJTkFSWV9PUEVSQVRPUlNdO1xuZXhwb3J0cy5CSU5BUllfT1BFUkFUT1JTID0gQklOQVJZX09QRVJBVE9SUztcbmNvbnN0IEFTU0lHTk1FTlRfT1BFUkFUT1JTID0gW1wiPVwiLCBcIis9XCIsIC4uLk5VTUJFUl9CSU5BUllfT1BFUkFUT1JTLm1hcChvcCA9PiBvcCArIFwiPVwiKSwgLi4uTE9HSUNBTF9PUEVSQVRPUlMubWFwKG9wID0+IG9wICsgXCI9XCIpXTtcbmV4cG9ydHMuQVNTSUdOTUVOVF9PUEVSQVRPUlMgPSBBU1NJR05NRU5UX09QRVJBVE9SUztcbmNvbnN0IEJPT0xFQU5fVU5BUllfT1BFUkFUT1JTID0gW1wiZGVsZXRlXCIsIFwiIVwiXTtcbmV4cG9ydHMuQk9PTEVBTl9VTkFSWV9PUEVSQVRPUlMgPSBCT09MRUFOX1VOQVJZX09QRVJBVE9SUztcbmNvbnN0IE5VTUJFUl9VTkFSWV9PUEVSQVRPUlMgPSBbXCIrXCIsIFwiLVwiLCBcIn5cIl07XG5leHBvcnRzLk5VTUJFUl9VTkFSWV9PUEVSQVRPUlMgPSBOVU1CRVJfVU5BUllfT1BFUkFUT1JTO1xuY29uc3QgU1RSSU5HX1VOQVJZX09QRVJBVE9SUyA9IFtcInR5cGVvZlwiXTtcbmV4cG9ydHMuU1RSSU5HX1VOQVJZX09QRVJBVE9SUyA9IFNUUklOR19VTkFSWV9PUEVSQVRPUlM7XG5jb25zdCBVTkFSWV9PUEVSQVRPUlMgPSBbXCJ2b2lkXCIsIFwidGhyb3dcIiwgLi4uQk9PTEVBTl9VTkFSWV9PUEVSQVRPUlMsIC4uLk5VTUJFUl9VTkFSWV9PUEVSQVRPUlMsIC4uLlNUUklOR19VTkFSWV9PUEVSQVRPUlNdO1xuZXhwb3J0cy5VTkFSWV9PUEVSQVRPUlMgPSBVTkFSWV9PUEVSQVRPUlM7XG5jb25zdCBJTkhFUklUX0tFWVMgPSB7XG4gIG9wdGlvbmFsOiBbXCJ0eXBlQW5ub3RhdGlvblwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicmV0dXJuVHlwZVwiXSxcbiAgZm9yY2U6IFtcInN0YXJ0XCIsIFwibG9jXCIsIFwiZW5kXCJdXG59O1xuZXhwb3J0cy5JTkhFUklUX0tFWVMgPSBJTkhFUklUX0tFWVM7XG5jb25zdCBCTE9DS19TQ09QRURfU1lNQk9MID0gU3ltYm9sLmZvcihcInZhciB1c2VkIHRvIGJlIGJsb2NrIHNjb3BlZFwiKTtcbmV4cG9ydHMuQkxPQ0tfU0NPUEVEX1NZTUJPTCA9IEJMT0NLX1NDT1BFRF9TWU1CT0w7XG5jb25zdCBOT1RfTE9DQUxfQklORElORyA9IFN5bWJvbC5mb3IoXCJzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgYSBsb2NhbCBiaW5kaW5nXCIpO1xuZXhwb3J0cy5OT1RfTE9DQUxfQklORElORyA9IE5PVF9MT0NBTF9CSU5ESU5HOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZW5zdXJlQmxvY2s7XG5cbnZhciBfdG9CbG9jayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdG9CbG9ja1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGVuc3VyZUJsb2NrKG5vZGUsIGtleSA9IFwiYm9keVwiKSB7XG4gIHJldHVybiBub2RlW2tleV0gPSAoMCwgX3RvQmxvY2suZGVmYXVsdCkobm9kZVtrZXldLCBub2RlKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGdhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnM7XG5cbnZhciBfZ2V0QmluZGluZ0lkZW50aWZpZXJzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcmV0cmlldmVycy9nZXRCaW5kaW5nSWRlbnRpZmllcnNcIikpO1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2dlbmVyYXRlZFwiKTtcblxudmFyIF9nZW5lcmF0ZWQyID0gcmVxdWlyZShcIi4uL2J1aWxkZXJzL2dlbmVyYXRlZFwiKTtcblxudmFyIF9jbG9uZU5vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9jbG9uZS9jbG9uZU5vZGVcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnYXRoZXJTZXF1ZW5jZUV4cHJlc3Npb25zKG5vZGVzLCBzY29wZSwgZGVjbGFycykge1xuICBjb25zdCBleHBycyA9IFtdO1xuICBsZXQgZW5zdXJlTGFzdFVuZGVmaW5lZCA9IHRydWU7XG5cbiAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgaWYgKCEoMCwgX2dlbmVyYXRlZC5pc0VtcHR5U3RhdGVtZW50KShub2RlKSkge1xuICAgICAgZW5zdXJlTGFzdFVuZGVmaW5lZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICgoMCwgX2dlbmVyYXRlZC5pc0V4cHJlc3Npb24pKG5vZGUpKSB7XG4gICAgICBleHBycy5wdXNoKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNFeHByZXNzaW9uU3RhdGVtZW50KShub2RlKSkge1xuICAgICAgZXhwcnMucHVzaChub2RlLmV4cHJlc3Npb24pO1xuICAgIH0gZWxzZSBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNWYXJpYWJsZURlY2xhcmF0aW9uKShub2RlKSkge1xuICAgICAgaWYgKG5vZGUua2luZCAhPT0gXCJ2YXJcIikgcmV0dXJuO1xuXG4gICAgICBmb3IgKGNvbnN0IGRlY2xhciBvZiBub2RlLmRlY2xhcmF0aW9ucykge1xuICAgICAgICBjb25zdCBiaW5kaW5ncyA9ICgwLCBfZ2V0QmluZGluZ0lkZW50aWZpZXJzLmRlZmF1bHQpKGRlY2xhcik7XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoYmluZGluZ3MpKSB7XG4gICAgICAgICAgZGVjbGFycy5wdXNoKHtcbiAgICAgICAgICAgIGtpbmQ6IG5vZGUua2luZCxcbiAgICAgICAgICAgIGlkOiAoMCwgX2Nsb25lTm9kZS5kZWZhdWx0KShiaW5kaW5nc1trZXldKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlY2xhci5pbml0KSB7XG4gICAgICAgICAgZXhwcnMucHVzaCgoMCwgX2dlbmVyYXRlZDIuYXNzaWdubWVudEV4cHJlc3Npb24pKFwiPVwiLCBkZWNsYXIuaWQsIGRlY2xhci5pbml0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZW5zdXJlTGFzdFVuZGVmaW5lZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICgoMCwgX2dlbmVyYXRlZC5pc0lmU3RhdGVtZW50KShub2RlKSkge1xuICAgICAgY29uc3QgY29uc2VxdWVudCA9IG5vZGUuY29uc2VxdWVudCA/IGdhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnMoW25vZGUuY29uc2VxdWVudF0sIHNjb3BlLCBkZWNsYXJzKSA6IHNjb3BlLmJ1aWxkVW5kZWZpbmVkTm9kZSgpO1xuICAgICAgY29uc3QgYWx0ZXJuYXRlID0gbm9kZS5hbHRlcm5hdGUgPyBnYXRoZXJTZXF1ZW5jZUV4cHJlc3Npb25zKFtub2RlLmFsdGVybmF0ZV0sIHNjb3BlLCBkZWNsYXJzKSA6IHNjb3BlLmJ1aWxkVW5kZWZpbmVkTm9kZSgpO1xuICAgICAgaWYgKCFjb25zZXF1ZW50IHx8ICFhbHRlcm5hdGUpIHJldHVybjtcbiAgICAgIGV4cHJzLnB1c2goKDAsIF9nZW5lcmF0ZWQyLmNvbmRpdGlvbmFsRXhwcmVzc2lvbikobm9kZS50ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpKTtcbiAgICB9IGVsc2UgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzQmxvY2tTdGF0ZW1lbnQpKG5vZGUpKSB7XG4gICAgICBjb25zdCBib2R5ID0gZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucyhub2RlLmJvZHksIHNjb3BlLCBkZWNsYXJzKTtcbiAgICAgIGlmICghYm9keSkgcmV0dXJuO1xuICAgICAgZXhwcnMucHVzaChib2R5KTtcbiAgICB9IGVsc2UgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzRW1wdHlTdGF0ZW1lbnQpKG5vZGUpKSB7XG4gICAgICBpZiAobm9kZXMuaW5kZXhPZihub2RlKSA9PT0gMCkge1xuICAgICAgICBlbnN1cmVMYXN0VW5kZWZpbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbnN1cmVMYXN0VW5kZWZpbmVkKSB7XG4gICAgZXhwcnMucHVzaChzY29wZS5idWlsZFVuZGVmaW5lZE5vZGUoKSk7XG4gIH1cblxuICBpZiAoZXhwcnMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGV4cHJzWzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoMCwgX2dlbmVyYXRlZDIuc2VxdWVuY2VFeHByZXNzaW9uKShleHBycyk7XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvQmluZGluZ0lkZW50aWZpZXJOYW1lO1xuXG52YXIgX3RvSWRlbnRpZmllciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdG9JZGVudGlmaWVyXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gdG9CaW5kaW5nSWRlbnRpZmllck5hbWUobmFtZSkge1xuICBuYW1lID0gKDAsIF90b0lkZW50aWZpZXIuZGVmYXVsdCkobmFtZSk7XG4gIGlmIChuYW1lID09PSBcImV2YWxcIiB8fCBuYW1lID09PSBcImFyZ3VtZW50c1wiKSBuYW1lID0gXCJfXCIgKyBuYW1lO1xuICByZXR1cm4gbmFtZTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvQmxvY2s7XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkXCIpO1xuXG52YXIgX2dlbmVyYXRlZDIgPSByZXF1aXJlKFwiLi4vYnVpbGRlcnMvZ2VuZXJhdGVkXCIpO1xuXG5mdW5jdGlvbiB0b0Jsb2NrKG5vZGUsIHBhcmVudCkge1xuICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNCbG9ja1N0YXRlbWVudCkobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGxldCBibG9ja05vZGVzID0gW107XG5cbiAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzRW1wdHlTdGF0ZW1lbnQpKG5vZGUpKSB7XG4gICAgYmxvY2tOb2RlcyA9IFtdO1xuICB9IGVsc2Uge1xuICAgIGlmICghKDAsIF9nZW5lcmF0ZWQuaXNTdGF0ZW1lbnQpKG5vZGUpKSB7XG4gICAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNGdW5jdGlvbikocGFyZW50KSkge1xuICAgICAgICBub2RlID0gKDAsIF9nZW5lcmF0ZWQyLnJldHVyblN0YXRlbWVudCkobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gKDAsIF9nZW5lcmF0ZWQyLmV4cHJlc3Npb25TdGF0ZW1lbnQpKG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJsb2NrTm9kZXMgPSBbbm9kZV07XG4gIH1cblxuICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQyLmJsb2NrU3RhdGVtZW50KShibG9ja05vZGVzKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvQ29tcHV0ZWRLZXk7XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkXCIpO1xuXG52YXIgX2dlbmVyYXRlZDIgPSByZXF1aXJlKFwiLi4vYnVpbGRlcnMvZ2VuZXJhdGVkXCIpO1xuXG5mdW5jdGlvbiB0b0NvbXB1dGVkS2V5KG5vZGUsIGtleSA9IG5vZGUua2V5IHx8IG5vZGUucHJvcGVydHkpIHtcbiAgaWYgKCFub2RlLmNvbXB1dGVkICYmICgwLCBfZ2VuZXJhdGVkLmlzSWRlbnRpZmllcikoa2V5KSkga2V5ID0gKDAsIF9nZW5lcmF0ZWQyLnN0cmluZ0xpdGVyYWwpKGtleS5uYW1lKTtcbiAgcmV0dXJuIGtleTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvRXhwcmVzc2lvbjtcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy9nZW5lcmF0ZWRcIik7XG5cbmZ1bmN0aW9uIHRvRXhwcmVzc2lvbihub2RlKSB7XG4gIGlmICgoMCwgX2dlbmVyYXRlZC5pc0V4cHJlc3Npb25TdGF0ZW1lbnQpKG5vZGUpKSB7XG4gICAgbm9kZSA9IG5vZGUuZXhwcmVzc2lvbjtcbiAgfVxuXG4gIGlmICgoMCwgX2dlbmVyYXRlZC5pc0V4cHJlc3Npb24pKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNDbGFzcykobm9kZSkpIHtcbiAgICBub2RlLnR5cGUgPSBcIkNsYXNzRXhwcmVzc2lvblwiO1xuICB9IGVsc2UgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzRnVuY3Rpb24pKG5vZGUpKSB7XG4gICAgbm9kZS50eXBlID0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIjtcbiAgfVxuXG4gIGlmICghKDAsIF9nZW5lcmF0ZWQuaXNFeHByZXNzaW9uKShub2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHR1cm4gJHtub2RlLnR5cGV9IHRvIGFuIGV4cHJlc3Npb25gKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9JZGVudGlmaWVyO1xuXG52YXIgX2lzVmFsaWRJZGVudGlmaWVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy9pc1ZhbGlkSWRlbnRpZmllclwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHRvSWRlbnRpZmllcihuYW1lKSB7XG4gIG5hbWUgPSBuYW1lICsgXCJcIjtcbiAgbmFtZSA9IG5hbWUucmVwbGFjZSgvW15hLXpBLVowLTkkX10vZywgXCItXCIpO1xuICBuYW1lID0gbmFtZS5yZXBsYWNlKC9eWy0wLTldKy8sIFwiXCIpO1xuICBuYW1lID0gbmFtZS5yZXBsYWNlKC9bLVxcc10rKC4pPy9nLCBmdW5jdGlvbiAobWF0Y2gsIGMpIHtcbiAgICByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6IFwiXCI7XG4gIH0pO1xuXG4gIGlmICghKDAsIF9pc1ZhbGlkSWRlbnRpZmllci5kZWZhdWx0KShuYW1lKSkge1xuICAgIG5hbWUgPSBgXyR7bmFtZX1gO1xuICB9XG5cbiAgcmV0dXJuIG5hbWUgfHwgXCJfXCI7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0b0tleUFsaWFzO1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2dlbmVyYXRlZFwiKTtcblxudmFyIF9jbG9uZU5vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9jbG9uZS9jbG9uZU5vZGVcIikpO1xuXG52YXIgX3JlbW92ZVByb3BlcnRpZXNEZWVwID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vbW9kaWZpY2F0aW9ucy9yZW1vdmVQcm9wZXJ0aWVzRGVlcFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHRvS2V5QWxpYXMobm9kZSwga2V5ID0gbm9kZS5rZXkpIHtcbiAgbGV0IGFsaWFzO1xuXG4gIGlmIChub2RlLmtpbmQgPT09IFwibWV0aG9kXCIpIHtcbiAgICByZXR1cm4gdG9LZXlBbGlhcy5pbmNyZW1lbnQoKSArIFwiXCI7XG4gIH0gZWxzZSBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNJZGVudGlmaWVyKShrZXkpKSB7XG4gICAgYWxpYXMgPSBrZXkubmFtZTtcbiAgfSBlbHNlIGlmICgoMCwgX2dlbmVyYXRlZC5pc1N0cmluZ0xpdGVyYWwpKGtleSkpIHtcbiAgICBhbGlhcyA9IEpTT04uc3RyaW5naWZ5KGtleS52YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgYWxpYXMgPSBKU09OLnN0cmluZ2lmeSgoMCwgX3JlbW92ZVByb3BlcnRpZXNEZWVwLmRlZmF1bHQpKCgwLCBfY2xvbmVOb2RlLmRlZmF1bHQpKGtleSkpKTtcbiAgfVxuXG4gIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgYWxpYXMgPSBgWyR7YWxpYXN9XWA7XG4gIH1cblxuICBpZiAobm9kZS5zdGF0aWMpIHtcbiAgICBhbGlhcyA9IGBzdGF0aWM6JHthbGlhc31gO1xuICB9XG5cbiAgcmV0dXJuIGFsaWFzO1xufVxuXG50b0tleUFsaWFzLnVpZCA9IDA7XG5cbnRvS2V5QWxpYXMuaW5jcmVtZW50ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodG9LZXlBbGlhcy51aWQgPj0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICByZXR1cm4gdG9LZXlBbGlhcy51aWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0b0tleUFsaWFzLnVpZCsrO1xuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9TZXF1ZW5jZUV4cHJlc3Npb247XG5cbnZhciBfZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9uc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHRvU2VxdWVuY2VFeHByZXNzaW9uKG5vZGVzLCBzY29wZSkge1xuICBpZiAoIShub2RlcyA9PSBudWxsID8gdm9pZCAwIDogbm9kZXMubGVuZ3RoKSkgcmV0dXJuO1xuICBjb25zdCBkZWNsYXJzID0gW107XG4gIGNvbnN0IHJlc3VsdCA9ICgwLCBfZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucy5kZWZhdWx0KShub2Rlcywgc2NvcGUsIGRlY2xhcnMpO1xuICBpZiAoIXJlc3VsdCkgcmV0dXJuO1xuXG4gIGZvciAoY29uc3QgZGVjbGFyIG9mIGRlY2xhcnMpIHtcbiAgICBzY29wZS5wdXNoKGRlY2xhcik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9TdGF0ZW1lbnQ7XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkXCIpO1xuXG52YXIgX2dlbmVyYXRlZDIgPSByZXF1aXJlKFwiLi4vYnVpbGRlcnMvZ2VuZXJhdGVkXCIpO1xuXG5mdW5jdGlvbiB0b1N0YXRlbWVudChub2RlLCBpZ25vcmUpIHtcbiAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzU3RhdGVtZW50KShub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgbGV0IG11c3RIYXZlSWQgPSBmYWxzZTtcbiAgbGV0IG5ld1R5cGU7XG5cbiAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzQ2xhc3MpKG5vZGUpKSB7XG4gICAgbXVzdEhhdmVJZCA9IHRydWU7XG4gICAgbmV3VHlwZSA9IFwiQ2xhc3NEZWNsYXJhdGlvblwiO1xuICB9IGVsc2UgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzRnVuY3Rpb24pKG5vZGUpKSB7XG4gICAgbXVzdEhhdmVJZCA9IHRydWU7XG4gICAgbmV3VHlwZSA9IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiO1xuICB9IGVsc2UgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzQXNzaWdubWVudEV4cHJlc3Npb24pKG5vZGUpKSB7XG4gICAgcmV0dXJuICgwLCBfZ2VuZXJhdGVkMi5leHByZXNzaW9uU3RhdGVtZW50KShub2RlKTtcbiAgfVxuXG4gIGlmIChtdXN0SGF2ZUlkICYmICFub2RlLmlkKSB7XG4gICAgbmV3VHlwZSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCFuZXdUeXBlKSB7XG4gICAgaWYgKGlnbm9yZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCB0dXJuICR7bm9kZS50eXBlfSB0byBhIHN0YXRlbWVudGApO1xuICAgIH1cbiAgfVxuXG4gIG5vZGUudHlwZSA9IG5ld1R5cGU7XG4gIHJldHVybiBub2RlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdmFsdWVUb05vZGU7XG5cbnZhciBfaXNQbGFpbk9iamVjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc1BsYWluT2JqZWN0XCIpKTtcblxudmFyIF9pc1JlZ0V4cCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc1JlZ0V4cFwiKSk7XG5cbnZhciBfaXNWYWxpZElkZW50aWZpZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2lzVmFsaWRJZGVudGlmaWVyXCIpKTtcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi4vYnVpbGRlcnMvZ2VuZXJhdGVkXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB2YWx1ZVRvTm9kZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAoMCwgX2dlbmVyYXRlZC5pZGVudGlmaWVyKShcInVuZGVmaW5lZFwiKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQuYm9vbGVhbkxpdGVyYWwpKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAoMCwgX2dlbmVyYXRlZC5udWxsTGl0ZXJhbCkoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQuc3RyaW5nTGl0ZXJhbCkodmFsdWUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGxldCByZXN1bHQ7XG5cbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgcmVzdWx0ID0gKDAsIF9nZW5lcmF0ZWQubnVtZXJpY0xpdGVyYWwpKE1hdGguYWJzKHZhbHVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBudW1lcmF0b3I7XG5cbiAgICAgIGlmIChOdW1iZXIuaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIG51bWVyYXRvciA9ICgwLCBfZ2VuZXJhdGVkLm51bWVyaWNMaXRlcmFsKSgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG51bWVyYXRvciA9ICgwLCBfZ2VuZXJhdGVkLm51bWVyaWNMaXRlcmFsKSgxKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gKDAsIF9nZW5lcmF0ZWQuYmluYXJ5RXhwcmVzc2lvbikoXCIvXCIsIG51bWVyYXRvciwgKDAsIF9nZW5lcmF0ZWQubnVtZXJpY0xpdGVyYWwpKDApKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPCAwIHx8IE9iamVjdC5pcyh2YWx1ZSwgLTApKSB7XG4gICAgICByZXN1bHQgPSAoMCwgX2dlbmVyYXRlZC51bmFyeUV4cHJlc3Npb24pKFwiLVwiLCByZXN1bHQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoKDAsIF9pc1JlZ0V4cC5kZWZhdWx0KSh2YWx1ZSkpIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gdmFsdWUuc291cmNlO1xuICAgIGNvbnN0IGZsYWdzID0gdmFsdWUudG9TdHJpbmcoKS5tYXRjaCgvXFwvKFthLXpdK3wpJC8pWzFdO1xuICAgIHJldHVybiAoMCwgX2dlbmVyYXRlZC5yZWdFeHBMaXRlcmFsKShwYXR0ZXJuLCBmbGFncyk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQuYXJyYXlFeHByZXNzaW9uKSh2YWx1ZS5tYXAodmFsdWVUb05vZGUpKTtcbiAgfVxuXG4gIGlmICgoMCwgX2lzUGxhaW5PYmplY3QuZGVmYXVsdCkodmFsdWUpKSB7XG4gICAgY29uc3QgcHJvcHMgPSBbXTtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbHVlKSkge1xuICAgICAgbGV0IG5vZGVLZXk7XG5cbiAgICAgIGlmICgoMCwgX2lzVmFsaWRJZGVudGlmaWVyLmRlZmF1bHQpKGtleSkpIHtcbiAgICAgICAgbm9kZUtleSA9ICgwLCBfZ2VuZXJhdGVkLmlkZW50aWZpZXIpKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlS2V5ID0gKDAsIF9nZW5lcmF0ZWQuc3RyaW5nTGl0ZXJhbCkoa2V5KTtcbiAgICAgIH1cblxuICAgICAgcHJvcHMucHVzaCgoMCwgX2dlbmVyYXRlZC5vYmplY3RQcm9wZXJ0eSkobm9kZUtleSwgdmFsdWVUb05vZGUodmFsdWVba2V5XSkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQub2JqZWN0RXhwcmVzc2lvbikocHJvcHMpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiZG9uJ3Qga25vdyBob3cgdG8gdHVybiB0aGlzIHZhbHVlIGludG8gYSBub2RlXCIpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5wYXR0ZXJuTGlrZUNvbW1vbiA9IGV4cG9ydHMuZnVuY3Rpb25EZWNsYXJhdGlvbkNvbW1vbiA9IGV4cG9ydHMuZnVuY3Rpb25UeXBlQW5ub3RhdGlvbkNvbW1vbiA9IGV4cG9ydHMuZnVuY3Rpb25Db21tb24gPSB2b2lkIDA7XG5cbnZhciBfaXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2lzXCIpKTtcblxudmFyIF9pc1ZhbGlkSWRlbnRpZmllciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvaXNWYWxpZElkZW50aWZpZXJcIikpO1xuXG52YXIgX2hlbHBlclZhbGlkYXRvcklkZW50aWZpZXIgPSByZXF1aXJlKFwiQGJhYmVsL2hlbHBlci12YWxpZGF0b3ItaWRlbnRpZmllclwiKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuXG52YXIgX3V0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuKDAsIF91dGlscy5kZWZhdWx0KShcIkFycmF5RXhwcmVzc2lvblwiLCB7XG4gIGZpZWxkczoge1xuICAgIGVsZW1lbnRzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlT3JWYWx1ZVR5cGUpKFwibnVsbFwiLCBcIkV4cHJlc3Npb25cIiwgXCJTcHJlYWRFbGVtZW50XCIpKSksXG4gICAgICBkZWZhdWx0OiAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/IFtdIDogdW5kZWZpbmVkXG4gICAgfVxuICB9LFxuICB2aXNpdG9yOiBbXCJlbGVtZW50c1wiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiwge1xuICBmaWVsZHM6IHtcbiAgICBvcGVyYXRvcjoge1xuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSB7XG4gICAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKSguLi5fY29uc3RhbnRzLkFTU0lHTk1FTlRfT1BFUkFUT1JTKTtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwiPVwiKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9ICgwLCBfaXMuZGVmYXVsdCkoXCJQYXR0ZXJuXCIsIG5vZGUubGVmdCkgPyBwYXR0ZXJuIDogaWRlbnRpZmllcjtcbiAgICAgICAgICB2YWxpZGF0b3Iobm9kZSwga2V5LCB2YWwpO1xuICAgICAgICB9O1xuICAgICAgfSgpXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB2YWxpZGF0ZTogIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkxWYWxcIikgOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIFwiQXJyYXlQYXR0ZXJuXCIsIFwiT2JqZWN0UGF0dGVyblwiKVxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH0sXG4gIGJ1aWxkZXI6IFtcIm9wZXJhdG9yXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdLFxuICB2aXNpdG9yOiBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkJpbmFyeUV4cHJlc3Npb25cIiwge1xuICBidWlsZGVyOiBbXCJvcGVyYXRvclwiLCBcImxlZnRcIiwgXCJyaWdodFwiXSxcbiAgZmllbGRzOiB7XG4gICAgb3BlcmF0b3I6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKSguLi5fY29uc3RhbnRzLkJJTkFSWV9PUEVSQVRPUlMpXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpO1xuICAgICAgICBjb25zdCBpbk9wID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIsIFwiUHJpdmF0ZU5hbWVcIik7XG5cbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gbm9kZS5vcGVyYXRvciA9PT0gXCJpblwiID8gaW5PcCA6IGV4cHJlc3Npb247XG4gICAgICAgICAgdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YWxpZGF0b3Iub25lT2ZOb2RlVHlwZXMgPSBbXCJFeHByZXNzaW9uXCIsIFwiUHJpdmF0ZU5hbWVcIl07XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgICB9KClcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9LFxuICB2aXNpdG9yOiBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIGFsaWFzZXM6IFtcIkJpbmFyeVwiLCBcIkV4cHJlc3Npb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkludGVycHJldGVyRGlyZWN0aXZlXCIsIHtcbiAgYnVpbGRlcjogW1widmFsdWVcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJEaXJlY3RpdmVcIiwge1xuICB2aXNpdG9yOiBbXCJ2YWx1ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkRpcmVjdGl2ZUxpdGVyYWxcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkRpcmVjdGl2ZUxpdGVyYWxcIiwge1xuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkJsb2NrU3RhdGVtZW50XCIsIHtcbiAgYnVpbGRlcjogW1wiYm9keVwiLCBcImRpcmVjdGl2ZXNcIl0sXG4gIHZpc2l0b3I6IFtcImRpcmVjdGl2ZXNcIiwgXCJib2R5XCJdLFxuICBmaWVsZHM6IHtcbiAgICBkaXJlY3RpdmVzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJEaXJlY3RpdmVcIikpKSxcbiAgICAgIGRlZmF1bHQ6IFtdXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIikpKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkJsb2NrXCIsIFwiU3RhdGVtZW50XCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJCcmVha1N0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImxhYmVsXCJdLFxuICBmaWVsZHM6IHtcbiAgICBsYWJlbDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJUZXJtaW5hdG9ybGVzc1wiLCBcIkNvbXBsZXRpb25TdGF0ZW1lbnRcIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkNhbGxFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiY2FsbGVlXCIsIFwiYXJndW1lbnRzXCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJ0eXBlQXJndW1lbnRzXCJdLFxuICBidWlsZGVyOiBbXCJjYWxsZWVcIiwgXCJhcmd1bWVudHNcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7XG4gICAgY2FsbGVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIsIFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCIpXG4gICAgfSxcbiAgICBhcmd1bWVudHM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIiwgXCJTcHJlYWRFbGVtZW50XCIsIFwiSlNYTmFtZXNwYWNlZE5hbWVcIiwgXCJBcmd1bWVudFBsYWNlaG9sZGVyXCIpKSlcbiAgICB9XG4gIH0sICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8ge1xuICAgIG9wdGlvbmFsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikodHJ1ZSwgZmFsc2UpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0gOiB7fSwge1xuICAgIHR5cGVBcmd1bWVudHM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHR5cGVQYXJhbWV0ZXJzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0pXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJDYXRjaENsYXVzZVwiLCB7XG4gIHZpc2l0b3I6IFtcInBhcmFtXCIsIFwiYm9keVwiXSxcbiAgZmllbGRzOiB7XG4gICAgcGFyYW06IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJBcnJheVBhdHRlcm5cIiwgXCJPYmplY3RQYXR0ZXJuXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIpXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIkJsb2NrUGFyZW50XCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiwge1xuICB2aXNpdG9yOiBbXCJ0ZXN0XCIsIFwiY29uc2VxdWVudFwiLCBcImFsdGVybmF0ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdGVzdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgY29uc2VxdWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgYWx0ZXJuYXRlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiQ29uZGl0aW9uYWxcIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkNvbnRpbnVlU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wibGFiZWxcIl0sXG4gIGZpZWxkczoge1xuICAgIGxhYmVsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIlRlcm1pbmF0b3JsZXNzXCIsIFwiQ29tcGxldGlvblN0YXRlbWVudFwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRGVidWdnZXJTdGF0ZW1lbnRcIiwge1xuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkRvV2hpbGVTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJ0ZXN0XCIsIFwiYm9keVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdGVzdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkxvb3BcIiwgXCJXaGlsZVwiLCBcIlNjb3BhYmxlXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFbXB0eVN0YXRlbWVudFwiLCB7XG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRXhwcmVzc2lvblN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkV4cHJlc3Npb25XcmFwcGVyXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJGaWxlXCIsIHtcbiAgYnVpbGRlcjogW1wicHJvZ3JhbVwiLCBcImNvbW1lbnRzXCIsIFwidG9rZW5zXCJdLFxuICB2aXNpdG9yOiBbXCJwcm9ncmFtXCJdLFxuICBmaWVsZHM6IHtcbiAgICBwcm9ncmFtOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJQcm9ncmFtXCIpXG4gICAgfSxcbiAgICBjb21tZW50czoge1xuICAgICAgdmFsaWRhdGU6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gT2JqZWN0LmFzc2lnbigoKSA9PiB7fSwge1xuICAgICAgICBlYWNoOiB7XG4gICAgICAgICAgb25lT2ZOb2RlVHlwZXM6IFtcIkNvbW1lbnRCbG9ja1wiLCBcIkNvbW1lbnRMaW5lXCJdXG4gICAgICAgIH1cbiAgICAgIH0pIDogKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkNvbW1lbnRCbG9ja1wiLCBcIkNvbW1lbnRMaW5lXCIpKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICB0b2tlbnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKE9iamVjdC5hc3NpZ24oKCkgPT4ge30sIHtcbiAgICAgICAgdHlwZTogXCJhbnlcIlxuICAgICAgfSkpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkZvckluU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wibGVmdFwiLCBcInJpZ2h0XCIsIFwiYm9keVwiXSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJTdGF0ZW1lbnRcIiwgXCJGb3JcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkxvb3BcIiwgXCJGb3JYU3RhdGVtZW50XCJdLFxuICBmaWVsZHM6IHtcbiAgICBsZWZ0OiB7XG4gICAgICB2YWxpZGF0ZTogIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiwgXCJMVmFsXCIpIDogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIFwiSWRlbnRpZmllclwiLCBcIk1lbWJlckV4cHJlc3Npb25cIiwgXCJBcnJheVBhdHRlcm5cIiwgXCJPYmplY3RQYXR0ZXJuXCIpXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJGb3JTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJpbml0XCIsIFwidGVzdFwiLCBcInVwZGF0ZVwiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiU3RhdGVtZW50XCIsIFwiRm9yXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJMb29wXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpbml0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIFwiRXhwcmVzc2lvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICB0ZXN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHVwZGF0ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH1cbn0pO1xuY29uc3QgZnVuY3Rpb25Db21tb24gPSB7XG4gIHBhcmFtczoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJQYXR0ZXJuXCIsIFwiUmVzdEVsZW1lbnRcIiwgXCJUU1BhcmFtZXRlclByb3BlcnR5XCIpKSlcbiAgfSxcbiAgZ2VuZXJhdG9yOiB7XG4gICAgZGVmYXVsdDogZmFsc2VcbiAgfSxcbiAgYXN5bmM6IHtcbiAgICBkZWZhdWx0OiBmYWxzZVxuICB9XG59O1xuZXhwb3J0cy5mdW5jdGlvbkNvbW1vbiA9IGZ1bmN0aW9uQ29tbW9uO1xuY29uc3QgZnVuY3Rpb25UeXBlQW5ub3RhdGlvbkNvbW1vbiA9IHtcbiAgcmV0dXJuVHlwZToge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVBbm5vdGF0aW9uXCIsIFwiVFNUeXBlQW5ub3RhdGlvblwiLCBcIk5vb3BcIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSxcbiAgdHlwZVBhcmFtZXRlcnM6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiwgXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCBcIk5vb3BcIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfVxufTtcbmV4cG9ydHMuZnVuY3Rpb25UeXBlQW5ub3RhdGlvbkNvbW1vbiA9IGZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb247XG5jb25zdCBmdW5jdGlvbkRlY2xhcmF0aW9uQ29tbW9uID0gT2JqZWN0LmFzc2lnbih7fSwgZnVuY3Rpb25Db21tb24sIHtcbiAgZGVjbGFyZToge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0sXG4gIGlkOiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9XG59KTtcbmV4cG9ydHMuZnVuY3Rpb25EZWNsYXJhdGlvbkNvbW1vbiA9IGZ1bmN0aW9uRGVjbGFyYXRpb25Db21tb247XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLCB7XG4gIGJ1aWxkZXI6IFtcImlkXCIsIFwicGFyYW1zXCIsIFwiYm9keVwiLCBcImdlbmVyYXRvclwiLCBcImFzeW5jXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcInBhcmFtc1wiLCBcImJvZHlcIiwgXCJyZXR1cm5UeXBlXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgZnVuY3Rpb25EZWNsYXJhdGlvbkNvbW1vbiwgZnVuY3Rpb25UeXBlQW5ub3RhdGlvbkNvbW1vbiwge1xuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIpXG4gICAgfVxuICB9KSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJGdW5jdGlvblwiLCBcIkJsb2NrUGFyZW50XCIsIFwiRnVuY3Rpb25QYXJlbnRcIiwgXCJTdGF0ZW1lbnRcIiwgXCJQdXJlaXNoXCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSByZXR1cm4gKCkgPT4ge307XG4gICAgY29uc3QgaWRlbnRpZmllciA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBhcmVudCwga2V5LCBub2RlKSB7XG4gICAgICBpZiAoISgwLCBfaXMuZGVmYXVsdCkoXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiwgcGFyZW50KSkge1xuICAgICAgICBpZGVudGlmaWVyKG5vZGUsIFwiaWRcIiwgbm9kZS5pZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSgpXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJGdW5jdGlvbkV4cHJlc3Npb25cIiwge1xuICBpbmhlcml0czogXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIsXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiRnVuY3Rpb25cIiwgXCJCbG9ja1BhcmVudFwiLCBcIkZ1bmN0aW9uUGFyZW50XCIsIFwiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgZnVuY3Rpb25Db21tb24sIGZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24sIHtcbiAgICBpZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH1cbiAgfSlcbn0pO1xuY29uc3QgcGF0dGVybkxpa2VDb21tb24gPSB7XG4gIHR5cGVBbm5vdGF0aW9uOiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZUFubm90YXRpb25cIiwgXCJUU1R5cGVBbm5vdGF0aW9uXCIsIFwiTm9vcFwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9LFxuICBkZWNvcmF0b3JzOiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRGVjb3JhdG9yXCIpKSlcbiAgfVxufTtcbmV4cG9ydHMucGF0dGVybkxpa2VDb21tb24gPSBwYXR0ZXJuTGlrZUNvbW1vbjtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJJZGVudGlmaWVyXCIsIHtcbiAgYnVpbGRlcjogW1wibmFtZVwiXSxcbiAgdmlzaXRvcjogW1widHlwZUFubm90YXRpb25cIiwgXCJkZWNvcmF0b3JzXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiUGF0dGVybkxpa2VcIiwgXCJMVmFsXCIsIFwiVFNFbnRpdHlOYW1lXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIHBhdHRlcm5MaWtlQ29tbW9uLCB7XG4gICAgbmFtZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKSwgT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCEoMCwgX2lzVmFsaWRJZGVudGlmaWVyLmRlZmF1bHQpKHZhbCwgZmFsc2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCIke3ZhbH1cIiBpcyBub3QgYSB2YWxpZCBpZGVudGlmaWVyIG5hbWVgKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9KSlcbiAgICB9LFxuICAgIG9wdGlvbmFsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9KSxcblxuICB2YWxpZGF0ZShwYXJlbnQsIGtleSwgbm9kZSkge1xuICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykgcmV0dXJuO1xuICAgIGNvbnN0IG1hdGNoID0gL1xcLihcXHcrKSQvLmV4ZWMoa2V5KTtcbiAgICBpZiAoIW1hdGNoKSByZXR1cm47XG4gICAgY29uc3QgWywgcGFyZW50S2V5XSA9IG1hdGNoO1xuICAgIGNvbnN0IG5vbkNvbXAgPSB7XG4gICAgICBjb21wdXRlZDogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKHBhcmVudEtleSA9PT0gXCJwcm9wZXJ0eVwiKSB7XG4gICAgICBpZiAoKDAsIF9pcy5kZWZhdWx0KShcIk1lbWJlckV4cHJlc3Npb25cIiwgcGFyZW50LCBub25Db21wKSkgcmV0dXJuO1xuICAgICAgaWYgKCgwLCBfaXMuZGVmYXVsdCkoXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiwgcGFyZW50LCBub25Db21wKSkgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocGFyZW50S2V5ID09PSBcImtleVwiKSB7XG4gICAgICBpZiAoKDAsIF9pcy5kZWZhdWx0KShcIlByb3BlcnR5XCIsIHBhcmVudCwgbm9uQ29tcCkpIHJldHVybjtcbiAgICAgIGlmICgoMCwgX2lzLmRlZmF1bHQpKFwiTWV0aG9kXCIsIHBhcmVudCwgbm9uQ29tcCkpIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHBhcmVudEtleSA9PT0gXCJleHBvcnRlZFwiKSB7XG4gICAgICBpZiAoKDAsIF9pcy5kZWZhdWx0KShcIkV4cG9ydFNwZWNpZmllclwiLCBwYXJlbnQpKSByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwYXJlbnRLZXkgPT09IFwiaW1wb3J0ZWRcIikge1xuICAgICAgaWYgKCgwLCBfaXMuZGVmYXVsdCkoXCJJbXBvcnRTcGVjaWZpZXJcIiwgcGFyZW50LCB7XG4gICAgICAgIGltcG9ydGVkOiBub2RlXG4gICAgICB9KSkgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocGFyZW50S2V5ID09PSBcIm1ldGFcIikge1xuICAgICAgaWYgKCgwLCBfaXMuZGVmYXVsdCkoXCJNZXRhUHJvcGVydHlcIiwgcGFyZW50LCB7XG4gICAgICAgIG1ldGE6IG5vZGVcbiAgICAgIH0pKSByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCgoMCwgX2hlbHBlclZhbGlkYXRvcklkZW50aWZpZXIuaXNLZXl3b3JkKShub2RlLm5hbWUpIHx8ICgwLCBfaGVscGVyVmFsaWRhdG9ySWRlbnRpZmllci5pc1Jlc2VydmVkV29yZCkobm9kZS5uYW1lKSkgJiYgbm9kZS5uYW1lICE9PSBcInRoaXNcIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCIke25vZGUubmFtZX1cIiBpcyBub3QgYSB2YWxpZCBpZGVudGlmaWVyYCk7XG4gICAgfVxuICB9XG5cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIklmU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1widGVzdFwiLCBcImNvbnNlcXVlbnRcIiwgXCJhbHRlcm5hdGVcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkNvbmRpdGlvbmFsXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0ZXN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBjb25zZXF1ZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9LFxuICAgIGFsdGVybmF0ZToge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkxhYmVsZWRTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJsYWJlbFwiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbGFiZWw6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlN0YXRlbWVudFwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiU3RyaW5nTGl0ZXJhbFwiLCB7XG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIiwgXCJMaXRlcmFsXCIsIFwiSW1tdXRhYmxlXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJOdW1lcmljTGl0ZXJhbFwiLCB7XG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBkZXByZWNhdGVkQWxpYXM6IFwiTnVtYmVyTGl0ZXJhbFwiLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcIm51bWJlclwiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIiwgXCJMaXRlcmFsXCIsIFwiSW1tdXRhYmxlXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJOdWxsTGl0ZXJhbFwiLCB7XG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJQdXJlaXNoXCIsIFwiTGl0ZXJhbFwiLCBcIkltbXV0YWJsZVwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQm9vbGVhbkxpdGVyYWxcIiwge1xuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiUHVyZWlzaFwiLCBcIkxpdGVyYWxcIiwgXCJJbW11dGFibGVcIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlJlZ0V4cExpdGVyYWxcIiwge1xuICBidWlsZGVyOiBbXCJwYXR0ZXJuXCIsIFwiZmxhZ3NcIl0sXG4gIGRlcHJlY2F0ZWRBbGlhczogXCJSZWdleExpdGVyYWxcIixcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIiwgXCJMaXRlcmFsXCJdLFxuICBmaWVsZHM6IHtcbiAgICBwYXR0ZXJuOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpXG4gICAgfSxcbiAgICBmbGFnczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKSwgT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGludmFsaWQgPSAvW15naW1zdXldLy5leGVjKHZhbCk7XG5cbiAgICAgICAgaWYgKGludmFsaWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcIiR7aW52YWxpZFswXX1cIiBpcyBub3QgYSB2YWxpZCBSZWdFeHAgZmxhZ2ApO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0pKSxcbiAgICAgIGRlZmF1bHQ6IFwiXCJcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkxvZ2ljYWxFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wib3BlcmF0b3JcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIHZpc2l0b3I6IFtcImxlZnRcIiwgXCJyaWdodFwiXSxcbiAgYWxpYXNlczogW1wiQmluYXJ5XCIsIFwiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgb3BlcmF0b3I6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKSguLi5fY29uc3RhbnRzLkxPR0lDQUxfT1BFUkFUT1JTKVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk1lbWJlckV4cHJlc3Npb25cIiwge1xuICBidWlsZGVyOiBbXCJvYmplY3RcIiwgXCJwcm9wZXJ0eVwiLCBcImNvbXB1dGVkXCIsIFwib3B0aW9uYWxcIl0sXG4gIHZpc2l0b3I6IFtcIm9iamVjdFwiLCBcInByb3BlcnR5XCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiTFZhbFwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHtcbiAgICBvYmplY3Q6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIHByb3BlcnR5OiB7XG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBub3JtYWwgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJQcml2YXRlTmFtZVwiKTtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIik7XG5cbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gbm9kZS5jb21wdXRlZCA/IGNvbXB1dGVkIDogbm9ybWFsO1xuICAgICAgICAgIHZhbGlkYXRvcihub2RlLCBrZXksIHZhbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFsaWRhdG9yLm9uZU9mTm9kZVR5cGVzID0gW1wiRXhwcmVzc2lvblwiLCBcIklkZW50aWZpZXJcIiwgXCJQcml2YXRlTmFtZVwiXTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvcjtcbiAgICAgIH0oKVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9LCAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/IHtcbiAgICBvcHRpb25hbDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKHRydWUsIGZhbHNlKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9IDoge30pXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJOZXdFeHByZXNzaW9uXCIsIHtcbiAgaW5oZXJpdHM6IFwiQ2FsbEV4cHJlc3Npb25cIlxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiUHJvZ3JhbVwiLCB7XG4gIHZpc2l0b3I6IFtcImRpcmVjdGl2ZXNcIiwgXCJib2R5XCJdLFxuICBidWlsZGVyOiBbXCJib2R5XCIsIFwiZGlyZWN0aXZlc1wiLCBcInNvdXJjZVR5cGVcIiwgXCJpbnRlcnByZXRlclwiXSxcbiAgZmllbGRzOiB7XG4gICAgc291cmNlRmlsZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH0sXG4gICAgc291cmNlVHlwZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwic2NyaXB0XCIsIFwibW9kdWxlXCIpLFxuICAgICAgZGVmYXVsdDogXCJzY3JpcHRcIlxuICAgIH0sXG4gICAgaW50ZXJwcmV0ZXI6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkludGVycHJldGVyRGlyZWN0aXZlXCIpLFxuICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkaXJlY3RpdmVzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJEaXJlY3RpdmVcIikpKSxcbiAgICAgIGRlZmF1bHQ6IFtdXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIikpKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkJsb2NrXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJPYmplY3RFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wicHJvcGVydGllc1wiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgcHJvcGVydGllczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiT2JqZWN0TWV0aG9kXCIsIFwiT2JqZWN0UHJvcGVydHlcIiwgXCJTcHJlYWRFbGVtZW50XCIpKSlcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk9iamVjdE1ldGhvZFwiLCB7XG4gIGJ1aWxkZXI6IFtcImtpbmRcIiwgXCJrZXlcIiwgXCJwYXJhbXNcIiwgXCJib2R5XCIsIFwiY29tcHV0ZWRcIiwgXCJnZW5lcmF0b3JcIiwgXCJhc3luY1wiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBmdW5jdGlvbkNvbW1vbiwgZnVuY3Rpb25UeXBlQW5ub3RhdGlvbkNvbW1vbiwge1xuICAgIGtpbmQ6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwibWV0aG9kXCIsIFwiZ2V0XCIsIFwic2V0XCIpXG4gICAgfSwgIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyB7XG4gICAgICBkZWZhdWx0OiBcIm1ldGhvZFwiXG4gICAgfSA6IHt9KSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGtleToge1xuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiU3RyaW5nTGl0ZXJhbFwiLCBcIk51bWVyaWNMaXRlcmFsXCIpO1xuICAgICAgICBjb25zdCBjb21wdXRlZCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKTtcblxuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBub2RlLmNvbXB1dGVkID8gY29tcHV0ZWQgOiBub3JtYWw7XG4gICAgICAgICAgdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YWxpZGF0b3Iub25lT2ZOb2RlVHlwZXMgPSBbXCJFeHByZXNzaW9uXCIsIFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiXTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvcjtcbiAgICAgIH0oKVxuICAgIH0sXG4gICAgZGVjb3JhdG9yczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRGVjb3JhdG9yXCIpKSksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiQmxvY2tTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH0pLFxuICB2aXNpdG9yOiBbXCJrZXlcIiwgXCJwYXJhbXNcIiwgXCJib2R5XCIsIFwiZGVjb3JhdG9yc1wiLCBcInJldHVyblR5cGVcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiXSxcbiAgYWxpYXNlczogW1wiVXNlcldoaXRlc3BhY2FibGVcIiwgXCJGdW5jdGlvblwiLCBcIlNjb3BhYmxlXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJGdW5jdGlvblBhcmVudFwiLCBcIk1ldGhvZFwiLCBcIk9iamVjdE1lbWJlclwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiT2JqZWN0UHJvcGVydHlcIiwge1xuICBidWlsZGVyOiBbXCJrZXlcIiwgXCJ2YWx1ZVwiLCBcImNvbXB1dGVkXCIsIFwic2hvcnRoYW5kXCIsIC4uLighcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/IFtcImRlY29yYXRvcnNcIl0gOiBbXSldLFxuICBmaWVsZHM6IHtcbiAgICBjb21wdXRlZDoge1xuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGtleToge1xuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiU3RyaW5nTGl0ZXJhbFwiLCBcIk51bWVyaWNMaXRlcmFsXCIpO1xuICAgICAgICBjb25zdCBjb21wdXRlZCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKTtcblxuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBub2RlLmNvbXB1dGVkID8gY29tcHV0ZWQgOiBub3JtYWw7XG4gICAgICAgICAgdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YWxpZGF0b3Iub25lT2ZOb2RlVHlwZXMgPSBbXCJFeHByZXNzaW9uXCIsIFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiXTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvcjtcbiAgICAgIH0oKVxuICAgIH0sXG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIiwgXCJQYXR0ZXJuTGlrZVwiKVxuICAgIH0sXG4gICAgc2hvcnRoYW5kOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSwgT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHZhbCAmJiBub2RlLmNvbXB1dGVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb3BlcnR5IHNob3J0aGFuZCBvZiBPYmplY3RQcm9wZXJ0eSBjYW5ub3QgYmUgdHJ1ZSBpZiBjb21wdXRlZCBpcyB0cnVlXCIpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiYm9vbGVhblwiXG4gICAgICB9KSwgZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykgcmV0dXJuO1xuXG4gICAgICAgIGlmICh2YWwgJiYgISgwLCBfaXMuZGVmYXVsdCkoXCJJZGVudGlmaWVyXCIsIG5vZGUua2V5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9wZXJ0eSBzaG9ydGhhbmQgb2YgT2JqZWN0UHJvcGVydHkgY2Fubm90IGJlIHRydWUgaWYga2V5IGlzIG5vdCBhbiBJZGVudGlmaWVyXCIpO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBkZWNvcmF0b3JzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJEZWNvcmF0b3JcIikpKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9LFxuICB2aXNpdG9yOiBbXCJrZXlcIiwgXCJ2YWx1ZVwiLCBcImRlY29yYXRvcnNcIl0sXG4gIGFsaWFzZXM6IFtcIlVzZXJXaGl0ZXNwYWNhYmxlXCIsIFwiUHJvcGVydHlcIiwgXCJPYmplY3RNZW1iZXJcIl0sXG4gIHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgcGF0dGVybiA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlBhdHRlcm5cIik7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBhcmVudCwga2V5LCBub2RlKSB7XG4gICAgICBpZiAoIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcpIHJldHVybjtcbiAgICAgIGNvbnN0IHZhbGlkYXRvciA9ICgwLCBfaXMuZGVmYXVsdCkoXCJPYmplY3RQYXR0ZXJuXCIsIHBhcmVudCkgPyBwYXR0ZXJuIDogZXhwcmVzc2lvbjtcbiAgICAgIHZhbGlkYXRvcihub2RlLCBcInZhbHVlXCIsIG5vZGUudmFsdWUpO1xuICAgIH07XG4gIH0oKVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiUmVzdEVsZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJhcmd1bWVudFwiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBidWlsZGVyOiBbXCJhcmd1bWVudFwiXSxcbiAgYWxpYXNlczogW1wiTFZhbFwiLCBcIlBhdHRlcm5MaWtlXCJdLFxuICBkZXByZWNhdGVkQWxpYXM6IFwiUmVzdFByb3BlcnR5XCIsXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgcGF0dGVybkxpa2VDb21tb24sIHtcbiAgICBhcmd1bWVudDoge1xuICAgICAgdmFsaWRhdGU6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJMVmFsXCIpIDogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiUGF0dGVyblwiLCBcIk1lbWJlckV4cHJlc3Npb25cIilcbiAgICB9XG4gIH0pLFxuXG4gIHZhbGlkYXRlKHBhcmVudCwga2V5KSB7XG4gICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSByZXR1cm47XG4gICAgY29uc3QgbWF0Y2ggPSAvKFxcdyspXFxbKFxcZCspXFxdLy5leGVjKGtleSk7XG4gICAgaWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgQmFiZWwgZXJyb3I6IG1hbGZvcm1lZCBrZXkuXCIpO1xuICAgIGNvbnN0IFssIGxpc3RLZXksIGluZGV4XSA9IG1hdGNoO1xuXG4gICAgaWYgKHBhcmVudFtsaXN0S2V5XS5sZW5ndGggPiBpbmRleCArIDEpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFJlc3RFbGVtZW50IG11c3QgYmUgbGFzdCBlbGVtZW50IG9mICR7bGlzdEtleX1gKTtcbiAgICB9XG4gIH1cblxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiUmV0dXJuU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIlRlcm1pbmF0b3JsZXNzXCIsIFwiQ29tcGxldGlvblN0YXRlbWVudFwiXSxcbiAgZmllbGRzOiB7XG4gICAgYXJndW1lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiU2VxdWVuY2VFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvbnNcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb25zOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpKSlcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIkV4cHJlc3Npb25XcmFwcGVyXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJTd2l0Y2hDYXNlXCIsIHtcbiAgdmlzaXRvcjogW1widGVzdFwiLCBcImNvbnNlcXVlbnRcIl0sXG4gIGZpZWxkczoge1xuICAgIHRlc3Q6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgY29uc2VxdWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpKSlcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlN3aXRjaFN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImRpc2NyaW1pbmFudFwiLCBcImNhc2VzXCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJCbG9ja1BhcmVudFwiLCBcIlNjb3BhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBkaXNjcmltaW5hbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGNhc2VzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTd2l0Y2hDYXNlXCIpKSlcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRoaXNFeHByZXNzaW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVGhyb3dTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJhcmd1bWVudFwiXSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiVGVybWluYXRvcmxlc3NcIiwgXCJDb21wbGV0aW9uU3RhdGVtZW50XCJdLFxuICBmaWVsZHM6IHtcbiAgICBhcmd1bWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVHJ5U3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wiYmxvY2tcIiwgXCJoYW5kbGVyXCIsIFwiZmluYWxpemVyXCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIl0sXG4gIGZpZWxkczoge1xuICAgIGJsb2NrOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKSwgT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcpIHJldHVybjtcblxuICAgICAgICBpZiAoIW5vZGUuaGFuZGxlciAmJiAhbm9kZS5maW5hbGl6ZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVHJ5U3RhdGVtZW50IGV4cGVjdHMgZWl0aGVyIGEgaGFuZGxlciBvciBmaW5hbGl6ZXIsIG9yIGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgb25lT2ZOb2RlVHlwZXM6IFtcIkJsb2NrU3RhdGVtZW50XCJdXG4gICAgICB9KSlcbiAgICB9LFxuICAgIGhhbmRsZXI6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiQ2F0Y2hDbGF1c2VcIilcbiAgICB9LFxuICAgIGZpbmFsaXplcjoge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVW5hcnlFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wib3BlcmF0b3JcIiwgXCJhcmd1bWVudFwiLCBcInByZWZpeFwiXSxcbiAgZmllbGRzOiB7XG4gICAgcHJlZml4OiB7XG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBhcmd1bWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgb3BlcmF0b3I6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKSguLi5fY29uc3RhbnRzLlVOQVJZX09QRVJBVE9SUylcbiAgICB9XG4gIH0sXG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJVbmFyeUxpa2VcIiwgXCJFeHByZXNzaW9uXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJVcGRhdGVFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wib3BlcmF0b3JcIiwgXCJhcmd1bWVudFwiLCBcInByZWZpeFwiXSxcbiAgZmllbGRzOiB7XG4gICAgcHJlZml4OiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgYXJndW1lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKSA6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIk1lbWJlckV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIG9wZXJhdG9yOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoLi4uX2NvbnN0YW50cy5VUERBVEVfT1BFUkFUT1JTKVxuICAgIH1cbiAgfSxcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiwge1xuICBidWlsZGVyOiBbXCJraW5kXCIsIFwiZGVjbGFyYXRpb25zXCJdLFxuICB2aXNpdG9yOiBbXCJkZWNsYXJhdGlvbnNcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBkZWNsYXJlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBraW5kOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJ2YXJcIiwgXCJsZXRcIiwgXCJjb25zdFwiKVxuICAgIH0sXG4gICAgZGVjbGFyYXRpb25zOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpKVxuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZShwYXJlbnQsIGtleSwgbm9kZSkge1xuICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykgcmV0dXJuO1xuICAgIGlmICghKDAsIF9pcy5kZWZhdWx0KShcIkZvclhTdGF0ZW1lbnRcIiwgcGFyZW50LCB7XG4gICAgICBsZWZ0OiBub2RlXG4gICAgfSkpIHJldHVybjtcblxuICAgIGlmIChub2RlLmRlY2xhcmF0aW9ucy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4YWN0bHkgb25lIFZhcmlhYmxlRGVjbGFyYXRvciBpcyByZXF1aXJlZCBpbiB0aGUgVmFyaWFibGVEZWNsYXJhdGlvbiBvZiBhICR7cGFyZW50LnR5cGV9YCk7XG4gICAgfVxuICB9XG5cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlZhcmlhYmxlRGVjbGFyYXRvclwiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwiaW5pdFwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6IHtcbiAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykge1xuICAgICAgICAgIHJldHVybiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkxWYWxcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub3JtYWwgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJBcnJheVBhdHRlcm5cIiwgXCJPYmplY3RQYXR0ZXJuXCIpO1xuICAgICAgICBjb25zdCB3aXRob3V0ID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gbm9kZS5pbml0ID8gbm9ybWFsIDogd2l0aG91dDtcbiAgICAgICAgICB2YWxpZGF0b3Iobm9kZSwga2V5LCB2YWwpO1xuICAgICAgICB9O1xuICAgICAgfSgpXG4gICAgfSxcbiAgICBkZWZpbml0ZToge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKVxuICAgIH0sXG4gICAgaW5pdDoge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJXaGlsZVN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcInRlc3RcIiwgXCJib2R5XCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkxvb3BcIiwgXCJXaGlsZVwiLCBcIlNjb3BhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0ZXN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIldpdGhTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJvYmplY3RcIiwgXCJib2R5XCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIl0sXG4gIGZpZWxkczoge1xuICAgIG9iamVjdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpXG4gICAgfVxuICB9XG59KTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY2xhc3NNZXRob2RPckRlY2xhcmVNZXRob2RDb21tb24gPSBleHBvcnRzLmNsYXNzTWV0aG9kT3JQcm9wZXJ0eUNvbW1vbiA9IHZvaWQgMDtcblxudmFyIF91dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcblxudmFyIF9jb3JlID0gcmVxdWlyZShcIi4vY29yZVwiKTtcblxudmFyIF9pcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvaXNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuKDAsIF91dGlscy5kZWZhdWx0KShcIkFzc2lnbm1lbnRQYXR0ZXJuXCIsIHtcbiAgdmlzaXRvcjogW1wibGVmdFwiLCBcInJpZ2h0XCIsIFwiZGVjb3JhdG9yc1wiXSxcbiAgYnVpbGRlcjogW1wibGVmdFwiLCBcInJpZ2h0XCJdLFxuICBhbGlhc2VzOiBbXCJQYXR0ZXJuXCIsIFwiUGF0dGVybkxpa2VcIiwgXCJMVmFsXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIF9jb3JlLnBhdHRlcm5MaWtlQ29tbW9uLCB7XG4gICAgbGVmdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIk9iamVjdFBhdHRlcm5cIiwgXCJBcnJheVBhdHRlcm5cIiwgXCJNZW1iZXJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgZGVjb3JhdG9yczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRGVjb3JhdG9yXCIpKSksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSlcbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkFycmF5UGF0dGVyblwiLCB7XG4gIHZpc2l0b3I6IFtcImVsZW1lbnRzXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGJ1aWxkZXI6IFtcImVsZW1lbnRzXCJdLFxuICBhbGlhc2VzOiBbXCJQYXR0ZXJuXCIsIFwiUGF0dGVybkxpa2VcIiwgXCJMVmFsXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIF9jb3JlLnBhdHRlcm5MaWtlQ29tbW9uLCB7XG4gICAgZWxlbWVudHM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVPclZhbHVlVHlwZSkoXCJudWxsXCIsIFwiUGF0dGVybkxpa2VcIikpKVxuICAgIH0sXG4gICAgZGVjb3JhdG9yczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRGVjb3JhdG9yXCIpKSksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSlcbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wicGFyYW1zXCIsIFwiYm9keVwiLCBcImFzeW5jXCJdLFxuICB2aXNpdG9yOiBbXCJwYXJhbXNcIiwgXCJib2R5XCIsIFwicmV0dXJuVHlwZVwiLCBcInR5cGVQYXJhbWV0ZXJzXCJdLFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIkZ1bmN0aW9uXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJGdW5jdGlvblBhcmVudFwiLCBcIkV4cHJlc3Npb25cIiwgXCJQdXJlaXNoXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIF9jb3JlLmZ1bmN0aW9uQ29tbW9uLCBfY29yZS5mdW5jdGlvblR5cGVBbm5vdGF0aW9uQ29tbW9uLCB7XG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIilcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIsIFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfSlcbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkNsYXNzQm9keVwiLCB7XG4gIHZpc2l0b3I6IFtcImJvZHlcIl0sXG4gIGZpZWxkczoge1xuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkNsYXNzTWV0aG9kXCIsIFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIsIFwiQ2xhc3NQcm9wZXJ0eVwiLCBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIsIFwiVFNEZWNsYXJlTWV0aG9kXCIsIFwiVFNJbmRleFNpZ25hdHVyZVwiKSkpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJDbGFzc0V4cHJlc3Npb25cIiwge1xuICBidWlsZGVyOiBbXCJpZFwiLCBcInN1cGVyQ2xhc3NcIiwgXCJib2R5XCIsIFwiZGVjb3JhdG9yc1wiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJib2R5XCIsIFwic3VwZXJDbGFzc1wiLCBcIm1peGluc1wiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwic3VwZXJUeXBlUGFyYW1ldGVyc1wiLCBcImltcGxlbWVudHNcIiwgXCJkZWNvcmF0b3JzXCJdLFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIkNsYXNzXCIsIFwiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgdHlwZVBhcmFtZXRlcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCBcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIFwiTm9vcFwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJDbGFzc0JvZHlcIilcbiAgICB9LFxuICAgIHN1cGVyQ2xhc3M6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgc3VwZXJUeXBlUGFyYW1ldGVyczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiwgXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGltcGxlbWVudHM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIsIFwiQ2xhc3NJbXBsZW1lbnRzXCIpKSksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgZGVjb3JhdG9yczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRGVjb3JhdG9yXCIpKSksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgbWl4aW5zOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJbnRlcmZhY2VFeHRlbmRzXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkNsYXNzRGVjbGFyYXRpb25cIiwge1xuICBpbmhlcml0czogXCJDbGFzc0V4cHJlc3Npb25cIixcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJDbGFzc1wiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH0sXG4gICAgdHlwZVBhcmFtZXRlcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCBcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIFwiTm9vcFwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJDbGFzc0JvZHlcIilcbiAgICB9LFxuICAgIHN1cGVyQ2xhc3M6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgc3VwZXJUeXBlUGFyYW1ldGVyczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiwgXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGltcGxlbWVudHM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIsIFwiQ2xhc3NJbXBsZW1lbnRzXCIpKSksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgZGVjb3JhdG9yczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRGVjb3JhdG9yXCIpKSksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgbWl4aW5zOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJbnRlcmZhY2VFeHRlbmRzXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGRlY2xhcmU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGFic3RyYWN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9LFxuICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwYXJlbnQsIGtleSwgbm9kZSkge1xuICAgICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSByZXR1cm47XG5cbiAgICAgIGlmICghKDAsIF9pcy5kZWZhdWx0KShcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiLCBwYXJlbnQpKSB7XG4gICAgICAgIGlkZW50aWZpZXIobm9kZSwgXCJpZFwiLCBub2RlLmlkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KClcbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wic291cmNlXCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiLCBcIk1vZHVsZURlY2xhcmF0aW9uXCIsIFwiRXhwb3J0RGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHNvdXJjZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RyaW5nTGl0ZXJhbFwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiZGVjbGFyYXRpb25cIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCIsIFwiTW9kdWxlRGVjbGFyYXRpb25cIiwgXCJFeHBvcnREZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgZGVjbGFyYXRpb246IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiwgXCJUU0RlY2xhcmVGdW5jdGlvblwiLCBcIkNsYXNzRGVjbGFyYXRpb25cIiwgXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiZGVjbGFyYXRpb25cIiwgXCJzcGVjaWZpZXJzXCIsIFwic291cmNlXCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiLCBcIk1vZHVsZURlY2xhcmF0aW9uXCIsIFwiRXhwb3J0RGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGRlY2xhcmF0aW9uOiB7XG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkRlY2xhcmF0aW9uXCIpLCBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICBpZiAoIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcpIHJldHVybjtcblxuICAgICAgICBpZiAodmFsICYmIG5vZGUuc3BlY2lmaWVycy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT25seSBkZWNsYXJhdGlvbiBvciBzcGVjaWZpZXJzIGlzIGFsbG93ZWQgb24gRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBvbmVPZk5vZGVUeXBlczogW1wiRGVjbGFyYXRpb25cIl1cbiAgICAgIH0pLCBmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHZhbCAmJiBub2RlLnNvdXJjZSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgZXhwb3J0IGEgZGVjbGFyYXRpb24gZnJvbSBhIHNvdXJjZVwiKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LFxuICAgIHNwZWNpZmllcnM6IHtcbiAgICAgIGRlZmF1bHQ6IFtdLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qgc291cmNlZCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwb3J0U3BlY2lmaWVyXCIsIFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiLCBcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKTtcbiAgICAgICAgY29uc3Qgc291cmNlbGVzcyA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwb3J0U3BlY2lmaWVyXCIpO1xuICAgICAgICBpZiAoIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcpIHJldHVybiBzb3VyY2VkO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gbm9kZS5zb3VyY2UgPyBzb3VyY2VkIDogc291cmNlbGVzcztcbiAgICAgICAgICB2YWxpZGF0b3Iobm9kZSwga2V5LCB2YWwpO1xuICAgICAgICB9O1xuICAgICAgfSgpKSlcbiAgICB9LFxuICAgIHNvdXJjZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RyaW5nTGl0ZXJhbFwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBleHBvcnRLaW5kOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwidHlwZVwiLCBcInZhbHVlXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFeHBvcnRTcGVjaWZpZXJcIiwge1xuICB2aXNpdG9yOiBbXCJsb2NhbFwiLCBcImV4cG9ydGVkXCJdLFxuICBhbGlhc2VzOiBbXCJNb2R1bGVTcGVjaWZpZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIGxvY2FsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfSxcbiAgICBleHBvcnRlZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRm9yT2ZTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJib2R5XCJdLFxuICBidWlsZGVyOiBbXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJib2R5XCIsIFwiYXdhaXRcIl0sXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiU3RhdGVtZW50XCIsIFwiRm9yXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJMb29wXCIsIFwiRm9yWFN0YXRlbWVudFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbGVmdDoge1xuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSB7XG4gICAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLCBcIkxWYWxcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZWNsYXJhdGlvbiA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcbiAgICAgICAgY29uc3QgbHZhbCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIk1lbWJlckV4cHJlc3Npb25cIiwgXCJBcnJheVBhdHRlcm5cIiwgXCJPYmplY3RQYXR0ZXJuXCIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgICAgaWYgKCgwLCBfaXMuZGVmYXVsdCkoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIHZhbCkpIHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbHZhbChub2RlLCBrZXksIHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSgpXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpXG4gICAgfSxcbiAgICBhd2FpdDoge1xuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkltcG9ydERlY2xhcmF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wic3BlY2lmaWVyc1wiLCBcInNvdXJjZVwiXSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIiwgXCJNb2R1bGVEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgc3BlY2lmaWVyczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSW1wb3J0U3BlY2lmaWVyXCIsIFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiLCBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSkpXG4gICAgfSxcbiAgICBzb3VyY2U6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlN0cmluZ0xpdGVyYWxcIilcbiAgICB9LFxuICAgIGltcG9ydEtpbmQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcInR5cGVcIiwgXCJ0eXBlb2ZcIiwgXCJ2YWx1ZVwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIsIHtcbiAgdmlzaXRvcjogW1wibG9jYWxcIl0sXG4gIGFsaWFzZXM6IFtcIk1vZHVsZVNwZWNpZmllclwiXSxcbiAgZmllbGRzOiB7XG4gICAgbG9jYWw6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiLCB7XG4gIHZpc2l0b3I6IFtcImxvY2FsXCJdLFxuICBhbGlhc2VzOiBbXCJNb2R1bGVTcGVjaWZpZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIGxvY2FsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJJbXBvcnRTcGVjaWZpZXJcIiwge1xuICB2aXNpdG9yOiBbXCJsb2NhbFwiLCBcImltcG9ydGVkXCJdLFxuICBhbGlhc2VzOiBbXCJNb2R1bGVTcGVjaWZpZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIGxvY2FsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfSxcbiAgICBpbXBvcnRlZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH0sXG4gICAgaW1wb3J0S2luZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwidHlwZVwiLCBcInR5cGVvZlwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJNZXRhUHJvcGVydHlcIiwge1xuICB2aXNpdG9yOiBbXCJtZXRhXCIsIFwicHJvcGVydHlcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIG1ldGE6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiksIE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykgcmV0dXJuO1xuICAgICAgICBsZXQgcHJvcGVydHk7XG5cbiAgICAgICAgc3dpdGNoICh2YWwubmFtZSkge1xuICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgcHJvcGVydHkgPSBcInNlbnRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIm5ld1wiOlxuICAgICAgICAgICAgcHJvcGVydHkgPSBcInRhcmdldFwiO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiaW1wb3J0XCI6XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IFwibWV0YVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISgwLCBfaXMuZGVmYXVsdCkoXCJJZGVudGlmaWVyXCIsIG5vZGUucHJvcGVydHksIHtcbiAgICAgICAgICBuYW1lOiBwcm9wZXJ0eVxuICAgICAgICB9KSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnJlY29nbmlzZWQgTWV0YVByb3BlcnR5XCIpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIG9uZU9mTm9kZVR5cGVzOiBbXCJJZGVudGlmaWVyXCJdXG4gICAgICB9KSlcbiAgICB9LFxuICAgIHByb3BlcnR5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcbmNvbnN0IGNsYXNzTWV0aG9kT3JQcm9wZXJ0eUNvbW1vbiA9IHtcbiAgYWJzdHJhY3Q6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9LFxuICBhY2Nlc3NpYmlsaXR5OiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwicHVibGljXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9LFxuICBzdGF0aWM6IHtcbiAgICBkZWZhdWx0OiBmYWxzZVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGRlZmF1bHQ6IGZhbHNlXG4gIH0sXG4gIG9wdGlvbmFsOiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSxcbiAga2V5OiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IG5vcm1hbCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiKTtcbiAgICAgIGNvbnN0IGNvbXB1dGVkID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBub2RlLmNvbXB1dGVkID8gY29tcHV0ZWQgOiBub3JtYWw7XG4gICAgICAgIHZhbGlkYXRvcihub2RlLCBrZXksIHZhbCk7XG4gICAgICB9O1xuICAgIH0oKSwgKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiU3RyaW5nTGl0ZXJhbFwiLCBcIk51bWVyaWNMaXRlcmFsXCIsIFwiRXhwcmVzc2lvblwiKSlcbiAgfVxufTtcbmV4cG9ydHMuY2xhc3NNZXRob2RPclByb3BlcnR5Q29tbW9uID0gY2xhc3NNZXRob2RPclByb3BlcnR5Q29tbW9uO1xuY29uc3QgY2xhc3NNZXRob2RPckRlY2xhcmVNZXRob2RDb21tb24gPSBPYmplY3QuYXNzaWduKHt9LCBfY29yZS5mdW5jdGlvbkNvbW1vbiwgY2xhc3NNZXRob2RPclByb3BlcnR5Q29tbW9uLCB7XG4gIGtpbmQ6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJnZXRcIiwgXCJzZXRcIiwgXCJtZXRob2RcIiwgXCJjb25zdHJ1Y3RvclwiKSxcbiAgICBkZWZhdWx0OiBcIm1ldGhvZFwiXG4gIH0sXG4gIGFjY2Vzczoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIiksICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwicHVibGljXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiKSksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSxcbiAgZGVjb3JhdG9yczoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkRlY29yYXRvclwiKSkpLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH1cbn0pO1xuZXhwb3J0cy5jbGFzc01ldGhvZE9yRGVjbGFyZU1ldGhvZENvbW1vbiA9IGNsYXNzTWV0aG9kT3JEZWNsYXJlTWV0aG9kQ29tbW9uO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkNsYXNzTWV0aG9kXCIsIHtcbiAgYWxpYXNlczogW1wiRnVuY3Rpb25cIiwgXCJTY29wYWJsZVwiLCBcIkJsb2NrUGFyZW50XCIsIFwiRnVuY3Rpb25QYXJlbnRcIiwgXCJNZXRob2RcIl0sXG4gIGJ1aWxkZXI6IFtcImtpbmRcIiwgXCJrZXlcIiwgXCJwYXJhbXNcIiwgXCJib2R5XCIsIFwiY29tcHV0ZWRcIiwgXCJzdGF0aWNcIiwgXCJnZW5lcmF0b3JcIiwgXCJhc3luY1wiXSxcbiAgdmlzaXRvcjogW1wia2V5XCIsIFwicGFyYW1zXCIsIFwiYm9keVwiLCBcImRlY29yYXRvcnNcIiwgXCJyZXR1cm5UeXBlXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgY2xhc3NNZXRob2RPckRlY2xhcmVNZXRob2RDb21tb24sIF9jb3JlLmZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24sIHtcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH1cbiAgfSlcbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk9iamVjdFBhdHRlcm5cIiwge1xuICB2aXNpdG9yOiBbXCJwcm9wZXJ0aWVzXCIsIFwidHlwZUFubm90YXRpb25cIiwgXCJkZWNvcmF0b3JzXCJdLFxuICBidWlsZGVyOiBbXCJwcm9wZXJ0aWVzXCJdLFxuICBhbGlhc2VzOiBbXCJQYXR0ZXJuXCIsIFwiUGF0dGVybkxpa2VcIiwgXCJMVmFsXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIF9jb3JlLnBhdHRlcm5MaWtlQ29tbW9uLCB7XG4gICAgcHJvcGVydGllczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiUmVzdEVsZW1lbnRcIiwgXCJPYmplY3RQcm9wZXJ0eVwiKSkpXG4gICAgfVxuICB9KVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiU3ByZWFkRWxlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJVbmFyeUxpa2VcIl0sXG4gIGRlcHJlY2F0ZWRBbGlhczogXCJTcHJlYWRQcm9wZXJ0eVwiLFxuICBmaWVsZHM6IHtcbiAgICBhcmd1bWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiU3VwZXJcIiwge1xuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIiwge1xuICB2aXNpdG9yOiBbXCJ0YWdcIiwgXCJxdWFzaVwiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgdGFnOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBxdWFzaToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVGVtcGxhdGVMaXRlcmFsXCIpXG4gICAgfSxcbiAgICB0eXBlUGFyYW1ldGVyczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiwgXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRlbXBsYXRlRWxlbWVudFwiLCB7XG4gIGJ1aWxkZXI6IFtcInZhbHVlXCIsIFwidGFpbFwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFNoYXBlKSh7XG4gICAgICAgIHJhdzoge1xuICAgICAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICAgICAgfSxcbiAgICAgICAgY29va2VkOiB7XG4gICAgICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKSxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sXG4gICAgdGFpbDoge1xuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRlbXBsYXRlTGl0ZXJhbFwiLCB7XG4gIHZpc2l0b3I6IFtcInF1YXNpc1wiLCBcImV4cHJlc3Npb25zXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiTGl0ZXJhbFwiXSxcbiAgZmllbGRzOiB7XG4gICAgcXVhc2lzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUZW1wbGF0ZUVsZW1lbnRcIikpKVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIikpLCBmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKG5vZGUucXVhc2lzLmxlbmd0aCAhPT0gdmFsLmxlbmd0aCArIDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBOdW1iZXIgb2YgJHtub2RlLnR5cGV9IHF1YXNpcyBzaG91bGQgYmUgZXhhY3RseSBvbmUgbW9yZSB0aGFuIHRoZSBudW1iZXIgb2YgZXhwcmVzc2lvbnMuXFxuRXhwZWN0ZWQgJHt2YWwubGVuZ3RoICsgMX0gcXVhc2lzIGJ1dCBnb3QgJHtub2RlLnF1YXNpcy5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJZaWVsZEV4cHJlc3Npb25cIiwge1xuICBidWlsZGVyOiBbXCJhcmd1bWVudFwiLCBcImRlbGVnYXRlXCJdLFxuICB2aXNpdG9yOiBbXCJhcmd1bWVudFwiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIlRlcm1pbmF0b3JsZXNzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBkZWxlZ2F0ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksIE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykgcmV0dXJuO1xuXG4gICAgICAgIGlmICh2YWwgJiYgIW5vZGUuYXJndW1lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvcGVydHkgZGVsZWdhdGUgb2YgWWllbGRFeHByZXNzaW9uIGNhbm5vdCBiZSB0cnVlIGlmIHRoZXJlIGlzIG5vIGFyZ3VtZW50XCIpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiYm9vbGVhblwiXG4gICAgICB9KSksXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgYXJndW1lbnQ6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5cbnZhciBfZXMgPSByZXF1aXJlKFwiLi9lczIwMTVcIik7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQXJndW1lbnRQbGFjZWhvbGRlclwiLCB7fSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQXdhaXRFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wiYXJndW1lbnRcIl0sXG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiVGVybWluYXRvcmxlc3NcIl0sXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJCaW5kRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcIm9iamVjdFwiLCBcImNhbGxlZVwiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/IHtcbiAgICBvYmplY3Q6IHtcbiAgICAgIHZhbGlkYXRlOiBPYmplY3QuYXNzaWduKCgpID0+IHt9LCB7XG4gICAgICAgIG9uZU9mTm9kZVR5cGVzOiBbXCJFeHByZXNzaW9uXCJdXG4gICAgICB9KVxuICAgIH0sXG4gICAgY2FsbGVlOiB7XG4gICAgICB2YWxpZGF0ZTogT2JqZWN0LmFzc2lnbigoKSA9PiB7fSwge1xuICAgICAgICBvbmVPZk5vZGVUeXBlczogW1wiRXhwcmVzc2lvblwiXVxuICAgICAgfSlcbiAgICB9XG4gIH0gOiB7XG4gICAgb2JqZWN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBjYWxsZWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkNsYXNzUHJvcGVydHlcIiwge1xuICB2aXNpdG9yOiBbXCJrZXlcIiwgXCJ2YWx1ZVwiLCBcInR5cGVBbm5vdGF0aW9uXCIsIFwiZGVjb3JhdG9yc1wiXSxcbiAgYnVpbGRlcjogW1wia2V5XCIsIFwidmFsdWVcIiwgXCJ0eXBlQW5ub3RhdGlvblwiLCBcImRlY29yYXRvcnNcIiwgXCJjb21wdXRlZFwiLCBcInN0YXRpY1wiXSxcbiAgYWxpYXNlczogW1wiUHJvcGVydHlcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgX2VzLmNsYXNzTWV0aG9kT3JQcm9wZXJ0eUNvbW1vbiwge1xuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGRlZmluaXRlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICB0eXBlQW5ub3RhdGlvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZUFubm90YXRpb25cIiwgXCJUU1R5cGVBbm5vdGF0aW9uXCIsIFwiTm9vcFwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkZWNvcmF0b3JzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJEZWNvcmF0b3JcIikpKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICByZWFkb25seToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgZGVjbGFyZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSlcbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiLCB7XG4gIGJ1aWxkZXI6IFtcIm9iamVjdFwiLCBcInByb3BlcnR5XCIsIFwiY29tcHV0ZWRcIiwgXCJvcHRpb25hbFwiXSxcbiAgdmlzaXRvcjogW1wib2JqZWN0XCIsIFwicHJvcGVydHlcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIG9iamVjdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgcHJvcGVydHk6IHtcbiAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKTtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIik7XG5cbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gbm9kZS5jb21wdXRlZCA/IGNvbXB1dGVkIDogbm9ybWFsO1xuICAgICAgICAgIHZhbGlkYXRvcihub2RlLCBrZXksIHZhbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFsaWRhdG9yLm9uZU9mTm9kZVR5cGVzID0gW1wiRXhwcmVzc2lvblwiLCBcIklkZW50aWZpZXJcIl07XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgICB9KClcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgb3B0aW9uYWw6IHtcbiAgICAgIHZhbGlkYXRlOiAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikgOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLCAoMCwgX3V0aWxzLmFzc2VydE9wdGlvbmFsQ2hhaW5TdGFydCkoKSlcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlBpcGVsaW5lVG9waWNFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wiZXhwcmVzc2lvblwiXSxcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiUGlwZWxpbmVCYXJlRnVuY3Rpb25cIiwge1xuICBidWlsZGVyOiBbXCJjYWxsZWVcIl0sXG4gIHZpc2l0b3I6IFtcImNhbGxlZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgY2FsbGVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJQaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZVwiLCB7XG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiwge1xuICB2aXNpdG9yOiBbXCJjYWxsZWVcIiwgXCJhcmd1bWVudHNcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInR5cGVBcmd1bWVudHNcIl0sXG4gIGJ1aWxkZXI6IFtcImNhbGxlZVwiLCBcImFyZ3VtZW50c1wiLCBcIm9wdGlvbmFsXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBjYWxsZWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGFyZ3VtZW50czoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiLCBcIlNwcmVhZEVsZW1lbnRcIiwgXCJKU1hOYW1lc3BhY2VkTmFtZVwiKSkpXG4gICAgfSxcbiAgICBvcHRpb25hbDoge1xuICAgICAgdmFsaWRhdGU6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSA6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksICgwLCBfdXRpbHMuYXNzZXJ0T3B0aW9uYWxDaGFpblN0YXJ0KSgpKVxuICAgIH0sXG4gICAgdHlwZUFyZ3VtZW50czoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgdHlwZVBhcmFtZXRlcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIiwge1xuICB2aXNpdG9yOiBbXCJrZXlcIiwgXCJ2YWx1ZVwiLCBcImRlY29yYXRvcnNcIl0sXG4gIGJ1aWxkZXI6IFtcImtleVwiLCBcInZhbHVlXCIsIFwiZGVjb3JhdG9yc1wiXSxcbiAgYWxpYXNlczogW1wiUHJvcGVydHlcIiwgXCJQcml2YXRlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBrZXk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlByaXZhdGVOYW1lXCIpXG4gICAgfSxcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkZWNvcmF0b3JzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJEZWNvcmF0b3JcIikpKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJDbGFzc1ByaXZhdGVNZXRob2RcIiwge1xuICBidWlsZGVyOiBbXCJraW5kXCIsIFwia2V5XCIsIFwicGFyYW1zXCIsIFwiYm9keVwiLCBcInN0YXRpY1wiXSxcbiAgdmlzaXRvcjogW1wia2V5XCIsIFwicGFyYW1zXCIsIFwiYm9keVwiLCBcImRlY29yYXRvcnNcIiwgXCJyZXR1cm5UeXBlXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGFsaWFzZXM6IFtcIkZ1bmN0aW9uXCIsIFwiU2NvcGFibGVcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkZ1bmN0aW9uUGFyZW50XCIsIFwiTWV0aG9kXCIsIFwiUHJpdmF0ZVwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBfZXMuY2xhc3NNZXRob2RPckRlY2xhcmVNZXRob2RDb21tb24sIF9jb3JlLmZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24sIHtcbiAgICBrZXk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlByaXZhdGVOYW1lXCIpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH1cbiAgfSlcbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkltcG9ydFwiLCB7XG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkltcG9ydEF0dHJpYnV0ZVwiLCB7XG4gIHZpc2l0b3I6IFtcImtleVwiLCBcInZhbHVlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBrZXk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJEZWNvcmF0b3JcIiwge1xuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJEb0V4cHJlc3Npb25cIiwge1xuICB2aXNpdG9yOiBbXCJib2R5XCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cG9ydGVkXCJdLFxuICBhbGlhc2VzOiBbXCJNb2R1bGVTcGVjaWZpZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cG9ydGVkOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIiwge1xuICB2aXNpdG9yOiBbXCJleHBvcnRlZFwiXSxcbiAgYWxpYXNlczogW1wiTW9kdWxlU3BlY2lmaWVyXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHBvcnRlZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiUHJpdmF0ZU5hbWVcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiXSxcbiAgYWxpYXNlczogW1wiUHJpdmF0ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkJpZ0ludExpdGVyYWxcIiwge1xuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJQdXJlaXNoXCIsIFwiTGl0ZXJhbFwiLCBcIkltbXV0YWJsZVwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiUmVjb3JkRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcInByb3BlcnRpZXNcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIk9iamVjdFByb3BlcnR5XCIsIFwiU3ByZWFkRWxlbWVudFwiKSkpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUdXBsZUV4cHJlc3Npb25cIiwge1xuICBmaWVsZHM6IHtcbiAgICBlbGVtZW50czoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiLCBcIlNwcmVhZEVsZW1lbnRcIikpKSxcbiAgICAgIGRlZmF1bHQ6IFtdXG4gICAgfVxuICB9LFxuICB2aXNpdG9yOiBbXCJlbGVtZW50c1wiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXVxufSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5jb25zdCBkZWZpbmVJbnRlcmZhY2Vpc2hUeXBlID0gKG5hbWUsIHR5cGVQYXJhbWV0ZXJUeXBlID0gXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIikgPT4ge1xuICAoMCwgX3V0aWxzLmRlZmF1bHQpKG5hbWUsIHtcbiAgICBidWlsZGVyOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwiZXh0ZW5kc1wiLCBcImJvZHlcIl0sXG4gICAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcImV4dGVuZHNcIiwgXCJtaXhpbnNcIiwgXCJpbXBsZW1lbnRzXCIsIFwiYm9keVwiXSxcbiAgICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd0RlY2xhcmF0aW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gICAgZmllbGRzOiB7XG4gICAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKSh0eXBlUGFyYW1ldGVyVHlwZSksXG4gICAgICBleHRlbmRzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiSW50ZXJmYWNlRXh0ZW5kc1wiKSksXG4gICAgICBtaXhpbnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJJbnRlcmZhY2VFeHRlbmRzXCIpKSxcbiAgICAgIGltcGxlbWVudHM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJDbGFzc0ltcGxlbWVudHNcIikpLFxuICAgICAgYm9keTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiT2JqZWN0VHlwZUFubm90YXRpb25cIilcbiAgICB9XG4gIH0pO1xufTtcblxuKDAsIF91dGlscy5kZWZhdWx0KShcIkFueVR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dUeXBlXCIsIFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJBcnJheVR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiZWxlbWVudFR5cGVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgZWxlbWVudFR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dUeXBlXCIsIFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJDbGFzc0ltcGxlbWVudHNcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKVxuICB9XG59KTtcbmRlZmluZUludGVyZmFjZWlzaFR5cGUoXCJEZWNsYXJlQ2xhc3NcIik7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRGVjbGFyZUZ1bmN0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93RGVjbGFyYXRpb25cIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgcHJlZGljYXRlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIkRlY2xhcmVkUHJlZGljYXRlXCIpXG4gIH1cbn0pO1xuZGVmaW5lSW50ZXJmYWNlaXNoVHlwZShcIkRlY2xhcmVJbnRlcmZhY2VcIik7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRGVjbGFyZU1vZHVsZVwiLCB7XG4gIGJ1aWxkZXI6IFtcImlkXCIsIFwiYm9keVwiLCBcImtpbmRcIl0sXG4gIHZpc2l0b3I6IFtcImlkXCIsIFwiYm9keVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFtcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCJdKSxcbiAgICBib2R5OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKSxcbiAgICBraW5kOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwiQ29tbW9uSlNcIiwgXCJFU1wiKSlcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIiwge1xuICB2aXNpdG9yOiBbXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVHlwZUFubm90YXRpb25cIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRGVjbGFyZVR5cGVBbGlhc1wiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJyaWdodFwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksXG4gICAgcmlnaHQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkRlY2xhcmVPcGFxdWVUeXBlXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInN1cGVydHlwZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksXG4gICAgc3VwZXJ0eXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkRlY2xhcmVWYXJpYWJsZVwiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd0RlY2xhcmF0aW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcImRlY2xhcmF0aW9uXCIsIFwic3BlY2lmaWVyc1wiLCBcInNvdXJjZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBkZWNsYXJhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJGbG93XCIpLFxuICAgIHNwZWNpZmllcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoW1wiRXhwb3J0U3BlY2lmaWVyXCIsIFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCJdKSksXG4gICAgc291cmNlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlN0cmluZ0xpdGVyYWxcIiksXG4gICAgZGVmYXVsdDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJzb3VyY2VcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93RGVjbGFyYXRpb25cIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgc291cmNlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpLFxuICAgIGV4cG9ydEtpbmQ6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJ0eXBlXCIsIFwidmFsdWVcIikpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkRlY2xhcmVkUHJlZGljYXRlXCIsIHtcbiAgdmlzaXRvcjogW1widmFsdWVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93UHJlZGljYXRlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1wiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFeGlzdHNUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInR5cGVQYXJhbWV0ZXJzXCIsIFwicGFyYW1zXCIsIFwicmVzdFwiLCBcInJldHVyblR5cGVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZVBhcmFtZXRlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpLFxuICAgIHBhcmFtczogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJGdW5jdGlvblR5cGVQYXJhbVwiKSksXG4gICAgcmVzdDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJGdW5jdGlvblR5cGVQYXJhbVwiKSxcbiAgICByZXR1cm5UeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJGdW5jdGlvblR5cGVQYXJhbVwiLCB7XG4gIHZpc2l0b3I6IFtcIm5hbWVcIiwgXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKSxcbiAgICBvcHRpb25hbDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJHZW5lcmljVHlwZUFubm90YXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoW1wiSWRlbnRpZmllclwiLCBcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCJdKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJJbmZlcnJlZFByZWRpY2F0ZVwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93UHJlZGljYXRlXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJJbnRlcmZhY2VFeHRlbmRzXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShbXCJJZGVudGlmaWVyXCIsIFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIl0pLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpXG4gIH1cbn0pO1xuZGVmaW5lSW50ZXJmYWNlaXNoVHlwZShcIkludGVyZmFjZURlY2xhcmF0aW9uXCIpO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkludGVyZmFjZVR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiZXh0ZW5kc1wiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXh0ZW5kczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkludGVyZmFjZUV4dGVuZHNcIikpLFxuICAgIGJvZHk6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1widHlwZXNcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZXM6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiRmxvd1R5cGVcIikpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk1peGVkVHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIiwgXCJGbG93QmFzZUFubm90YXRpb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkVtcHR5VHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIiwgXCJGbG93QmFzZUFubm90YXRpb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYnVpbGRlcjogW1widmFsdWVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcIm51bWJlclwiKSlcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiTnVtYmVyVHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIiwgXCJGbG93QmFzZUFubm90YXRpb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wicHJvcGVydGllc1wiLCBcImluZGV4ZXJzXCIsIFwiY2FsbFByb3BlcnRpZXNcIiwgXCJpbnRlcm5hbFNsb3RzXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIl0sXG4gIGJ1aWxkZXI6IFtcInByb3BlcnRpZXNcIiwgXCJpbmRleGVyc1wiLCBcImNhbGxQcm9wZXJ0aWVzXCIsIFwiaW50ZXJuYWxTbG90c1wiLCBcImV4YWN0XCJdLFxuICBmaWVsZHM6IHtcbiAgICBwcm9wZXJ0aWVzOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShbXCJPYmplY3RUeXBlUHJvcGVydHlcIiwgXCJPYmplY3RUeXBlU3ByZWFkUHJvcGVydHlcIl0pKSxcbiAgICBpbmRleGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIk9iamVjdFR5cGVJbmRleGVyXCIpKSxcbiAgICBjYWxsUHJvcGVydGllczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIikpLFxuICAgIGludGVybmFsU2xvdHM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJPYmplY3RUeXBlSW50ZXJuYWxTbG90XCIpKSxcbiAgICBleGFjdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgaW5leGFjdDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJPYmplY3RUeXBlSW50ZXJuYWxTbG90XCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ2YWx1ZVwiLCBcIm9wdGlvbmFsXCIsIFwic3RhdGljXCIsIFwibWV0aG9kXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiVXNlcldoaXRlc3BhY2FibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHZhbHVlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKSxcbiAgICBvcHRpb25hbDogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSksXG4gICAgc3RhdGljOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKSxcbiAgICBtZXRob2Q6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIiwge1xuICB2aXNpdG9yOiBbXCJ2YWx1ZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIlVzZXJXaGl0ZXNwYWNhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIiksXG4gICAgc3RhdGljOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJPYmplY3RUeXBlSW5kZXhlclwiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwia2V5XCIsIFwidmFsdWVcIiwgXCJ2YXJpYW5jZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIlVzZXJXaGl0ZXNwYWNhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIGtleTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIiksXG4gICAgdmFsdWU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpLFxuICAgIHN0YXRpYzogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSksXG4gICAgdmFyaWFuY2U6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVmFyaWFuY2VcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiT2JqZWN0VHlwZVByb3BlcnR5XCIsIHtcbiAgdmlzaXRvcjogW1wia2V5XCIsIFwidmFsdWVcIiwgXCJ2YXJpYW5jZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIlVzZXJXaGl0ZXNwYWNhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBrZXk6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShbXCJJZGVudGlmaWVyXCIsIFwiU3RyaW5nTGl0ZXJhbFwiXSksXG4gICAgdmFsdWU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpLFxuICAgIGtpbmQ6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwiaW5pdFwiLCBcImdldFwiLCBcInNldFwiKSksXG4gICAgc3RhdGljOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKSxcbiAgICBwcm90bzogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSksXG4gICAgb3B0aW9uYWw6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpLFxuICAgIHZhcmlhbmNlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlZhcmlhbmNlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eVwiLCB7XG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiVXNlcldoaXRlc3BhY2FibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJPcGFxdWVUeXBlXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInN1cGVydHlwZVwiLCBcImltcGx0eXBlXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd0RlY2xhcmF0aW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSxcbiAgICBzdXBlcnR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiRmxvd1R5cGVcIiksXG4gICAgaW1wbHR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJxdWFsaWZpY2F0aW9uXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICBxdWFsaWZpY2F0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoW1wiSWRlbnRpZmllclwiLCBcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCJdKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb25cIiwge1xuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZTogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJTdHJpbmdUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiU3ltYm9sVHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIiwgXCJGbG93QmFzZUFubm90YXRpb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRoaXNUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVHVwbGVUeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInR5cGVzXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIHR5cGVzOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkZsb3dUeXBlXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUeXBlb2ZUeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUeXBlQWxpYXNcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicmlnaHRcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93RGVjbGFyYXRpb25cIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgdHlwZVBhcmFtZXRlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpLFxuICAgIHJpZ2h0OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIl0sXG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVHlwZUNhc3RFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRXhwcmVzc2lvbldyYXBwZXJcIiwgXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJFeHByZXNzaW9uXCIpLFxuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUeXBlQW5ub3RhdGlvblwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUeXBlUGFyYW1ldGVyXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1wiXSxcbiAgdmlzaXRvcjogW1wiYm91bmRcIiwgXCJkZWZhdWx0XCIsIFwidmFyaWFuY2VcIl0sXG4gIGZpZWxkczoge1xuICAgIG5hbWU6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKSksXG4gICAgYm91bmQ6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVHlwZUFubm90YXRpb25cIiksXG4gICAgZGVmYXVsdDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJGbG93VHlwZVwiKSxcbiAgICB2YXJpYW5jZTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJWYXJpYW5jZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93XCJdLFxuICB2aXNpdG9yOiBbXCJwYXJhbXNcIl0sXG4gIGZpZWxkczoge1xuICAgIHBhcmFtczogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJUeXBlUGFyYW1ldGVyXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIl0sXG4gIHZpc2l0b3I6IFtcInBhcmFtc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgcGFyYW1zOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkZsb3dUeXBlXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJVbmlvblR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1widHlwZXNcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZXM6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiRmxvd1R5cGVcIikpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlZhcmlhbmNlXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1wiXSxcbiAgYnVpbGRlcjogW1wia2luZFwiXSxcbiAgZmllbGRzOiB7XG4gICAga2luZDogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJtaW51c1wiLCBcInBsdXNcIikpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlZvaWRUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRW51bURlY2xhcmF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIHZpc2l0b3I6IFtcImlkXCIsIFwiYm9keVwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgYm9keTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFtcIkVudW1Cb29sZWFuQm9keVwiLCBcIkVudW1OdW1iZXJCb2R5XCIsIFwiRW51bVN0cmluZ0JvZHlcIiwgXCJFbnVtU3ltYm9sQm9keVwiXSlcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRW51bUJvb2xlYW5Cb2R5XCIsIHtcbiAgYWxpYXNlczogW1wiRW51bUJvZHlcIl0sXG4gIHZpc2l0b3I6IFtcIm1lbWJlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cGxpY2l0OiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKSxcbiAgICBtZW1iZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiRW51bUJvb2xlYW5NZW1iZXJcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRW51bU51bWJlckJvZHlcIiwge1xuICBhbGlhc2VzOiBbXCJFbnVtQm9keVwiXSxcbiAgdmlzaXRvcjogW1wibWVtYmVyc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwbGljaXQ6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpLFxuICAgIG1lbWJlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJFbnVtTnVtYmVyTWVtYmVyXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkVudW1TdHJpbmdCb2R5XCIsIHtcbiAgYWxpYXNlczogW1wiRW51bUJvZHlcIl0sXG4gIHZpc2l0b3I6IFtcIm1lbWJlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cGxpY2l0OiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKSxcbiAgICBtZW1iZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFtcIkVudW1TdHJpbmdNZW1iZXJcIiwgXCJFbnVtRGVmYXVsdGVkTWVtYmVyXCJdKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFbnVtU3ltYm9sQm9keVwiLCB7XG4gIGFsaWFzZXM6IFtcIkVudW1Cb2R5XCJdLFxuICB2aXNpdG9yOiBbXCJtZW1iZXJzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBtZW1iZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiRW51bURlZmF1bHRlZE1lbWJlclwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFbnVtQm9vbGVhbk1lbWJlclwiLCB7XG4gIGFsaWFzZXM6IFtcIkVudW1NZW1iZXJcIl0sXG4gIHZpc2l0b3I6IFtcImlkXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICBpbml0OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJCb29sZWFuTGl0ZXJhbFwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFbnVtTnVtYmVyTWVtYmVyXCIsIHtcbiAgYWxpYXNlczogW1wiRW51bU1lbWJlclwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJpbml0XCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICBpbml0OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJOdW1lcmljTGl0ZXJhbFwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFbnVtU3RyaW5nTWVtYmVyXCIsIHtcbiAgYWxpYXNlczogW1wiRW51bU1lbWJlclwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJpbml0XCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICBpbml0OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkVudW1EZWZhdWx0ZWRNZW1iZXJcIiwge1xuICBhbGlhc2VzOiBbXCJFbnVtTWVtYmVyXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgfVxufSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWSVNJVE9SX0tFWVNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWxzLlZJU0lUT1JfS0VZUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBTElBU19LRVlTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlscy5BTElBU19LRVlTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZMSVBQRURfQUxJQVNfS0VZU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbHMuRkxJUFBFRF9BTElBU19LRVlTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5PREVfRklFTERTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlscy5OT0RFX0ZJRUxEUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCVUlMREVSX0tFWVNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWxzLkJVSUxERVJfS0VZUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJERVBSRUNBVEVEX0tFWVNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWxzLkRFUFJFQ0FURURfS0VZUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOT0RFX1BBUkVOVF9WQUxJREFUSU9OU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbHMuTk9ERV9QQVJFTlRfVkFMSURBVElPTlM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUExBQ0VIT0xERVJTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9wbGFjZWhvbGRlcnMuUExBQ0VIT0xERVJTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBMQUNFSE9MREVSU19BTElBU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcGxhY2Vob2xkZXJzLlBMQUNFSE9MREVSU19BTElBUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQTEFDRUhPTERFUlNfRkxJUFBFRF9BTElBU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcGxhY2Vob2xkZXJzLlBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTO1xuICB9XG59KTtcbmV4cG9ydHMuVFlQRVMgPSB2b2lkIDA7XG5cbnZhciBfdG9GYXN0UHJvcGVydGllcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInRvLWZhc3QtcHJvcGVydGllc1wiKSk7XG5cbnJlcXVpcmUoXCIuL2NvcmVcIik7XG5cbnJlcXVpcmUoXCIuL2VzMjAxNVwiKTtcblxucmVxdWlyZShcIi4vZmxvd1wiKTtcblxucmVxdWlyZShcIi4vanN4XCIpO1xuXG5yZXF1aXJlKFwiLi9taXNjXCIpO1xuXG5yZXF1aXJlKFwiLi9leHBlcmltZW50YWxcIik7XG5cbnJlcXVpcmUoXCIuL3R5cGVzY3JpcHRcIik7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcblxudmFyIF9wbGFjZWhvbGRlcnMgPSByZXF1aXJlKFwiLi9wbGFjZWhvbGRlcnNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbigwLCBfdG9GYXN0UHJvcGVydGllcy5kZWZhdWx0KShfdXRpbHMuVklTSVRPUl9LRVlTKTtcbigwLCBfdG9GYXN0UHJvcGVydGllcy5kZWZhdWx0KShfdXRpbHMuQUxJQVNfS0VZUyk7XG4oMCwgX3RvRmFzdFByb3BlcnRpZXMuZGVmYXVsdCkoX3V0aWxzLkZMSVBQRURfQUxJQVNfS0VZUyk7XG4oMCwgX3RvRmFzdFByb3BlcnRpZXMuZGVmYXVsdCkoX3V0aWxzLk5PREVfRklFTERTKTtcbigwLCBfdG9GYXN0UHJvcGVydGllcy5kZWZhdWx0KShfdXRpbHMuQlVJTERFUl9LRVlTKTtcbigwLCBfdG9GYXN0UHJvcGVydGllcy5kZWZhdWx0KShfdXRpbHMuREVQUkVDQVRFRF9LRVlTKTtcbigwLCBfdG9GYXN0UHJvcGVydGllcy5kZWZhdWx0KShfcGxhY2Vob2xkZXJzLlBMQUNFSE9MREVSU19BTElBUyk7XG4oMCwgX3RvRmFzdFByb3BlcnRpZXMuZGVmYXVsdCkoX3BsYWNlaG9sZGVycy5QTEFDRUhPTERFUlNfRkxJUFBFRF9BTElBUyk7XG5jb25zdCBUWVBFUyA9IE9iamVjdC5rZXlzKF91dGlscy5WSVNJVE9SX0tFWVMpLmNvbmNhdChPYmplY3Qua2V5cyhfdXRpbHMuRkxJUFBFRF9BTElBU19LRVlTKSkuY29uY2F0KE9iamVjdC5rZXlzKF91dGlscy5ERVBSRUNBVEVEX0tFWVMpKTtcbmV4cG9ydHMuVFlQRVMgPSBUWVBFUzsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF91dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJKU1hBdHRyaWJ1dGVcIiwge1xuICB2aXNpdG9yOiBbXCJuYW1lXCIsIFwidmFsdWVcIl0sXG4gIGFsaWFzZXM6IFtcIkpTWFwiLCBcIkltbXV0YWJsZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYSWRlbnRpZmllclwiLCBcIkpTWE5hbWVzcGFjZWROYW1lXCIpXG4gICAgfSxcbiAgICB2YWx1ZToge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hFbGVtZW50XCIsIFwiSlNYRnJhZ21lbnRcIiwgXCJTdHJpbmdMaXRlcmFsXCIsIFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSlNYQ2xvc2luZ0VsZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJuYW1lXCJdLFxuICBhbGlhc2VzOiBbXCJKU1hcIiwgXCJJbW11dGFibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWElkZW50aWZpZXJcIiwgXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIsIFwiSlNYTmFtZXNwYWNlZE5hbWVcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkpTWEVsZW1lbnRcIiwge1xuICBidWlsZGVyOiBbXCJvcGVuaW5nRWxlbWVudFwiLCBcImNsb3NpbmdFbGVtZW50XCIsIFwiY2hpbGRyZW5cIiwgXCJzZWxmQ2xvc2luZ1wiXSxcbiAgdmlzaXRvcjogW1wib3BlbmluZ0VsZW1lbnRcIiwgXCJjaGlsZHJlblwiLCBcImNsb3NpbmdFbGVtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJKU1hcIiwgXCJJbW11dGFibGVcIiwgXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBvcGVuaW5nRWxlbWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYT3BlbmluZ0VsZW1lbnRcIilcbiAgICB9LFxuICAgIGNsb3NpbmdFbGVtZW50OiB7XG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWENsb3NpbmdFbGVtZW50XCIpXG4gICAgfSxcbiAgICBjaGlsZHJlbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYVGV4dFwiLCBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiwgXCJKU1hTcHJlYWRDaGlsZFwiLCBcIkpTWEVsZW1lbnRcIiwgXCJKU1hGcmFnbWVudFwiKSkpXG4gICAgfSxcbiAgICBzZWxmQ2xvc2luZzoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSlNYRW1wdHlFeHByZXNzaW9uXCIsIHtcbiAgYWxpYXNlczogW1wiSlNYXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIsIHtcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiXSxcbiAgYWxpYXNlczogW1wiSlNYXCIsIFwiSW1tdXRhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIsIFwiSlNYRW1wdHlFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJKU1hTcHJlYWRDaGlsZFwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25cIl0sXG4gIGFsaWFzZXM6IFtcIkpTWFwiLCBcIkltbXV0YWJsZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSlNYSWRlbnRpZmllclwiLCB7XG4gIGJ1aWxkZXI6IFtcIm5hbWVcIl0sXG4gIGFsaWFzZXM6IFtcIkpTWFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcIm9iamVjdFwiLCBcInByb3BlcnR5XCJdLFxuICBhbGlhc2VzOiBbXCJKU1hcIl0sXG4gIGZpZWxkczoge1xuICAgIG9iamVjdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiLCBcIkpTWElkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIHByb3BlcnR5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJKU1hOYW1lc3BhY2VkTmFtZVwiLCB7XG4gIHZpc2l0b3I6IFtcIm5hbWVzcGFjZVwiLCBcIm5hbWVcIl0sXG4gIGFsaWFzZXM6IFtcIkpTWFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZXNwYWNlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hJZGVudGlmaWVyXCIpXG4gICAgfSxcbiAgICBuYW1lOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJKU1hPcGVuaW5nRWxlbWVudFwiLCB7XG4gIGJ1aWxkZXI6IFtcIm5hbWVcIiwgXCJhdHRyaWJ1dGVzXCIsIFwic2VsZkNsb3NpbmdcIl0sXG4gIHZpc2l0b3I6IFtcIm5hbWVcIiwgXCJhdHRyaWJ1dGVzXCJdLFxuICBhbGlhc2VzOiBbXCJKU1hcIiwgXCJJbW11dGFibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWElkZW50aWZpZXJcIiwgXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIsIFwiSlNYTmFtZXNwYWNlZE5hbWVcIilcbiAgICB9LFxuICAgIHNlbGZDbG9zaW5nOiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYQXR0cmlidXRlXCIsIFwiSlNYU3ByZWFkQXR0cmlidXRlXCIpKSlcbiAgICB9LFxuICAgIHR5cGVQYXJhbWV0ZXJzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiLCBcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSlNYU3ByZWFkQXR0cmlidXRlXCIsIHtcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIkpTWFwiXSxcbiAgZmllbGRzOiB7XG4gICAgYXJndW1lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkpTWFRleHRcIiwge1xuICBhbGlhc2VzOiBbXCJKU1hcIiwgXCJJbW11dGFibGVcIl0sXG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSlNYRnJhZ21lbnRcIiwge1xuICBidWlsZGVyOiBbXCJvcGVuaW5nRnJhZ21lbnRcIiwgXCJjbG9zaW5nRnJhZ21lbnRcIiwgXCJjaGlsZHJlblwiXSxcbiAgdmlzaXRvcjogW1wib3BlbmluZ0ZyYWdtZW50XCIsIFwiY2hpbGRyZW5cIiwgXCJjbG9zaW5nRnJhZ21lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIkpTWFwiLCBcIkltbXV0YWJsZVwiLCBcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIG9wZW5pbmdGcmFnbWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYT3BlbmluZ0ZyYWdtZW50XCIpXG4gICAgfSxcbiAgICBjbG9zaW5nRnJhZ21lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWENsb3NpbmdGcmFnbWVudFwiKVxuICAgIH0sXG4gICAgY2hpbGRyZW46IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWFRleHRcIiwgXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIsIFwiSlNYU3ByZWFkQ2hpbGRcIiwgXCJKU1hFbGVtZW50XCIsIFwiSlNYRnJhZ21lbnRcIikpKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSlNYT3BlbmluZ0ZyYWdtZW50XCIsIHtcbiAgYWxpYXNlczogW1wiSlNYXCIsIFwiSW1tdXRhYmxlXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJKU1hDbG9zaW5nRnJhZ21lbnRcIiwge1xuICBhbGlhc2VzOiBbXCJKU1hcIiwgXCJJbW11dGFibGVcIl1cbn0pOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3V0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuXG52YXIgX3BsYWNlaG9sZGVycyA9IHJlcXVpcmUoXCIuL3BsYWNlaG9sZGVyc1wiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJOb29wXCIsIHtcbiAgdmlzaXRvcjogW11cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlBsYWNlaG9sZGVyXCIsIHtcbiAgdmlzaXRvcjogW10sXG4gIGJ1aWxkZXI6IFtcImV4cGVjdGVkTm9kZVwiLCBcIm5hbWVcIl0sXG4gIGZpZWxkczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIGV4cGVjdGVkTm9kZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKC4uLl9wbGFjZWhvbGRlcnMuUExBQ0VIT0xERVJTKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCIsIHtcbiAgYnVpbGRlcjogW1wibmFtZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH1cbiAgfVxufSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTID0gZXhwb3J0cy5QTEFDRUhPTERFUlNfQUxJQVMgPSBleHBvcnRzLlBMQUNFSE9MREVSUyA9IHZvaWQgMDtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG5jb25zdCBQTEFDRUhPTERFUlMgPSBbXCJJZGVudGlmaWVyXCIsIFwiU3RyaW5nTGl0ZXJhbFwiLCBcIkV4cHJlc3Npb25cIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiLCBcIkJsb2NrU3RhdGVtZW50XCIsIFwiQ2xhc3NCb2R5XCIsIFwiUGF0dGVyblwiXTtcbmV4cG9ydHMuUExBQ0VIT0xERVJTID0gUExBQ0VIT0xERVJTO1xuY29uc3QgUExBQ0VIT0xERVJTX0FMSUFTID0ge1xuICBEZWNsYXJhdGlvbjogW1wiU3RhdGVtZW50XCJdLFxuICBQYXR0ZXJuOiBbXCJQYXR0ZXJuTGlrZVwiLCBcIkxWYWxcIl1cbn07XG5leHBvcnRzLlBMQUNFSE9MREVSU19BTElBUyA9IFBMQUNFSE9MREVSU19BTElBUztcblxuZm9yIChjb25zdCB0eXBlIG9mIFBMQUNFSE9MREVSUykge1xuICBjb25zdCBhbGlhcyA9IF91dGlscy5BTElBU19LRVlTW3R5cGVdO1xuICBpZiAoYWxpYXMgPT0gbnVsbCA/IHZvaWQgMCA6IGFsaWFzLmxlbmd0aCkgUExBQ0VIT0xERVJTX0FMSUFTW3R5cGVdID0gYWxpYXM7XG59XG5cbmNvbnN0IFBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTID0ge307XG5leHBvcnRzLlBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTID0gUExBQ0VIT0xERVJTX0ZMSVBQRURfQUxJQVM7XG5PYmplY3Qua2V5cyhQTEFDRUhPTERFUlNfQUxJQVMpLmZvckVhY2godHlwZSA9PiB7XG4gIFBMQUNFSE9MREVSU19BTElBU1t0eXBlXS5mb3JFYWNoKGFsaWFzID0+IHtcbiAgICBpZiAoIU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKFBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTLCBhbGlhcykpIHtcbiAgICAgIFBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTW2FsaWFzXSA9IFtdO1xuICAgIH1cblxuICAgIFBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTW2FsaWFzXS5wdXNoKHR5cGUpO1xuICB9KTtcbn0pOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3V0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuXG52YXIgX2NvcmUgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuXG52YXIgX2VzID0gcmVxdWlyZShcIi4vZXMyMDE1XCIpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuY29uc3QgYm9vbCA9ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIik7XG5jb25zdCB0U0Z1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24gPSB7XG4gIHJldHVyblR5cGU6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUU1R5cGVBbm5vdGF0aW9uXCIsIFwiTm9vcFwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9LFxuICB0eXBlUGFyYW1ldGVyczoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIFwiTm9vcFwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9XG59O1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTUGFyYW1ldGVyUHJvcGVydHlcIiwge1xuICBhbGlhc2VzOiBbXCJMVmFsXCJdLFxuICB2aXNpdG9yOiBbXCJwYXJhbWV0ZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIGFjY2Vzc2liaWxpdHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcInB1YmxpY1wiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgcmVhZG9ubHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHBhcmFtZXRlcjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0RlY2xhcmVGdW5jdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicGFyYW1zXCIsIFwicmV0dXJuVHlwZVwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBfY29yZS5mdW5jdGlvbkRlY2xhcmF0aW9uQ29tbW9uLCB0U0Z1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24pXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0RlY2xhcmVNZXRob2RcIiwge1xuICB2aXNpdG9yOiBbXCJkZWNvcmF0b3JzXCIsIFwia2V5XCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJwYXJhbXNcIiwgXCJyZXR1cm5UeXBlXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIF9lcy5jbGFzc01ldGhvZE9yRGVjbGFyZU1ldGhvZENvbW1vbiwgdFNGdW5jdGlvblR5cGVBbm5vdGF0aW9uQ29tbW9uKVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNRdWFsaWZpZWROYW1lXCIsIHtcbiAgYWxpYXNlczogW1wiVFNFbnRpdHlOYW1lXCJdLFxuICB2aXNpdG9yOiBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIGZpZWxkczoge1xuICAgIGxlZnQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTRW50aXR5TmFtZVwiKSxcbiAgICByaWdodDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICB9XG59KTtcbmNvbnN0IHNpZ25hdHVyZURlY2xhcmF0aW9uQ29tbW9uID0ge1xuICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSxcbiAgcGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShbXCJJZGVudGlmaWVyXCIsIFwiUmVzdEVsZW1lbnRcIl0pLFxuICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVBbm5vdGF0aW9uXCIpXG59O1xuY29uc3QgY2FsbENvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uID0ge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVFbGVtZW50XCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInBhcmFtZXRlcnNcIiwgXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgZmllbGRzOiBzaWduYXR1cmVEZWNsYXJhdGlvbkNvbW1vblxufTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvblwiLCBjYWxsQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb24pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb25cIiwgY2FsbENvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uKTtcbmNvbnN0IG5hbWVkVHlwZUVsZW1lbnRDb21tb24gPSB7XG4gIGtleTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgY29tcHV0ZWQ6ICgwLCBfdXRpbHMudmFsaWRhdGUpKGJvb2wpLFxuICBvcHRpb25hbDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKShib29sKVxufTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1Byb3BlcnR5U2lnbmF0dXJlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlRWxlbWVudFwiXSxcbiAgdmlzaXRvcjogW1wia2V5XCIsIFwidHlwZUFubm90YXRpb25cIiwgXCJpbml0aWFsaXplclwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBuYW1lZFR5cGVFbGVtZW50Q29tbW9uLCB7XG4gICAgcmVhZG9ubHk6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbCksXG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVFNUeXBlQW5ub3RhdGlvblwiKSxcbiAgICBpbml0aWFsaXplcjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gIH0pXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU01ldGhvZFNpZ25hdHVyZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZUVsZW1lbnRcIl0sXG4gIHZpc2l0b3I6IFtcImtleVwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicGFyYW1ldGVyc1wiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIHNpZ25hdHVyZURlY2xhcmF0aW9uQ29tbW9uLCBuYW1lZFR5cGVFbGVtZW50Q29tbW9uKVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNJbmRleFNpZ25hdHVyZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZUVsZW1lbnRcIl0sXG4gIHZpc2l0b3I6IFtcInBhcmFtZXRlcnNcIiwgXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgcmVhZG9ubHk6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbCksXG4gICAgcGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVFNUeXBlQW5ub3RhdGlvblwiKVxuICB9XG59KTtcbmNvbnN0IHRzS2V5d29yZFR5cGVzID0gW1wiVFNBbnlLZXl3b3JkXCIsIFwiVFNCb29sZWFuS2V5d29yZFwiLCBcIlRTQmlnSW50S2V5d29yZFwiLCBcIlRTTmV2ZXJLZXl3b3JkXCIsIFwiVFNOdWxsS2V5d29yZFwiLCBcIlRTTnVtYmVyS2V5d29yZFwiLCBcIlRTT2JqZWN0S2V5d29yZFwiLCBcIlRTU3RyaW5nS2V5d29yZFwiLCBcIlRTU3ltYm9sS2V5d29yZFwiLCBcIlRTVW5kZWZpbmVkS2V5d29yZFwiLCBcIlRTVW5rbm93bktleXdvcmRcIiwgXCJUU1ZvaWRLZXl3b3JkXCJdO1xuXG5mb3IgKGNvbnN0IHR5cGUgb2YgdHNLZXl3b3JkVHlwZXMpIHtcbiAgKDAsIF91dGlscy5kZWZhdWx0KSh0eXBlLCB7XG4gICAgYWxpYXNlczogW1wiVFNUeXBlXCIsIFwiVFNCYXNlVHlwZVwiXSxcbiAgICB2aXNpdG9yOiBbXSxcbiAgICBmaWVsZHM6IHt9XG4gIH0pO1xufVxuXG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNUaGlzVHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiLCBcIlRTQmFzZVR5cGVcIl0sXG4gIHZpc2l0b3I6IFtdLFxuICBmaWVsZHM6IHt9XG59KTtcbmNvbnN0IGZuT3JDdHIgPSB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1widHlwZVBhcmFtZXRlcnNcIiwgXCJwYXJhbWV0ZXJzXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczogc2lnbmF0dXJlRGVjbGFyYXRpb25Db21tb25cbn07XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNGdW5jdGlvblR5cGVcIiwgZm5PckN0cik7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNDb25zdHJ1Y3RvclR5cGVcIiwgZm5PckN0cik7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNUeXBlUmVmZXJlbmNlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlTmFtZVwiLCBcInR5cGVQYXJhbWV0ZXJzXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlTmFtZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNFbnRpdHlOYW1lXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNUeXBlUHJlZGljYXRlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJwYXJhbWV0ZXJOYW1lXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGJ1aWxkZXI6IFtcInBhcmFtZXRlck5hbWVcIiwgXCJ0eXBlQW5ub3RhdGlvblwiLCBcImFzc2VydHNcIl0sXG4gIGZpZWxkczoge1xuICAgIHBhcmFtZXRlck5hbWU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShbXCJJZGVudGlmaWVyXCIsIFwiVFNUaGlzVHlwZVwiXSksXG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVFNUeXBlQW5ub3RhdGlvblwiKSxcbiAgICBhc3NlcnRzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTVHlwZVF1ZXJ5XCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJleHByTmFtZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwck5hbWU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShbXCJUU0VudGl0eU5hbWVcIiwgXCJUU0ltcG9ydFR5cGVcIl0pXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTVHlwZUxpdGVyYWxcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcIm1lbWJlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIG1lbWJlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJUU1R5cGVFbGVtZW50XCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTQXJyYXlUeXBlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJlbGVtZW50VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgZWxlbWVudFR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1R1cGxlVHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1wiZWxlbWVudFR5cGVzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBlbGVtZW50VHlwZXM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNPcHRpb25hbFR5cGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTUmVzdFR5cGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpXG4gIH1cbn0pO1xuY29uc3QgdW5pb25PckludGVyc2VjdGlvbiA9IHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZXM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1VuaW9uVHlwZVwiLCB1bmlvbk9ySW50ZXJzZWN0aW9uKTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0ludGVyc2VjdGlvblR5cGVcIiwgdW5pb25PckludGVyc2VjdGlvbik7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNDb25kaXRpb25hbFR5cGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcImNoZWNrVHlwZVwiLCBcImV4dGVuZHNUeXBlXCIsIFwidHJ1ZVR5cGVcIiwgXCJmYWxzZVR5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGNoZWNrVHlwZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpLFxuICAgIGV4dGVuZHNUeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIiksXG4gICAgdHJ1ZVR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKSxcbiAgICBmYWxzZVR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0luZmVyVHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1widHlwZVBhcmFtZXRlclwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZVBhcmFtZXRlcjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlUGFyYW1ldGVyXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTUGFyZW50aGVzaXplZFR5cGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTVHlwZU9wZXJhdG9yXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgb3BlcmF0b3I6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKSksXG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0luZGV4ZWRBY2Nlc3NUeXBlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJvYmplY3RUeXBlXCIsIFwiaW5kZXhUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBvYmplY3RUeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIiksXG4gICAgaW5kZXhUeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNNYXBwZWRUeXBlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlUGFyYW1ldGVyXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHJlYWRvbmx5OiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpLFxuICAgIHR5cGVQYXJhbWV0ZXI6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVBhcmFtZXRlclwiKSxcbiAgICBvcHRpb25hbDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKShib29sKSxcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNMaXRlcmFsVHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiLCBcIlRTQmFzZVR5cGVcIl0sXG4gIHZpc2l0b3I6IFtcImxpdGVyYWxcIl0sXG4gIGZpZWxkczoge1xuICAgIGxpdGVyYWw6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShbXCJOdW1lcmljTGl0ZXJhbFwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJCb29sZWFuTGl0ZXJhbFwiLCBcIkJpZ0ludExpdGVyYWxcIl0pXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTRW50aXR5TmFtZVwiKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcImV4dGVuZHNcIiwgXCJib2R5XCJdLFxuICBmaWVsZHM6IHtcbiAgICBkZWNsYXJlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpLFxuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpLFxuICAgIGV4dGVuZHM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50c1wiKSksXG4gICAgYm9keTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNJbnRlcmZhY2VCb2R5XCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTSW50ZXJmYWNlQm9keVwiLCB7XG4gIHZpc2l0b3I6IFtcImJvZHlcIl0sXG4gIGZpZWxkczoge1xuICAgIGJvZHk6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJUU1R5cGVFbGVtZW50XCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBkZWNsYXJlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpLFxuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpLFxuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNBc0V4cHJlc3Npb25cIiwge1xuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkV4cHJlc3Npb25cIiksXG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1R5cGVBc3NlcnRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlQW5ub3RhdGlvblwiLCBcImV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIiksXG4gICAgZXhwcmVzc2lvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0VudW1EZWNsYXJhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcIm1lbWJlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIGRlY2xhcmU6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbCksXG4gICAgY29uc3Q6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbCksXG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgbWVtYmVyczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIlRTRW51bU1lbWJlclwiKSxcbiAgICBpbml0aWFsaXplcjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTRW51bU1lbWJlclwiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwiaW5pdGlhbGl6ZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoW1wiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIl0pLFxuICAgIGluaXRpYWxpemVyOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcImJvZHlcIl0sXG4gIGZpZWxkczoge1xuICAgIGRlY2xhcmU6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbCksXG4gICAgZ2xvYmFsOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpLFxuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoW1wiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIl0pLFxuICAgIGJvZHk6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShbXCJUU01vZHVsZUJsb2NrXCIsIFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiXSlcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNNb2R1bGVCbG9ja1wiLCB7XG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiQmxvY2tcIiwgXCJCbG9ja1BhcmVudFwiXSxcbiAgdmlzaXRvcjogW1wiYm9keVwiXSxcbiAgZmllbGRzOiB7XG4gICAgYm9keTogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIlN0YXRlbWVudFwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0ltcG9ydFR5cGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCIsIFwicXVhbGlmaWVyXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpLFxuICAgIHF1YWxpZmllcjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU0VudGl0eU5hbWVcIiksXG4gICAgdHlwZVBhcmFtZXRlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcIm1vZHVsZVJlZmVyZW5jZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgaXNFeHBvcnQ6ICgwLCBfdXRpbHMudmFsaWRhdGUpKGJvb2wpLFxuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIG1vZHVsZVJlZmVyZW5jZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFtcIlRTRW50aXR5TmFtZVwiLCBcIlRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2VcIl0pXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2VcIiwge1xuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTTm9uTnVsbEV4cHJlc3Npb25cIiwge1xuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTRXhwb3J0QXNzaWdubWVudFwiLCB7XG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiXSxcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNUeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlQW5ub3RhdGlvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVFNUeXBlXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wicGFyYW1zXCJdLFxuICBmaWVsZHM6IHtcbiAgICBwYXJhbXM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlRTVHlwZVwiKSkpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInBhcmFtc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgcGFyYW1zOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJcIikpKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNUeXBlUGFyYW1ldGVyXCIsIHtcbiAgYnVpbGRlcjogW1wiY29uc3RyYWludFwiLCBcImRlZmF1bHRcIiwgXCJuYW1lXCJdLFxuICB2aXNpdG9yOiBbXCJjb25zdHJhaW50XCIsIFwiZGVmYXVsdFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH0sXG4gICAgY29uc3RyYWludDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVFNUeXBlXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlRTVHlwZVwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbmV4cG9ydHMudHlwZUlzID0gdHlwZUlzO1xuZXhwb3J0cy52YWxpZGF0ZVR5cGUgPSB2YWxpZGF0ZVR5cGU7XG5leHBvcnRzLnZhbGlkYXRlT3B0aW9uYWwgPSB2YWxpZGF0ZU9wdGlvbmFsO1xuZXhwb3J0cy52YWxpZGF0ZU9wdGlvbmFsVHlwZSA9IHZhbGlkYXRlT3B0aW9uYWxUeXBlO1xuZXhwb3J0cy5hcnJheU9mID0gYXJyYXlPZjtcbmV4cG9ydHMuYXJyYXlPZlR5cGUgPSBhcnJheU9mVHlwZTtcbmV4cG9ydHMudmFsaWRhdGVBcnJheU9mVHlwZSA9IHZhbGlkYXRlQXJyYXlPZlR5cGU7XG5leHBvcnRzLmFzc2VydEVhY2ggPSBhc3NlcnRFYWNoO1xuZXhwb3J0cy5hc3NlcnRPbmVPZiA9IGFzc2VydE9uZU9mO1xuZXhwb3J0cy5hc3NlcnROb2RlVHlwZSA9IGFzc2VydE5vZGVUeXBlO1xuZXhwb3J0cy5hc3NlcnROb2RlT3JWYWx1ZVR5cGUgPSBhc3NlcnROb2RlT3JWYWx1ZVR5cGU7XG5leHBvcnRzLmFzc2VydFZhbHVlVHlwZSA9IGFzc2VydFZhbHVlVHlwZTtcbmV4cG9ydHMuYXNzZXJ0U2hhcGUgPSBhc3NlcnRTaGFwZTtcbmV4cG9ydHMuYXNzZXJ0T3B0aW9uYWxDaGFpblN0YXJ0ID0gYXNzZXJ0T3B0aW9uYWxDaGFpblN0YXJ0O1xuZXhwb3J0cy5jaGFpbiA9IGNoYWluO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmaW5lVHlwZTtcbmV4cG9ydHMuTk9ERV9QQVJFTlRfVkFMSURBVElPTlMgPSBleHBvcnRzLkRFUFJFQ0FURURfS0VZUyA9IGV4cG9ydHMuQlVJTERFUl9LRVlTID0gZXhwb3J0cy5OT0RFX0ZJRUxEUyA9IGV4cG9ydHMuRkxJUFBFRF9BTElBU19LRVlTID0gZXhwb3J0cy5BTElBU19LRVlTID0gZXhwb3J0cy5WSVNJVE9SX0tFWVMgPSB2b2lkIDA7XG5cbnZhciBfaXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2lzXCIpKTtcblxudmFyIF92YWxpZGF0ZSA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL3ZhbGlkYXRlXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCBWSVNJVE9SX0tFWVMgPSB7fTtcbmV4cG9ydHMuVklTSVRPUl9LRVlTID0gVklTSVRPUl9LRVlTO1xuY29uc3QgQUxJQVNfS0VZUyA9IHt9O1xuZXhwb3J0cy5BTElBU19LRVlTID0gQUxJQVNfS0VZUztcbmNvbnN0IEZMSVBQRURfQUxJQVNfS0VZUyA9IHt9O1xuZXhwb3J0cy5GTElQUEVEX0FMSUFTX0tFWVMgPSBGTElQUEVEX0FMSUFTX0tFWVM7XG5jb25zdCBOT0RFX0ZJRUxEUyA9IHt9O1xuZXhwb3J0cy5OT0RFX0ZJRUxEUyA9IE5PREVfRklFTERTO1xuY29uc3QgQlVJTERFUl9LRVlTID0ge307XG5leHBvcnRzLkJVSUxERVJfS0VZUyA9IEJVSUxERVJfS0VZUztcbmNvbnN0IERFUFJFQ0FURURfS0VZUyA9IHt9O1xuZXhwb3J0cy5ERVBSRUNBVEVEX0tFWVMgPSBERVBSRUNBVEVEX0tFWVM7XG5jb25zdCBOT0RFX1BBUkVOVF9WQUxJREFUSU9OUyA9IHt9O1xuZXhwb3J0cy5OT0RFX1BBUkVOVF9WQUxJREFUSU9OUyA9IE5PREVfUEFSRU5UX1ZBTElEQVRJT05TO1xuXG5mdW5jdGlvbiBnZXRUeXBlKHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGUodmFsaWRhdGUpIHtcbiAgcmV0dXJuIHtcbiAgICB2YWxpZGF0ZVxuICB9O1xufVxuXG5mdW5jdGlvbiB0eXBlSXModHlwZU5hbWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlTmFtZSA9PT0gXCJzdHJpbmdcIiA/IGFzc2VydE5vZGVUeXBlKHR5cGVOYW1lKSA6IGFzc2VydE5vZGVUeXBlKC4uLnR5cGVOYW1lKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlKHR5cGVOYW1lKSB7XG4gIHJldHVybiB2YWxpZGF0ZSh0eXBlSXModHlwZU5hbWUpKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25hbCh2YWxpZGF0ZSkge1xuICByZXR1cm4ge1xuICAgIHZhbGlkYXRlLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9uYWxUeXBlKHR5cGVOYW1lKSB7XG4gIHJldHVybiB7XG4gICAgdmFsaWRhdGU6IHR5cGVJcyh0eXBlTmFtZSksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXJyYXlPZihlbGVtZW50VHlwZSkge1xuICByZXR1cm4gY2hhaW4oYXNzZXJ0VmFsdWVUeXBlKFwiYXJyYXlcIiksIGFzc2VydEVhY2goZWxlbWVudFR5cGUpKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlPZlR5cGUodHlwZU5hbWUpIHtcbiAgcmV0dXJuIGFycmF5T2YodHlwZUlzKHR5cGVOYW1lKSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQXJyYXlPZlR5cGUodHlwZU5hbWUpIHtcbiAgcmV0dXJuIHZhbGlkYXRlKGFycmF5T2ZUeXBlKHR5cGVOYW1lKSk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEVhY2goY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHJldHVybjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdWJrZXkgPSBgJHtrZXl9WyR7aX1dYDtcbiAgICAgIGNvbnN0IHYgPSB2YWxbaV07XG4gICAgICBjYWxsYmFjayhub2RlLCBzdWJrZXksIHYpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcpICgwLCBfdmFsaWRhdGUudmFsaWRhdGVDaGlsZCkobm9kZSwgc3Via2V5LCB2KTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0b3IuZWFjaCA9IGNhbGxiYWNrO1xuICByZXR1cm4gdmFsaWRhdG9yO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRPbmVPZiguLi52YWx1ZXMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUobm9kZSwga2V5LCB2YWwpIHtcbiAgICBpZiAodmFsdWVzLmluZGV4T2YodmFsKSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFByb3BlcnR5ICR7a2V5fSBleHBlY3RlZCB2YWx1ZSB0byBiZSBvbmUgb2YgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZXMpfSBidXQgZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsKX1gKTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZS5vbmVPZiA9IHZhbHVlcztcbiAgcmV0dXJuIHZhbGlkYXRlO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROb2RlVHlwZSguLi50eXBlcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShub2RlLCBrZXksIHZhbCkge1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlcykge1xuICAgICAgaWYgKCgwLCBfaXMuZGVmYXVsdCkodHlwZSwgdmFsKSkge1xuICAgICAgICAoMCwgX3ZhbGlkYXRlLnZhbGlkYXRlQ2hpbGQpKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFByb3BlcnR5ICR7a2V5fSBvZiAke25vZGUudHlwZX0gZXhwZWN0ZWQgbm9kZSB0byBiZSBvZiBhIHR5cGUgJHtKU09OLnN0cmluZ2lmeSh0eXBlcyl9IGJ1dCBpbnN0ZWFkIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCA9PSBudWxsID8gdm9pZCAwIDogdmFsLnR5cGUpfWApO1xuICB9XG5cbiAgdmFsaWRhdGUub25lT2ZOb2RlVHlwZXMgPSB0eXBlcztcbiAgcmV0dXJuIHZhbGlkYXRlO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROb2RlT3JWYWx1ZVR5cGUoLi4udHlwZXMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUobm9kZSwga2V5LCB2YWwpIHtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgIGlmIChnZXRUeXBlKHZhbCkgPT09IHR5cGUgfHwgKDAsIF9pcy5kZWZhdWx0KSh0eXBlLCB2YWwpKSB7XG4gICAgICAgICgwLCBfdmFsaWRhdGUudmFsaWRhdGVDaGlsZCkobm9kZSwga2V5LCB2YWwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUHJvcGVydHkgJHtrZXl9IG9mICR7bm9kZS50eXBlfSBleHBlY3RlZCBub2RlIHRvIGJlIG9mIGEgdHlwZSAke0pTT04uc3RyaW5naWZ5KHR5cGVzKX0gYnV0IGluc3RlYWQgZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsID09IG51bGwgPyB2b2lkIDAgOiB2YWwudHlwZSl9YCk7XG4gIH1cblxuICB2YWxpZGF0ZS5vbmVPZk5vZGVPclZhbHVlVHlwZXMgPSB0eXBlcztcbiAgcmV0dXJuIHZhbGlkYXRlO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRWYWx1ZVR5cGUodHlwZSkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShub2RlLCBrZXksIHZhbCkge1xuICAgIGNvbnN0IHZhbGlkID0gZ2V0VHlwZSh2YWwpID09PSB0eXBlO1xuXG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUHJvcGVydHkgJHtrZXl9IGV4cGVjdGVkIHR5cGUgb2YgJHt0eXBlfSBidXQgZ290ICR7Z2V0VHlwZSh2YWwpfWApO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlLnR5cGUgPSB0eXBlO1xuICByZXR1cm4gdmFsaWRhdGU7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNoYXBlKHNoYXBlKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIE9iamVjdC5rZXlzKHNoYXBlKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgKDAsIF92YWxpZGF0ZS52YWxpZGF0ZUZpZWxkKShub2RlLCBwcm9wZXJ0eSwgdmFsW3Byb3BlcnR5XSwgc2hhcGVbcHJvcGVydHldKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFByb3BlcnR5ICR7a2V5fSBvZiAke25vZGUudHlwZX0gZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgZm9sbG93aW5nOlxcbiR7ZXJyb3JzLmpvaW4oXCJcXG5cIil9YCk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUuc2hhcGVPZiA9IHNoYXBlO1xuICByZXR1cm4gdmFsaWRhdGU7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9wdGlvbmFsQ2hhaW5TdGFydCgpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUobm9kZSkge1xuICAgIHZhciBfY3VycmVudDtcblxuICAgIGxldCBjdXJyZW50ID0gbm9kZTtcblxuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSBjdXJyZW50O1xuXG4gICAgICBpZiAodHlwZSA9PT0gXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQub3B0aW9uYWwpIHJldHVybjtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuY2FsbGVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQub3B0aW9uYWwpIHJldHVybjtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQub2JqZWN0O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm9uLW9wdGlvbmFsICR7bm9kZS50eXBlfSBtdXN0IGNoYWluIGZyb20gYW4gb3B0aW9uYWwgT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uIG9yIE9wdGlvbmFsQ2FsbEV4cHJlc3Npb24uIEZvdW5kIGNoYWluIGZyb20gJHsoX2N1cnJlbnQgPSBjdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2N1cnJlbnQudHlwZX1gKTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZTtcbn1cblxuZnVuY3Rpb24gY2hhaW4oLi4uZm5zKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKC4uLmFyZ3MpIHtcbiAgICBmb3IgKGNvbnN0IGZuIG9mIGZucykge1xuICAgICAgZm4oLi4uYXJncyk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUuY2hhaW5PZiA9IGZucztcbiAgcmV0dXJuIHZhbGlkYXRlO1xufVxuXG5jb25zdCB2YWxpZFR5cGVPcHRzID0gW1wiYWxpYXNlc1wiLCBcImJ1aWxkZXJcIiwgXCJkZXByZWNhdGVkQWxpYXNcIiwgXCJmaWVsZHNcIiwgXCJpbmhlcml0c1wiLCBcInZpc2l0b3JcIiwgXCJ2YWxpZGF0ZVwiXTtcbmNvbnN0IHZhbGlkRmllbGRLZXlzID0gW1wiZGVmYXVsdFwiLCBcIm9wdGlvbmFsXCIsIFwidmFsaWRhdGVcIl07XG5cbmZ1bmN0aW9uIGRlZmluZVR5cGUodHlwZSwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGluaGVyaXRzID0gb3B0cy5pbmhlcml0cyAmJiBzdG9yZVtvcHRzLmluaGVyaXRzXSB8fCB7fTtcbiAgbGV0IGZpZWxkcyA9IG9wdHMuZmllbGRzO1xuXG4gIGlmICghZmllbGRzKSB7XG4gICAgZmllbGRzID0ge307XG5cbiAgICBpZiAoaW5oZXJpdHMuZmllbGRzKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5oZXJpdHMuZmllbGRzKTtcblxuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGluaGVyaXRzLmZpZWxkc1trZXldO1xuICAgICAgICBmaWVsZHNba2V5XSA9IHtcbiAgICAgICAgICBkZWZhdWx0OiBmaWVsZC5kZWZhdWx0LFxuICAgICAgICAgIG9wdGlvbmFsOiBmaWVsZC5vcHRpb25hbCxcbiAgICAgICAgICB2YWxpZGF0ZTogZmllbGQudmFsaWRhdGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCB2aXNpdG9yID0gb3B0cy52aXNpdG9yIHx8IGluaGVyaXRzLnZpc2l0b3IgfHwgW107XG4gIGNvbnN0IGFsaWFzZXMgPSBvcHRzLmFsaWFzZXMgfHwgaW5oZXJpdHMuYWxpYXNlcyB8fCBbXTtcbiAgY29uc3QgYnVpbGRlciA9IG9wdHMuYnVpbGRlciB8fCBpbmhlcml0cy5idWlsZGVyIHx8IG9wdHMudmlzaXRvciB8fCBbXTtcblxuICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMob3B0cykpIHtcbiAgICBpZiAodmFsaWRUeXBlT3B0cy5pbmRleE9mKGspID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHR5cGUgb3B0aW9uIFwiJHtrfVwiIG9uICR7dHlwZX1gKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5kZXByZWNhdGVkQWxpYXMpIHtcbiAgICBERVBSRUNBVEVEX0tFWVNbb3B0cy5kZXByZWNhdGVkQWxpYXNdID0gdHlwZTtcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IG9mIHZpc2l0b3IuY29uY2F0KGJ1aWxkZXIpKSB7XG4gICAgZmllbGRzW2tleV0gPSBmaWVsZHNba2V5XSB8fCB7fTtcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGZpZWxkcykpIHtcbiAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1trZXldO1xuXG4gICAgaWYgKGZpZWxkLmRlZmF1bHQgIT09IHVuZGVmaW5lZCAmJiBidWlsZGVyLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgIGZpZWxkLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZmllbGQuZGVmYXVsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaWVsZC5kZWZhdWx0ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKCFmaWVsZC52YWxpZGF0ZSAmJiBmaWVsZC5kZWZhdWx0ICE9IG51bGwpIHtcbiAgICAgIGZpZWxkLnZhbGlkYXRlID0gYXNzZXJ0VmFsdWVUeXBlKGdldFR5cGUoZmllbGQuZGVmYXVsdCkpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhmaWVsZCkpIHtcbiAgICAgIGlmICh2YWxpZEZpZWxkS2V5cy5pbmRleE9mKGspID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZmllbGQga2V5IFwiJHtrfVwiIG9uICR7dHlwZX0uJHtrZXl9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgVklTSVRPUl9LRVlTW3R5cGVdID0gb3B0cy52aXNpdG9yID0gdmlzaXRvcjtcbiAgQlVJTERFUl9LRVlTW3R5cGVdID0gb3B0cy5idWlsZGVyID0gYnVpbGRlcjtcbiAgTk9ERV9GSUVMRFNbdHlwZV0gPSBvcHRzLmZpZWxkcyA9IGZpZWxkcztcbiAgQUxJQVNfS0VZU1t0eXBlXSA9IG9wdHMuYWxpYXNlcyA9IGFsaWFzZXM7XG4gIGFsaWFzZXMuZm9yRWFjaChhbGlhcyA9PiB7XG4gICAgRkxJUFBFRF9BTElBU19LRVlTW2FsaWFzXSA9IEZMSVBQRURfQUxJQVNfS0VZU1thbGlhc10gfHwgW107XG4gICAgRkxJUFBFRF9BTElBU19LRVlTW2FsaWFzXS5wdXNoKHR5cGUpO1xuICB9KTtcblxuICBpZiAob3B0cy52YWxpZGF0ZSkge1xuICAgIE5PREVfUEFSRU5UX1ZBTElEQVRJT05TW3R5cGVdID0gb3B0cy52YWxpZGF0ZTtcbiAgfVxuXG4gIHN0b3JlW3R5cGVdID0gb3B0cztcbn1cblxuY29uc3Qgc3RvcmUgPSB7fTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBfZXhwb3J0TmFtZXMgPSB7XG4gIHJlYWN0OiB0cnVlLFxuICBhc3NlcnROb2RlOiB0cnVlLFxuICBjcmVhdGVUeXBlQW5ub3RhdGlvbkJhc2VkT25UeXBlb2Y6IHRydWUsXG4gIGNyZWF0ZVVuaW9uVHlwZUFubm90YXRpb246IHRydWUsXG4gIGNyZWF0ZUZsb3dVbmlvblR5cGU6IHRydWUsXG4gIGNyZWF0ZVRTVW5pb25UeXBlOiB0cnVlLFxuICBjbG9uZU5vZGU6IHRydWUsXG4gIGNsb25lOiB0cnVlLFxuICBjbG9uZURlZXA6IHRydWUsXG4gIGNsb25lRGVlcFdpdGhvdXRMb2M6IHRydWUsXG4gIGNsb25lV2l0aG91dExvYzogdHJ1ZSxcbiAgYWRkQ29tbWVudDogdHJ1ZSxcbiAgYWRkQ29tbWVudHM6IHRydWUsXG4gIGluaGVyaXRJbm5lckNvbW1lbnRzOiB0cnVlLFxuICBpbmhlcml0TGVhZGluZ0NvbW1lbnRzOiB0cnVlLFxuICBpbmhlcml0c0NvbW1lbnRzOiB0cnVlLFxuICBpbmhlcml0VHJhaWxpbmdDb21tZW50czogdHJ1ZSxcbiAgcmVtb3ZlQ29tbWVudHM6IHRydWUsXG4gIGVuc3VyZUJsb2NrOiB0cnVlLFxuICB0b0JpbmRpbmdJZGVudGlmaWVyTmFtZTogdHJ1ZSxcbiAgdG9CbG9jazogdHJ1ZSxcbiAgdG9Db21wdXRlZEtleTogdHJ1ZSxcbiAgdG9FeHByZXNzaW9uOiB0cnVlLFxuICB0b0lkZW50aWZpZXI6IHRydWUsXG4gIHRvS2V5QWxpYXM6IHRydWUsXG4gIHRvU2VxdWVuY2VFeHByZXNzaW9uOiB0cnVlLFxuICB0b1N0YXRlbWVudDogdHJ1ZSxcbiAgdmFsdWVUb05vZGU6IHRydWUsXG4gIGFwcGVuZFRvTWVtYmVyRXhwcmVzc2lvbjogdHJ1ZSxcbiAgaW5oZXJpdHM6IHRydWUsXG4gIHByZXBlbmRUb01lbWJlckV4cHJlc3Npb246IHRydWUsXG4gIHJlbW92ZVByb3BlcnRpZXM6IHRydWUsXG4gIHJlbW92ZVByb3BlcnRpZXNEZWVwOiB0cnVlLFxuICByZW1vdmVUeXBlRHVwbGljYXRlczogdHJ1ZSxcbiAgZ2V0QmluZGluZ0lkZW50aWZpZXJzOiB0cnVlLFxuICBnZXRPdXRlckJpbmRpbmdJZGVudGlmaWVyczogdHJ1ZSxcbiAgdHJhdmVyc2U6IHRydWUsXG4gIHRyYXZlcnNlRmFzdDogdHJ1ZSxcbiAgc2hhbGxvd0VxdWFsOiB0cnVlLFxuICBpczogdHJ1ZSxcbiAgaXNCaW5kaW5nOiB0cnVlLFxuICBpc0Jsb2NrU2NvcGVkOiB0cnVlLFxuICBpc0ltbXV0YWJsZTogdHJ1ZSxcbiAgaXNMZXQ6IHRydWUsXG4gIGlzTm9kZTogdHJ1ZSxcbiAgaXNOb2Rlc0VxdWl2YWxlbnQ6IHRydWUsXG4gIGlzUGxhY2Vob2xkZXJUeXBlOiB0cnVlLFxuICBpc1JlZmVyZW5jZWQ6IHRydWUsXG4gIGlzU2NvcGU6IHRydWUsXG4gIGlzU3BlY2lmaWVyRGVmYXVsdDogdHJ1ZSxcbiAgaXNUeXBlOiB0cnVlLFxuICBpc1ZhbGlkRVMzSWRlbnRpZmllcjogdHJ1ZSxcbiAgaXNWYWxpZElkZW50aWZpZXI6IHRydWUsXG4gIGlzVmFyOiB0cnVlLFxuICBtYXRjaGVzUGF0dGVybjogdHJ1ZSxcbiAgdmFsaWRhdGU6IHRydWUsXG4gIGJ1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uOiB0cnVlXG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXNzZXJ0Tm9kZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXNzZXJ0Tm9kZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVR5cGVBbm5vdGF0aW9uQmFzZWRPblR5cGVvZlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY3JlYXRlVHlwZUFubm90YXRpb25CYXNlZE9uVHlwZW9mLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlVW5pb25UeXBlQW5ub3RhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY3JlYXRlRmxvd1VuaW9uVHlwZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZUZsb3dVbmlvblR5cGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2NyZWF0ZUZsb3dVbmlvblR5cGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVUU1VuaW9uVHlwZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY3JlYXRlVFNVbmlvblR5cGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjbG9uZU5vZGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Nsb25lTm9kZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNsb25lXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9jbG9uZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNsb25lRGVlcFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY2xvbmVEZWVwLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2xvbmVEZWVwV2l0aG91dExvY1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY2xvbmVEZWVwV2l0aG91dExvYy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNsb25lV2l0aG91dExvY1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY2xvbmVXaXRob3V0TG9jLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWRkQ29tbWVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYWRkQ29tbWVudC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZENvbW1lbnRzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hZGRDb21tZW50cy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImluaGVyaXRJbm5lckNvbW1lbnRzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmhlcml0SW5uZXJDb21tZW50cy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImluaGVyaXRMZWFkaW5nQ29tbWVudHNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luaGVyaXRMZWFkaW5nQ29tbWVudHMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbmhlcml0c0NvbW1lbnRzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmhlcml0c0NvbW1lbnRzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW5oZXJpdFRyYWlsaW5nQ29tbWVudHNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luaGVyaXRUcmFpbGluZ0NvbW1lbnRzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVtb3ZlQ29tbWVudHNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3JlbW92ZUNvbW1lbnRzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5zdXJlQmxvY2tcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Vuc3VyZUJsb2NrLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9CaW5kaW5nSWRlbnRpZmllck5hbWVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RvQmluZGluZ0lkZW50aWZpZXJOYW1lLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9CbG9ja1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdG9CbG9jay5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvQ29tcHV0ZWRLZXlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RvQ29tcHV0ZWRLZXkuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0V4cHJlc3Npb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RvRXhwcmVzc2lvbi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvSWRlbnRpZmllclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdG9JZGVudGlmaWVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9LZXlBbGlhc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdG9LZXlBbGlhcy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvU2VxdWVuY2VFeHByZXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90b1NlcXVlbmNlRXhwcmVzc2lvbi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvU3RhdGVtZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90b1N0YXRlbWVudC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZhbHVlVG9Ob2RlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92YWx1ZVRvTm9kZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFwcGVuZFRvTWVtYmVyRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXBwZW5kVG9NZW1iZXJFeHByZXNzaW9uLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW5oZXJpdHNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luaGVyaXRzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicHJlcGVuZFRvTWVtYmVyRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcHJlcGVuZFRvTWVtYmVyRXhwcmVzc2lvbi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlbW92ZVByb3BlcnRpZXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3JlbW92ZVByb3BlcnRpZXMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZW1vdmVQcm9wZXJ0aWVzRGVlcFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcmVtb3ZlUHJvcGVydGllc0RlZXAuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZW1vdmVUeXBlRHVwbGljYXRlc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcmVtb3ZlVHlwZUR1cGxpY2F0ZXMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRCaW5kaW5nSWRlbnRpZmllcnNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2dldEJpbmRpbmdJZGVudGlmaWVycy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldE91dGVyQmluZGluZ0lkZW50aWZpZXJzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9nZXRPdXRlckJpbmRpbmdJZGVudGlmaWVycy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRyYXZlcnNlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90cmF2ZXJzZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRyYXZlcnNlRmFzdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdHJhdmVyc2VGYXN0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hhbGxvd0VxdWFsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9zaGFsbG93RXF1YWwuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0JpbmRpbmdcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzQmluZGluZy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQmxvY2tTY29wZWRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzQmxvY2tTY29wZWQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0ltbXV0YWJsZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNJbW11dGFibGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0xldFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNMZXQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc05vZGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzTm9kZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzTm9kZXNFcXVpdmFsZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pc05vZGVzRXF1aXZhbGVudC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzUGxhY2Vob2xkZXJUeXBlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyVHlwZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzUmVmZXJlbmNlZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNSZWZlcmVuY2VkLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNTY29wZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNTY29wZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzU3BlY2lmaWVyRGVmYXVsdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNTcGVjaWZpZXJEZWZhdWx0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNUeXBlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pc1R5cGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1ZhbGlkRVMzSWRlbnRpZmllclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNWYWxpZEVTM0lkZW50aWZpZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1ZhbGlkSWRlbnRpZmllclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNWYWxpZElkZW50aWZpZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1ZhclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNWYXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYXRjaGVzUGF0dGVyblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfbWF0Y2hlc1BhdHRlcm4uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YWxpZGF0ZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdmFsaWRhdGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJidWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYnVpbGRNYXRjaE1lbWJlckV4cHJlc3Npb24uZGVmYXVsdDtcbiAgfVxufSk7XG5leHBvcnRzLnJlYWN0ID0gdm9pZCAwO1xuXG52YXIgX2lzUmVhY3RDb21wb25lbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvcmVhY3QvaXNSZWFjdENvbXBvbmVudFwiKSk7XG5cbnZhciBfaXNDb21wYXRUYWcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvcmVhY3QvaXNDb21wYXRUYWdcIikpO1xuXG52YXIgX2J1aWxkQ2hpbGRyZW4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2J1aWxkZXJzL3JlYWN0L2J1aWxkQ2hpbGRyZW5cIikpO1xuXG52YXIgX2Fzc2VydE5vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Fzc2VydHMvYXNzZXJ0Tm9kZVwiKSk7XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4vYXNzZXJ0cy9nZW5lcmF0ZWRcIik7XG5cbk9iamVjdC5rZXlzKF9nZW5lcmF0ZWQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9nZW5lcmF0ZWRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBfY3JlYXRlVHlwZUFubm90YXRpb25CYXNlZE9uVHlwZW9mID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9idWlsZGVycy9mbG93L2NyZWF0ZVR5cGVBbm5vdGF0aW9uQmFzZWRPblR5cGVvZlwiKSk7XG5cbnZhciBfY3JlYXRlRmxvd1VuaW9uVHlwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYnVpbGRlcnMvZmxvdy9jcmVhdGVGbG93VW5pb25UeXBlXCIpKTtcblxudmFyIF9jcmVhdGVUU1VuaW9uVHlwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYnVpbGRlcnMvdHlwZXNjcmlwdC9jcmVhdGVUU1VuaW9uVHlwZVwiKSk7XG5cbnZhciBfZ2VuZXJhdGVkMiA9IHJlcXVpcmUoXCIuL2J1aWxkZXJzL2dlbmVyYXRlZFwiKTtcblxuT2JqZWN0LmtleXMoX2dlbmVyYXRlZDIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9nZW5lcmF0ZWQyW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xuXG52YXIgX2Nsb25lTm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY2xvbmUvY2xvbmVOb2RlXCIpKTtcblxudmFyIF9jbG9uZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY2xvbmUvY2xvbmVcIikpO1xuXG52YXIgX2Nsb25lRGVlcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY2xvbmUvY2xvbmVEZWVwXCIpKTtcblxudmFyIF9jbG9uZURlZXBXaXRob3V0TG9jID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jbG9uZS9jbG9uZURlZXBXaXRob3V0TG9jXCIpKTtcblxudmFyIF9jbG9uZVdpdGhvdXRMb2MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nsb25lL2Nsb25lV2l0aG91dExvY1wiKSk7XG5cbnZhciBfYWRkQ29tbWVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29tbWVudHMvYWRkQ29tbWVudFwiKSk7XG5cbnZhciBfYWRkQ29tbWVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbW1lbnRzL2FkZENvbW1lbnRzXCIpKTtcblxudmFyIF9pbmhlcml0SW5uZXJDb21tZW50cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29tbWVudHMvaW5oZXJpdElubmVyQ29tbWVudHNcIikpO1xuXG52YXIgX2luaGVyaXRMZWFkaW5nQ29tbWVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbW1lbnRzL2luaGVyaXRMZWFkaW5nQ29tbWVudHNcIikpO1xuXG52YXIgX2luaGVyaXRzQ29tbWVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbW1lbnRzL2luaGVyaXRzQ29tbWVudHNcIikpO1xuXG52YXIgX2luaGVyaXRUcmFpbGluZ0NvbW1lbnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb21tZW50cy9pbmhlcml0VHJhaWxpbmdDb21tZW50c1wiKSk7XG5cbnZhciBfcmVtb3ZlQ29tbWVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbW1lbnRzL3JlbW92ZUNvbW1lbnRzXCIpKTtcblxudmFyIF9nZW5lcmF0ZWQzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzL2dlbmVyYXRlZFwiKTtcblxuT2JqZWN0LmtleXMoX2dlbmVyYXRlZDMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9nZW5lcmF0ZWQzW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcblxuT2JqZWN0LmtleXMoX2NvbnN0YW50cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2NvbnN0YW50c1trZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9lbnN1cmVCbG9jayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29udmVydGVycy9lbnN1cmVCbG9ja1wiKSk7XG5cbnZhciBfdG9CaW5kaW5nSWRlbnRpZmllck5hbWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdG9CaW5kaW5nSWRlbnRpZmllck5hbWVcIikpO1xuXG52YXIgX3RvQmxvY2sgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdG9CbG9ja1wiKSk7XG5cbnZhciBfdG9Db21wdXRlZEtleSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29udmVydGVycy90b0NvbXB1dGVkS2V5XCIpKTtcblxudmFyIF90b0V4cHJlc3Npb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdG9FeHByZXNzaW9uXCIpKTtcblxudmFyIF90b0lkZW50aWZpZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdG9JZGVudGlmaWVyXCIpKTtcblxudmFyIF90b0tleUFsaWFzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb252ZXJ0ZXJzL3RvS2V5QWxpYXNcIikpO1xuXG52YXIgX3RvU2VxdWVuY2VFeHByZXNzaW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb252ZXJ0ZXJzL3RvU2VxdWVuY2VFeHByZXNzaW9uXCIpKTtcblxudmFyIF90b1N0YXRlbWVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29udmVydGVycy90b1N0YXRlbWVudFwiKSk7XG5cbnZhciBfdmFsdWVUb05vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdmFsdWVUb05vZGVcIikpO1xuXG52YXIgX2RlZmluaXRpb25zID0gcmVxdWlyZShcIi4vZGVmaW5pdGlvbnNcIik7XG5cbk9iamVjdC5rZXlzKF9kZWZpbml0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2RlZmluaXRpb25zW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xuXG52YXIgX2FwcGVuZFRvTWVtYmVyRXhwcmVzc2lvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbW9kaWZpY2F0aW9ucy9hcHBlbmRUb01lbWJlckV4cHJlc3Npb25cIikpO1xuXG52YXIgX2luaGVyaXRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9tb2RpZmljYXRpb25zL2luaGVyaXRzXCIpKTtcblxudmFyIF9wcmVwZW5kVG9NZW1iZXJFeHByZXNzaW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9tb2RpZmljYXRpb25zL3ByZXBlbmRUb01lbWJlckV4cHJlc3Npb25cIikpO1xuXG52YXIgX3JlbW92ZVByb3BlcnRpZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL21vZGlmaWNhdGlvbnMvcmVtb3ZlUHJvcGVydGllc1wiKSk7XG5cbnZhciBfcmVtb3ZlUHJvcGVydGllc0RlZXAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL21vZGlmaWNhdGlvbnMvcmVtb3ZlUHJvcGVydGllc0RlZXBcIikpO1xuXG52YXIgX3JlbW92ZVR5cGVEdXBsaWNhdGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9tb2RpZmljYXRpb25zL2Zsb3cvcmVtb3ZlVHlwZUR1cGxpY2F0ZXNcIikpO1xuXG52YXIgX2dldEJpbmRpbmdJZGVudGlmaWVycyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmV0cmlldmVycy9nZXRCaW5kaW5nSWRlbnRpZmllcnNcIikpO1xuXG52YXIgX2dldE91dGVyQmluZGluZ0lkZW50aWZpZXJzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yZXRyaWV2ZXJzL2dldE91dGVyQmluZGluZ0lkZW50aWZpZXJzXCIpKTtcblxudmFyIF90cmF2ZXJzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdHJhdmVyc2UvdHJhdmVyc2VcIikpO1xuXG52YXIgX3RyYXZlcnNlRmFzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdHJhdmVyc2UvdHJhdmVyc2VGYXN0XCIpKTtcblxudmFyIF9zaGFsbG93RXF1YWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxzL3NoYWxsb3dFcXVhbFwiKSk7XG5cbnZhciBfaXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNcIikpO1xuXG52YXIgX2lzQmluZGluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdG9ycy9pc0JpbmRpbmdcIikpO1xuXG52YXIgX2lzQmxvY2tTY29wZWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNCbG9ja1Njb3BlZFwiKSk7XG5cbnZhciBfaXNJbW11dGFibGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNJbW11dGFibGVcIikpO1xuXG52YXIgX2lzTGV0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzTGV0XCIpKTtcblxudmFyIF9pc05vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNOb2RlXCIpKTtcblxudmFyIF9pc05vZGVzRXF1aXZhbGVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdG9ycy9pc05vZGVzRXF1aXZhbGVudFwiKSk7XG5cbnZhciBfaXNQbGFjZWhvbGRlclR5cGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNQbGFjZWhvbGRlclR5cGVcIikpO1xuXG52YXIgX2lzUmVmZXJlbmNlZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdG9ycy9pc1JlZmVyZW5jZWRcIikpO1xuXG52YXIgX2lzU2NvcGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNTY29wZVwiKSk7XG5cbnZhciBfaXNTcGVjaWZpZXJEZWZhdWx0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzU3BlY2lmaWVyRGVmYXVsdFwiKSk7XG5cbnZhciBfaXNUeXBlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzVHlwZVwiKSk7XG5cbnZhciBfaXNWYWxpZEVTM0lkZW50aWZpZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNWYWxpZEVTM0lkZW50aWZpZXJcIikpO1xuXG52YXIgX2lzVmFsaWRJZGVudGlmaWVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzVmFsaWRJZGVudGlmaWVyXCIpKTtcblxudmFyIF9pc1ZhciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdG9ycy9pc1ZhclwiKSk7XG5cbnZhciBfbWF0Y2hlc1BhdHRlcm4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvbWF0Y2hlc1BhdHRlcm5cIikpO1xuXG52YXIgX3ZhbGlkYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0b3JzL3ZhbGlkYXRlXCIpKTtcblxudmFyIF9idWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdG9ycy9idWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvblwiKSk7XG5cbnZhciBfZ2VuZXJhdGVkNCA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkXCIpO1xuXG5PYmplY3Qua2V5cyhfZ2VuZXJhdGVkNCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2dlbmVyYXRlZDRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IHJlYWN0ID0ge1xuICBpc1JlYWN0Q29tcG9uZW50OiBfaXNSZWFjdENvbXBvbmVudC5kZWZhdWx0LFxuICBpc0NvbXBhdFRhZzogX2lzQ29tcGF0VGFnLmRlZmF1bHQsXG4gIGJ1aWxkQ2hpbGRyZW46IF9idWlsZENoaWxkcmVuLmRlZmF1bHRcbn07XG5leHBvcnRzLnJlYWN0ID0gcmVhY3Q7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhcHBlbmRUb01lbWJlckV4cHJlc3Npb247XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4uL2J1aWxkZXJzL2dlbmVyYXRlZFwiKTtcblxuZnVuY3Rpb24gYXBwZW5kVG9NZW1iZXJFeHByZXNzaW9uKG1lbWJlciwgYXBwZW5kLCBjb21wdXRlZCA9IGZhbHNlKSB7XG4gIG1lbWJlci5vYmplY3QgPSAoMCwgX2dlbmVyYXRlZC5tZW1iZXJFeHByZXNzaW9uKShtZW1iZXIub2JqZWN0LCBtZW1iZXIucHJvcGVydHksIG1lbWJlci5jb21wdXRlZCk7XG4gIG1lbWJlci5wcm9wZXJ0eSA9IGFwcGVuZDtcbiAgbWVtYmVyLmNvbXB1dGVkID0gISFjb21wdXRlZDtcbiAgcmV0dXJuIG1lbWJlcjtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlbW92ZVR5cGVEdXBsaWNhdGVzO1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuLi8uLi92YWxpZGF0b3JzL2dlbmVyYXRlZFwiKTtcblxuZnVuY3Rpb24gcmVtb3ZlVHlwZUR1cGxpY2F0ZXMobm9kZXMpIHtcbiAgY29uc3QgZ2VuZXJpY3MgPSB7fTtcbiAgY29uc3QgYmFzZXMgPSB7fTtcbiAgY29uc3QgdHlwZUdyb3VwcyA9IFtdO1xuICBjb25zdCB0eXBlcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKCFub2RlKSBjb250aW51ZTtcblxuICAgIGlmICh0eXBlcy5pbmRleE9mKG5vZGUpID49IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICgoMCwgX2dlbmVyYXRlZC5pc0FueVR5cGVBbm5vdGF0aW9uKShub2RlKSkge1xuICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICB9XG5cbiAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNGbG93QmFzZUFubm90YXRpb24pKG5vZGUpKSB7XG4gICAgICBiYXNlc1tub2RlLnR5cGVdID0gbm9kZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICgoMCwgX2dlbmVyYXRlZC5pc1VuaW9uVHlwZUFubm90YXRpb24pKG5vZGUpKSB7XG4gICAgICBpZiAodHlwZUdyb3Vwcy5pbmRleE9mKG5vZGUudHlwZXMpIDwgMCkge1xuICAgICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChub2RlLnR5cGVzKTtcbiAgICAgICAgdHlwZUdyb3Vwcy5wdXNoKG5vZGUudHlwZXMpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNHZW5lcmljVHlwZUFubm90YXRpb24pKG5vZGUpKSB7XG4gICAgICBjb25zdCBuYW1lID0gbm9kZS5pZC5uYW1lO1xuXG4gICAgICBpZiAoZ2VuZXJpY3NbbmFtZV0pIHtcbiAgICAgICAgbGV0IGV4aXN0aW5nID0gZ2VuZXJpY3NbbmFtZV07XG5cbiAgICAgICAgaWYgKGV4aXN0aW5nLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgaWYgKG5vZGUudHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLnR5cGVQYXJhbWV0ZXJzLnBhcmFtcyA9IHJlbW92ZVR5cGVEdXBsaWNhdGVzKGV4aXN0aW5nLnR5cGVQYXJhbWV0ZXJzLnBhcmFtcy5jb25jYXQobm9kZS50eXBlUGFyYW1ldGVycy5wYXJhbXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhpc3RpbmcgPSBub2RlLnR5cGVQYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5lcmljc1tuYW1lXSA9IG5vZGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHR5cGVzLnB1c2gobm9kZSk7XG4gIH1cblxuICBmb3IgKGNvbnN0IHR5cGUgb2YgT2JqZWN0LmtleXMoYmFzZXMpKSB7XG4gICAgdHlwZXMucHVzaChiYXNlc1t0eXBlXSk7XG4gIH1cblxuICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoZ2VuZXJpY3MpKSB7XG4gICAgdHlwZXMucHVzaChnZW5lcmljc1tuYW1lXSk7XG4gIH1cblxuICByZXR1cm4gdHlwZXM7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpbmhlcml0cztcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuXG52YXIgX2luaGVyaXRzQ29tbWVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9jb21tZW50cy9pbmhlcml0c0NvbW1lbnRzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaW5oZXJpdHMoY2hpbGQsIHBhcmVudCkge1xuICBpZiAoIWNoaWxkIHx8ICFwYXJlbnQpIHJldHVybiBjaGlsZDtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBfY29uc3RhbnRzLklOSEVSSVRfS0VZUy5vcHRpb25hbCkge1xuICAgIGlmIChjaGlsZFtrZXldID09IG51bGwpIHtcbiAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwYXJlbnQpKSB7XG4gICAgaWYgKGtleVswXSA9PT0gXCJfXCIgJiYga2V5ICE9PSBcIl9fY2xvbmVcIikgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgX2NvbnN0YW50cy5JTkhFUklUX0tFWVMuZm9yY2UpIHtcbiAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG4gIH1cblxuICAoMCwgX2luaGVyaXRzQ29tbWVudHMuZGVmYXVsdCkoY2hpbGQsIHBhcmVudCk7XG4gIHJldHVybiBjaGlsZDtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHByZXBlbmRUb01lbWJlckV4cHJlc3Npb247XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4uL2J1aWxkZXJzL2dlbmVyYXRlZFwiKTtcblxuZnVuY3Rpb24gcHJlcGVuZFRvTWVtYmVyRXhwcmVzc2lvbihtZW1iZXIsIHByZXBlbmQpIHtcbiAgbWVtYmVyLm9iamVjdCA9ICgwLCBfZ2VuZXJhdGVkLm1lbWJlckV4cHJlc3Npb24pKHByZXBlbmQsIG1lbWJlci5vYmplY3QpO1xuICByZXR1cm4gbWVtYmVyO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcmVtb3ZlUHJvcGVydGllcztcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuXG5jb25zdCBDTEVBUl9LRVlTID0gW1widG9rZW5zXCIsIFwic3RhcnRcIiwgXCJlbmRcIiwgXCJsb2NcIiwgXCJyYXdcIiwgXCJyYXdWYWx1ZVwiXTtcblxuY29uc3QgQ0xFQVJfS0VZU19QTFVTX0NPTU1FTlRTID0gX2NvbnN0YW50cy5DT01NRU5UX0tFWVMuY29uY2F0KFtcImNvbW1lbnRzXCJdKS5jb25jYXQoQ0xFQVJfS0VZUyk7XG5cbmZ1bmN0aW9uIHJlbW92ZVByb3BlcnRpZXMobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IG1hcCA9IG9wdHMucHJlc2VydmVDb21tZW50cyA/IENMRUFSX0tFWVMgOiBDTEVBUl9LRVlTX1BMVVNfQ09NTUVOVFM7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgbWFwKSB7XG4gICAgaWYgKG5vZGVba2V5XSAhPSBudWxsKSBub2RlW2tleV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhub2RlKSkge1xuICAgIGlmIChrZXlbMF0gPT09IFwiX1wiICYmIG5vZGVba2V5XSAhPSBudWxsKSBub2RlW2tleV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhub2RlKTtcblxuICBmb3IgKGNvbnN0IHN5bSBvZiBzeW1ib2xzKSB7XG4gICAgbm9kZVtzeW1dID0gbnVsbDtcbiAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcmVtb3ZlUHJvcGVydGllc0RlZXA7XG5cbnZhciBfdHJhdmVyc2VGYXN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdHJhdmVyc2UvdHJhdmVyc2VGYXN0XCIpKTtcblxudmFyIF9yZW1vdmVQcm9wZXJ0aWVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yZW1vdmVQcm9wZXJ0aWVzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gcmVtb3ZlUHJvcGVydGllc0RlZXAodHJlZSwgb3B0cykge1xuICAoMCwgX3RyYXZlcnNlRmFzdC5kZWZhdWx0KSh0cmVlLCBfcmVtb3ZlUHJvcGVydGllcy5kZWZhdWx0LCBvcHRzKTtcbiAgcmV0dXJuIHRyZWU7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSByZW1vdmVUeXBlRHVwbGljYXRlcztcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi4vLi4vdmFsaWRhdG9ycy9nZW5lcmF0ZWRcIik7XG5cbmZ1bmN0aW9uIHJlbW92ZVR5cGVEdXBsaWNhdGVzKG5vZGVzKSB7XG4gIGNvbnN0IGdlbmVyaWNzID0ge307XG4gIGNvbnN0IGJhc2VzID0ge307XG4gIGNvbnN0IHR5cGVHcm91cHMgPSBbXTtcbiAgY29uc3QgdHlwZXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICghbm9kZSkgY29udGludWU7XG5cbiAgICBpZiAodHlwZXMuaW5kZXhPZihub2RlKSA+PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNUU0FueUtleXdvcmQpKG5vZGUudHlwZSkpIHtcbiAgICAgIHJldHVybiBbbm9kZV07XG4gICAgfVxuXG4gICAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzVFNCYXNlVHlwZSkobm9kZSkpIHtcbiAgICAgIGJhc2VzW25vZGUudHlwZV0gPSBub2RlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzVFNVbmlvblR5cGUpKG5vZGUpKSB7XG4gICAgICBpZiAodHlwZUdyb3Vwcy5pbmRleE9mKG5vZGUudHlwZXMpIDwgMCkge1xuICAgICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChub2RlLnR5cGVzKTtcbiAgICAgICAgdHlwZUdyb3Vwcy5wdXNoKG5vZGUudHlwZXMpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0eXBlcy5wdXNoKG5vZGUpO1xuICB9XG5cbiAgZm9yIChjb25zdCB0eXBlIG9mIE9iamVjdC5rZXlzKGJhc2VzKSkge1xuICAgIHR5cGVzLnB1c2goYmFzZXNbdHlwZV0pO1xuICB9XG5cbiAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGdlbmVyaWNzKSkge1xuICAgIHR5cGVzLnB1c2goZ2VuZXJpY3NbbmFtZV0pO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVzO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0QmluZGluZ0lkZW50aWZpZXJzO1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2dlbmVyYXRlZFwiKTtcblxuZnVuY3Rpb24gZ2V0QmluZGluZ0lkZW50aWZpZXJzKG5vZGUsIGR1cGxpY2F0ZXMsIG91dGVyT25seSkge1xuICBsZXQgc2VhcmNoID0gW10uY29uY2F0KG5vZGUpO1xuICBjb25zdCBpZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHdoaWxlIChzZWFyY2gubGVuZ3RoKSB7XG4gICAgY29uc3QgaWQgPSBzZWFyY2guc2hpZnQoKTtcbiAgICBpZiAoIWlkKSBjb250aW51ZTtcbiAgICBjb25zdCBrZXlzID0gZ2V0QmluZGluZ0lkZW50aWZpZXJzLmtleXNbaWQudHlwZV07XG5cbiAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNJZGVudGlmaWVyKShpZCkpIHtcbiAgICAgIGlmIChkdXBsaWNhdGVzKSB7XG4gICAgICAgIGNvbnN0IF9pZHMgPSBpZHNbaWQubmFtZV0gPSBpZHNbaWQubmFtZV0gfHwgW107XG5cbiAgICAgICAgX2lkcy5wdXNoKGlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkc1tpZC5uYW1lXSA9IGlkO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNFeHBvcnREZWNsYXJhdGlvbikoaWQpKSB7XG4gICAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNEZWNsYXJhdGlvbikoaWQuZGVjbGFyYXRpb24pKSB7XG4gICAgICAgIHNlYXJjaC5wdXNoKGlkLmRlY2xhcmF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG91dGVyT25seSkge1xuICAgICAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzRnVuY3Rpb25EZWNsYXJhdGlvbikoaWQpKSB7XG4gICAgICAgIHNlYXJjaC5wdXNoKGlkLmlkKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgoMCwgX2dlbmVyYXRlZC5pc0Z1bmN0aW9uRXhwcmVzc2lvbikoaWQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXlzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoaWRba2V5XSkge1xuICAgICAgICAgIHNlYXJjaCA9IHNlYXJjaC5jb25jYXQoaWRba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaWRzO1xufVxuXG5nZXRCaW5kaW5nSWRlbnRpZmllcnMua2V5cyA9IHtcbiAgRGVjbGFyZUNsYXNzOiBbXCJpZFwiXSxcbiAgRGVjbGFyZUZ1bmN0aW9uOiBbXCJpZFwiXSxcbiAgRGVjbGFyZU1vZHVsZTogW1wiaWRcIl0sXG4gIERlY2xhcmVWYXJpYWJsZTogW1wiaWRcIl0sXG4gIERlY2xhcmVJbnRlcmZhY2U6IFtcImlkXCJdLFxuICBEZWNsYXJlVHlwZUFsaWFzOiBbXCJpZFwiXSxcbiAgRGVjbGFyZU9wYXF1ZVR5cGU6IFtcImlkXCJdLFxuICBJbnRlcmZhY2VEZWNsYXJhdGlvbjogW1wiaWRcIl0sXG4gIFR5cGVBbGlhczogW1wiaWRcIl0sXG4gIE9wYXF1ZVR5cGU6IFtcImlkXCJdLFxuICBDYXRjaENsYXVzZTogW1wicGFyYW1cIl0sXG4gIExhYmVsZWRTdGF0ZW1lbnQ6IFtcImxhYmVsXCJdLFxuICBVbmFyeUV4cHJlc3Npb246IFtcImFyZ3VtZW50XCJdLFxuICBBc3NpZ25tZW50RXhwcmVzc2lvbjogW1wibGVmdFwiXSxcbiAgSW1wb3J0U3BlY2lmaWVyOiBbXCJsb2NhbFwiXSxcbiAgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyOiBbXCJsb2NhbFwiXSxcbiAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogW1wibG9jYWxcIl0sXG4gIEltcG9ydERlY2xhcmF0aW9uOiBbXCJzcGVjaWZpZXJzXCJdLFxuICBFeHBvcnRTcGVjaWZpZXI6IFtcImV4cG9ydGVkXCJdLFxuICBFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IFtcImV4cG9ydGVkXCJdLFxuICBFeHBvcnREZWZhdWx0U3BlY2lmaWVyOiBbXCJleHBvcnRlZFwiXSxcbiAgRnVuY3Rpb25EZWNsYXJhdGlvbjogW1wiaWRcIiwgXCJwYXJhbXNcIl0sXG4gIEZ1bmN0aW9uRXhwcmVzc2lvbjogW1wiaWRcIiwgXCJwYXJhbXNcIl0sXG4gIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiBbXCJwYXJhbXNcIl0sXG4gIE9iamVjdE1ldGhvZDogW1wicGFyYW1zXCJdLFxuICBDbGFzc01ldGhvZDogW1wicGFyYW1zXCJdLFxuICBGb3JJblN0YXRlbWVudDogW1wibGVmdFwiXSxcbiAgRm9yT2ZTdGF0ZW1lbnQ6IFtcImxlZnRcIl0sXG4gIENsYXNzRGVjbGFyYXRpb246IFtcImlkXCJdLFxuICBDbGFzc0V4cHJlc3Npb246IFtcImlkXCJdLFxuICBSZXN0RWxlbWVudDogW1wiYXJndW1lbnRcIl0sXG4gIFVwZGF0ZUV4cHJlc3Npb246IFtcImFyZ3VtZW50XCJdLFxuICBPYmplY3RQcm9wZXJ0eTogW1widmFsdWVcIl0sXG4gIEFzc2lnbm1lbnRQYXR0ZXJuOiBbXCJsZWZ0XCJdLFxuICBBcnJheVBhdHRlcm46IFtcImVsZW1lbnRzXCJdLFxuICBPYmplY3RQYXR0ZXJuOiBbXCJwcm9wZXJ0aWVzXCJdLFxuICBWYXJpYWJsZURlY2xhcmF0aW9uOiBbXCJkZWNsYXJhdGlvbnNcIl0sXG4gIFZhcmlhYmxlRGVjbGFyYXRvcjogW1wiaWRcIl1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRPdXRlckJpbmRpbmdJZGVudGlmaWVycztcblxudmFyIF9nZXRCaW5kaW5nSWRlbnRpZmllcnMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2dldEJpbmRpbmdJZGVudGlmaWVyc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldE91dGVyQmluZGluZ0lkZW50aWZpZXJzKG5vZGUsIGR1cGxpY2F0ZXMpIHtcbiAgcmV0dXJuICgwLCBfZ2V0QmluZGluZ0lkZW50aWZpZXJzLmRlZmF1bHQpKG5vZGUsIGR1cGxpY2F0ZXMsIHRydWUpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdHJhdmVyc2U7XG5cbnZhciBfZGVmaW5pdGlvbnMgPSByZXF1aXJlKFwiLi4vZGVmaW5pdGlvbnNcIik7XG5cbmZ1bmN0aW9uIHRyYXZlcnNlKG5vZGUsIGhhbmRsZXJzLCBzdGF0ZSkge1xuICBpZiAodHlwZW9mIGhhbmRsZXJzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBoYW5kbGVycyA9IHtcbiAgICAgIGVudGVyOiBoYW5kbGVyc1xuICAgIH07XG4gIH1cblxuICBjb25zdCB7XG4gICAgZW50ZXIsXG4gICAgZXhpdFxuICB9ID0gaGFuZGxlcnM7XG4gIHRyYXZlcnNlU2ltcGxlSW1wbChub2RlLCBlbnRlciwgZXhpdCwgc3RhdGUsIFtdKTtcbn1cblxuZnVuY3Rpb24gdHJhdmVyc2VTaW1wbGVJbXBsKG5vZGUsIGVudGVyLCBleGl0LCBzdGF0ZSwgYW5jZXN0b3JzKSB7XG4gIGNvbnN0IGtleXMgPSBfZGVmaW5pdGlvbnMuVklTSVRPUl9LRVlTW25vZGUudHlwZV07XG4gIGlmICgha2V5cykgcmV0dXJuO1xuICBpZiAoZW50ZXIpIGVudGVyKG5vZGUsIGFuY2VzdG9ycywgc3RhdGUpO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCBzdWJOb2RlID0gbm9kZVtrZXldO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3ViTm9kZSkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViTm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHN1Yk5vZGVbaV07XG4gICAgICAgIGlmICghY2hpbGQpIGNvbnRpbnVlO1xuICAgICAgICBhbmNlc3RvcnMucHVzaCh7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgfSk7XG4gICAgICAgIHRyYXZlcnNlU2ltcGxlSW1wbChjaGlsZCwgZW50ZXIsIGV4aXQsIHN0YXRlLCBhbmNlc3RvcnMpO1xuICAgICAgICBhbmNlc3RvcnMucG9wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdWJOb2RlKSB7XG4gICAgICBhbmNlc3RvcnMucHVzaCh7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIGtleVxuICAgICAgfSk7XG4gICAgICB0cmF2ZXJzZVNpbXBsZUltcGwoc3ViTm9kZSwgZW50ZXIsIGV4aXQsIHN0YXRlLCBhbmNlc3RvcnMpO1xuICAgICAgYW5jZXN0b3JzLnBvcCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChleGl0KSBleGl0KG5vZGUsIGFuY2VzdG9ycywgc3RhdGUpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdHJhdmVyc2VGYXN0O1xuXG52YXIgX2RlZmluaXRpb25zID0gcmVxdWlyZShcIi4uL2RlZmluaXRpb25zXCIpO1xuXG5mdW5jdGlvbiB0cmF2ZXJzZUZhc3Qobm9kZSwgZW50ZXIsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm47XG4gIGNvbnN0IGtleXMgPSBfZGVmaW5pdGlvbnMuVklTSVRPUl9LRVlTW25vZGUudHlwZV07XG4gIGlmICgha2V5cykgcmV0dXJuO1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgZW50ZXIobm9kZSwgb3B0cyk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IHN1Yk5vZGUgPSBub2RlW2tleV07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdWJOb2RlKSkge1xuICAgICAgZm9yIChjb25zdCBub2RlIG9mIHN1Yk5vZGUpIHtcbiAgICAgICAgdHJhdmVyc2VGYXN0KG5vZGUsIGVudGVyLCBvcHRzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJhdmVyc2VGYXN0KHN1Yk5vZGUsIGVudGVyLCBvcHRzKTtcbiAgICB9XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGluaGVyaXQ7XG5cbmZ1bmN0aW9uIGluaGVyaXQoa2V5LCBjaGlsZCwgcGFyZW50KSB7XG4gIGlmIChjaGlsZCAmJiBwYXJlbnQpIHtcbiAgICBjaGlsZFtrZXldID0gQXJyYXkuZnJvbShuZXcgU2V0KFtdLmNvbmNhdChjaGlsZFtrZXldLCBwYXJlbnRba2V5XSkuZmlsdGVyKEJvb2xlYW4pKSk7XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNsZWFuSlNYRWxlbWVudExpdGVyYWxDaGlsZDtcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi4vLi4vYnVpbGRlcnMvZ2VuZXJhdGVkXCIpO1xuXG5mdW5jdGlvbiBjbGVhbkpTWEVsZW1lbnRMaXRlcmFsQ2hpbGQoY2hpbGQsIGFyZ3MpIHtcbiAgY29uc3QgbGluZXMgPSBjaGlsZC52YWx1ZS5zcGxpdCgvXFxyXFxufFxcbnxcXHIvKTtcbiAgbGV0IGxhc3ROb25FbXB0eUxpbmUgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobGluZXNbaV0ubWF0Y2goL1teIFxcdF0vKSkge1xuICAgICAgbGFzdE5vbkVtcHR5TGluZSA9IGk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHN0ciA9IFwiXCI7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICBjb25zdCBpc0ZpcnN0TGluZSA9IGkgPT09IDA7XG4gICAgY29uc3QgaXNMYXN0TGluZSA9IGkgPT09IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgaXNMYXN0Tm9uRW1wdHlMaW5lID0gaSA9PT0gbGFzdE5vbkVtcHR5TGluZTtcbiAgICBsZXQgdHJpbW1lZExpbmUgPSBsaW5lLnJlcGxhY2UoL1xcdC9nLCBcIiBcIik7XG5cbiAgICBpZiAoIWlzRmlyc3RMaW5lKSB7XG4gICAgICB0cmltbWVkTGluZSA9IHRyaW1tZWRMaW5lLnJlcGxhY2UoL15bIF0rLywgXCJcIik7XG4gICAgfVxuXG4gICAgaWYgKCFpc0xhc3RMaW5lKSB7XG4gICAgICB0cmltbWVkTGluZSA9IHRyaW1tZWRMaW5lLnJlcGxhY2UoL1sgXSskLywgXCJcIik7XG4gICAgfVxuXG4gICAgaWYgKHRyaW1tZWRMaW5lKSB7XG4gICAgICBpZiAoIWlzTGFzdE5vbkVtcHR5TGluZSkge1xuICAgICAgICB0cmltbWVkTGluZSArPSBcIiBcIjtcbiAgICAgIH1cblxuICAgICAgc3RyICs9IHRyaW1tZWRMaW5lO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdHIpIGFyZ3MucHVzaCgoMCwgX2dlbmVyYXRlZC5zdHJpbmdMaXRlcmFsKShzdHIpKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHNoYWxsb3dFcXVhbDtcblxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGV4cGVjdGVkKTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKGFjdHVhbFtrZXldICE9PSBleHBlY3RlZFtrZXldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBidWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbjtcblxudmFyIF9tYXRjaGVzUGF0dGVybiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbWF0Y2hlc1BhdHRlcm5cIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBidWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbihtYXRjaCwgYWxsb3dQYXJ0aWFsKSB7XG4gIGNvbnN0IHBhcnRzID0gbWF0Y2guc3BsaXQoXCIuXCIpO1xuICByZXR1cm4gbWVtYmVyID0+ICgwLCBfbWF0Y2hlc1BhdHRlcm4uZGVmYXVsdCkobWVtYmVyLCBwYXJ0cywgYWxsb3dQYXJ0aWFsKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNBcnJheUV4cHJlc3Npb24gPSBpc0FycmF5RXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNBc3NpZ25tZW50RXhwcmVzc2lvbiA9IGlzQXNzaWdubWVudEV4cHJlc3Npb247XG5leHBvcnRzLmlzQmluYXJ5RXhwcmVzc2lvbiA9IGlzQmluYXJ5RXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNJbnRlcnByZXRlckRpcmVjdGl2ZSA9IGlzSW50ZXJwcmV0ZXJEaXJlY3RpdmU7XG5leHBvcnRzLmlzRGlyZWN0aXZlID0gaXNEaXJlY3RpdmU7XG5leHBvcnRzLmlzRGlyZWN0aXZlTGl0ZXJhbCA9IGlzRGlyZWN0aXZlTGl0ZXJhbDtcbmV4cG9ydHMuaXNCbG9ja1N0YXRlbWVudCA9IGlzQmxvY2tTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzQnJlYWtTdGF0ZW1lbnQgPSBpc0JyZWFrU3RhdGVtZW50O1xuZXhwb3J0cy5pc0NhbGxFeHByZXNzaW9uID0gaXNDYWxsRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNDYXRjaENsYXVzZSA9IGlzQ2F0Y2hDbGF1c2U7XG5leHBvcnRzLmlzQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gaXNDb25kaXRpb25hbEV4cHJlc3Npb247XG5leHBvcnRzLmlzQ29udGludWVTdGF0ZW1lbnQgPSBpc0NvbnRpbnVlU3RhdGVtZW50O1xuZXhwb3J0cy5pc0RlYnVnZ2VyU3RhdGVtZW50ID0gaXNEZWJ1Z2dlclN0YXRlbWVudDtcbmV4cG9ydHMuaXNEb1doaWxlU3RhdGVtZW50ID0gaXNEb1doaWxlU3RhdGVtZW50O1xuZXhwb3J0cy5pc0VtcHR5U3RhdGVtZW50ID0gaXNFbXB0eVN0YXRlbWVudDtcbmV4cG9ydHMuaXNFeHByZXNzaW9uU3RhdGVtZW50ID0gaXNFeHByZXNzaW9uU3RhdGVtZW50O1xuZXhwb3J0cy5pc0ZpbGUgPSBpc0ZpbGU7XG5leHBvcnRzLmlzRm9ySW5TdGF0ZW1lbnQgPSBpc0ZvckluU3RhdGVtZW50O1xuZXhwb3J0cy5pc0ZvclN0YXRlbWVudCA9IGlzRm9yU3RhdGVtZW50O1xuZXhwb3J0cy5pc0Z1bmN0aW9uRGVjbGFyYXRpb24gPSBpc0Z1bmN0aW9uRGVjbGFyYXRpb247XG5leHBvcnRzLmlzRnVuY3Rpb25FeHByZXNzaW9uID0gaXNGdW5jdGlvbkV4cHJlc3Npb247XG5leHBvcnRzLmlzSWRlbnRpZmllciA9IGlzSWRlbnRpZmllcjtcbmV4cG9ydHMuaXNJZlN0YXRlbWVudCA9IGlzSWZTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzTGFiZWxlZFN0YXRlbWVudCA9IGlzTGFiZWxlZFN0YXRlbWVudDtcbmV4cG9ydHMuaXNTdHJpbmdMaXRlcmFsID0gaXNTdHJpbmdMaXRlcmFsO1xuZXhwb3J0cy5pc051bWVyaWNMaXRlcmFsID0gaXNOdW1lcmljTGl0ZXJhbDtcbmV4cG9ydHMuaXNOdWxsTGl0ZXJhbCA9IGlzTnVsbExpdGVyYWw7XG5leHBvcnRzLmlzQm9vbGVhbkxpdGVyYWwgPSBpc0Jvb2xlYW5MaXRlcmFsO1xuZXhwb3J0cy5pc1JlZ0V4cExpdGVyYWwgPSBpc1JlZ0V4cExpdGVyYWw7XG5leHBvcnRzLmlzTG9naWNhbEV4cHJlc3Npb24gPSBpc0xvZ2ljYWxFeHByZXNzaW9uO1xuZXhwb3J0cy5pc01lbWJlckV4cHJlc3Npb24gPSBpc01lbWJlckV4cHJlc3Npb247XG5leHBvcnRzLmlzTmV3RXhwcmVzc2lvbiA9IGlzTmV3RXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNQcm9ncmFtID0gaXNQcm9ncmFtO1xuZXhwb3J0cy5pc09iamVjdEV4cHJlc3Npb24gPSBpc09iamVjdEV4cHJlc3Npb247XG5leHBvcnRzLmlzT2JqZWN0TWV0aG9kID0gaXNPYmplY3RNZXRob2Q7XG5leHBvcnRzLmlzT2JqZWN0UHJvcGVydHkgPSBpc09iamVjdFByb3BlcnR5O1xuZXhwb3J0cy5pc1Jlc3RFbGVtZW50ID0gaXNSZXN0RWxlbWVudDtcbmV4cG9ydHMuaXNSZXR1cm5TdGF0ZW1lbnQgPSBpc1JldHVyblN0YXRlbWVudDtcbmV4cG9ydHMuaXNTZXF1ZW5jZUV4cHJlc3Npb24gPSBpc1NlcXVlbmNlRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiA9IGlzUGFyZW50aGVzaXplZEV4cHJlc3Npb247XG5leHBvcnRzLmlzU3dpdGNoQ2FzZSA9IGlzU3dpdGNoQ2FzZTtcbmV4cG9ydHMuaXNTd2l0Y2hTdGF0ZW1lbnQgPSBpc1N3aXRjaFN0YXRlbWVudDtcbmV4cG9ydHMuaXNUaGlzRXhwcmVzc2lvbiA9IGlzVGhpc0V4cHJlc3Npb247XG5leHBvcnRzLmlzVGhyb3dTdGF0ZW1lbnQgPSBpc1Rocm93U3RhdGVtZW50O1xuZXhwb3J0cy5pc1RyeVN0YXRlbWVudCA9IGlzVHJ5U3RhdGVtZW50O1xuZXhwb3J0cy5pc1VuYXJ5RXhwcmVzc2lvbiA9IGlzVW5hcnlFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1VwZGF0ZUV4cHJlc3Npb24gPSBpc1VwZGF0ZUV4cHJlc3Npb247XG5leHBvcnRzLmlzVmFyaWFibGVEZWNsYXJhdGlvbiA9IGlzVmFyaWFibGVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNWYXJpYWJsZURlY2xhcmF0b3IgPSBpc1ZhcmlhYmxlRGVjbGFyYXRvcjtcbmV4cG9ydHMuaXNXaGlsZVN0YXRlbWVudCA9IGlzV2hpbGVTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzV2l0aFN0YXRlbWVudCA9IGlzV2l0aFN0YXRlbWVudDtcbmV4cG9ydHMuaXNBc3NpZ25tZW50UGF0dGVybiA9IGlzQXNzaWdubWVudFBhdHRlcm47XG5leHBvcnRzLmlzQXJyYXlQYXR0ZXJuID0gaXNBcnJheVBhdHRlcm47XG5leHBvcnRzLmlzQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSBpc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uO1xuZXhwb3J0cy5pc0NsYXNzQm9keSA9IGlzQ2xhc3NCb2R5O1xuZXhwb3J0cy5pc0NsYXNzRXhwcmVzc2lvbiA9IGlzQ2xhc3NFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0NsYXNzRGVjbGFyYXRpb24gPSBpc0NsYXNzRGVjbGFyYXRpb247XG5leHBvcnRzLmlzRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBpc0V4cG9ydEFsbERlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IGlzRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0V4cG9ydE5hbWVkRGVjbGFyYXRpb24gPSBpc0V4cG9ydE5hbWVkRGVjbGFyYXRpb247XG5leHBvcnRzLmlzRXhwb3J0U3BlY2lmaWVyID0gaXNFeHBvcnRTcGVjaWZpZXI7XG5leHBvcnRzLmlzRm9yT2ZTdGF0ZW1lbnQgPSBpc0Zvck9mU3RhdGVtZW50O1xuZXhwb3J0cy5pc0ltcG9ydERlY2xhcmF0aW9uID0gaXNJbXBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNJbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gaXNJbXBvcnREZWZhdWx0U3BlY2lmaWVyO1xuZXhwb3J0cy5pc0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGlzSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xuZXhwb3J0cy5pc0ltcG9ydFNwZWNpZmllciA9IGlzSW1wb3J0U3BlY2lmaWVyO1xuZXhwb3J0cy5pc01ldGFQcm9wZXJ0eSA9IGlzTWV0YVByb3BlcnR5O1xuZXhwb3J0cy5pc0NsYXNzTWV0aG9kID0gaXNDbGFzc01ldGhvZDtcbmV4cG9ydHMuaXNPYmplY3RQYXR0ZXJuID0gaXNPYmplY3RQYXR0ZXJuO1xuZXhwb3J0cy5pc1NwcmVhZEVsZW1lbnQgPSBpc1NwcmVhZEVsZW1lbnQ7XG5leHBvcnRzLmlzU3VwZXIgPSBpc1N1cGVyO1xuZXhwb3J0cy5pc1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiA9IGlzVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1RlbXBsYXRlRWxlbWVudCA9IGlzVGVtcGxhdGVFbGVtZW50O1xuZXhwb3J0cy5pc1RlbXBsYXRlTGl0ZXJhbCA9IGlzVGVtcGxhdGVMaXRlcmFsO1xuZXhwb3J0cy5pc1lpZWxkRXhwcmVzc2lvbiA9IGlzWWllbGRFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0FueVR5cGVBbm5vdGF0aW9uID0gaXNBbnlUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNBcnJheVR5cGVBbm5vdGF0aW9uID0gaXNBcnJheVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0Jvb2xlYW5UeXBlQW5ub3RhdGlvbiA9IGlzQm9vbGVhblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0Jvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb24gPSBpc0Jvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGlzTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNDbGFzc0ltcGxlbWVudHMgPSBpc0NsYXNzSW1wbGVtZW50cztcbmV4cG9ydHMuaXNEZWNsYXJlQ2xhc3MgPSBpc0RlY2xhcmVDbGFzcztcbmV4cG9ydHMuaXNEZWNsYXJlRnVuY3Rpb24gPSBpc0RlY2xhcmVGdW5jdGlvbjtcbmV4cG9ydHMuaXNEZWNsYXJlSW50ZXJmYWNlID0gaXNEZWNsYXJlSW50ZXJmYWNlO1xuZXhwb3J0cy5pc0RlY2xhcmVNb2R1bGUgPSBpc0RlY2xhcmVNb2R1bGU7XG5leHBvcnRzLmlzRGVjbGFyZU1vZHVsZUV4cG9ydHMgPSBpc0RlY2xhcmVNb2R1bGVFeHBvcnRzO1xuZXhwb3J0cy5pc0RlY2xhcmVUeXBlQWxpYXMgPSBpc0RlY2xhcmVUeXBlQWxpYXM7XG5leHBvcnRzLmlzRGVjbGFyZU9wYXF1ZVR5cGUgPSBpc0RlY2xhcmVPcGFxdWVUeXBlO1xuZXhwb3J0cy5pc0RlY2xhcmVWYXJpYWJsZSA9IGlzRGVjbGFyZVZhcmlhYmxlO1xuZXhwb3J0cy5pc0RlY2xhcmVFeHBvcnREZWNsYXJhdGlvbiA9IGlzRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0RlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvbiA9IGlzRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0RlY2xhcmVkUHJlZGljYXRlID0gaXNEZWNsYXJlZFByZWRpY2F0ZTtcbmV4cG9ydHMuaXNFeGlzdHNUeXBlQW5ub3RhdGlvbiA9IGlzRXhpc3RzVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzRnVuY3Rpb25UeXBlQW5ub3RhdGlvbiA9IGlzRnVuY3Rpb25UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNGdW5jdGlvblR5cGVQYXJhbSA9IGlzRnVuY3Rpb25UeXBlUGFyYW07XG5leHBvcnRzLmlzR2VuZXJpY1R5cGVBbm5vdGF0aW9uID0gaXNHZW5lcmljVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzSW5mZXJyZWRQcmVkaWNhdGUgPSBpc0luZmVycmVkUHJlZGljYXRlO1xuZXhwb3J0cy5pc0ludGVyZmFjZUV4dGVuZHMgPSBpc0ludGVyZmFjZUV4dGVuZHM7XG5leHBvcnRzLmlzSW50ZXJmYWNlRGVjbGFyYXRpb24gPSBpc0ludGVyZmFjZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0ludGVyZmFjZVR5cGVBbm5vdGF0aW9uID0gaXNJbnRlcmZhY2VUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvbiA9IGlzSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzTWl4ZWRUeXBlQW5ub3RhdGlvbiA9IGlzTWl4ZWRUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNFbXB0eVR5cGVBbm5vdGF0aW9uID0gaXNFbXB0eVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc051bGxhYmxlVHlwZUFubm90YXRpb24gPSBpc051bGxhYmxlVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gaXNOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzTnVtYmVyVHlwZUFubm90YXRpb24gPSBpc051bWJlclR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc09iamVjdFR5cGVBbm5vdGF0aW9uID0gaXNPYmplY3RUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNPYmplY3RUeXBlSW50ZXJuYWxTbG90ID0gaXNPYmplY3RUeXBlSW50ZXJuYWxTbG90O1xuZXhwb3J0cy5pc09iamVjdFR5cGVDYWxsUHJvcGVydHkgPSBpc09iamVjdFR5cGVDYWxsUHJvcGVydHk7XG5leHBvcnRzLmlzT2JqZWN0VHlwZUluZGV4ZXIgPSBpc09iamVjdFR5cGVJbmRleGVyO1xuZXhwb3J0cy5pc09iamVjdFR5cGVQcm9wZXJ0eSA9IGlzT2JqZWN0VHlwZVByb3BlcnR5O1xuZXhwb3J0cy5pc09iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eSA9IGlzT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5O1xuZXhwb3J0cy5pc09wYXF1ZVR5cGUgPSBpc09wYXF1ZVR5cGU7XG5leHBvcnRzLmlzUXVhbGlmaWVkVHlwZUlkZW50aWZpZXIgPSBpc1F1YWxpZmllZFR5cGVJZGVudGlmaWVyO1xuZXhwb3J0cy5pc1N0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGlzU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc1N0cmluZ1R5cGVBbm5vdGF0aW9uID0gaXNTdHJpbmdUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNTeW1ib2xUeXBlQW5ub3RhdGlvbiA9IGlzU3ltYm9sVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzVGhpc1R5cGVBbm5vdGF0aW9uID0gaXNUaGlzVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzVHVwbGVUeXBlQW5ub3RhdGlvbiA9IGlzVHVwbGVUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNUeXBlb2ZUeXBlQW5ub3RhdGlvbiA9IGlzVHlwZW9mVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzVHlwZUFsaWFzID0gaXNUeXBlQWxpYXM7XG5leHBvcnRzLmlzVHlwZUFubm90YXRpb24gPSBpc1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc1R5cGVDYXN0RXhwcmVzc2lvbiA9IGlzVHlwZUNhc3RFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1R5cGVQYXJhbWV0ZXIgPSBpc1R5cGVQYXJhbWV0ZXI7XG5leHBvcnRzLmlzVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uID0gaXNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24gPSBpc1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uO1xuZXhwb3J0cy5pc1VuaW9uVHlwZUFubm90YXRpb24gPSBpc1VuaW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzVmFyaWFuY2UgPSBpc1ZhcmlhbmNlO1xuZXhwb3J0cy5pc1ZvaWRUeXBlQW5ub3RhdGlvbiA9IGlzVm9pZFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0VudW1EZWNsYXJhdGlvbiA9IGlzRW51bURlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0VudW1Cb29sZWFuQm9keSA9IGlzRW51bUJvb2xlYW5Cb2R5O1xuZXhwb3J0cy5pc0VudW1OdW1iZXJCb2R5ID0gaXNFbnVtTnVtYmVyQm9keTtcbmV4cG9ydHMuaXNFbnVtU3RyaW5nQm9keSA9IGlzRW51bVN0cmluZ0JvZHk7XG5leHBvcnRzLmlzRW51bVN5bWJvbEJvZHkgPSBpc0VudW1TeW1ib2xCb2R5O1xuZXhwb3J0cy5pc0VudW1Cb29sZWFuTWVtYmVyID0gaXNFbnVtQm9vbGVhbk1lbWJlcjtcbmV4cG9ydHMuaXNFbnVtTnVtYmVyTWVtYmVyID0gaXNFbnVtTnVtYmVyTWVtYmVyO1xuZXhwb3J0cy5pc0VudW1TdHJpbmdNZW1iZXIgPSBpc0VudW1TdHJpbmdNZW1iZXI7XG5leHBvcnRzLmlzRW51bURlZmF1bHRlZE1lbWJlciA9IGlzRW51bURlZmF1bHRlZE1lbWJlcjtcbmV4cG9ydHMuaXNKU1hBdHRyaWJ1dGUgPSBpc0pTWEF0dHJpYnV0ZTtcbmV4cG9ydHMuaXNKU1hDbG9zaW5nRWxlbWVudCA9IGlzSlNYQ2xvc2luZ0VsZW1lbnQ7XG5leHBvcnRzLmlzSlNYRWxlbWVudCA9IGlzSlNYRWxlbWVudDtcbmV4cG9ydHMuaXNKU1hFbXB0eUV4cHJlc3Npb24gPSBpc0pTWEVtcHR5RXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNKU1hFeHByZXNzaW9uQ29udGFpbmVyID0gaXNKU1hFeHByZXNzaW9uQ29udGFpbmVyO1xuZXhwb3J0cy5pc0pTWFNwcmVhZENoaWxkID0gaXNKU1hTcHJlYWRDaGlsZDtcbmV4cG9ydHMuaXNKU1hJZGVudGlmaWVyID0gaXNKU1hJZGVudGlmaWVyO1xuZXhwb3J0cy5pc0pTWE1lbWJlckV4cHJlc3Npb24gPSBpc0pTWE1lbWJlckV4cHJlc3Npb247XG5leHBvcnRzLmlzSlNYTmFtZXNwYWNlZE5hbWUgPSBpc0pTWE5hbWVzcGFjZWROYW1lO1xuZXhwb3J0cy5pc0pTWE9wZW5pbmdFbGVtZW50ID0gaXNKU1hPcGVuaW5nRWxlbWVudDtcbmV4cG9ydHMuaXNKU1hTcHJlYWRBdHRyaWJ1dGUgPSBpc0pTWFNwcmVhZEF0dHJpYnV0ZTtcbmV4cG9ydHMuaXNKU1hUZXh0ID0gaXNKU1hUZXh0O1xuZXhwb3J0cy5pc0pTWEZyYWdtZW50ID0gaXNKU1hGcmFnbWVudDtcbmV4cG9ydHMuaXNKU1hPcGVuaW5nRnJhZ21lbnQgPSBpc0pTWE9wZW5pbmdGcmFnbWVudDtcbmV4cG9ydHMuaXNKU1hDbG9zaW5nRnJhZ21lbnQgPSBpc0pTWENsb3NpbmdGcmFnbWVudDtcbmV4cG9ydHMuaXNOb29wID0gaXNOb29wO1xuZXhwb3J0cy5pc1BsYWNlaG9sZGVyID0gaXNQbGFjZWhvbGRlcjtcbmV4cG9ydHMuaXNWOEludHJpbnNpY0lkZW50aWZpZXIgPSBpc1Y4SW50cmluc2ljSWRlbnRpZmllcjtcbmV4cG9ydHMuaXNBcmd1bWVudFBsYWNlaG9sZGVyID0gaXNBcmd1bWVudFBsYWNlaG9sZGVyO1xuZXhwb3J0cy5pc0F3YWl0RXhwcmVzc2lvbiA9IGlzQXdhaXRFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0JpbmRFeHByZXNzaW9uID0gaXNCaW5kRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNDbGFzc1Byb3BlcnR5ID0gaXNDbGFzc1Byb3BlcnR5O1xuZXhwb3J0cy5pc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbiA9IGlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1BpcGVsaW5lVG9waWNFeHByZXNzaW9uID0gaXNQaXBlbGluZVRvcGljRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNQaXBlbGluZUJhcmVGdW5jdGlvbiA9IGlzUGlwZWxpbmVCYXJlRnVuY3Rpb247XG5leHBvcnRzLmlzUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2UgPSBpc1BpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlO1xuZXhwb3J0cy5pc09wdGlvbmFsQ2FsbEV4cHJlc3Npb24gPSBpc09wdGlvbmFsQ2FsbEV4cHJlc3Npb247XG5leHBvcnRzLmlzQ2xhc3NQcml2YXRlUHJvcGVydHkgPSBpc0NsYXNzUHJpdmF0ZVByb3BlcnR5O1xuZXhwb3J0cy5pc0NsYXNzUHJpdmF0ZU1ldGhvZCA9IGlzQ2xhc3NQcml2YXRlTWV0aG9kO1xuZXhwb3J0cy5pc0ltcG9ydCA9IGlzSW1wb3J0O1xuZXhwb3J0cy5pc0ltcG9ydEF0dHJpYnV0ZSA9IGlzSW1wb3J0QXR0cmlidXRlO1xuZXhwb3J0cy5pc0RlY29yYXRvciA9IGlzRGVjb3JhdG9yO1xuZXhwb3J0cy5pc0RvRXhwcmVzc2lvbiA9IGlzRG9FeHByZXNzaW9uO1xuZXhwb3J0cy5pc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIgPSBpc0V4cG9ydERlZmF1bHRTcGVjaWZpZXI7XG5leHBvcnRzLmlzRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gaXNFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXI7XG5leHBvcnRzLmlzUHJpdmF0ZU5hbWUgPSBpc1ByaXZhdGVOYW1lO1xuZXhwb3J0cy5pc0JpZ0ludExpdGVyYWwgPSBpc0JpZ0ludExpdGVyYWw7XG5leHBvcnRzLmlzUmVjb3JkRXhwcmVzc2lvbiA9IGlzUmVjb3JkRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNUdXBsZUV4cHJlc3Npb24gPSBpc1R1cGxlRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNUU1BhcmFtZXRlclByb3BlcnR5ID0gaXNUU1BhcmFtZXRlclByb3BlcnR5O1xuZXhwb3J0cy5pc1RTRGVjbGFyZUZ1bmN0aW9uID0gaXNUU0RlY2xhcmVGdW5jdGlvbjtcbmV4cG9ydHMuaXNUU0RlY2xhcmVNZXRob2QgPSBpc1RTRGVjbGFyZU1ldGhvZDtcbmV4cG9ydHMuaXNUU1F1YWxpZmllZE5hbWUgPSBpc1RTUXVhbGlmaWVkTmFtZTtcbmV4cG9ydHMuaXNUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbiA9IGlzVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbiA9IGlzVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNUU1Byb3BlcnR5U2lnbmF0dXJlID0gaXNUU1Byb3BlcnR5U2lnbmF0dXJlO1xuZXhwb3J0cy5pc1RTTWV0aG9kU2lnbmF0dXJlID0gaXNUU01ldGhvZFNpZ25hdHVyZTtcbmV4cG9ydHMuaXNUU0luZGV4U2lnbmF0dXJlID0gaXNUU0luZGV4U2lnbmF0dXJlO1xuZXhwb3J0cy5pc1RTQW55S2V5d29yZCA9IGlzVFNBbnlLZXl3b3JkO1xuZXhwb3J0cy5pc1RTQm9vbGVhbktleXdvcmQgPSBpc1RTQm9vbGVhbktleXdvcmQ7XG5leHBvcnRzLmlzVFNCaWdJbnRLZXl3b3JkID0gaXNUU0JpZ0ludEtleXdvcmQ7XG5leHBvcnRzLmlzVFNOZXZlcktleXdvcmQgPSBpc1RTTmV2ZXJLZXl3b3JkO1xuZXhwb3J0cy5pc1RTTnVsbEtleXdvcmQgPSBpc1RTTnVsbEtleXdvcmQ7XG5leHBvcnRzLmlzVFNOdW1iZXJLZXl3b3JkID0gaXNUU051bWJlcktleXdvcmQ7XG5leHBvcnRzLmlzVFNPYmplY3RLZXl3b3JkID0gaXNUU09iamVjdEtleXdvcmQ7XG5leHBvcnRzLmlzVFNTdHJpbmdLZXl3b3JkID0gaXNUU1N0cmluZ0tleXdvcmQ7XG5leHBvcnRzLmlzVFNTeW1ib2xLZXl3b3JkID0gaXNUU1N5bWJvbEtleXdvcmQ7XG5leHBvcnRzLmlzVFNVbmRlZmluZWRLZXl3b3JkID0gaXNUU1VuZGVmaW5lZEtleXdvcmQ7XG5leHBvcnRzLmlzVFNVbmtub3duS2V5d29yZCA9IGlzVFNVbmtub3duS2V5d29yZDtcbmV4cG9ydHMuaXNUU1ZvaWRLZXl3b3JkID0gaXNUU1ZvaWRLZXl3b3JkO1xuZXhwb3J0cy5pc1RTVGhpc1R5cGUgPSBpc1RTVGhpc1R5cGU7XG5leHBvcnRzLmlzVFNGdW5jdGlvblR5cGUgPSBpc1RTRnVuY3Rpb25UeXBlO1xuZXhwb3J0cy5pc1RTQ29uc3RydWN0b3JUeXBlID0gaXNUU0NvbnN0cnVjdG9yVHlwZTtcbmV4cG9ydHMuaXNUU1R5cGVSZWZlcmVuY2UgPSBpc1RTVHlwZVJlZmVyZW5jZTtcbmV4cG9ydHMuaXNUU1R5cGVQcmVkaWNhdGUgPSBpc1RTVHlwZVByZWRpY2F0ZTtcbmV4cG9ydHMuaXNUU1R5cGVRdWVyeSA9IGlzVFNUeXBlUXVlcnk7XG5leHBvcnRzLmlzVFNUeXBlTGl0ZXJhbCA9IGlzVFNUeXBlTGl0ZXJhbDtcbmV4cG9ydHMuaXNUU0FycmF5VHlwZSA9IGlzVFNBcnJheVR5cGU7XG5leHBvcnRzLmlzVFNUdXBsZVR5cGUgPSBpc1RTVHVwbGVUeXBlO1xuZXhwb3J0cy5pc1RTT3B0aW9uYWxUeXBlID0gaXNUU09wdGlvbmFsVHlwZTtcbmV4cG9ydHMuaXNUU1Jlc3RUeXBlID0gaXNUU1Jlc3RUeXBlO1xuZXhwb3J0cy5pc1RTVW5pb25UeXBlID0gaXNUU1VuaW9uVHlwZTtcbmV4cG9ydHMuaXNUU0ludGVyc2VjdGlvblR5cGUgPSBpc1RTSW50ZXJzZWN0aW9uVHlwZTtcbmV4cG9ydHMuaXNUU0NvbmRpdGlvbmFsVHlwZSA9IGlzVFNDb25kaXRpb25hbFR5cGU7XG5leHBvcnRzLmlzVFNJbmZlclR5cGUgPSBpc1RTSW5mZXJUeXBlO1xuZXhwb3J0cy5pc1RTUGFyZW50aGVzaXplZFR5cGUgPSBpc1RTUGFyZW50aGVzaXplZFR5cGU7XG5leHBvcnRzLmlzVFNUeXBlT3BlcmF0b3IgPSBpc1RTVHlwZU9wZXJhdG9yO1xuZXhwb3J0cy5pc1RTSW5kZXhlZEFjY2Vzc1R5cGUgPSBpc1RTSW5kZXhlZEFjY2Vzc1R5cGU7XG5leHBvcnRzLmlzVFNNYXBwZWRUeXBlID0gaXNUU01hcHBlZFR5cGU7XG5leHBvcnRzLmlzVFNMaXRlcmFsVHlwZSA9IGlzVFNMaXRlcmFsVHlwZTtcbmV4cG9ydHMuaXNUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cyA9IGlzVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHM7XG5leHBvcnRzLmlzVFNJbnRlcmZhY2VEZWNsYXJhdGlvbiA9IGlzVFNJbnRlcmZhY2VEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNUU0ludGVyZmFjZUJvZHkgPSBpc1RTSW50ZXJmYWNlQm9keTtcbmV4cG9ydHMuaXNUU1R5cGVBbGlhc0RlY2xhcmF0aW9uID0gaXNUU1R5cGVBbGlhc0RlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc1RTQXNFeHByZXNzaW9uID0gaXNUU0FzRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNUU1R5cGVBc3NlcnRpb24gPSBpc1RTVHlwZUFzc2VydGlvbjtcbmV4cG9ydHMuaXNUU0VudW1EZWNsYXJhdGlvbiA9IGlzVFNFbnVtRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVFNFbnVtTWVtYmVyID0gaXNUU0VudW1NZW1iZXI7XG5leHBvcnRzLmlzVFNNb2R1bGVEZWNsYXJhdGlvbiA9IGlzVFNNb2R1bGVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNUU01vZHVsZUJsb2NrID0gaXNUU01vZHVsZUJsb2NrO1xuZXhwb3J0cy5pc1RTSW1wb3J0VHlwZSA9IGlzVFNJbXBvcnRUeXBlO1xuZXhwb3J0cy5pc1RTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24gPSBpc1RTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZSA9IGlzVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZTtcbmV4cG9ydHMuaXNUU05vbk51bGxFeHByZXNzaW9uID0gaXNUU05vbk51bGxFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1RTRXhwb3J0QXNzaWdubWVudCA9IGlzVFNFeHBvcnRBc3NpZ25tZW50O1xuZXhwb3J0cy5pc1RTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24gPSBpc1RTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb247XG5leHBvcnRzLmlzVFNUeXBlQW5ub3RhdGlvbiA9IGlzVFNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uID0gaXNUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uO1xuZXhwb3J0cy5pc1RTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uID0gaXNUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNUU1R5cGVQYXJhbWV0ZXIgPSBpc1RTVHlwZVBhcmFtZXRlcjtcbmV4cG9ydHMuaXNFeHByZXNzaW9uID0gaXNFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0JpbmFyeSA9IGlzQmluYXJ5O1xuZXhwb3J0cy5pc1Njb3BhYmxlID0gaXNTY29wYWJsZTtcbmV4cG9ydHMuaXNCbG9ja1BhcmVudCA9IGlzQmxvY2tQYXJlbnQ7XG5leHBvcnRzLmlzQmxvY2sgPSBpc0Jsb2NrO1xuZXhwb3J0cy5pc1N0YXRlbWVudCA9IGlzU3RhdGVtZW50O1xuZXhwb3J0cy5pc1Rlcm1pbmF0b3JsZXNzID0gaXNUZXJtaW5hdG9ybGVzcztcbmV4cG9ydHMuaXNDb21wbGV0aW9uU3RhdGVtZW50ID0gaXNDb21wbGV0aW9uU3RhdGVtZW50O1xuZXhwb3J0cy5pc0NvbmRpdGlvbmFsID0gaXNDb25kaXRpb25hbDtcbmV4cG9ydHMuaXNMb29wID0gaXNMb29wO1xuZXhwb3J0cy5pc1doaWxlID0gaXNXaGlsZTtcbmV4cG9ydHMuaXNFeHByZXNzaW9uV3JhcHBlciA9IGlzRXhwcmVzc2lvbldyYXBwZXI7XG5leHBvcnRzLmlzRm9yID0gaXNGb3I7XG5leHBvcnRzLmlzRm9yWFN0YXRlbWVudCA9IGlzRm9yWFN0YXRlbWVudDtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmlzRnVuY3Rpb25QYXJlbnQgPSBpc0Z1bmN0aW9uUGFyZW50O1xuZXhwb3J0cy5pc1B1cmVpc2ggPSBpc1B1cmVpc2g7XG5leHBvcnRzLmlzRGVjbGFyYXRpb24gPSBpc0RlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc1BhdHRlcm5MaWtlID0gaXNQYXR0ZXJuTGlrZTtcbmV4cG9ydHMuaXNMVmFsID0gaXNMVmFsO1xuZXhwb3J0cy5pc1RTRW50aXR5TmFtZSA9IGlzVFNFbnRpdHlOYW1lO1xuZXhwb3J0cy5pc0xpdGVyYWwgPSBpc0xpdGVyYWw7XG5leHBvcnRzLmlzSW1tdXRhYmxlID0gaXNJbW11dGFibGU7XG5leHBvcnRzLmlzVXNlcldoaXRlc3BhY2FibGUgPSBpc1VzZXJXaGl0ZXNwYWNhYmxlO1xuZXhwb3J0cy5pc01ldGhvZCA9IGlzTWV0aG9kO1xuZXhwb3J0cy5pc09iamVjdE1lbWJlciA9IGlzT2JqZWN0TWVtYmVyO1xuZXhwb3J0cy5pc1Byb3BlcnR5ID0gaXNQcm9wZXJ0eTtcbmV4cG9ydHMuaXNVbmFyeUxpa2UgPSBpc1VuYXJ5TGlrZTtcbmV4cG9ydHMuaXNQYXR0ZXJuID0gaXNQYXR0ZXJuO1xuZXhwb3J0cy5pc0NsYXNzID0gaXNDbGFzcztcbmV4cG9ydHMuaXNNb2R1bGVEZWNsYXJhdGlvbiA9IGlzTW9kdWxlRGVjbGFyYXRpb247XG5leHBvcnRzLmlzRXhwb3J0RGVjbGFyYXRpb24gPSBpc0V4cG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc01vZHVsZVNwZWNpZmllciA9IGlzTW9kdWxlU3BlY2lmaWVyO1xuZXhwb3J0cy5pc0Zsb3cgPSBpc0Zsb3c7XG5leHBvcnRzLmlzRmxvd1R5cGUgPSBpc0Zsb3dUeXBlO1xuZXhwb3J0cy5pc0Zsb3dCYXNlQW5ub3RhdGlvbiA9IGlzRmxvd0Jhc2VBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0Zsb3dEZWNsYXJhdGlvbiA9IGlzRmxvd0RlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0Zsb3dQcmVkaWNhdGUgPSBpc0Zsb3dQcmVkaWNhdGU7XG5leHBvcnRzLmlzRW51bUJvZHkgPSBpc0VudW1Cb2R5O1xuZXhwb3J0cy5pc0VudW1NZW1iZXIgPSBpc0VudW1NZW1iZXI7XG5leHBvcnRzLmlzSlNYID0gaXNKU1g7XG5leHBvcnRzLmlzUHJpdmF0ZSA9IGlzUHJpdmF0ZTtcbmV4cG9ydHMuaXNUU1R5cGVFbGVtZW50ID0gaXNUU1R5cGVFbGVtZW50O1xuZXhwb3J0cy5pc1RTVHlwZSA9IGlzVFNUeXBlO1xuZXhwb3J0cy5pc1RTQmFzZVR5cGUgPSBpc1RTQmFzZVR5cGU7XG5leHBvcnRzLmlzTnVtYmVyTGl0ZXJhbCA9IGlzTnVtYmVyTGl0ZXJhbDtcbmV4cG9ydHMuaXNSZWdleExpdGVyYWwgPSBpc1JlZ2V4TGl0ZXJhbDtcbmV4cG9ydHMuaXNSZXN0UHJvcGVydHkgPSBpc1Jlc3RQcm9wZXJ0eTtcbmV4cG9ydHMuaXNTcHJlYWRQcm9wZXJ0eSA9IGlzU3ByZWFkUHJvcGVydHk7XG5cbnZhciBfc2hhbGxvd0VxdWFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vdXRpbHMvc2hhbGxvd0VxdWFsXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNBcnJheUV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkFycmF5RXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQmluYXJ5RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQmluYXJ5RXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNJbnRlcnByZXRlckRpcmVjdGl2ZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSW50ZXJwcmV0ZXJEaXJlY3RpdmVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRGlyZWN0aXZlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJEaXJlY3RpdmVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRGlyZWN0aXZlTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRGlyZWN0aXZlTGl0ZXJhbFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNCbG9ja1N0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQmxvY2tTdGF0ZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQnJlYWtTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkJyZWFrU3RhdGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0NhbGxFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNDYXRjaENsYXVzZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQ2F0Y2hDbGF1c2VcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQ29uZGl0aW9uYWxFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGludWVTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkNvbnRpbnVlU3RhdGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlYnVnZ2VyU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJEZWJ1Z2dlclN0YXRlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNEb1doaWxlU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJEb1doaWxlU3RhdGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VtcHR5U3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFbXB0eVN0YXRlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0ZpbGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkZpbGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRm9ySW5TdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkZvckluU3RhdGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0ZvclN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRm9yU3RhdGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNJZlN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSWZTdGF0ZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTGFiZWxlZFN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiTGFiZWxlZFN0YXRlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJTdHJpbmdMaXRlcmFsXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc051bWVyaWNMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJOdW1lcmljTGl0ZXJhbFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNOdWxsTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiTnVsbExpdGVyYWxcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbkxpdGVyYWwobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkJvb2xlYW5MaXRlcmFsXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cExpdGVyYWwobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlJlZ0V4cExpdGVyYWxcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTG9naWNhbEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkxvZ2ljYWxFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc01lbWJlckV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTmV3RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiTmV3RXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNQcm9ncmFtKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJQcm9ncmFtXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk9iamVjdEV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0TWV0aG9kKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJPYmplY3RNZXRob2RcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0UHJvcGVydHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk9iamVjdFByb3BlcnR5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1Jlc3RFbGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNSZXR1cm5TdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlJldHVyblN0YXRlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNTZXF1ZW5jZUV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNQYXJlbnRoZXNpemVkRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzU3dpdGNoQ2FzZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiU3dpdGNoQ2FzZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNTd2l0Y2hTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlN3aXRjaFN0YXRlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUaGlzRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVGhpc0V4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVGhyb3dTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRocm93U3RhdGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RyeVN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVHJ5U3RhdGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1VuYXJ5RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVW5hcnlFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1VwZGF0ZUV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlVwZGF0ZUV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVmFyaWFibGVEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNWYXJpYWJsZURlY2xhcmF0b3Iobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNXaGlsZVN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiV2hpbGVTdGF0ZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzV2l0aFN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiV2l0aFN0YXRlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNBc3NpZ25tZW50UGF0dGVybihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlQYXR0ZXJuKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0NsYXNzQm9keShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQ2xhc3NCb2R5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0NsYXNzRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQ2xhc3NFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0NsYXNzRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRXhwb3J0QWxsRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0V4cG9ydE5hbWVkRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRXhwb3J0U3BlY2lmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFeHBvcnRTcGVjaWZpZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRm9yT2ZTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkZvck9mU3RhdGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0ltcG9ydERlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJJbXBvcnREZWNsYXJhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNJbXBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0ltcG9ydFNwZWNpZmllcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSW1wb3J0U3BlY2lmaWVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc01ldGFQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiTWV0YVByb3BlcnR5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0NsYXNzTWV0aG9kKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJDbGFzc01ldGhvZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3RQYXR0ZXJuKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1NwcmVhZEVsZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzU3VwZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlN1cGVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RlbXBsYXRlRWxlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVGVtcGxhdGVFbGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RlbXBsYXRlTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVGVtcGxhdGVMaXRlcmFsXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1lpZWxkRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiWWllbGRFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0FueVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJBbnlUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNBcnJheVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJBcnJheVR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW5UeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQm9vbGVhblR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNDbGFzc0ltcGxlbWVudHMobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkNsYXNzSW1wbGVtZW50c1wiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNEZWNsYXJlQ2xhc3Mobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRlY2xhcmVDbGFzc1wiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNEZWNsYXJlRnVuY3Rpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRlY2xhcmVGdW5jdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNEZWNsYXJlSW50ZXJmYWNlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJEZWNsYXJlSW50ZXJmYWNlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlY2xhcmVNb2R1bGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRlY2xhcmVNb2R1bGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRGVjbGFyZU1vZHVsZUV4cG9ydHMobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlY2xhcmVUeXBlQWxpYXMobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRlY2xhcmVUeXBlQWxpYXNcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRGVjbGFyZU9wYXF1ZVR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRlY2xhcmVPcGFxdWVUeXBlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlY2xhcmVWYXJpYWJsZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRGVjbGFyZVZhcmlhYmxlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlY2xhcmVFeHBvcnREZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlY2xhcmVkUHJlZGljYXRlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJEZWNsYXJlZFByZWRpY2F0ZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFeGlzdHNUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRXhpc3RzVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb25UeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvblR5cGVQYXJhbShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRnVuY3Rpb25UeXBlUGFyYW1cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzR2VuZXJpY1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJHZW5lcmljVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSW5mZXJyZWRQcmVkaWNhdGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkluZmVycmVkUHJlZGljYXRlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0ludGVyZmFjZUV4dGVuZHMobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkludGVyZmFjZUV4dGVuZHNcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkludGVyZmFjZURlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0ludGVyZmFjZVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJJbnRlcmZhY2VUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTWl4ZWRUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiTWl4ZWRUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFbXB0eVR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc051bGxhYmxlVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk51bWJlclR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3RUeXBlSW50ZXJuYWxTbG90KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJPYmplY3RUeXBlSW50ZXJuYWxTbG90XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdFR5cGVDYWxsUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0VHlwZUluZGV4ZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk9iamVjdFR5cGVJbmRleGVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdFR5cGVQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiT2JqZWN0VHlwZVByb3BlcnR5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc09wYXF1ZVR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk9wYXF1ZVR5cGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzUXVhbGlmaWVkVHlwZUlkZW50aWZpZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1N0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1N0cmluZ1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJTdHJpbmdUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNTeW1ib2xUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiU3ltYm9sVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVGhpc1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUaGlzVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVHVwbGVUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVHVwbGVUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUeXBlb2ZUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVHlwZW9mVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVHlwZUFsaWFzKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUeXBlQWxpYXNcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1R5cGVDYXN0RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1R5cGVQYXJhbWV0ZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlR5cGVQYXJhbWV0ZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1VuaW9uVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlVuaW9uVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVmFyaWFuY2Uobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlZhcmlhbmNlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1ZvaWRUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVm9pZFR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VudW1EZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRW51bURlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VudW1Cb29sZWFuQm9keShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRW51bUJvb2xlYW5Cb2R5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VudW1OdW1iZXJCb2R5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFbnVtTnVtYmVyQm9keVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFbnVtU3RyaW5nQm9keShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRW51bVN0cmluZ0JvZHlcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRW51bVN5bWJvbEJvZHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkVudW1TeW1ib2xCb2R5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VudW1Cb29sZWFuTWVtYmVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFbnVtQm9vbGVhbk1lbWJlclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFbnVtTnVtYmVyTWVtYmVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFbnVtTnVtYmVyTWVtYmVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VudW1TdHJpbmdNZW1iZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkVudW1TdHJpbmdNZW1iZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRW51bURlZmF1bHRlZE1lbWJlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRW51bURlZmF1bHRlZE1lbWJlclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1hBdHRyaWJ1dGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWEF0dHJpYnV0ZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1hDbG9zaW5nRWxlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSlNYQ2xvc2luZ0VsZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSlNYRWxlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSlNYRWxlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1hFbXB0eUV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWEVtcHR5RXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1hFeHByZXNzaW9uQ29udGFpbmVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0pTWFNwcmVhZENoaWxkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJKU1hTcHJlYWRDaGlsZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1hJZGVudGlmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJKU1hJZGVudGlmaWVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0pTWE1lbWJlckV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWE1lbWJlckV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSlNYTmFtZXNwYWNlZE5hbWUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWE5hbWVzcGFjZWROYW1lXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0pTWE9wZW5pbmdFbGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJKU1hPcGVuaW5nRWxlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1hTcHJlYWRBdHRyaWJ1dGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWFNwcmVhZEF0dHJpYnV0ZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1hUZXh0KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJKU1hUZXh0XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0pTWEZyYWdtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJKU1hGcmFnbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1hPcGVuaW5nRnJhZ21lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWE9wZW5pbmdGcmFnbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1hDbG9zaW5nRnJhZ21lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWENsb3NpbmdGcmFnbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNOb29wKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJOb29wXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1BsYWNlaG9sZGVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNWOEludHJpbnNpY0lkZW50aWZpZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlY4SW50cmluc2ljSWRlbnRpZmllclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudFBsYWNlaG9sZGVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJBcmd1bWVudFBsYWNlaG9sZGVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0F3YWl0RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQXdhaXRFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0JpbmRFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJCaW5kRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNDbGFzc1Byb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJDbGFzc1Byb3BlcnR5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1BpcGVsaW5lVG9waWNFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJQaXBlbGluZVRvcGljRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNQaXBlbGluZUJhcmVGdW5jdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiUGlwZWxpbmVCYXJlRnVuY3Rpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2Uobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc09wdGlvbmFsQ2FsbEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQ2xhc3NQcml2YXRlUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0NsYXNzUHJpdmF0ZU1ldGhvZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0ltcG9ydChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSW1wb3J0XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0ltcG9ydEF0dHJpYnV0ZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSW1wb3J0QXR0cmlidXRlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlY29yYXRvcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRGVjb3JhdG9yXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RvRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRG9FeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzUHJpdmF0ZU5hbWUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlByaXZhdGVOYW1lXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0JpZ0ludExpdGVyYWwobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkJpZ0ludExpdGVyYWxcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzUmVjb3JkRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiUmVjb3JkRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUdXBsZUV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlR1cGxlRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1BhcmFtZXRlclByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1BhcmFtZXRlclByb3BlcnR5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTRGVjbGFyZUZ1bmN0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0RlY2xhcmVGdW5jdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0RlY2xhcmVNZXRob2Qobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTRGVjbGFyZU1ldGhvZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1F1YWxpZmllZE5hbWUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTUXVhbGlmaWVkTmFtZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1Byb3BlcnR5U2lnbmF0dXJlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1Byb3BlcnR5U2lnbmF0dXJlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTTWV0aG9kU2lnbmF0dXJlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU01ldGhvZFNpZ25hdHVyZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0luZGV4U2lnbmF0dXJlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0luZGV4U2lnbmF0dXJlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTQW55S2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNBbnlLZXl3b3JkXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTQm9vbGVhbktleXdvcmQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTQm9vbGVhbktleXdvcmRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNCaWdJbnRLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0JpZ0ludEtleXdvcmRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNOZXZlcktleXdvcmQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTTmV2ZXJLZXl3b3JkXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTTnVsbEtleXdvcmQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTTnVsbEtleXdvcmRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNOdW1iZXJLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU051bWJlcktleXdvcmRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNPYmplY3RLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU09iamVjdEtleXdvcmRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNTdHJpbmdLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1N0cmluZ0tleXdvcmRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNTeW1ib2xLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1N5bWJvbEtleXdvcmRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNVbmRlZmluZWRLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1VuZGVmaW5lZEtleXdvcmRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNVbmtub3duS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNVbmtub3duS2V5d29yZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1ZvaWRLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1ZvaWRLZXl3b3JkXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTVGhpc1R5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVGhpc1R5cGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNGdW5jdGlvblR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTRnVuY3Rpb25UeXBlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTQ29uc3RydWN0b3JUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0NvbnN0cnVjdG9yVHlwZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1R5cGVSZWZlcmVuY2Uobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVHlwZVJlZmVyZW5jZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1R5cGVQcmVkaWNhdGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVHlwZVByZWRpY2F0ZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1R5cGVRdWVyeShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNUeXBlUXVlcnlcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNUeXBlTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNUeXBlTGl0ZXJhbFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0FycmF5VHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNBcnJheVR5cGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNUdXBsZVR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVHVwbGVUeXBlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTT3B0aW9uYWxUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU09wdGlvbmFsVHlwZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1Jlc3RUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1Jlc3RUeXBlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTVW5pb25UeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1VuaW9uVHlwZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0ludGVyc2VjdGlvblR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTSW50ZXJzZWN0aW9uVHlwZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0NvbmRpdGlvbmFsVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNDb25kaXRpb25hbFR5cGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNJbmZlclR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTSW5mZXJUeXBlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTUGFyZW50aGVzaXplZFR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTUGFyZW50aGVzaXplZFR5cGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNUeXBlT3BlcmF0b3Iobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVHlwZU9wZXJhdG9yXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTSW5kZXhlZEFjY2Vzc1R5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTSW5kZXhlZEFjY2Vzc1R5cGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNNYXBwZWRUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU01hcHBlZFR5cGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNMaXRlcmFsVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNMaXRlcmFsVHlwZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cyhub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHNcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNJbnRlcmZhY2VEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0ludGVyZmFjZUJvZHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTSW50ZXJmYWNlQm9keVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1R5cGVBbGlhc0RlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTQXNFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0FzRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1R5cGVBc3NlcnRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVHlwZUFzc2VydGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0VudW1EZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNFbnVtRGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNFbnVtTWVtYmVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0VudW1NZW1iZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNNb2R1bGVEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU01vZHVsZUJsb2NrKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU01vZHVsZUJsb2NrXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTSW1wb3J0VHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNJbXBvcnRUeXBlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU05vbk51bGxFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU05vbk51bGxFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTRXhwb3J0QXNzaWdubWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNFeHBvcnRBc3NpZ25tZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1R5cGVQYXJhbWV0ZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVHlwZVBhcmFtZXRlclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFeHByZXNzaW9uXCIgfHwgXCJBcnJheUV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkJpbmFyeUV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJDYWxsRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIklkZW50aWZpZXJcIiA9PT0gbm9kZVR5cGUgfHwgXCJTdHJpbmdMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiTnVtZXJpY0xpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJOdWxsTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIkJvb2xlYW5MaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiUmVnRXhwTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIkxvZ2ljYWxFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiTWVtYmVyRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIk5ld0V4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiU2VxdWVuY2VFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUaGlzRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIlVuYXJ5RXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIlVwZGF0ZUV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkNsYXNzRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIk1ldGFQcm9wZXJ0eVwiID09PSBub2RlVHlwZSB8fCBcIlN1cGVyXCIgPT09IG5vZGVUeXBlIHx8IFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVGVtcGxhdGVMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiWWllbGRFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYRWxlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkpTWEZyYWdtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiQXdhaXRFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQmluZEV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJQaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZVwiID09PSBub2RlVHlwZSB8fCBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJJbXBvcnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJEb0V4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJCaWdJbnRMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiUmVjb3JkRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIlR1cGxlRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIlRTQXNFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNUeXBlQXNzZXJ0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNOb25OdWxsRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBub2RlVHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiICYmIChcIkV4cHJlc3Npb25cIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUgfHwgXCJJZGVudGlmaWVyXCIgPT09IG5vZGUuZXhwZWN0ZWROb2RlIHx8IFwiU3RyaW5nTGl0ZXJhbFwiID09PSBub2RlLmV4cGVjdGVkTm9kZSkpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0JpbmFyeShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQmluYXJ5XCIgfHwgXCJCaW5hcnlFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiTG9naWNhbEV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1Njb3BhYmxlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJTY29wYWJsZVwiIHx8IFwiQmxvY2tTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJDYXRjaENsYXVzZVwiID09PSBub2RlVHlwZSB8fCBcIkRvV2hpbGVTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJGb3JJblN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkZvclN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJGdW5jdGlvbkV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJQcm9ncmFtXCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0TWV0aG9kXCIgPT09IG5vZGVUeXBlIHx8IFwiU3dpdGNoU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiV2hpbGVTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkNsYXNzRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkNsYXNzRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJGb3JPZlN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkNsYXNzTWV0aG9kXCIgPT09IG5vZGVUeXBlIHx8IFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNNb2R1bGVCbG9ja1wiID09PSBub2RlVHlwZSB8fCBub2RlVHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiICYmIFwiQmxvY2tTdGF0ZW1lbnRcIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Jsb2NrUGFyZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJCbG9ja1BhcmVudFwiIHx8IFwiQmxvY2tTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJDYXRjaENsYXVzZVwiID09PSBub2RlVHlwZSB8fCBcIkRvV2hpbGVTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJGb3JJblN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkZvclN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJGdW5jdGlvbkV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJQcm9ncmFtXCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0TWV0aG9kXCIgPT09IG5vZGVUeXBlIHx8IFwiU3dpdGNoU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiV2hpbGVTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkZvck9mU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiQ2xhc3NNZXRob2RcIiA9PT0gbm9kZVR5cGUgfHwgXCJDbGFzc1ByaXZhdGVNZXRob2RcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU01vZHVsZUJsb2NrXCIgPT09IG5vZGVUeXBlIHx8IG5vZGVUeXBlID09PSBcIlBsYWNlaG9sZGVyXCIgJiYgXCJCbG9ja1N0YXRlbWVudFwiID09PSBub2RlLmV4cGVjdGVkTm9kZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQmxvY2sobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkJsb2NrXCIgfHwgXCJCbG9ja1N0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIlByb2dyYW1cIiA9PT0gbm9kZVR5cGUgfHwgXCJUU01vZHVsZUJsb2NrXCIgPT09IG5vZGVUeXBlIHx8IG5vZGVUeXBlID09PSBcIlBsYWNlaG9sZGVyXCIgJiYgXCJCbG9ja1N0YXRlbWVudFwiID09PSBub2RlLmV4cGVjdGVkTm9kZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJTdGF0ZW1lbnRcIiB8fCBcIkJsb2NrU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiQnJlYWtTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJDb250aW51ZVN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkRlYnVnZ2VyU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiRG9XaGlsZVN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkVtcHR5U3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkZvckluU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiRm9yU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIklmU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiTGFiZWxlZFN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIlJldHVyblN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIlN3aXRjaFN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIlRocm93U3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiVHJ5U3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIldoaWxlU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiV2l0aFN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkNsYXNzRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJGb3JPZlN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkltcG9ydERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUNsYXNzXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUZ1bmN0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUludGVyZmFjZVwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVNb2R1bGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVUeXBlQWxpYXNcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlT3BhcXVlVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVWYXJpYWJsZVwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkludGVyZmFjZURlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiT3BhcXVlVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIlR5cGVBbGlhc1wiID09PSBub2RlVHlwZSB8fCBcIkVudW1EZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlRTRGVjbGFyZUZ1bmN0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0VudW1EZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNFeHBvcnRBc3NpZ25tZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBub2RlVHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiICYmIChcIlN0YXRlbWVudFwiID09PSBub2RlLmV4cGVjdGVkTm9kZSB8fCBcIkRlY2xhcmF0aW9uXCIgPT09IG5vZGUuZXhwZWN0ZWROb2RlIHx8IFwiQmxvY2tTdGF0ZW1lbnRcIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUpKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUZXJtaW5hdG9ybGVzcyhub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVGVybWluYXRvcmxlc3NcIiB8fCBcIkJyZWFrU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiQ29udGludWVTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJSZXR1cm5TdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUaHJvd1N0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIllpZWxkRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkF3YWl0RXhwcmVzc2lvblwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQ29tcGxldGlvblN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQ29tcGxldGlvblN0YXRlbWVudFwiIHx8IFwiQnJlYWtTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJDb250aW51ZVN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIlJldHVyblN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIlRocm93U3RhdGVtZW50XCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNDb25kaXRpb25hbChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQ29uZGl0aW9uYWxcIiB8fCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIklmU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNMb29wKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJMb29wXCIgfHwgXCJEb1doaWxlU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiRm9ySW5TdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJGb3JTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJXaGlsZVN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkZvck9mU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNXaGlsZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiV2hpbGVcIiB8fCBcIkRvV2hpbGVTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJXaGlsZVN0YXRlbWVudFwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRXhwcmVzc2lvbldyYXBwZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkV4cHJlc3Npb25XcmFwcGVyXCIgfHwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUeXBlQ2FzdEV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Zvcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRm9yXCIgfHwgXCJGb3JJblN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkZvclN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkZvck9mU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNGb3JYU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJGb3JYU3RhdGVtZW50XCIgfHwgXCJGb3JJblN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkZvck9mU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRnVuY3Rpb25cIiB8fCBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJGdW5jdGlvbkV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RNZXRob2RcIiA9PT0gbm9kZVR5cGUgfHwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkNsYXNzTWV0aG9kXCIgPT09IG5vZGVUeXBlIHx8IFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvblBhcmVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRnVuY3Rpb25QYXJlbnRcIiB8fCBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJGdW5jdGlvbkV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RNZXRob2RcIiA9PT0gbm9kZVR5cGUgfHwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkNsYXNzTWV0aG9kXCIgPT09IG5vZGVUeXBlIHx8IFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNQdXJlaXNoKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJQdXJlaXNoXCIgfHwgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiU3RyaW5nTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIk51bWVyaWNMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiTnVsbExpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJCb29sZWFuTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIlJlZ0V4cExpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkJpZ0ludExpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgbm9kZVR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIiAmJiBcIlN0cmluZ0xpdGVyYWxcIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJEZWNsYXJhdGlvblwiIHx8IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJDbGFzc0RlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiSW1wb3J0RGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlQ2xhc3NcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlRnVuY3Rpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlSW50ZXJmYWNlXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZU1vZHVsZVwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZVR5cGVBbGlhc1wiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVPcGFxdWVUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZVZhcmlhYmxlXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJPcGFxdWVUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiVHlwZUFsaWFzXCIgPT09IG5vZGVUeXBlIHx8IFwiRW51bURlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNEZWNsYXJlRnVuY3Rpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlRTRW51bURlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBub2RlVHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiICYmIFwiRGVjbGFyYXRpb25cIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1BhdHRlcm5MaWtlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJQYXR0ZXJuTGlrZVwiIHx8IFwiSWRlbnRpZmllclwiID09PSBub2RlVHlwZSB8fCBcIlJlc3RFbGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiQXNzaWdubWVudFBhdHRlcm5cIiA9PT0gbm9kZVR5cGUgfHwgXCJBcnJheVBhdHRlcm5cIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RQYXR0ZXJuXCIgPT09IG5vZGVUeXBlIHx8IG5vZGVUeXBlID09PSBcIlBsYWNlaG9sZGVyXCIgJiYgKFwiUGF0dGVyblwiID09PSBub2RlLmV4cGVjdGVkTm9kZSB8fCBcIklkZW50aWZpZXJcIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUpKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNMVmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJMVmFsXCIgfHwgXCJJZGVudGlmaWVyXCIgPT09IG5vZGVUeXBlIHx8IFwiTWVtYmVyRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIlJlc3RFbGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiQXNzaWdubWVudFBhdHRlcm5cIiA9PT0gbm9kZVR5cGUgfHwgXCJBcnJheVBhdHRlcm5cIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RQYXR0ZXJuXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiID09PSBub2RlVHlwZSB8fCBub2RlVHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiICYmIChcIlBhdHRlcm5cIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUgfHwgXCJJZGVudGlmaWVyXCIgPT09IG5vZGUuZXhwZWN0ZWROb2RlKSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNFbnRpdHlOYW1lKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0VudGl0eU5hbWVcIiB8fCBcIklkZW50aWZpZXJcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1F1YWxpZmllZE5hbWVcIiA9PT0gbm9kZVR5cGUgfHwgbm9kZVR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIiAmJiBcIklkZW50aWZpZXJcIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0xpdGVyYWwobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkxpdGVyYWxcIiB8fCBcIlN0cmluZ0xpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJOdW1lcmljTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIk51bGxMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiQm9vbGVhbkxpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJSZWdFeHBMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiVGVtcGxhdGVMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiQmlnSW50TGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBub2RlVHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiICYmIFwiU3RyaW5nTGl0ZXJhbFwiID09PSBub2RlLmV4cGVjdGVkTm9kZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSW1tdXRhYmxlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJJbW11dGFibGVcIiB8fCBcIlN0cmluZ0xpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJOdW1lcmljTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIk51bGxMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiQm9vbGVhbkxpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hBdHRyaWJ1dGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hDbG9zaW5nRWxlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkpTWEVsZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYU3ByZWFkQ2hpbGRcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hPcGVuaW5nRWxlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkpTWFRleHRcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hGcmFnbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkpTWE9wZW5pbmdGcmFnbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkpTWENsb3NpbmdGcmFnbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkJpZ0ludExpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgbm9kZVR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIiAmJiBcIlN0cmluZ0xpdGVyYWxcIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1VzZXJXaGl0ZXNwYWNhYmxlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJVc2VyV2hpdGVzcGFjYWJsZVwiIHx8IFwiT2JqZWN0TWV0aG9kXCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0UHJvcGVydHlcIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RUeXBlSW50ZXJuYWxTbG90XCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiID09PSBub2RlVHlwZSB8fCBcIk9iamVjdFR5cGVJbmRleGVyXCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0VHlwZVByb3BlcnR5XCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5XCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNNZXRob2Qobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk1ldGhvZFwiIHx8IFwiT2JqZWN0TWV0aG9kXCIgPT09IG5vZGVUeXBlIHx8IFwiQ2xhc3NNZXRob2RcIiA9PT0gbm9kZVR5cGUgfHwgXCJDbGFzc1ByaXZhdGVNZXRob2RcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdE1lbWJlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiT2JqZWN0TWVtYmVyXCIgfHwgXCJPYmplY3RNZXRob2RcIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RQcm9wZXJ0eVwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlByb3BlcnR5XCIgfHwgXCJPYmplY3RQcm9wZXJ0eVwiID09PSBub2RlVHlwZSB8fCBcIkNsYXNzUHJvcGVydHlcIiA9PT0gbm9kZVR5cGUgfHwgXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVW5hcnlMaWtlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJVbmFyeUxpa2VcIiB8fCBcIlVuYXJ5RXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIlNwcmVhZEVsZW1lbnRcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1BhdHRlcm4obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlBhdHRlcm5cIiB8fCBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIgPT09IG5vZGVUeXBlIHx8IFwiQXJyYXlQYXR0ZXJuXCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0UGF0dGVyblwiID09PSBub2RlVHlwZSB8fCBub2RlVHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiICYmIFwiUGF0dGVyblwiID09PSBub2RlLmV4cGVjdGVkTm9kZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQ2xhc3Mobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkNsYXNzXCIgfHwgXCJDbGFzc0V4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJDbGFzc0RlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNNb2R1bGVEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiTW9kdWxlRGVjbGFyYXRpb25cIiB8fCBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkltcG9ydERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFeHBvcnREZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRXhwb3J0RGVjbGFyYXRpb25cIiB8fCBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTW9kdWxlU3BlY2lmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJNb2R1bGVTcGVjaWZpZXJcIiB8fCBcIkV4cG9ydFNwZWNpZmllclwiID09PSBub2RlVHlwZSB8fCBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIiA9PT0gbm9kZVR5cGUgfHwgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIiA9PT0gbm9kZVR5cGUgfHwgXCJJbXBvcnRTcGVjaWZpZXJcIiA9PT0gbm9kZVR5cGUgfHwgXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCIgPT09IG5vZGVUeXBlIHx8IFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNGbG93KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJGbG93XCIgfHwgXCJBbnlUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkFycmF5VHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJCb29sZWFuVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkNsYXNzSW1wbGVtZW50c1wiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVDbGFzc1wiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVGdW5jdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVJbnRlcmZhY2VcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlTW9kdWxlXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlVHlwZUFsaWFzXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZU9wYXF1ZVR5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlVmFyaWFibGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlZFByZWRpY2F0ZVwiID09PSBub2RlVHlwZSB8fCBcIkV4aXN0c1R5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkZ1bmN0aW9uVHlwZVBhcmFtXCIgPT09IG5vZGVUeXBlIHx8IFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiSW5mZXJyZWRQcmVkaWNhdGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJJbnRlcmZhY2VFeHRlbmRzXCIgPT09IG5vZGVUeXBlIHx8IFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJJbnRlcmZhY2VUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiTWl4ZWRUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkVtcHR5VHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiTnVtYmVyVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIk9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RUeXBlQ2FsbFByb3BlcnR5XCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0VHlwZUluZGV4ZXJcIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RUeXBlUHJvcGVydHlcIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RUeXBlU3ByZWFkUHJvcGVydHlcIiA9PT0gbm9kZVR5cGUgfHwgXCJPcGFxdWVUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIiA9PT0gbm9kZVR5cGUgfHwgXCJTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJTdHJpbmdUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlN5bWJvbFR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVGhpc1R5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVHVwbGVUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVHlwZUFsaWFzXCIgPT09IG5vZGVUeXBlIHx8IFwiVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUeXBlQ2FzdEV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUeXBlUGFyYW1ldGVyXCIgPT09IG5vZGVUeXBlIHx8IFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJVbmlvblR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVmFyaWFuY2VcIiA9PT0gbm9kZVR5cGUgfHwgXCJWb2lkVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Zsb3dUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJGbG93VHlwZVwiIHx8IFwiQW55VHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJBcnJheVR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQm9vbGVhblR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIk51bGxMaXRlcmFsVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJFeGlzdHNUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJHZW5lcmljVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJJbnRlcmZhY2VUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiTWl4ZWRUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkVtcHR5VHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiTnVtYmVyVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiU3ltYm9sVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUaGlzVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVHlwZW9mVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJVbmlvblR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVm9pZFR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNGbG93QmFzZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkZsb3dCYXNlQW5ub3RhdGlvblwiIHx8IFwiQW55VHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJCb29sZWFuVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiTWl4ZWRUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkVtcHR5VHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiU3ltYm9sVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUaGlzVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJWb2lkVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Zsb3dEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRmxvd0RlY2xhcmF0aW9uXCIgfHwgXCJEZWNsYXJlQ2xhc3NcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlRnVuY3Rpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlSW50ZXJmYWNlXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZU1vZHVsZVwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZVR5cGVBbGlhc1wiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVPcGFxdWVUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZVZhcmlhYmxlXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJPcGFxdWVUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiVHlwZUFsaWFzXCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNGbG93UHJlZGljYXRlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJGbG93UHJlZGljYXRlXCIgfHwgXCJEZWNsYXJlZFByZWRpY2F0ZVwiID09PSBub2RlVHlwZSB8fCBcIkluZmVycmVkUHJlZGljYXRlXCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFbnVtQm9keShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRW51bUJvZHlcIiB8fCBcIkVudW1Cb29sZWFuQm9keVwiID09PSBub2RlVHlwZSB8fCBcIkVudW1OdW1iZXJCb2R5XCIgPT09IG5vZGVUeXBlIHx8IFwiRW51bVN0cmluZ0JvZHlcIiA9PT0gbm9kZVR5cGUgfHwgXCJFbnVtU3ltYm9sQm9keVwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRW51bU1lbWJlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRW51bU1lbWJlclwiIHx8IFwiRW51bUJvb2xlYW5NZW1iZXJcIiA9PT0gbm9kZVR5cGUgfHwgXCJFbnVtTnVtYmVyTWVtYmVyXCIgPT09IG5vZGVUeXBlIHx8IFwiRW51bVN0cmluZ01lbWJlclwiID09PSBub2RlVHlwZSB8fCBcIkVudW1EZWZhdWx0ZWRNZW1iZXJcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0pTWChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSlNYXCIgfHwgXCJKU1hBdHRyaWJ1dGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hDbG9zaW5nRWxlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkpTWEVsZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hFbXB0eUV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYU3ByZWFkQ2hpbGRcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hJZGVudGlmaWVyXCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkpTWE5hbWVzcGFjZWROYW1lXCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYT3BlbmluZ0VsZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hUZXh0XCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYRnJhZ21lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hPcGVuaW5nRnJhZ21lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hDbG9zaW5nRnJhZ21lbnRcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1ByaXZhdGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlByaXZhdGVcIiB8fCBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIgPT09IG5vZGVUeXBlIHx8IFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIgPT09IG5vZGVUeXBlIHx8IFwiUHJpdmF0ZU5hbWVcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTVHlwZUVsZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVHlwZUVsZW1lbnRcIiB8fCBcIlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlRTUHJvcGVydHlTaWduYXR1cmVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU01ldGhvZFNpZ25hdHVyZVwiID09PSBub2RlVHlwZSB8fCBcIlRTSW5kZXhTaWduYXR1cmVcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNUeXBlXCIgfHwgXCJUU0FueUtleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0Jvb2xlYW5LZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNCaWdJbnRLZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNOZXZlcktleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU051bGxLZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNOdW1iZXJLZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNPYmplY3RLZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNTdHJpbmdLZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNTeW1ib2xLZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNVbmRlZmluZWRLZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNVbmtub3duS2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTVm9pZEtleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1RoaXNUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNGdW5jdGlvblR5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0NvbnN0cnVjdG9yVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIlRTVHlwZVJlZmVyZW5jZVwiID09PSBub2RlVHlwZSB8fCBcIlRTVHlwZVByZWRpY2F0ZVwiID09PSBub2RlVHlwZSB8fCBcIlRTVHlwZVF1ZXJ5XCIgPT09IG5vZGVUeXBlIHx8IFwiVFNUeXBlTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIlRTQXJyYXlUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNUdXBsZVR5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU09wdGlvbmFsVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIlRTUmVzdFR5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1VuaW9uVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIlRTSW50ZXJzZWN0aW9uVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIlRTQ29uZGl0aW9uYWxUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNJbmZlclR5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1BhcmVudGhlc2l6ZWRUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNUeXBlT3BlcmF0b3JcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0luZGV4ZWRBY2Nlc3NUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNNYXBwZWRUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNMaXRlcmFsVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNJbXBvcnRUeXBlXCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0Jhc2VUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0Jhc2VUeXBlXCIgfHwgXCJUU0FueUtleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0Jvb2xlYW5LZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNCaWdJbnRLZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNOZXZlcktleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU051bGxLZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNOdW1iZXJLZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNPYmplY3RLZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNTdHJpbmdLZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNTeW1ib2xLZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNVbmRlZmluZWRLZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNVbmtub3duS2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTVm9pZEtleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1RoaXNUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNMaXRlcmFsVHlwZVwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGNvbnNvbGUudHJhY2UoXCJUaGUgbm9kZSB0eXBlIE51bWJlckxpdGVyYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBOdW1lcmljTGl0ZXJhbFwiKTtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJOdW1iZXJMaXRlcmFsXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1JlZ2V4TGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGNvbnNvbGUudHJhY2UoXCJUaGUgbm9kZSB0eXBlIFJlZ2V4TGl0ZXJhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFJlZ0V4cExpdGVyYWxcIik7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiUmVnZXhMaXRlcmFsXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1Jlc3RQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGNvbnNvbGUudHJhY2UoXCJUaGUgbm9kZSB0eXBlIFJlc3RQcm9wZXJ0eSBoYXMgYmVlbiByZW5hbWVkIHRvIFJlc3RFbGVtZW50XCIpO1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlJlc3RQcm9wZXJ0eVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNTcHJlYWRQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGNvbnNvbGUudHJhY2UoXCJUaGUgbm9kZSB0eXBlIFNwcmVhZFByb3BlcnR5IGhhcyBiZWVuIHJlbmFtZWQgdG8gU3ByZWFkRWxlbWVudFwiKTtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJTcHJlYWRQcm9wZXJ0eVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzO1xuXG52YXIgX3NoYWxsb3dFcXVhbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3V0aWxzL3NoYWxsb3dFcXVhbFwiKSk7XG5cbnZhciBfaXNUeXBlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc1R5cGVcIikpO1xuXG52YXIgX2lzUGxhY2Vob2xkZXJUeXBlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc1BsYWNlaG9sZGVyVHlwZVwiKSk7XG5cbnZhciBfZGVmaW5pdGlvbnMgPSByZXF1aXJlKFwiLi4vZGVmaW5pdGlvbnNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGlzKHR5cGUsIG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG1hdGNoZXMgPSAoMCwgX2lzVHlwZS5kZWZhdWx0KShub2RlLnR5cGUsIHR5cGUpO1xuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIGlmICghb3B0cyAmJiBub2RlLnR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIiAmJiB0eXBlIGluIF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVMpIHtcbiAgICAgIHJldHVybiAoMCwgX2lzUGxhY2Vob2xkZXJUeXBlLmRlZmF1bHQpKG5vZGUuZXhwZWN0ZWROb2RlLCB0eXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQmluZGluZztcblxudmFyIF9nZXRCaW5kaW5nSWRlbnRpZmllcnMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9yZXRyaWV2ZXJzL2dldEJpbmRpbmdJZGVudGlmaWVyc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGlzQmluZGluZyhub2RlLCBwYXJlbnQsIGdyYW5kcGFyZW50KSB7XG4gIGlmIChncmFuZHBhcmVudCAmJiBub2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHBhcmVudC50eXBlID09PSBcIk9iamVjdFByb3BlcnR5XCIgJiYgZ3JhbmRwYXJlbnQudHlwZSA9PT0gXCJPYmplY3RFeHByZXNzaW9uXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBrZXlzID0gX2dldEJpbmRpbmdJZGVudGlmaWVycy5kZWZhdWx0LmtleXNbcGFyZW50LnR5cGVdO1xuXG4gIGlmIChrZXlzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgY29uc3QgdmFsID0gcGFyZW50W2tleV07XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgaWYgKHZhbC5pbmRleE9mKG5vZGUpID49IDApIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gbm9kZSkgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNCbG9ja1Njb3BlZDtcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZWRcIik7XG5cbnZhciBfaXNMZXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzTGV0XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNCbG9ja1Njb3BlZChub2RlKSB7XG4gIHJldHVybiAoMCwgX2dlbmVyYXRlZC5pc0Z1bmN0aW9uRGVjbGFyYXRpb24pKG5vZGUpIHx8ICgwLCBfZ2VuZXJhdGVkLmlzQ2xhc3NEZWNsYXJhdGlvbikobm9kZSkgfHwgKDAsIF9pc0xldC5kZWZhdWx0KShub2RlKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSW1tdXRhYmxlO1xuXG52YXIgX2lzVHlwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNUeXBlXCIpKTtcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZWRcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGlzSW1tdXRhYmxlKG5vZGUpIHtcbiAgaWYgKCgwLCBfaXNUeXBlLmRlZmF1bHQpKG5vZGUudHlwZSwgXCJJbW11dGFibGVcIikpIHJldHVybiB0cnVlO1xuXG4gIGlmICgoMCwgX2dlbmVyYXRlZC5pc0lkZW50aWZpZXIpKG5vZGUpKSB7XG4gICAgaWYgKG5vZGUubmFtZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0xldDtcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZWRcIik7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcblxuZnVuY3Rpb24gaXNMZXQobm9kZSkge1xuICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQuaXNWYXJpYWJsZURlY2xhcmF0aW9uKShub2RlKSAmJiAobm9kZS5raW5kICE9PSBcInZhclwiIHx8IG5vZGVbX2NvbnN0YW50cy5CTE9DS19TQ09QRURfU1lNQk9MXSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc05vZGU7XG5cbnZhciBfZGVmaW5pdGlvbnMgPSByZXF1aXJlKFwiLi4vZGVmaW5pdGlvbnNcIik7XG5cbmZ1bmN0aW9uIGlzTm9kZShub2RlKSB7XG4gIHJldHVybiAhIShub2RlICYmIF9kZWZpbml0aW9ucy5WSVNJVE9SX0tFWVNbbm9kZS50eXBlXSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc05vZGVzRXF1aXZhbGVudDtcblxudmFyIF9kZWZpbml0aW9ucyA9IHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uc1wiKTtcblxuZnVuY3Rpb24gaXNOb2Rlc0VxdWl2YWxlbnQoYSwgYikge1xuICBpZiAodHlwZW9mIGEgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGIgIT09IFwib2JqZWN0XCIgfHwgYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9XG5cbiAgaWYgKGEudHlwZSAhPT0gYi50eXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgZmllbGRzID0gT2JqZWN0LmtleXMoX2RlZmluaXRpb25zLk5PREVfRklFTERTW2EudHlwZV0gfHwgYS50eXBlKTtcbiAgY29uc3QgdmlzaXRvcktleXMgPSBfZGVmaW5pdGlvbnMuVklTSVRPUl9LRVlTW2EudHlwZV07XG5cbiAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICBpZiAodHlwZW9mIGFbZmllbGRdICE9PSB0eXBlb2YgYltmaWVsZF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYVtmaWVsZF0gPT0gbnVsbCAmJiBiW2ZpZWxkXSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGFbZmllbGRdID09IG51bGwgfHwgYltmaWVsZF0gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGFbZmllbGRdKSkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGJbZmllbGRdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChhW2ZpZWxkXS5sZW5ndGggIT09IGJbZmllbGRdLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYVtmaWVsZF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFpc05vZGVzRXF1aXZhbGVudChhW2ZpZWxkXVtpXSwgYltmaWVsZF1baV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYVtmaWVsZF0gPT09IFwib2JqZWN0XCIgJiYgISh2aXNpdG9yS2V5cyA9PSBudWxsID8gdm9pZCAwIDogdmlzaXRvcktleXMuaW5jbHVkZXMoZmllbGQpKSkge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoYVtmaWVsZF0pKSB7XG4gICAgICAgIGlmIChhW2ZpZWxkXVtrZXldICE9PSBiW2ZpZWxkXVtrZXldKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICghaXNOb2Rlc0VxdWl2YWxlbnQoYVtmaWVsZF0sIGJbZmllbGRdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNQbGFjZWhvbGRlclR5cGU7XG5cbnZhciBfZGVmaW5pdGlvbnMgPSByZXF1aXJlKFwiLi4vZGVmaW5pdGlvbnNcIik7XG5cbmZ1bmN0aW9uIGlzUGxhY2Vob2xkZXJUeXBlKHBsYWNlaG9sZGVyVHlwZSwgdGFyZ2V0VHlwZSkge1xuICBpZiAocGxhY2Vob2xkZXJUeXBlID09PSB0YXJnZXRUeXBlKSByZXR1cm4gdHJ1ZTtcbiAgY29uc3QgYWxpYXNlcyA9IF9kZWZpbml0aW9ucy5QTEFDRUhPTERFUlNfQUxJQVNbcGxhY2Vob2xkZXJUeXBlXTtcblxuICBpZiAoYWxpYXNlcykge1xuICAgIGZvciAoY29uc3QgYWxpYXMgb2YgYWxpYXNlcykge1xuICAgICAgaWYgKHRhcmdldFR5cGUgPT09IGFsaWFzKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1JlZmVyZW5jZWQ7XG5cbmZ1bmN0aW9uIGlzUmVmZXJlbmNlZChub2RlLCBwYXJlbnQsIGdyYW5kcGFyZW50KSB7XG4gIHN3aXRjaCAocGFyZW50LnR5cGUpIHtcbiAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJKU1hNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgaWYgKHBhcmVudC5wcm9wZXJ0eSA9PT0gbm9kZSkge1xuICAgICAgICByZXR1cm4gISFwYXJlbnQuY29tcHV0ZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJlbnQub2JqZWN0ID09PSBub2RlO1xuXG4gICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiOlxuICAgICAgcmV0dXJuIHBhcmVudC5pbml0ID09PSBub2RlO1xuXG4gICAgY2FzZSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgICByZXR1cm4gcGFyZW50LmJvZHkgPT09IG5vZGU7XG5cbiAgICBjYXNlIFwiRXhwb3J0U3BlY2lmaWVyXCI6XG4gICAgICBpZiAocGFyZW50LnNvdXJjZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJlbnQubG9jYWwgPT09IG5vZGU7XG5cbiAgICBjYXNlIFwiUHJpdmF0ZU5hbWVcIjpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGNhc2UgXCJDbGFzc01ldGhvZFwiOlxuICAgIGNhc2UgXCJDbGFzc1ByaXZhdGVNZXRob2RcIjpcbiAgICBjYXNlIFwiT2JqZWN0TWV0aG9kXCI6XG4gICAgICBpZiAocGFyZW50LnBhcmFtcy5pbmNsdWRlcyhub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBjYXNlIFwiT2JqZWN0UHJvcGVydHlcIjpcbiAgICBjYXNlIFwiQ2xhc3NQcm9wZXJ0eVwiOlxuICAgIGNhc2UgXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiOlxuICAgICAgaWYgKHBhcmVudC5rZXkgPT09IG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICEhcGFyZW50LmNvbXB1dGVkO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50LnZhbHVlID09PSBub2RlKSB7XG4gICAgICAgIHJldHVybiAhZ3JhbmRwYXJlbnQgfHwgZ3JhbmRwYXJlbnQudHlwZSAhPT0gXCJPYmplY3RQYXR0ZXJuXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBcIkNsYXNzRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiQ2xhc3NFeHByZXNzaW9uXCI6XG4gICAgICByZXR1cm4gcGFyZW50LnN1cGVyQ2xhc3MgPT09IG5vZGU7XG5cbiAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBwYXJlbnQucmlnaHQgPT09IG5vZGU7XG5cbiAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgIHJldHVybiBwYXJlbnQucmlnaHQgPT09IG5vZGU7XG5cbiAgICBjYXNlIFwiTGFiZWxlZFN0YXRlbWVudFwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSBcIkNhdGNoQ2xhdXNlXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGNhc2UgXCJCcmVha1N0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJDb250aW51ZVN0YXRlbWVudFwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlIFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCI6XG4gICAgY2FzZSBcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIjpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGNhc2UgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCI6XG4gICAgY2FzZSBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiOlxuICAgIGNhc2UgXCJJbXBvcnRTcGVjaWZpZXJcIjpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGNhc2UgXCJKU1hBdHRyaWJ1dGVcIjpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSBcIk1ldGFQcm9wZXJ0eVwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSBcIk9iamVjdFR5cGVQcm9wZXJ0eVwiOlxuICAgICAgcmV0dXJuIHBhcmVudC5rZXkgIT09IG5vZGU7XG5cbiAgICBjYXNlIFwiVFNFbnVtTWVtYmVyXCI6XG4gICAgICByZXR1cm4gcGFyZW50LmlkICE9PSBub2RlO1xuXG4gICAgY2FzZSBcIlRTUHJvcGVydHlTaWduYXR1cmVcIjpcbiAgICAgIGlmIChwYXJlbnQua2V5ID09PSBub2RlKSB7XG4gICAgICAgIHJldHVybiAhIXBhcmVudC5jb21wdXRlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzU2NvcGU7XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVkXCIpO1xuXG5mdW5jdGlvbiBpc1Njb3BlKG5vZGUsIHBhcmVudCkge1xuICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNCbG9ja1N0YXRlbWVudCkobm9kZSkgJiYgKDAsIF9nZW5lcmF0ZWQuaXNGdW5jdGlvbikocGFyZW50LCB7XG4gICAgYm9keTogbm9kZVxuICB9KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICgoMCwgX2dlbmVyYXRlZC5pc0Jsb2NrU3RhdGVtZW50KShub2RlKSAmJiAoMCwgX2dlbmVyYXRlZC5pc0NhdGNoQ2xhdXNlKShwYXJlbnQsIHtcbiAgICBib2R5OiBub2RlXG4gIH0pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzUGF0dGVybikobm9kZSkgJiYgKDAsIF9nZW5lcmF0ZWQuaXNGdW5jdGlvbikocGFyZW50KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuICgwLCBfZ2VuZXJhdGVkLmlzU2NvcGFibGUpKG5vZGUpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNTcGVjaWZpZXJEZWZhdWx0O1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlZFwiKTtcblxuZnVuY3Rpb24gaXNTcGVjaWZpZXJEZWZhdWx0KHNwZWNpZmllcikge1xuICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQuaXNJbXBvcnREZWZhdWx0U3BlY2lmaWVyKShzcGVjaWZpZXIpIHx8ICgwLCBfZ2VuZXJhdGVkLmlzSWRlbnRpZmllcikoc3BlY2lmaWVyLmltcG9ydGVkIHx8IHNwZWNpZmllci5leHBvcnRlZCwge1xuICAgIG5hbWU6IFwiZGVmYXVsdFwiXG4gIH0pO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNUeXBlO1xuXG52YXIgX2RlZmluaXRpb25zID0gcmVxdWlyZShcIi4uL2RlZmluaXRpb25zXCIpO1xuXG5mdW5jdGlvbiBpc1R5cGUobm9kZVR5cGUsIHRhcmdldFR5cGUpIHtcbiAgaWYgKG5vZGVUeXBlID09PSB0YXJnZXRUeXBlKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKF9kZWZpbml0aW9ucy5BTElBU19LRVlTW3RhcmdldFR5cGVdKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGFsaWFzZXMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW3RhcmdldFR5cGVdO1xuXG4gIGlmIChhbGlhc2VzKSB7XG4gICAgaWYgKGFsaWFzZXNbMF0gPT09IG5vZGVUeXBlKSByZXR1cm4gdHJ1ZTtcblxuICAgIGZvciAoY29uc3QgYWxpYXMgb2YgYWxpYXNlcykge1xuICAgICAgaWYgKG5vZGVUeXBlID09PSBhbGlhcykgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNWYWxpZEVTM0lkZW50aWZpZXI7XG5cbnZhciBfaXNWYWxpZElkZW50aWZpZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzVmFsaWRJZGVudGlmaWVyXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3QgUkVTRVJWRURfV09SRFNfRVMzX09OTFkgPSBuZXcgU2V0KFtcImFic3RyYWN0XCIsIFwiYm9vbGVhblwiLCBcImJ5dGVcIiwgXCJjaGFyXCIsIFwiZG91YmxlXCIsIFwiZW51bVwiLCBcImZpbmFsXCIsIFwiZmxvYXRcIiwgXCJnb3RvXCIsIFwiaW1wbGVtZW50c1wiLCBcImludFwiLCBcImludGVyZmFjZVwiLCBcImxvbmdcIiwgXCJuYXRpdmVcIiwgXCJwYWNrYWdlXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcInB1YmxpY1wiLCBcInNob3J0XCIsIFwic3RhdGljXCIsIFwic3luY2hyb25pemVkXCIsIFwidGhyb3dzXCIsIFwidHJhbnNpZW50XCIsIFwidm9sYXRpbGVcIl0pO1xuXG5mdW5jdGlvbiBpc1ZhbGlkRVMzSWRlbnRpZmllcihuYW1lKSB7XG4gIHJldHVybiAoMCwgX2lzVmFsaWRJZGVudGlmaWVyLmRlZmF1bHQpKG5hbWUpICYmICFSRVNFUlZFRF9XT1JEU19FUzNfT05MWS5oYXMobmFtZSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1ZhbGlkSWRlbnRpZmllcjtcblxudmFyIF9oZWxwZXJWYWxpZGF0b3JJZGVudGlmaWVyID0gcmVxdWlyZShcIkBiYWJlbC9oZWxwZXItdmFsaWRhdG9yLWlkZW50aWZpZXJcIik7XG5cbmZ1bmN0aW9uIGlzVmFsaWRJZGVudGlmaWVyKG5hbWUsIHJlc2VydmVkID0gdHJ1ZSkge1xuICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHJldHVybiBmYWxzZTtcblxuICBpZiAocmVzZXJ2ZWQpIHtcbiAgICBpZiAoKDAsIF9oZWxwZXJWYWxpZGF0b3JJZGVudGlmaWVyLmlzS2V5d29yZCkobmFtZSkgfHwgKDAsIF9oZWxwZXJWYWxpZGF0b3JJZGVudGlmaWVyLmlzU3RyaWN0UmVzZXJ2ZWRXb3JkKShuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJhd2FpdFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICgwLCBfaGVscGVyVmFsaWRhdG9ySWRlbnRpZmllci5pc0lkZW50aWZpZXJOYW1lKShuYW1lKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzVmFyO1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlZFwiKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuXG5mdW5jdGlvbiBpc1Zhcihub2RlKSB7XG4gIHJldHVybiAoMCwgX2dlbmVyYXRlZC5pc1ZhcmlhYmxlRGVjbGFyYXRpb24pKG5vZGUsIHtcbiAgICBraW5kOiBcInZhclwiXG4gIH0pICYmICFub2RlW19jb25zdGFudHMuQkxPQ0tfU0NPUEVEX1NZTUJPTF07XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBtYXRjaGVzUGF0dGVybjtcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZWRcIik7XG5cbmZ1bmN0aW9uIG1hdGNoZXNQYXR0ZXJuKG1lbWJlciwgbWF0Y2gsIGFsbG93UGFydGlhbCkge1xuICBpZiAoISgwLCBfZ2VuZXJhdGVkLmlzTWVtYmVyRXhwcmVzc2lvbikobWVtYmVyKSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwYXJ0cyA9IEFycmF5LmlzQXJyYXkobWF0Y2gpID8gbWF0Y2ggOiBtYXRjaC5zcGxpdChcIi5cIik7XG4gIGNvbnN0IG5vZGVzID0gW107XG4gIGxldCBub2RlO1xuXG4gIGZvciAobm9kZSA9IG1lbWJlcjsgKDAsIF9nZW5lcmF0ZWQuaXNNZW1iZXJFeHByZXNzaW9uKShub2RlKTsgbm9kZSA9IG5vZGUub2JqZWN0KSB7XG4gICAgbm9kZXMucHVzaChub2RlLnByb3BlcnR5KTtcbiAgfVxuXG4gIG5vZGVzLnB1c2gobm9kZSk7XG4gIGlmIChub2Rlcy5sZW5ndGggPCBwYXJ0cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFhbGxvd1BhcnRpYWwgJiYgbm9kZXMubGVuZ3RoID4gcGFydHMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGogPSBub2Rlcy5sZW5ndGggLSAxOyBpIDwgcGFydHMubGVuZ3RoOyBpKyssIGotLSkge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tqXTtcbiAgICBsZXQgdmFsdWU7XG5cbiAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNJZGVudGlmaWVyKShub2RlKSkge1xuICAgICAgdmFsdWUgPSBub2RlLm5hbWU7XG4gICAgfSBlbHNlIGlmICgoMCwgX2dlbmVyYXRlZC5pc1N0cmluZ0xpdGVyYWwpKG5vZGUpKSB7XG4gICAgICB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAocGFydHNbaV0gIT09IHZhbHVlKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQ29tcGF0VGFnO1xuXG5mdW5jdGlvbiBpc0NvbXBhdFRhZyh0YWdOYW1lKSB7XG4gIHJldHVybiAhIXRhZ05hbWUgJiYgL15bYS16XS8udGVzdCh0YWdOYW1lKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9idWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2J1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3QgaXNSZWFjdENvbXBvbmVudCA9ICgwLCBfYnVpbGRNYXRjaE1lbWJlckV4cHJlc3Npb24uZGVmYXVsdCkoXCJSZWFjdC5Db21wb25lbnRcIik7XG52YXIgX2RlZmF1bHQgPSBpc1JlYWN0Q29tcG9uZW50O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2YWxpZGF0ZTtcbmV4cG9ydHMudmFsaWRhdGVGaWVsZCA9IHZhbGlkYXRlRmllbGQ7XG5leHBvcnRzLnZhbGlkYXRlQ2hpbGQgPSB2YWxpZGF0ZUNoaWxkO1xuXG52YXIgX2RlZmluaXRpb25zID0gcmVxdWlyZShcIi4uL2RlZmluaXRpb25zXCIpO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZShub2RlLCBrZXksIHZhbCkge1xuICBpZiAoIW5vZGUpIHJldHVybjtcbiAgY29uc3QgZmllbGRzID0gX2RlZmluaXRpb25zLk5PREVfRklFTERTW25vZGUudHlwZV07XG4gIGlmICghZmllbGRzKSByZXR1cm47XG4gIGNvbnN0IGZpZWxkID0gZmllbGRzW2tleV07XG4gIHZhbGlkYXRlRmllbGQobm9kZSwga2V5LCB2YWwsIGZpZWxkKTtcbiAgdmFsaWRhdGVDaGlsZChub2RlLCBrZXksIHZhbCk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRmllbGQobm9kZSwga2V5LCB2YWwsIGZpZWxkKSB7XG4gIGlmICghKGZpZWxkID09IG51bGwgPyB2b2lkIDAgOiBmaWVsZC52YWxpZGF0ZSkpIHJldHVybjtcbiAgaWYgKGZpZWxkLm9wdGlvbmFsICYmIHZhbCA9PSBudWxsKSByZXR1cm47XG4gIGZpZWxkLnZhbGlkYXRlKG5vZGUsIGtleSwgdmFsKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZChub2RlLCBrZXksIHZhbCkge1xuICBpZiAodmFsID09IG51bGwpIHJldHVybjtcbiAgY29uc3QgdmFsaWRhdGUgPSBfZGVmaW5pdGlvbnMuTk9ERV9QQVJFTlRfVkFMSURBVElPTlNbdmFsLnR5cGVdO1xuICBpZiAoIXZhbGlkYXRlKSByZXR1cm47XG4gIHZhbGlkYXRlKG5vZGUsIGtleSwgdmFsKTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbmxldCBmYXN0UHJvdG8gPSBudWxsO1xuXG4vLyBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHBlcm1hbmVudGx5IGZhc3QgcHJvcGVydGllcyBpbiBWOC4gU2VlIFRvb24gVmVyd2Flc3Qnc1xuLy8gcG9zdCBodHRwczovL21lZGl1bS5jb20vQHR2ZXJ3YWVzL3NldHRpbmctdXAtcHJvdG90eXBlcy1pbi12OC1lYzljOTQ5MWRmZTIjNWY2MlxuLy8gZm9yIG1vcmUgZGV0YWlscy4gVXNlICVIYXNGYXN0UHJvcGVydGllcyhvYmplY3QpIGFuZCB0aGUgTm9kZS5qcyBmbGFnXG4vLyAtLWFsbG93LW5hdGl2ZXMtc3ludGF4IHRvIGNoZWNrIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBmYXN0IHByb3BlcnRpZXMuXG5mdW5jdGlvbiBGYXN0T2JqZWN0KG8pIHtcblx0Ly8gQSBwcm90b3R5cGUgb2JqZWN0IHdpbGwgaGF2ZSBcImZhc3QgcHJvcGVydGllc1wiIGVuYWJsZWQgb25jZSBpdCBpcyBjaGVja2VkXG5cdC8vIGFnYWluc3QgdGhlIGlubGluZSBwcm9wZXJ0eSBjYWNoZSBvZiBhIGZ1bmN0aW9uLCBlLmcuIGZhc3RQcm90by5wcm9wZXJ0eTpcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3Y4L3Y4L2Jsb2IvNi4wLjEyMi90ZXN0L21qc3VuaXQvZmFzdC1wcm90b3R5cGUuanMjTDQ4LUw2M1xuXHRpZiAoZmFzdFByb3RvICE9PSBudWxsICYmIHR5cGVvZiBmYXN0UHJvdG8ucHJvcGVydHkpIHtcblx0XHRjb25zdCByZXN1bHQgPSBmYXN0UHJvdG87XG5cdFx0ZmFzdFByb3RvID0gRmFzdE9iamVjdC5wcm90b3R5cGUgPSBudWxsO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblx0ZmFzdFByb3RvID0gRmFzdE9iamVjdC5wcm90b3R5cGUgPSBvID09IG51bGwgPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbztcblx0cmV0dXJuIG5ldyBGYXN0T2JqZWN0O1xufVxuXG4vLyBJbml0aWFsaXplIHRoZSBpbmxpbmUgcHJvcGVydHkgY2FjaGUgb2YgRmFzdE9iamVjdFxuRmFzdE9iamVjdCgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRvRmFzdHByb3BlcnRpZXMobykge1xuXHRyZXR1cm4gRmFzdE9iamVjdChvKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIikpO1xuaWYgKCEoQXJyYXkuaXNBcnJheSh0LlRZUEVTKSAmJlxuICAgIHQuVFlQRVMuZXZlcnkoKHQpID0+IHR5cGVvZiB0ID09PSAnc3RyaW5nJykpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdAYmFiZWwvdHlwZXMgVFlQRVMgZG9lcyBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIHR5cGUuJyk7XG59XG5jb25zdCBGTElQUEVEX0FMSUFTX0tFWVMgPSB0XG4gICAgLkZMSVBQRURfQUxJQVNfS0VZUztcbmNvbnN0IFRZUEVTID0gbmV3IFNldCh0LlRZUEVTKTtcbmlmICghKEZMSVBQRURfQUxJQVNfS0VZUyAmJlxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogc3RyaWN0LXR5cGUtcHJlZGljYXRlc1xuICAgIHR5cGVvZiBGTElQUEVEX0FMSUFTX0tFWVMgPT09ICdvYmplY3QnICYmXG4gICAgT2JqZWN0LmtleXMoRkxJUFBFRF9BTElBU19LRVlTKS5ldmVyeSgoa2V5KSA9PiBBcnJheS5pc0FycmF5KEZMSVBQRURfQUxJQVNfS0VZU1trZXldKSAmJlxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHN0cmljdC10eXBlLXByZWRpY2F0ZXNcbiAgICAgICAgRkxJUFBFRF9BTElBU19LRVlTW2tleV0uZXZlcnkoKHYpID0+IHR5cGVvZiB2ID09PSAnc3RyaW5nJykpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQGJhYmVsL3R5cGVzIEZMSVBQRURfQUxJQVNfS0VZUyBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgdHlwZS4nKTtcbn1cbi8qKlxuICogVGhpcyBzZXJ2ZXMgdGhyZSBmdW5jdGlvbnM6XG4gKlxuICogMS4gVGFrZSBhbnkgXCJhbGlhc2VzXCIgYW5kIGV4cGxvZGUgdGhlbSB0byByZWZlY2VuY2UgdGhlIGNvbmNyZXRlIHR5cGVzXG4gKiAyLiBOb3JtYWxpemUgYWxsIGhhbmRsZXJzIHRvIGhhdmUgYW4gYHtlbnRlciwgZXhpdH1gIHBhaXIsIHJhdGhlciB0aGFuIHJhdyBmdW5jdGlvbnNcbiAqIDMuIG1ha2UgdGhlIGVudGVyIGFuZCBleGl0IGhhbmRsZXJzIGFycmF5cywgc28gdGhhdCBtdWx0aXBsZSBoYW5kbGVycyBjYW4gYmUgbWVyZ2VkXG4gKi9cbmZ1bmN0aW9uIGV4cGxvZGUoaW5wdXQpIHtcbiAgICBjb25zdCByZXN1bHRzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgY29uc3QgYWxpYXNlcyA9IEZMSVBQRURfQUxJQVNfS0VZU1trZXldO1xuICAgICAgICBpZiAoYWxpYXNlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb25jcmV0ZUtleSBvZiBhbGlhc2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmNyZXRlS2V5IGluIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2NvbmNyZXRlS2V5XS5lbnRlci5wdXNoKGlucHV0W2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0W2tleV0uZW50ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tjb25jcmV0ZUtleV0uZW50ZXIucHVzaChpbnB1dFtrZXldLmVudGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFtrZXldLmV4aXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tjb25jcmV0ZUtleV0uZXhpdC5wdXNoKGlucHV0W2tleV0uZXhpdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXRba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tjb25jcmV0ZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXI6IFtpbnB1dFtrZXldXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0OiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2NvbmNyZXRlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRlcjogaW5wdXRba2V5XS5lbnRlciA/IFtpbnB1dFtrZXldLmVudGVyXSA6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQ6IGlucHV0W2tleV0uZXhpdCA/IFtpbnB1dFtrZXldLmV4aXRdIDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFRZUEVTLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trZXldLmVudGVyLnB1c2goaW5wdXRba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRba2V5XS5lbnRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba2V5XS5lbnRlci5wdXNoKGlucHV0W2tleV0uZW50ZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRba2V5XS5leGl0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trZXldLmV4aXQucHVzaChpbnB1dFtrZXldLmV4aXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXRba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlcjogW2lucHV0W2tleV1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdDogW10sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlcjogaW5wdXRba2V5XS5lbnRlciA/IFtpbnB1dFtrZXldLmVudGVyXSA6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdDogaW5wdXRba2V5XS5leGl0ID8gW2lucHV0W2tleV0uZXhpdF0gOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBleHBsb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhwbG9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlY3Vyc2l2ZSA9IGV4cG9ydHMuYW5jZXN0b3IgPSBleHBvcnRzLnNpbXBsZSA9IHZvaWQgMDtcbmNvbnN0IHQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKSk7XG5jb25zdCBleHBsb2RlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZXhwbG9kZVwiKSk7XG5jb25zdCBWSVNJVE9SX0tFWVMgPSB0LlZJU0lUT1JfS0VZUztcbmlmICghKFZJU0lUT1JfS0VZUyAmJlxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogc3RyaWN0LXR5cGUtcHJlZGljYXRlc1xuICAgIHR5cGVvZiBWSVNJVE9SX0tFWVMgPT09ICdvYmplY3QnICYmXG4gICAgT2JqZWN0LmtleXMoVklTSVRPUl9LRVlTKS5ldmVyeSgoa2V5KSA9PiBBcnJheS5pc0FycmF5KFZJU0lUT1JfS0VZU1trZXldKSAmJlxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHN0cmljdC10eXBlLXByZWRpY2F0ZXNcbiAgICAgICAgVklTSVRPUl9LRVlTW2tleV0uZXZlcnkoKHYpID0+IHR5cGVvZiB2ID09PSAnc3RyaW5nJykpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQGJhYmVsL3R5cGVzIFZJU0lUT1JfS0VZUyBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgdHlwZS4nKTtcbn1cbmZ1bmN0aW9uIHNpbXBsZSh2aXNpdG9ycykge1xuICAgIGNvbnN0IHZpcyA9IGV4cGxvZGVfMS5kZWZhdWx0KHZpc2l0b3JzKTtcbiAgICByZXR1cm4gKG5vZGUsIHN0YXRlKSA9PiB7XG4gICAgICAgIChmdW5jdGlvbiByZWN1cnNlKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB2aXNpdG9yID0gdmlzW25vZGUudHlwZV07XG4gICAgICAgICAgICBpZiAodmlzaXRvciA9PT0gbnVsbCB8fCB2aXNpdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXNpdG9yLmVudGVyKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHZpc2l0b3IuZW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdihub2RlLCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgVklTSVRPUl9LRVlTW25vZGUudHlwZV0gfHwgW10pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJOb2RlID0gbm9kZVtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN1Yk5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViU3ViTm9kZSBvZiBzdWJOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN1cnNlKHN1YlN1Yk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWN1cnNlKHN1Yk5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aXNpdG9yID09PSBudWxsIHx8IHZpc2l0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc2l0b3IuZXhpdCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2aXNpdG9yLmV4aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdihub2RlLCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KShub2RlKTtcbiAgICB9O1xufVxuZXhwb3J0cy5zaW1wbGUgPSBzaW1wbGU7XG5mdW5jdGlvbiBhbmNlc3Rvcih2aXNpdG9ycykge1xuICAgIGNvbnN0IHZpcyA9IGV4cGxvZGVfMS5kZWZhdWx0KHZpc2l0b3JzKTtcbiAgICByZXR1cm4gKG5vZGUsIHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IFtdO1xuICAgICAgICAoZnVuY3Rpb24gcmVjdXJzZShub2RlKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgdmlzaXRvciA9IHZpc1tub2RlLnR5cGVdO1xuICAgICAgICAgICAgY29uc3QgaXNOZXcgPSBub2RlICE9PSBhbmNlc3RvcnNbYW5jZXN0b3JzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGlzTmV3KVxuICAgICAgICAgICAgICAgIGFuY2VzdG9ycy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgaWYgKHZpc2l0b3IgPT09IG51bGwgfHwgdmlzaXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlzaXRvci5lbnRlcikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2aXNpdG9yLmVudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHYobm9kZSwgc3RhdGUsIGFuY2VzdG9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgVklTSVRPUl9LRVlTW25vZGUudHlwZV0gfHwgW10pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJOb2RlID0gbm9kZVtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN1Yk5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViU3ViTm9kZSBvZiBzdWJOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN1cnNlKHN1YlN1Yk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWN1cnNlKHN1Yk5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aXNpdG9yID09PSBudWxsIHx8IHZpc2l0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc2l0b3IuZXhpdCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2aXNpdG9yLmV4aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdihub2RlLCBzdGF0ZSwgYW5jZXN0b3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOZXcpXG4gICAgICAgICAgICAgICAgYW5jZXN0b3JzLnBvcCgpO1xuICAgICAgICB9KShub2RlKTtcbiAgICB9O1xufVxuZXhwb3J0cy5hbmNlc3RvciA9IGFuY2VzdG9yO1xuZnVuY3Rpb24gcmVjdXJzaXZlKHZpc2l0b3JzKSB7XG4gICAgY29uc3QgdmlzID0gZXhwbG9kZV8xLmRlZmF1bHQodmlzaXRvcnMpO1xuICAgIHJldHVybiAobm9kZSwgc3RhdGUpID0+IHtcbiAgICAgICAgKGZ1bmN0aW9uIHJlY3Vyc2Uobm9kZSkge1xuICAgICAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHZpc2l0b3IgPSB2aXNbbm9kZS50eXBlXTtcbiAgICAgICAgICAgIGlmICh2aXNpdG9yID09PSBudWxsIHx8IHZpc2l0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc2l0b3IuZW50ZXIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmlzaXRvci5lbnRlcikge1xuICAgICAgICAgICAgICAgICAgICB2KG5vZGUsIHN0YXRlLCByZWN1cnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBWSVNJVE9SX0tFWVNbbm9kZS50eXBlXSB8fCBbXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJOb2RlID0gbm9kZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdWJOb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdWJTdWJOb2RlIG9mIHN1Yk5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN1cnNlKHN1YlN1Yk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXJzZShzdWJOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkobm9kZSk7XG4gICAgfTtcbn1cbmV4cG9ydHMucmVjdXJzaXZlID0gcmVjdXJzaXZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcbiIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG4iLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2Vha01hcDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUVhY2g7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlGaWx0ZXI7XG4iLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ247XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbkluO1xuIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduVmFsdWU7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbicpLFxuICAgIGJhc2VBc3NpZ25JbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25JbicpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBjb3B5U3ltYm9scyA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzJyksXG4gICAgY29weVN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzSW4nKSxcbiAgICBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpLFxuICAgIGdldEFsbEtleXNJbiA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXNJbicpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGluaXRDbG9uZUFycmF5ID0gcmVxdWlyZSgnLi9faW5pdENsb25lQXJyYXknKSxcbiAgICBpbml0Q2xvbmVCeVRhZyA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUJ5VGFnJyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzTWFwID0gcmVxdWlyZSgnLi9pc01hcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU2V0ID0gcmVxdWlyZSgnLi9pc1NldCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xudmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbmNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG5jbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbmNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG5jbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbmNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIERlZXAgY2xvbmVcbiAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICB2YXIgcmVzdWx0LFxuICAgICAgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRyxcbiAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHO1xuXG4gIGlmIChjdXN0b21pemVyKSB7XG4gICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICB9XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc0Fycikge1xuICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgfVxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBpc0ZsYXRcbiAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gIGlmIChzdGFja2VkKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQ7XG4gIH1cbiAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlKSB7XG4gICAgICByZXN1bHQuYWRkKGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3ViVmFsdWUsIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNsb25lO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgfVxuICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDcmVhdGU7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldEFsbEtleXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG4iLCJ2YXIgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBtYXBUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWFwO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1JlZ0V4cGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzUmVnRXhwKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHJlZ2V4cFRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNSZWdFeHA7XG4iLCJ2YXIgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzU2V0YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzU2V0O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCJ2YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5c0luID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5c0luJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXNJbjtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsInZhciBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVBcnJheUJ1ZmZlcjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEYXRhVmlldztcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVSZWdFeHA7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVN5bWJvbDtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpO1xuXG4vKipcbiAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHM7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzSW47XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5cztcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzSW47XG4iLCJ2YXIgaXNLZXlhYmxlID0gcmVxdWlyZSgnLi9faXNLZXlhYmxlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXBEYXRhO1xuIiwidmFyIGJhc2VJc05hdGl2ZSA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hdGl2ZScpLFxuICAgIGdldFZhbHVlID0gcmVxdWlyZSgnLi9fZ2V0VmFsdWUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuIiwidmFyIGFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9scztcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKG9iamVjdCkge1xuICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9sc0luO1xuIiwidmFyIERhdGFWaWV3ID0gcmVxdWlyZSgnLi9fRGF0YVZpZXcnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgnLi9fUHJvbWlzZScpLFxuICAgIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIFdlYWtNYXAgPSByZXF1aXJlKCcuL19XZWFrTWFwJyksXG4gICAgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGFnO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVBcnJheTtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpLFxuICAgIGNsb25lRGF0YVZpZXcgPSByZXF1aXJlKCcuL19jbG9uZURhdGFWaWV3JyksXG4gICAgY2xvbmVSZWdFeHAgPSByZXF1aXJlKCcuL19jbG9uZVJlZ0V4cCcpLFxuICAgIGNsb25lU3ltYm9sID0gcmVxdWlyZSgnLi9fY2xvbmVTeW1ib2wnKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBpc0RlZXApIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQnlUYWc7XG4iLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVPYmplY3Q7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG4iLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5c0luO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsInZhciBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGB2YWx1ZWAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHBzOi8vbWRuLmlvL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtKVxuICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gKiBhcnJheXMuIFRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGNsb25lZFxuICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lRGVlcFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuIiwidmFyIGJhc2VJc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vX2Jhc2VJc0FyZ3VtZW50cycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcbiIsInZhciBiYXNlSXNNYXAgPSByZXF1aXJlKCcuL19iYXNlSXNNYXAnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXA7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTWFwKG5ldyBNYXApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXA7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuIiwidmFyIGJhc2VJc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2Jhc2VJc1JlZ0V4cCcpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNSZWdFeHAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1JlZ0V4cDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFJlZ0V4cGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNSZWdFeHAoL2FiYy8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNSZWdFeHAoJy9hYmMvJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNSZWdFeHAgPSBub2RlSXNSZWdFeHAgPyBiYXNlVW5hcnkobm9kZUlzUmVnRXhwKSA6IGJhc2VJc1JlZ0V4cDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1JlZ0V4cDtcbiIsInZhciBiYXNlSXNTZXQgPSByZXF1aXJlKCcuL19iYXNlSXNTZXQnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU2V0KG5ldyBTZXQpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTZXQ7XG4iLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzSW4gPSByZXF1aXJlKCcuL19iYXNlS2V5c0luJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkFycmF5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJGYWxzZTtcbiJdLCJzb3VyY2VSb290IjoiIn0=